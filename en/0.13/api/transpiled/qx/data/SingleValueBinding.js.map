{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "statics",
    "__bindings",
    "__bindingsByTarget",
    "bind",
    "sourceObject",
    "sourcePropertyChain",
    "targetObject",
    "targetPropertyChain",
    "options",
    "targetListenerMap",
    "__setUpTargetBinding",
    "propertyNames",
    "split",
    "arrayIndexValues",
    "__checkForArrayInPropertyChain",
    "sources",
    "listeners",
    "listenerIds",
    "eventNames",
    "source",
    "initialPromise",
    "i",
    "length",
    "propertyName",
    "push",
    "eventName",
    "__getEventNameForProperty",
    "core",
    "AssertionError",
    "Object",
    "hasProperty",
    "constructor",
    "log",
    "Logger",
    "warn",
    "__setInitialValue",
    "undefined",
    "itemIndex",
    "currentValue",
    "getItem",
    "__bindEventToProperty",
    "lang",
    "String",
    "firstUp",
    "context",
    "index",
    "listener",
    "Function",
    "__chainListener",
    "addListener",
    "ex",
    "removeListenerById",
    "targets",
    "targetIds",
    "id",
    "type",
    "targetListenerIds",
    "__storeBinding",
    "onUpdate",
    "j",
    "converter",
    "ignoreConverter",
    "currentSourceChain",
    "slice",
    "join",
    "match",
    "RegExp",
    "__setTargetValue",
    "__resetTargetValue",
    "implementsInterface",
    "data",
    "IListData",
    "target",
    "firstUpPropName",
    "currentIndex",
    "getLength",
    "SingleValueBinding",
    "updateTarget",
    "value",
    "resolvePropertyChain",
    "__convertValue",
    "o",
    "propertyChain",
    "properties",
    "__getPropertyChainArray",
    "__getTargetFromChain",
    "__getEventForProperty",
    "supportsEvent",
    "lastProperty",
    "__getArrayIndex",
    "setItem",
    "arrayExp",
    "arrayMatch",
    "replace",
    "filter",
    "prop",
    "targetProperties",
    "property",
    "arrIndex",
    "result",
    "e",
    "ValidationError",
    "onSetFail",
    "name",
    "endsWith",
    "arrayIndex",
    "substring",
    "indexOf",
    "Error",
    "isNaN",
    "parseInt",
    "splice",
    "sourceEvent",
    "targetProperty",
    "bindListener",
    "start",
    "getData",
    "end",
    "hash",
    "toHashCode",
    "binding",
    "model",
    "getModel",
    "lastIndexOf",
    "propertieDefinition",
    "getPropertyDefinition",
    "check",
    "__defaultConversion",
    "sourceProperty",
    "event",
    "targetCheck",
    "dataType",
    "Type",
    "getClass",
    "parseFloat",
    "removeBindingFromObject",
    "error",
    "classname",
    "bindings",
    "getAllBindingsForObject",
    "Array",
    "remove",
    "removeAllBindingsForObject",
    "object",
    "removeRelatedBindings",
    "relatedObject",
    "sourceBindings",
    "targetBindings",
    "clone",
    "unique",
    "concat",
    "removeAllBindings",
    "ObjectRegistry",
    "fromHashCode",
    "getAllBindings",
    "showBindingInLog",
    "message",
    "debug",
    "showAllBindingsInLog"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/data/SingleValueBinding.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (martinwittemann)\n\n************************************************************************ */\n\n/**\n * Single-value binding is a core component of the data binding package.\n */\nqx.Class.define(\"qx.data.SingleValueBinding\", {\n  statics: {\n    /** internal reference for all bindings indexed by source object */\n    __bindings: {},\n\n    /** internal reference for all bindings indexed by target object */\n    __bindingsByTarget: {},\n\n    /**\n     * The function is responsible for binding a source objects property to\n     * a target objects property. Both properties have to have the usual qooxdoo\n     * getter and setter. The source property also needs to fire change-events\n     * on every change of its value.\n     * Please keep in mind, that this binding is unidirectional. If you need\n     * a binding in both directions, you have to use two of this bindings.\n     *\n     * It's also possible to bind some kind of a hierarchy as a source. This\n     * means that you can separate the source properties with a dot and bind\n     * by that the object referenced to this property chain.\n     * Example with an object 'a' which has object 'b' stored in its 'child'\n     * property. Object b has a string property named abc:\n     * <pre><code>\n     * qx.data.SingleValueBinding.bind(a, \"child.abc\", textfield, \"value\");\n     * </code></pre>\n     * In that case, if the property abc of b changes, the textfield will\n     * automatically contain the new value. Also if the child of a changes, the\n     * new value (abc of the new child) will be in the textfield.\n     *\n     * There is also a possibility of binding an array. Therefore the array\n     * {@link qx.data.IListData} is needed because this array has change events\n     * which the native does not. Imagine a qooxdoo object a which has a\n     * children property containing an array holding more of its own kind.\n     * Every object has a name property as a string.\n     * <pre>\n     * var svb = qx.data.SingleValueBinding;\n     * // bind the first child's name of 'a' to a textfield\n     * svb.bind(a, \"children[0].name\", textfield, \"value\");\n     * // bind the last child's name of 'a' to a textfield\n     * svb.bind(a, \"children[last].name\", textfield2, \"value\");\n     * // also deeper bindings are possible\n     * svb.bind(a, \"children[0].children[0].name\", textfield3, \"value\");\n     * </pre>\n     *\n     * As you can see in this example, the abc property of a's b will be bound\n     * to the textfield. If now the value of b changed or even the a will get a\n     * new b, the binding still shows the right value.\n     *\n     * @param sourceObject {qx.core.Object} The source of the binding.\n     * @param sourcePropertyChain {String} The property chain which represents\n     *   the source property.\n     * @param targetObject {qx.core.Object} The object which the source should\n     *   be bind to.\n     * @param targetPropertyChain {String} The property chain to the target\n     *   object.\n     * @param options {Map?null} A map containing the options.\n     *   <li>converter: A converter function which takes four parameters\n     *       and should return the converted value.\n     *       <ol>\n     *         <li>The data to convert</li>\n     *         <li>The corresponding model object, which is only set in case of the use of an controller.</li>\n     *         <li>The source object for the binding</li>\n     *         <li>The target object.</li>\n     *       </ol>\n     *       If no conversion has been done, the given value should be returned.\n     *       e.g. a number to boolean converter\n     *       <code>function(data, model, source, target) {return data > 100;}</code>\n     *   </li>\n     *   <li>onUpdate: A callback function can be given here. This method will be\n     *       called if the binding was updated successful. There will be\n     *       three parameter you do get in that method call.\n     *       <ol>\n     *         <li>The source object</li>\n     *         <li>The target object</li>\n     *         <li>The data</li>\n     *       </ol>\n     *       Here is a sample: <code>onUpdate : function(source, target, data) {...}</code>\n     *   </li>\n     *   <li>onSetFail: A callback function can be given here. This method will\n     *       be called if the set of the value fails.\n     *   </li>\n     *   <li>ignoreConverter: A string which will be matched using the current\n     *       property chain. If it matches, the converter will not be called.\n     *   </li>\n     *\n     * @return {var} Returns the internal id for that binding. This can be used\n     *   for referencing the binding or e.g. for removing. This is not an atomic\n     *   id so you can't you use it as a hash-map index.\n     *\n     * @throws {qx.core.AssertionError} If the event is no data event or\n     *   there is no property definition for object and property (source and\n     *   target).\n     */\n    bind(\n      sourceObject,\n      sourcePropertyChain,\n      targetObject,\n      targetPropertyChain,\n      options\n    ) {\n      // check for the arguments\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert.assertObject(sourceObject, \"sourceObject\");\n        qx.core.Assert.assertString(sourcePropertyChain, \"sourcePropertyChain\");\n        qx.core.Assert.assertObject(targetObject, \"targetObject\");\n        qx.core.Assert.assertString(targetPropertyChain, \"targetPropertyChain\");\n      }\n\n      // set up the target binding\n      var targetListenerMap = this.__setUpTargetBinding(\n        sourceObject,\n        sourcePropertyChain,\n        targetObject,\n        targetPropertyChain,\n        options\n      );\n\n      // get the property names\n      var propertyNames = sourcePropertyChain.split(\".\");\n\n      // stuff that's needed to store for the listener function\n      var arrayIndexValues = this.__checkForArrayInPropertyChain(propertyNames);\n      var sources = [];\n      var listeners = [];\n      var listenerIds = [];\n      var eventNames = [];\n      var source = sourceObject;\n      var initialPromise = null;\n\n      // add a try catch to make it possible to remove the listeners of the\n      // chain in case the loop breaks after some listeners already added.\n      try {\n        // go through all property names\n        for (var i = 0; i < propertyNames.length; i++) {\n          var propertyName = propertyNames[i];\n\n          // check for the array\n          if (arrayIndexValues[i] !== \"\") {\n            // push the array change event\n            eventNames.push(\"change\");\n          } else {\n            var eventName = this.__getEventNameForProperty(\n              source,\n              propertyName\n            );\n\n            if (!eventName) {\n              if (i == 0) {\n                // the root property can not change --> error\n                throw new qx.core.AssertionError(\n                  \"Binding property \" +\n                    propertyName +\n                    \" of object \" +\n                    source +\n                    \" not possible: No event available. Full property chain: \" +\n                    sourcePropertyChain\n                );\n              }\n\n              if (\n                source instanceof qx.core.Object &&\n                qx.Class.hasProperty(source.constructor, propertyName)\n              ) {\n                qx.log.Logger.warn(\n                  \"Binding property \" +\n                    propertyName +\n                    \" of object \" +\n                    source +\n                    \" not possible: No event available. Full property chain: \" +\n                    sourcePropertyChain\n                );\n              }\n\n              // call the converter if no event could be found on binding creation\n              initialPromise = this.__setInitialValue(\n                undefined,\n                targetObject,\n                targetPropertyChain,\n                options,\n                sourceObject\n              );\n\n              break;\n            }\n            eventNames.push(eventName);\n          }\n\n          // save the current source\n          sources[i] = source;\n\n          // check for the last property\n          if (i == propertyNames.length - 1) {\n            // if it is an array, set the initial value and bind the event\n            if (arrayIndexValues[i] !== \"\") {\n              // get the current value\n              var itemIndex =\n                arrayIndexValues[i] === \"last\"\n                  ? source.length - 1\n                  : arrayIndexValues[i];\n              var currentValue = source.getItem(itemIndex);\n\n              // set the initial value\n              initialPromise = this.__setInitialValue(\n                currentValue,\n                targetObject,\n                targetPropertyChain,\n                options,\n                sourceObject\n              );\n\n              // bind the event\n              listenerIds[i] = this.__bindEventToProperty(\n                source,\n                eventNames[i],\n                targetObject,\n                targetPropertyChain,\n                options,\n                arrayIndexValues[i]\n              );\n            } else {\n              // try to set the initial value\n              if (\n                propertyNames[i] != null &&\n                source[\"get\" + qx.lang.String.firstUp(propertyNames[i])] != null\n              ) {\n                var currentValue =\n                  source[\"get\" + qx.lang.String.firstUp(propertyNames[i])]();\n                initialPromise = this.__setInitialValue(\n                  currentValue,\n                  targetObject,\n                  targetPropertyChain,\n                  options,\n                  sourceObject\n                );\n              }\n              // bind the property\n              listenerIds[i] = this.__bindEventToProperty(\n                source,\n                eventNames[i],\n                targetObject,\n                targetPropertyChain,\n                options\n              );\n            }\n\n            // if its not the last property\n          } else {\n            // create the context for the listener\n            var context = {\n              index: i,\n              propertyNames: propertyNames,\n              sources: sources,\n              listenerIds: listenerIds,\n              arrayIndexValues: arrayIndexValues,\n              targetObject: targetObject,\n              targetPropertyChain: targetPropertyChain,\n              options: options,\n              listeners: listeners\n            };\n\n            // create a listener\n            var listener = qx.lang.Function.bind(\n              this.__chainListener,\n              this,\n              context\n            );\n\n            // store the listener for further processing\n            listeners.push(listener);\n\n            // add the chaining listener\n            listenerIds[i] = source.addListener(eventNames[i], listener);\n          }\n\n          // get and store the next source\n          if (\n            source[\"get\" + qx.lang.String.firstUp(propertyNames[i])] == null\n          ) {\n            source = undefined;\n          } else if (arrayIndexValues[i] !== \"\") {\n            var itemIndex =\n              arrayIndexValues[i] === \"last\"\n                ? source.length - 1\n                : arrayIndexValues[i];\n            source =\n              source[\"get\" + qx.lang.String.firstUp(propertyNames[i])](\n                itemIndex\n              );\n          } else {\n            source = source[\"get\" + qx.lang.String.firstUp(propertyNames[i])]();\n            // the value should be undefined if we can not find the last part of the property chain\n            if (source === null && propertyNames.length - 1 != i) {\n              source = undefined;\n            }\n          }\n          if (!source) {\n            // call the converter if no source could be found on binding creation\n            this.__setInitialValue(\n              source,\n              targetObject,\n              targetPropertyChain,\n              options,\n              sourceObject\n            );\n\n            break;\n          }\n        }\n      } catch (ex) {\n        // remove the already added listener\n        // go through all added listeners (source)\n\n        for (var i = 0; i < sources.length; i++) {\n          // check if a source is available\n          if (sources[i] && listenerIds[i]) {\n            sources[i].removeListenerById(listenerIds[i]);\n          }\n        }\n        var targets = targetListenerMap.targets;\n        var targetIds = targetListenerMap.listenerIds;\n        // go through all added listeners (target)\n        for (var i = 0; i < targets.length; i++) {\n          // check if a target is available\n          if (targets[i] && targetIds[i]) {\n            targets[i].removeListenerById(targetIds[i]);\n          }\n        }\n\n        throw ex;\n      }\n\n      // create the id map\n      var id = {\n        type: \"deepBinding\",\n        listenerIds: listenerIds,\n        sources: sources,\n        targetListenerIds: targetListenerMap.listenerIds,\n        targets: targetListenerMap.targets,\n        initialPromise: initialPromise\n      };\n\n      // store the bindings\n      this.__storeBinding(\n        id,\n        sourceObject,\n        sourcePropertyChain,\n        targetObject,\n        targetPropertyChain\n      );\n\n      return id;\n    },\n\n    /**\n     * Event listener for the chaining of the properties.\n     *\n     * @param context {Map} The current context for the listener.\n     */\n    __chainListener(context) {\n      // invoke the onUpdate method\n      if (context.options && context.options.onUpdate) {\n        context.options.onUpdate(\n          context.sources[context.index],\n          context.targetObject\n        );\n      }\n\n      // delete all listener after the current one\n      for (var j = context.index + 1; j < context.propertyNames.length; j++) {\n        // remove the old sources\n        var source = context.sources[j];\n        context.sources[j] = null;\n        if (!source) {\n          continue;\n        }\n\n        // remove the listeners\n        source.removeListenerById(context.listenerIds[j]);\n      }\n\n      // get the current source\n      var source = context.sources[context.index];\n      // add new once after the current one\n      for (var j = context.index + 1; j < context.propertyNames.length; j++) {\n        // get and store the new source\n        if (context.arrayIndexValues[j - 1] !== \"\") {\n          source = source[\n            \"get\" + qx.lang.String.firstUp(context.propertyNames[j - 1])\n          ](context.arrayIndexValues[j - 1]);\n        } else {\n          source =\n            source[\n              \"get\" + qx.lang.String.firstUp(context.propertyNames[j - 1])\n            ]();\n        }\n        context.sources[j] = source;\n        // reset the target object if no new source could be found\n        if (!source) {\n          // use the converter if the property chain breaks [BUG# 6880]\n          if (context.options && context.options.converter) {\n            var ignoreConverter = false;\n            // take care of the ignore pattern used for the controller\n            if (context.options.ignoreConverter) {\n              // the current property chain as string\n              var currentSourceChain = context.propertyNames\n                .slice(0, j)\n                .join(\".\");\n              // match for the current pattern given in the options\n              var match = currentSourceChain.match(\n                new RegExp(\"^\" + context.options.ignoreConverter)\n              );\n\n              ignoreConverter = match ? match.length > 0 : false;\n            }\n\n            if (!ignoreConverter) {\n              this.__setTargetValue(\n                context.targetObject,\n                context.targetPropertyChain,\n                context.options.converter()\n              );\n            } else {\n              this.__resetTargetValue(\n                context.targetObject,\n                context.targetPropertyChain\n              );\n            }\n          } else {\n            this.__resetTargetValue(\n              context.targetObject,\n              context.targetPropertyChain\n            );\n          }\n\n          break;\n        }\n\n        // if its the last property\n        if (j == context.propertyNames.length - 1) {\n          // if its an array\n          if (\n            qx.Class.implementsInterface(source, qx.data.IListData) &&\n            context.arrayIndexValues[j] !== \"\"\n          ) {\n            // set the initial value\n            var itemIndex =\n              context.arrayIndexValues[j] === \"last\"\n                ? source.length - 1\n                : context.arrayIndexValues[j];\n            var currentValue = source.getItem(itemIndex);\n            this.__setInitialValue(\n              currentValue,\n              context.targetObject,\n              context.targetPropertyChain,\n              context.options,\n              context.sources[context.index]\n            );\n\n            // bind the item event to the new target\n            context.listenerIds[j] = this.__bindEventToProperty(\n              source,\n              \"change\",\n              context.targetObject,\n              context.targetPropertyChain,\n              context.options,\n              context.arrayIndexValues[j]\n            );\n          } else {\n            if (\n              context.propertyNames[j] != null &&\n              source[\n                \"get\" + qx.lang.String.firstUp(context.propertyNames[j])\n              ] != null\n            ) {\n              var currentValue =\n                source[\n                  \"get\" + qx.lang.String.firstUp(context.propertyNames[j])\n                ]();\n\n              this.__setInitialValue(\n                currentValue,\n                context.targetObject,\n                context.targetPropertyChain,\n                context.options,\n                context.sources[context.index]\n              );\n            }\n            var eventName = this.__getEventNameForProperty(\n              source,\n              context.propertyNames[j]\n            );\n\n            if (!eventName) {\n              context.sources[j] = null;\n              this.__resetTargetValue(\n                context.targetObject,\n                context.targetPropertyChain\n              );\n\n              return;\n            }\n            // bind the last property to the new target\n            context.listenerIds[j] = this.__bindEventToProperty(\n              source,\n              eventName,\n              context.targetObject,\n              context.targetPropertyChain,\n              context.options\n            );\n          }\n        } else {\n          // check if a listener already created\n          if (context.listeners[j] == null) {\n            var listener = qx.lang.Function.bind(\n              this.__chainListener,\n              this,\n              context\n            );\n\n            // store the listener for further processing\n            context.listeners.push(listener);\n          }\n          // add a new listener\n          if (qx.Class.implementsInterface(source, qx.data.IListData)) {\n            var eventName = \"change\";\n          } else {\n            var eventName = this.__getEventNameForProperty(\n              source,\n              context.propertyNames[j]\n            );\n          }\n\n          if (!eventName) {\n            context.sources[j] = null;\n            this.__resetTargetValue(\n              context.targetObject,\n              context.targetPropertyChain\n            );\n\n            return;\n          }\n          context.listenerIds[j] = source.addListener(\n            eventName,\n            context.listeners[j]\n          );\n        }\n      }\n    },\n\n    /**\n     * Internal helper for setting up the listening to the changes on the\n     * target side of the binding. Only works if the target property is a\n     * property chain\n     *\n     * @param sourceObject {qx.core.Object} The source of the binding.\n     * @param sourcePropertyChain {String} The property chain which represents\n     *   the source property.\n     * @param targetObject {qx.core.Object} The object which the source should\n     *   be bind to.\n     * @param targetPropertyChain {String} The property name of the target\n     *   object.\n     * @param options {Map} The options map perhaps containing the user defined\n     *   converter.\n     * @return {var} A map containing the listener ids and the targets.\n     */\n    __setUpTargetBinding(\n      sourceObject,\n      sourcePropertyChain,\n      targetObject,\n      targetPropertyChain,\n      options\n    ) {\n      // get the property names\n      var propertyNames = targetPropertyChain.split(\".\");\n\n      var arrayIndexValues = this.__checkForArrayInPropertyChain(propertyNames);\n      var targets = [];\n      var listeners = [];\n      var listenerIds = [];\n      var eventNames = [];\n      var target = targetObject;\n\n      // go through all property names\n      for (var i = 0; i < propertyNames.length - 1; i++) {\n        // check for the array\n        if (arrayIndexValues[i] !== \"\") {\n          // push the array change event\n          eventNames.push(\"change\");\n        } else {\n          var eventName = this.__getEventNameForProperty(\n            target,\n            propertyNames[i]\n          );\n\n          if (!eventName) {\n            // if the event names could not be terminated,\n            // just ignore the target chain listening\n            break;\n          }\n          eventNames.push(eventName);\n        }\n\n        // save the current source\n        targets[i] = target;\n\n        // create a listener\n        var listener = function () {\n          // delete all listener after the current one\n          for (var j = i + 1; j < propertyNames.length - 1; j++) {\n            // remove the old sources\n            var target = targets[j];\n            targets[j] = null;\n            if (!target) {\n              continue;\n            }\n\n            // remove the listeners\n            target.removeListenerById(listenerIds[j]);\n          }\n\n          // get the current target\n          var target = targets[i];\n          // add new once after the current one\n          for (var j = i + 1; j < propertyNames.length - 1; j++) {\n            var firstUpPropName = qx.lang.String.firstUp(propertyNames[j - 1]);\n            // get and store the new target\n            if (arrayIndexValues[j - 1] !== \"\") {\n              var currentIndex =\n                arrayIndexValues[j - 1] === \"last\"\n                  ? target.getLength() - 1\n                  : arrayIndexValues[j - 1];\n              target = target[\"get\" + firstUpPropName](currentIndex);\n            } else {\n              target = target[\"get\" + firstUpPropName]();\n            }\n            targets[j] = target;\n            if (!target) {\n              break;\n            }\n\n            // check if a listener already created\n            if (listeners[j] == null) {\n              // store the listener for further processing\n              listeners.push(listener);\n            }\n\n            // add a new listener\n            if (qx.Class.implementsInterface(target, qx.data.IListData)) {\n              var eventName = \"change\";\n            } else {\n              var eventName =\n                qx.data.SingleValueBinding.__getEventNameForProperty(\n                  target,\n                  propertyNames[j]\n                );\n\n              if (!eventName) {\n                // if the event name could not be terminated,\n                // ignore the rest\n                break;\n              }\n            }\n\n            listenerIds[j] = target.addListener(eventName, listeners[j]);\n          }\n\n          qx.data.SingleValueBinding.updateTarget(\n            sourceObject,\n            sourcePropertyChain,\n            targetObject,\n            targetPropertyChain,\n            options\n          );\n        };\n\n        // store the listener for further processing\n        listeners.push(listener);\n\n        // add the chaining listener\n        listenerIds[i] = target.addListener(eventNames[i], listener);\n\n        var firstUpPropName = qx.lang.String.firstUp(propertyNames[i]);\n        // get and store the next target\n        if (target[\"get\" + firstUpPropName] == null) {\n          target = null;\n        } else if (arrayIndexValues[i] !== \"\") {\n          target = target[\"get\" + firstUpPropName](arrayIndexValues[i]);\n        } else {\n          target = target[\"get\" + firstUpPropName]();\n        }\n        if (!target) {\n          break;\n        }\n      }\n\n      return { listenerIds: listenerIds, targets: targets };\n    },\n\n    /**\n     * Helper for updating the target. Gets the current set data from the source\n     * and set that on the target.\n     *\n     * @param sourceObject {qx.core.Object} The source of the binding.\n     * @param sourcePropertyChain {String} The property chain which represents\n     *   the source property.\n     * @param targetObject {qx.core.Object} The object which the source should\n     *   be bind to.\n     * @param targetPropertyChain {String} The property name of the target\n     *   object.\n     * @param options {Map} The options map perhaps containing the user defined\n     *   converter.\n     *\n     * @internal\n     */\n    updateTarget(\n      sourceObject,\n      sourcePropertyChain,\n      targetObject,\n      targetPropertyChain,\n      options\n    ) {\n      var value = this.resolvePropertyChain(sourceObject, sourcePropertyChain);\n\n      // convert the data before setting\n      value = qx.data.SingleValueBinding.__convertValue(\n        value,\n        targetObject,\n        targetPropertyChain,\n        options,\n        sourceObject\n      );\n\n      this.__setTargetValue(targetObject, targetPropertyChain, value);\n    },\n\n    /**\n     * Internal helper for getting the current set value at the property chain.\n     *\n     * @param o {qx.core.Object} The source of the binding.\n     * @param propertyChain {String} The property chain which represents\n     *   the source property.\n     * @return {var?undefined} Returns the set value if defined.\n     */\n    resolvePropertyChain(o, propertyChain) {\n      var properties = this.__getPropertyChainArray(propertyChain);\n      return this.__getTargetFromChain(o, properties, properties.length);\n    },\n\n    /**\n     * Tries to return a fitting event name to the given source object and\n     * property name. First, it assumes that the property name is a real property\n     * and therefore it checks the property definition for the event. The second\n     * possibility is to check if there is an event with the given name. The\n     * third and last possibility checked is if there is an event which is named\n     * change + propertyName. If this three possibilities fail, an error will be\n     * thrown.\n     *\n     * @param source {qx.core.Object} The source where the property is stored.\n     * @param propertyName {String} The name of the property.\n     * @return {String|null} The name of the corresponding event or null.\n     */\n    __getEventNameForProperty(source, propertyName) {\n      // get the current event name from the property definition\n      var eventName = this.__getEventForProperty(source, propertyName);\n      // if no event name could be found\n      if (eventName == null) {\n        // check if the propertyName is the event name\n        if (qx.Class.supportsEvent(source.constructor, propertyName)) {\n          eventName = propertyName;\n          // check if the change + propertyName is the event name\n        } else if (\n          qx.Class.supportsEvent(\n            source.constructor,\n            \"change\" + qx.lang.String.firstUp(propertyName)\n          )\n        ) {\n          eventName = \"change\" + qx.lang.String.firstUp(propertyName);\n        } else {\n          return null;\n        }\n      }\n      return eventName;\n    },\n\n    /**\n     * Resets the value of the given target after resolving the target property\n     * chain.\n     *\n     * @param targetObject {qx.core.Object} The object where the property chain\n     *   starts.\n     * @param targetPropertyChain {String} The names of the properties,\n     *   separated with a dot.\n     */\n    __resetTargetValue(targetObject, targetPropertyChain) {\n      // get the last target object of the chain\n      var properties = this.__getPropertyChainArray(targetPropertyChain);\n      var target = this.__getTargetFromChain(targetObject, properties);\n      if (target != null) {\n        // get the name of the last property\n        var lastProperty = properties[properties.length - 1];\n        // check for an array and set the value to null\n        var index = this.__getArrayIndex(lastProperty);\n        if (index) {\n          this.__setTargetValue(targetObject, targetPropertyChain, null);\n          return;\n        }\n\n        // try to reset the property\n        if (\n          target[\"reset\" + qx.lang.String.firstUp(lastProperty)] != undefined\n        ) {\n          target[\"reset\" + qx.lang.String.firstUp(lastProperty)]();\n        } else {\n          // fallback if no resetter is given (see bug #2456)\n          if (\n            typeof target[\"set\" + qx.lang.String.firstUp(lastProperty)] !=\n            \"function\"\n          ) {\n            throw new qx.core.AssertionError(\n              \"No setter for '\" + lastProperty + \"' on target \" + target + \".\"\n            );\n          }\n          target[\"set\" + qx.lang.String.firstUp(lastProperty)](null);\n        }\n      }\n    },\n\n    /**\n     * Sets the given value to the given target after resolving the\n     * target property chain.\n     *\n     * @param targetObject {qx.core.Object} The object where the property chain\n     *   starts.\n     * @param targetPropertyChain {String} The names of the properties,\n     *   separated with a dot.\n     * @param value {var} The value to set.\n     */\n    __setTargetValue(targetObject, targetPropertyChain, value) {\n      // get the last target object of the chain\n      var properties = this.__getPropertyChainArray(targetPropertyChain);\n      var target = this.__getTargetFromChain(targetObject, properties);\n      if (target) {\n        // get the name of the last property\n        var lastProperty = properties[properties.length - 1];\n\n        // check for array notation\n        var index = this.__getArrayIndex(lastProperty);\n        if (index) {\n          if (index === \"last\") {\n            // check for the 'last' notation\n            index = target.length - 1;\n          }\n          target.setItem(index, value);\n        } else {\n          if (\n            typeof target[\"set\" + qx.lang.String.firstUp(lastProperty)] !=\n            \"function\"\n          ) {\n            throw new qx.core.AssertionError(\n              \"No setter for '\" + lastProperty + \"' on target \" + target + \".\"\n            );\n          }\n          return target[\"set\" + qx.lang.String.firstUp(lastProperty)](value);\n        }\n      }\n    },\n\n    /**\n     * Returns the index from a property using bracket notation, e.g.\n     * \"[42]\" returns \"42\", \"[last]\" returns \"last\"\n     *\n     * @param propertyName {String} A property name\n     * @return {String|null} Array index or null if the property name does\n     * not use bracket notation\n     */\n    __getArrayIndex(propertyName) {\n      var arrayExp = /^\\[(\\d+|last)\\]$/;\n      var arrayMatch = propertyName.match(arrayExp);\n      if (arrayMatch) {\n        return arrayMatch[1];\n      }\n      return null;\n    },\n\n    /**\n     * Converts a property chain string into a list of properties and/or\n     * array indexes\n     * @param targetPropertyChain {String} property chain\n     * @return {String[]} Array of property names\n     */\n    __getPropertyChainArray(targetPropertyChain) {\n      // split properties (dot notation) and array indexes (bracket notation)\n      return targetPropertyChain\n        .replace(/\\[/g, \".[\")\n        .split(\".\")\n        .filter(function (prop) {\n          return prop !== \"\";\n        });\n    },\n\n    /**\n     * Helper-Function resolving the object on which the last property of the\n     * chain should be set.\n     *\n     * @param targetObject {qx.core.Object} The object where the property chain\n     *   starts.\n     * @param targetProperties {String[]} Array containing the names of the properties\n     * @param index {Number?} The array index of the last property to be considered.\n     * Default: The last item's index\n     * @return {qx.core.Object|null} The object on which the last property\n     *   should be set.\n     */\n    __getTargetFromChain(targetObject, targetProperties, index) {\n      index = index || targetProperties.length - 1;\n      var target = targetObject;\n\n      for (var i = 0; target !== null && i < index; i++) {\n        try {\n          var property = targetProperties[i];\n\n          // array notation\n          var arrIndex = this.__getArrayIndex(property);\n          if (arrIndex) {\n            if (arrIndex === \"last\") {\n              // check for the 'last' notation\n              arrIndex = target.length - 1;\n            }\n            target = target.getItem(arrIndex);\n          } else {\n            target = target[\"get\" + qx.lang.String.firstUp(property)]();\n          }\n        } catch (ex) {\n          return null;\n        }\n      }\n      return target;\n    },\n\n    /**\n     * Set the given value to the target property. This method is used for\n     * initially set the value.\n     *\n     * @param value {var} The value to set.\n     * @param targetObject {qx.core.Object} The object which contains the target\n     *   property.\n     * @param targetPropertyChain {String} The name of the target property in the\n     *   target object.\n     * @param options {Map} The options map perhaps containing the user defined\n     *   converter.\n     * @param sourceObject {qx.core.Object} The source object of the binding (\n     *   used for the onUpdate callback).\n     */\n    __setInitialValue(\n      value,\n      targetObject,\n      targetPropertyChain,\n      options,\n      sourceObject\n    ) {\n      // first convert the initial value\n      value = this.__convertValue(\n        value,\n        targetObject,\n        targetPropertyChain,\n        options,\n        sourceObject\n      );\n\n      // check if the converted value is undefined\n      if (value === undefined) {\n        this.__resetTargetValue(targetObject, targetPropertyChain);\n      }\n      // only set the initial value if one is given (may be null)\n      if (value !== undefined) {\n        try {\n          var result = this.__setTargetValue(\n            targetObject,\n            targetPropertyChain,\n            value\n          );\n\n          // tell the user that the setter was invoked probably\n          if (options && options.onUpdate) {\n            options.onUpdate(sourceObject, targetObject, value);\n          }\n          return result;\n        } catch (e) {\n          if (!(e instanceof qx.core.ValidationError)) {\n            throw e;\n          }\n\n          if (options && options.onSetFail) {\n            options.onSetFail(e);\n          } else {\n            qx.log.Logger.warn(\n              \"Failed so set value \" +\n                value +\n                \" on \" +\n                targetObject +\n                \". Error message: \" +\n                e\n            );\n          }\n        }\n      }\n    },\n\n    /**\n     * Checks for an array element in the given property names and adapts the\n     * arrays to fit the algorithm.\n     *\n     * @param propertyNames {Array} The array containing the property names.\n     *   Attention, this method can change this parameter!!!\n     * @return {Array} An array containing the values of the array properties\n     *   corresponding to the property names.\n     */\n    __checkForArrayInPropertyChain(propertyNames) {\n      // array for the values of the array properties\n      var arrayIndexValues = [];\n\n      // go through all properties and check for array notations\n      for (var i = 0; i < propertyNames.length; i++) {\n        var name = propertyNames[i];\n        // if its an array property in the chain\n        if (name.endsWith(\"]\")) {\n          // get the inner value of the array notation\n          var arrayIndex = name.substring(\n            name.indexOf(\"[\") + 1,\n            name.indexOf(\"]\")\n          );\n\n          // check the arrayIndex\n          if (name.indexOf(\"]\") != name.length - 1) {\n            throw new Error(\n              \"Please use only one array at a time: \" + name + \" does not work.\"\n            );\n          }\n          if (arrayIndex !== \"last\") {\n            if (arrayIndex == \"\" || isNaN(parseInt(arrayIndex, 10))) {\n              throw new Error(\n                \"No number or 'last' value has been given\" +\n                  \" in an array binding: \" +\n                  name +\n                  \" does not work.\"\n              );\n            }\n          }\n\n          // if a property is in front of the array notation\n          if (name.indexOf(\"[\") != 0) {\n            // store the property name without the array notation\n            propertyNames[i] = name.substring(0, name.indexOf(\"[\"));\n            // store the values in the array for the current iteration\n            arrayIndexValues[i] = \"\";\n            // store the properties for the next iteration (the item of the array)\n            arrayIndexValues[i + 1] = arrayIndex;\n            propertyNames.splice(i + 1, 0, \"item\");\n            // skip the next iteration. its the array item and its already set\n            i++;\n            // it the array notation is the beginning\n          } else {\n            // store the array index and override the entry in the property names\n            arrayIndexValues[i] = arrayIndex;\n            propertyNames.splice(i, 1, \"item\");\n          }\n        } else {\n          arrayIndexValues[i] = \"\";\n        }\n      }\n\n      return arrayIndexValues;\n    },\n\n    /**\n     * Internal helper method which is actually doing all bindings. That means\n     * that an event listener will be added to the source object which listens\n     * to the given event and invokes an set on the target property on the\n     * targetObject.\n     * This method does not store the binding in the internal reference store\n     * so it should NOT be used from outside this class. For an outside usage,\n     * use {@link #bind}.\n     *\n     * @param sourceObject {qx.core.Object} The source of the binding.\n     * @param sourceEvent {String} The event of the source object which could\n     *   be the change event in common but has to be an\n     *   {@link qx.event.type.Data} event.\n     * @param targetObject {qx.core.Object} The object which the source should\n     *   be bind to.\n     * @param targetProperty {String} The property name of the target object.\n     * @param options {Map} A map containing the options. See\n     *   {@link #bind} for more information.\n     * @param arrayIndex {String} The index of the given array if its an array\n     *   to bind.\n     *\n     * @return {var} Returns the internal id for that binding. This can be used\n     *   for referencing the binding or e.g. for removing. This is not an atomic\n     *   id so you can't you use it as a hash-map index. It's the id which will\n     *   be returned by the {@link qx.core.Object#addListener} method.\n     * @throws {qx.core.AssertionError} If the event is no data event or\n     *   there is no property definition for the target object and target\n     *   property.\n     */\n    __bindEventToProperty(\n      sourceObject,\n      sourceEvent,\n      targetObject,\n      targetProperty,\n      options,\n      arrayIndex\n    ) {\n      // checks\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        // check for the data event\n        var eventType = qx.Class.getEventType(\n          sourceObject.constructor,\n          sourceEvent\n        );\n\n        qx.core.Assert.assertEquals(\n          \"qx.event.type.Data\",\n          eventType,\n          sourceEvent +\n            \" is not an data (qx.event.type.Data) event on \" +\n            sourceObject +\n            \".\"\n        );\n      }\n\n      var bindListener = function (arrayIndex, e) {\n        // if an array value is given\n        if (arrayIndex !== \"\") {\n          //check if its the \"last\" value\n          if (arrayIndex === \"last\") {\n            arrayIndex = sourceObject.length - 1;\n          }\n\n          // get the data of the array\n          var data = sourceObject.getItem(arrayIndex);\n\n          // reset the target if the data is not set\n          if (data === undefined) {\n            qx.data.SingleValueBinding.__resetTargetValue(\n              targetObject,\n              targetProperty\n            );\n          }\n\n          // only do something if the current array has been changed\n          var start = e.getData().start;\n          var end = e.getData().end;\n          if (arrayIndex < start || arrayIndex > end) {\n            return;\n          }\n        } else {\n          // get the data out of the event\n          var data = e.getData();\n        }\n\n        // debug message\n        if (qx.core.Environment.get(\"qx.debug.databinding\")) {\n          qx.log.Logger.debug(\n            \"Binding executed from \" +\n              sourceObject +\n              \" by \" +\n              sourceEvent +\n              \" to \" +\n              targetObject +\n              \" (\" +\n              targetProperty +\n              \")\"\n          );\n\n          qx.log.Logger.debug(\"Data before conversion: \" + data);\n        }\n\n        // convert the data\n        data = qx.data.SingleValueBinding.__convertValue(\n          data,\n          targetObject,\n          targetProperty,\n          options,\n          sourceObject\n        );\n\n        // debug message\n        if (qx.core.Environment.get(\"qx.debug.databinding\")) {\n          qx.log.Logger.debug(\"Data after conversion: \" + data);\n        }\n\n        // try to set the value\n        var result;\n        try {\n          if (data !== undefined) {\n            result = qx.data.SingleValueBinding.__setTargetValue(\n              targetObject,\n              targetProperty,\n              data\n            );\n          } else {\n            result = qx.data.SingleValueBinding.__resetTargetValue(\n              targetObject,\n              targetProperty\n            );\n          }\n\n          // tell the user that the setter was invoked probably\n          if (options && options.onUpdate) {\n            options.onUpdate(sourceObject, targetObject, data);\n          }\n        } catch (ex) {\n          if (!(ex instanceof qx.core.ValidationError)) {\n            throw ex;\n          }\n\n          if (options && options.onSetFail) {\n            options.onSetFail(ex);\n          } else {\n            qx.log.Logger.warn(\n              \"Failed so set value \" +\n                data +\n                \" on \" +\n                targetObject +\n                \". Error message: \" +\n                ex\n            );\n          }\n        }\n        return result;\n      };\n\n      // check if an array index is given\n      if (!arrayIndex) {\n        // if not, signal it a s an empty string\n        arrayIndex = \"\";\n      }\n      // bind the listener function (make the array index in the listener available)\n      bindListener = qx.lang.Function.bind(\n        bindListener,\n        sourceObject,\n        arrayIndex\n      );\n\n      // add the listener\n      var id = sourceObject.addListener(sourceEvent, bindListener);\n\n      return id;\n    },\n\n    /**\n     * This method stores the given value as a binding in the internal structure\n     * of all bindings.\n     *\n     * @param id {var} The listener id of the id for a deeper binding.\n     * @param sourceObject {qx.core.Object} The source Object of the binding.\n     * @param sourceEvent {String} The name of the source event.\n     * @param targetObject {qx.core.Object} The target object.\n     * @param targetProperty {String} The name of the property on the target\n     *   object.\n     */\n    __storeBinding(\n      id,\n      sourceObject,\n      sourceEvent,\n      targetObject,\n      targetProperty\n    ) {\n      var hash;\n\n      // add the listener id to the internal registry\n      hash = sourceObject.toHashCode();\n      if (this.__bindings[hash] === undefined) {\n        this.__bindings[hash] = [];\n      }\n\n      var binding = [\n        id,\n        sourceObject,\n        sourceEvent,\n        targetObject,\n        targetProperty\n      ];\n\n      this.__bindings[hash].push(binding);\n\n      // add same binding data indexed by target object\n      hash = targetObject.toHashCode();\n      if (this.__bindingsByTarget[hash] === undefined) {\n        this.__bindingsByTarget[hash] = [];\n      }\n      this.__bindingsByTarget[hash].push(binding);\n    },\n\n    /**\n     * This method takes the given value, checks if the user has given a\n     * converter and converts the value to its target type. If no converter is\n     * given by the user, the {@link #__defaultConversion} will try to convert\n     * the value.\n     *\n     * @param value {var} The value which possibly should be converted.\n     * @param targetObject {qx.core.Object} The target object.\n     * @param targetPropertyChain {String} The property name of the target object.\n     * @param options {Map} The options map which can includes the converter.\n     *   For a detailed information on the map, take a look at\n     *   {@link #bind}.\n     * @param sourceObject {qx.core.Object} The source object for the binding.\n     *\n     * @return {var} The converted value. If no conversion has been done, the\n     *   value property will be returned.\n     * @throws {qx.core.AssertionError} If there is no property definition\n     *   of the given target object and target property.\n     */\n    __convertValue(\n      value,\n      targetObject,\n      targetPropertyChain,\n      options,\n      sourceObject\n    ) {\n      // do the conversion given by the user\n      if (options && options.converter) {\n        var model;\n        if (targetObject.getModel) {\n          model = targetObject.getModel();\n        }\n        return options.converter(value, model, sourceObject, targetObject);\n        // try default conversion\n      } else {\n        var properties = this.__getPropertyChainArray(targetPropertyChain);\n        var target = this.__getTargetFromChain(targetObject, properties);\n        var lastProperty = targetPropertyChain.substring(\n          targetPropertyChain.lastIndexOf(\".\") + 1,\n          targetPropertyChain.length\n        );\n\n        // if no target is currently available, return the original value\n        if (target == null) {\n          return value;\n        }\n\n        var propertieDefinition = qx.Class.getPropertyDefinition(\n          target.constructor,\n          lastProperty\n        );\n\n        var check =\n          propertieDefinition == null ? \"\" : propertieDefinition.check;\n        return this.__defaultConversion(value, check);\n      }\n    },\n\n    /**\n     * Helper method which tries to figure out if the given property on the\n     * given object does have a change event and if returns the name of it.\n     *\n     * @param sourceObject {qx.core.Object} The object to check.\n     * @param sourceProperty {String} The name of the property.\n     *\n     * @return {String} The name of the change event.\n     * @throws {qx.core.AssertionError} If there is no property definition of\n     *   the given object property pair.\n     */\n    __getEventForProperty(sourceObject, sourceProperty) {\n      // get the event name\n      var propertieDefinition = qx.Class.getPropertyDefinition(\n        sourceObject.constructor,\n        sourceProperty\n      );\n\n      if (propertieDefinition == null) {\n        return null;\n      }\n      return propertieDefinition.event;\n    },\n\n    /**\n     * Tries to convert the data to the type given in the targetCheck argument.\n     *\n     * @param data {var} The data to convert.\n     * @param targetCheck {String} The value of the check property. That usually\n     *   contains the target type.\n     * @return {Integer|String|Float} The converted data\n     */\n    __defaultConversion(data, targetCheck) {\n      var dataType = qx.lang.Type.getClass(data);\n\n      // to integer\n      if (\n        (dataType == \"Number\" || dataType == \"String\") &&\n        (targetCheck == \"Integer\" || targetCheck == \"PositiveInteger\")\n      ) {\n        data = parseInt(data, 10);\n      }\n\n      // to string\n      if (\n        (dataType == \"Boolean\" || dataType == \"Number\" || dataType == \"Date\") &&\n        targetCheck == \"String\"\n      ) {\n        data = data + \"\";\n      }\n\n      // to float\n      if (\n        (dataType == \"Number\" || dataType == \"String\") &&\n        (targetCheck == \"Number\" || targetCheck == \"PositiveNumber\")\n      ) {\n        data = parseFloat(data);\n      }\n\n      return data;\n    },\n\n    /**\n     * Removes the binding with the given id from the given sourceObject. The\n     * id has to be the id returned by any of the bind functions.\n     *\n     * @param sourceObject {qx.core.Object} The source object of the binding.\n     * @param id {var} The id of the binding.\n     * @throws {Error} If the binding could not be found.\n     */\n    removeBindingFromObject(sourceObject, id) {\n      // check for a deep binding\n      if (id.type == \"deepBinding\") {\n        // go through all added listeners (source)\n        for (var i = 0; i < id.sources.length; i++) {\n          // check if a source is available\n          if (id.sources[i]) {\n            if (id.listenerIds[i]) {\n              id.sources[i].removeListenerById(id.listenerIds[i]);\n            }\n            // If the listener id is not available, it is most likely\n            // caused by some hidden error situation.\n            // At least an error message should be displayed\n            else {\n              sourceObject.error(\n                \"Could not remove deep bindings. Binding id for \" +\n                  id.sources[i].classname +\n                  \" could not be found!\"\n              );\n            }\n          }\n        }\n        // go through all added listeners (target)\n        for (var i = 0; i < id.targets.length; i++) {\n          // check if a target is available\n          if (id.targets[i]) {\n            if (id.targetListenerIds[i]) {\n              id.targets[i].removeListenerById(id.targetListenerIds[i]);\n            }\n            // If the target listener id is not available, it is most likely\n            // caused by some hidden error situation.\n            // At least an error message should be displayed\n            else {\n              sourceObject.error(\n                \"Could not remove target listener. Listener id for target \" +\n                  id.targets[i].classname +\n                  \" could not be found!\"\n              );\n            }\n          }\n        }\n      } else {\n        // remove the listener\n        sourceObject.removeListenerById(id);\n      }\n\n      // remove the id from the internal reference system\n      var bindings = this.getAllBindingsForObject(sourceObject);\n      // check if the binding exists\n      if (bindings != undefined) {\n        for (var i = 0; i < bindings.length; i++) {\n          if (bindings[i][0] == id) {\n            // remove binding data from internal reference indexed by target object\n            var target = bindings[i][3];\n            if (this.__bindingsByTarget[target.toHashCode()]) {\n              qx.lang.Array.remove(\n                this.__bindingsByTarget[target.toHashCode()],\n                bindings[i]\n              );\n            }\n\n            // remove binding data from internal reference indexed by source object\n            var source = bindings[i][1];\n            if (this.__bindings[source.toHashCode()]) {\n              qx.lang.Array.remove(\n                this.__bindings[source.toHashCode()],\n                bindings[i]\n              );\n            }\n            return;\n          }\n        }\n      }\n      throw new Error(\"Binding could not be found!\");\n    },\n\n    /**\n     * Removes all bindings for the given object.\n     *\n     * @param object {qx.core.Object} The object of which the bindings should be\n     *   removed.\n     * @throws {qx.core.AssertionError} If the object is not in the internal\n     *   registry of the bindings.\n     * @throws {Error} If one of the bindings listed internally can not be\n     *   removed.\n     */\n    removeAllBindingsForObject(object) {\n      // check for the null value\n\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert.assertNotNull(\n          object,\n          \"Can not remove the bindings for null object!\"\n        );\n      }\n\n      // get the bindings\n      var bindings = this.getAllBindingsForObject(object);\n      if (bindings != undefined) {\n        // remove every binding with the removeBindingFromObject function\n        for (var i = bindings.length - 1; i >= 0; i--) {\n          this.removeBindingFromObject(object, bindings[i][0]);\n        }\n      }\n\n      var hash = object.toHashCode();\n      delete this.__bindings[hash];\n      delete this.__bindingsByTarget[hash];\n    },\n\n    /**\n     * Removes all bindings between given objects.\n     *\n     * @param object {qx.core.Object} The object of which the bindings should be\n     *   removed.\n     * @param relatedObject {qx.core.Object} The object of which related\n     *   bindings should be removed.\n     * @throws {qx.core.AssertionError} If the object is not in the internal\n     *   registry of the bindings.\n     * @throws {Error} If one of the bindings listed internally can not be\n     *   removed.\n     */\n    removeRelatedBindings(object, relatedObject) {\n      // check for the null value\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert.assertNotNull(\n          object,\n          \"Can not remove the bindings for null object!\"\n        );\n\n        qx.core.Assert.assertNotNull(\n          relatedObject,\n          \"Can not remove the bindings for null object!\"\n        );\n      }\n\n      // get the bindings\n      var bindings = this.getAllBindingsForObject(object);\n      if (bindings != undefined) {\n        // remove every binding with the removeBindingFromObject function\n        for (var i = bindings.length - 1; i >= 0; i--) {\n          var source = bindings[i][1];\n          var target = bindings[i][3];\n          if (source === relatedObject || target === relatedObject) {\n            this.removeBindingFromObject(object, bindings[i][0]);\n          }\n        }\n      }\n    },\n\n    /**\n     * Returns an array which lists all bindings.\n     *\n     * @param object {qx.core.Object} The object of which the bindings should\n     *   be returned.\n     *\n     * @return {Array} An array of binding informations. Every binding\n     *   information is an array itself containing id, sourceObject,\n     *   sourceEvent, targetObject and targetProperty in that order.\n     */\n    getAllBindingsForObject(object) {\n      var hash = object.toHashCode();\n\n      // get all bindings of object as source\n      var sourceBindings = this.__bindings[hash];\n\n      // get all bindings of object as target\n      var targetBindings = this.__bindingsByTarget[hash];\n\n      if (!sourceBindings && !targetBindings) {\n        return [];\n      }\n      if (!sourceBindings) {\n        return qx.lang.Array.clone(targetBindings);\n      }\n      if (!targetBindings) {\n        return qx.lang.Array.clone(sourceBindings);\n      }\n\n      return qx.lang.Array.unique(sourceBindings.concat(targetBindings));\n    },\n\n    /**\n     * Removes all binding in the whole application. After that not a single\n     * binding is left.\n     * @deprecated {6.0} dispose and destructors are deprecated because of automatic memory management; this\n     * will only work for objects explicitly registered with ObjectRegistry.register\n     */\n    removeAllBindings() {\n      // go through all registered objects\n      for (var hash in this.__bindings) {\n        var object = qx.core.ObjectRegistry.fromHashCode(hash);\n        // check for the object, perhaps its already deleted\n        if (object == null) {\n          delete this.__bindings[hash];\n          continue;\n        }\n        this.removeAllBindingsForObject(object);\n      }\n      // reset the bindings map\n      this.__bindings = {};\n    },\n\n    /**\n     * Returns a map containing for every bound object an array of data binding\n     * information. The key of the map is the hash code of the bound objects.\n     * Every binding is represented by an array containing id, sourceObject,\n     * sourceEvent, targetObject and targetProperty.\n     *\n     * @return {Map} Map containing all bindings.\n     */\n    getAllBindings() {\n      return this.__bindings;\n    },\n\n    /**\n     * Debug function which shows some valuable information about the given\n     * binding in console. For that it uses {@link qx.log.Logger}.\n     *\n     * @param object {qx.core.Object} the source of the binding.\n     * @param id {var} The id of the binding.\n     */\n    showBindingInLog(object, id) {\n      var binding;\n      // go through all bindings of the given object\n      for (var i = 0; i < this.__bindings[object.toHashCode()].length; i++) {\n        // the first array item is the id\n        if (this.__bindings[object.toHashCode()][i][0] == id) {\n          binding = this.__bindings[object.toHashCode()][i];\n          break;\n        }\n      }\n\n      if (binding === undefined) {\n        var message = \"Binding does not exist!\";\n      } else {\n        var message =\n          \"Binding from '\" +\n          binding[1] +\n          \"' (\" +\n          binding[2] +\n          \") to the object '\" +\n          binding[3] +\n          \"' (\" +\n          binding[4] +\n          \").\";\n      }\n\n      qx.log.Logger.debug(message);\n    },\n\n    /**\n     * Debug function which shows all bindings in the log console. To get only\n     * one binding in the console use {@link #showBindingInLog}\n     * @deprecated {6.0} qx.core.ObjectRegistry no longer stores most objects\n     */\n    showAllBindingsInLog() {\n      // go through all objects in the registry\n      for (var hash in this.__bindings) {\n        var object = qx.core.ObjectRegistry.fromHashCode(hash);\n        if (object) {\n          for (var i = 0; i < this.__bindings[hash].length; i++) {\n            this.showBindingInLog(object, this.__bindings[hash][i][0]);\n          }\n        }\n      }\n    }\n  }\n});\n"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC;;EAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;EACAH,EAAE,CAACI,KAAH,CAASC,MAAT,CAAgB,4BAAhB,EAA8C;IAC5CC,OAAO,EAAE;MACP;MACAC,SAAU,EAAE,EAFL;;MAIP;MACAC,SAAkB,EAAE,EALb;;MAOP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,IA3FO,gBA4FLC,YA5FK,EA6FLC,mBA7FK,EA8FLC,YA9FK,EA+FLC,mBA/FK,EAgGLC,OAhGK,EAiGL;QACA;QAQA;QACA,IAAIC,iBAAiB,GAAG,KAAKC,SAAL,CACtBN,YADsB,EAEtBC,mBAFsB,EAGtBC,YAHsB,EAItBC,mBAJsB,EAKtBC,OALsB,CAAxB,CAVA,CAkBA;;;QACA,IAAIG,aAAa,GAAGN,mBAAmB,CAACO,KAApB,CAA0B,GAA1B,CAApB,CAnBA,CAqBA;;QACA,IAAIC,gBAAgB,GAAG,KAAKC,SAAL,CAAoCH,aAApC,CAAvB;;QACA,IAAII,OAAO,GAAG,EAAd;QACA,IAAIC,SAAS,GAAG,EAAhB;QACA,IAAIC,WAAW,GAAG,EAAlB;QACA,IAAIC,UAAU,GAAG,EAAjB;QACA,IAAIC,MAAM,GAAGf,YAAb;QACA,IAAIgB,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"
}