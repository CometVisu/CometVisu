{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "statics",
    "__bindings",
    "__bindingsByTarget",
    "bind",
    "sourceObject",
    "sourcePropertyChain",
    "targetObject",
    "targetPropertyChain",
    "options",
    "targetListenerMap",
    "__setUpTargetBinding",
    "propertyNames",
    "split",
    "arrayIndexValues",
    "__checkForArrayInPropertyChain",
    "sources",
    "listeners",
    "listenerIds",
    "eventNames",
    "source",
    "initialPromise",
    "i",
    "length",
    "propertyName",
    "push",
    "eventName",
    "__getEventNameForProperty",
    "core",
    "AssertionError",
    "Object",
    "hasProperty",
    "constructor",
    "log",
    "Logger",
    "warn",
    "__setInitialValue",
    "undefined",
    "itemIndex",
    "currentValue",
    "getItem",
    "__bindEventToProperty",
    "lang",
    "String",
    "firstUp",
    "context",
    "index",
    "listener",
    "Function",
    "__chainListener",
    "addListener",
    "ex",
    "removeListenerById",
    "targets",
    "targetIds",
    "id",
    "type",
    "targetListenerIds",
    "__storeBinding",
    "__P_171_7",
    "onUpdate",
    "j",
    "converter",
    "ignoreConverter",
    "currentSourceChain",
    "slice",
    "join",
    "match",
    "RegExp",
    "__setTargetValue",
    "__resetTargetValue",
    "implementsInterface",
    "data",
    "IListData",
    "__P_171_2",
    "target",
    "firstUpPropName",
    "currentIndex",
    "getLength",
    "SingleValueBinding",
    "updateTarget",
    "value",
    "resolvePropertyChain",
    "__convertValue",
    "o",
    "propertyChain",
    "properties",
    "__getPropertyChainArray",
    "__getTargetFromChain",
    "__P_171_4",
    "__getEventForProperty",
    "supportsEvent",
    "__P_171_10",
    "lastProperty",
    "__getArrayIndex",
    "__P_171_9",
    "setItem",
    "__P_171_15",
    "arrayExp",
    "arrayMatch",
    "__P_171_12",
    "replace",
    "filter",
    "prop",
    "__P_171_13",
    "targetProperties",
    "property",
    "arrIndex",
    "__P_171_5",
    "result",
    "e",
    "ValidationError",
    "onSetFail",
    "__P_171_3",
    "name",
    "endsWith",
    "arrayIndex",
    "substring",
    "indexOf",
    "Error",
    "isNaN",
    "parseInt",
    "splice",
    "__P_171_6",
    "sourceEvent",
    "targetProperty",
    "bindListener",
    "start",
    "getData",
    "end",
    "__P_171_8",
    "hash",
    "toHashCode",
    "binding",
    "__P_171_11",
    "model",
    "getModel",
    "lastIndexOf",
    "propertieDefinition",
    "getPropertyDefinition",
    "check",
    "__defaultConversion",
    "__P_171_14",
    "sourceProperty",
    "event",
    "__P_171_16",
    "targetCheck",
    "dataType",
    "Type",
    "getClass",
    "parseFloat",
    "removeBindingFromObject",
    "error",
    "classname",
    "bindings",
    "getAllBindingsForObject",
    "Array",
    "remove",
    "removeAllBindingsForObject",
    "object",
    "removeRelatedBindings",
    "relatedObject",
    "sourceBindings",
    "targetBindings",
    "clone",
    "unique",
    "concat",
    "removeAllBindings",
    "ObjectRegistry",
    "fromHashCode",
    "getAllBindings",
    "showBindingInLog",
    "message",
    "debug",
    "showAllBindingsInLog"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/data/SingleValueBinding.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Martin Wittemann (martinwittemann)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * Single-value binding is a core component of the data binding package.\r\n */\r\nqx.Class.define(\"qx.data.SingleValueBinding\", {\r\n  statics: {\r\n    /** internal reference for all bindings indexed by source object */\r\n    __bindings: {},\r\n\r\n    /** internal reference for all bindings indexed by target object */\r\n    __bindingsByTarget: {},\r\n\r\n    /**\r\n     * The function is responsible for binding a source objects property to\r\n     * a target objects property. Both properties have to have the usual qooxdoo\r\n     * getter and setter. The source property also needs to fire change-events\r\n     * on every change of its value.\r\n     * Please keep in mind, that this binding is unidirectional. If you need\r\n     * a binding in both directions, you have to use two of this bindings.\r\n     *\r\n     * It's also possible to bind some kind of a hierarchy as a source. This\r\n     * means that you can separate the source properties with a dot and bind\r\n     * by that the object referenced to this property chain.\r\n     * Example with an object 'a' which has object 'b' stored in its 'child'\r\n     * property. Object b has a string property named abc:\r\n     * <pre><code>\r\n     * qx.data.SingleValueBinding.bind(a, \"child.abc\", textfield, \"value\");\r\n     * </code></pre>\r\n     * In that case, if the property abc of b changes, the textfield will\r\n     * automatically contain the new value. Also if the child of a changes, the\r\n     * new value (abc of the new child) will be in the textfield.\r\n     *\r\n     * There is also a possibility of binding an array. Therefore the array\r\n     * {@link qx.data.IListData} is needed because this array has change events\r\n     * which the native does not. Imagine a qooxdoo object a which has a\r\n     * children property containing an array holding more of its own kind.\r\n     * Every object has a name property as a string.\r\n     * <pre>\r\n     * var svb = qx.data.SingleValueBinding;\r\n     * // bind the first child's name of 'a' to a textfield\r\n     * svb.bind(a, \"children[0].name\", textfield, \"value\");\r\n     * // bind the last child's name of 'a' to a textfield\r\n     * svb.bind(a, \"children[last].name\", textfield2, \"value\");\r\n     * // also deeper bindings are possible\r\n     * svb.bind(a, \"children[0].children[0].name\", textfield3, \"value\");\r\n     * </pre>\r\n     *\r\n     * As you can see in this example, the abc property of a's b will be bound\r\n     * to the textfield. If now the value of b changed or even the a will get a\r\n     * new b, the binding still shows the right value.\r\n     *\r\n     * @param sourceObject {qx.core.Object} The source of the binding.\r\n     * @param sourcePropertyChain {String} The property chain which represents\r\n     *   the source property.\r\n     * @param targetObject {qx.core.Object} The object which the source should\r\n     *   be bind to.\r\n     * @param targetPropertyChain {String} The property chain to the target\r\n     *   object.\r\n     * @param options {Map?null} A map containing the options.\r\n     *   <li>converter: A converter function which takes four parameters\r\n     *       and should return the converted value.\r\n     *       <ol>\r\n     *         <li>The data to convert</li>\r\n     *         <li>The corresponding model object, which is only set in case of the use of an controller.</li>\r\n     *         <li>The source object for the binding</li>\r\n     *         <li>The target object.</li>\r\n     *       </ol>\r\n     *       If no conversion has been done, the given value should be returned.\r\n     *       e.g. a number to boolean converter\r\n     *       <code>function(data, model, source, target) {return data > 100;}</code>\r\n     *   </li>\r\n     *   <li>onUpdate: A callback function can be given here. This method will be\r\n     *       called if the binding was updated successful. There will be\r\n     *       three parameter you do get in that method call.\r\n     *       <ol>\r\n     *         <li>The source object</li>\r\n     *         <li>The target object</li>\r\n     *         <li>The data</li>\r\n     *       </ol>\r\n     *       Here is a sample: <code>onUpdate : function(source, target, data) {...}</code>\r\n     *   </li>\r\n     *   <li>onSetFail: A callback function can be given here. This method will\r\n     *       be called if the set of the value fails.\r\n     *   </li>\r\n     *   <li>ignoreConverter: A string which will be matched using the current\r\n     *       property chain. If it matches, the converter will not be called.\r\n     *   </li>\r\n     *\r\n     * @return {var} Returns the internal id for that binding. This can be used\r\n     *   for referencing the binding or e.g. for removing. This is not an atomic\r\n     *   id so you can't you use it as a hash-map index.\r\n     *\r\n     * @throws {qx.core.AssertionError} If the event is no data event or\r\n     *   there is no property definition for object and property (source and\r\n     *   target).\r\n     */\r\n    bind(\r\n      sourceObject,\r\n      sourcePropertyChain,\r\n      targetObject,\r\n      targetPropertyChain,\r\n      options\r\n    ) {\r\n      // check for the arguments\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        qx.core.Assert.assertObject(sourceObject, \"sourceObject\");\r\n        qx.core.Assert.assertString(sourcePropertyChain, \"sourcePropertyChain\");\r\n        qx.core.Assert.assertObject(targetObject, \"targetObject\");\r\n        qx.core.Assert.assertString(targetPropertyChain, \"targetPropertyChain\");\r\n      }\r\n\r\n      // set up the target binding\r\n      var targetListenerMap = this.__setUpTargetBinding(\r\n        sourceObject,\r\n        sourcePropertyChain,\r\n        targetObject,\r\n        targetPropertyChain,\r\n        options\r\n      );\r\n\r\n      // get the property names\r\n      var propertyNames = sourcePropertyChain.split(\".\");\r\n\r\n      // stuff that's needed to store for the listener function\r\n      var arrayIndexValues = this.__checkForArrayInPropertyChain(propertyNames);\r\n      var sources = [];\r\n      var listeners = [];\r\n      var listenerIds = [];\r\n      var eventNames = [];\r\n      var source = sourceObject;\r\n      var initialPromise = null;\r\n\r\n      // add a try catch to make it possible to remove the listeners of the\r\n      // chain in case the loop breaks after some listeners already added.\r\n      try {\r\n        // go through all property names\r\n        for (var i = 0; i < propertyNames.length; i++) {\r\n          var propertyName = propertyNames[i];\r\n\r\n          // check for the array\r\n          if (arrayIndexValues[i] !== \"\") {\r\n            // push the array change event\r\n            eventNames.push(\"change\");\r\n          } else {\r\n            var eventName = this.__getEventNameForProperty(\r\n              source,\r\n              propertyName\r\n            );\r\n\r\n            if (!eventName) {\r\n              if (i == 0) {\r\n                // the root property can not change --> error\r\n                throw new qx.core.AssertionError(\r\n                  \"Binding property \" +\r\n                    propertyName +\r\n                    \" of object \" +\r\n                    source +\r\n                    \" not possible: No event available. Full property chain: \" +\r\n                    sourcePropertyChain\r\n                );\r\n              }\r\n\r\n              if (\r\n                source instanceof qx.core.Object &&\r\n                qx.Class.hasProperty(source.constructor, propertyName)\r\n              ) {\r\n                qx.log.Logger.warn(\r\n                  \"Binding property \" +\r\n                    propertyName +\r\n                    \" of object \" +\r\n                    source +\r\n                    \" not possible: No event available. Full property chain: \" +\r\n                    sourcePropertyChain\r\n                );\r\n              }\r\n\r\n              // call the converter if no event could be found on binding creation\r\n              initialPromise = this.__setInitialValue(\r\n                undefined,\r\n                targetObject,\r\n                targetPropertyChain,\r\n                options,\r\n                sourceObject\r\n              );\r\n\r\n              break;\r\n            }\r\n            eventNames.push(eventName);\r\n          }\r\n\r\n          // save the current source\r\n          sources[i] = source;\r\n\r\n          // check for the last property\r\n          if (i == propertyNames.length - 1) {\r\n            // if it is an array, set the initial value and bind the event\r\n            if (arrayIndexValues[i] !== \"\") {\r\n              // get the current value\r\n              var itemIndex =\r\n                arrayIndexValues[i] === \"last\"\r\n                  ? source.length - 1\r\n                  : arrayIndexValues[i];\r\n              var currentValue = source.getItem(itemIndex);\r\n\r\n              // set the initial value\r\n              initialPromise = this.__setInitialValue(\r\n                currentValue,\r\n                targetObject,\r\n                targetPropertyChain,\r\n                options,\r\n                sourceObject\r\n              );\r\n\r\n              // bind the event\r\n              listenerIds[i] = this.__bindEventToProperty(\r\n                source,\r\n                eventNames[i],\r\n                targetObject,\r\n                targetPropertyChain,\r\n                options,\r\n                arrayIndexValues[i]\r\n              );\r\n            } else {\r\n              // try to set the initial value\r\n              if (\r\n                propertyNames[i] != null &&\r\n                source[\"get\" + qx.lang.String.firstUp(propertyNames[i])] != null\r\n              ) {\r\n                var currentValue =\r\n                  source[\"get\" + qx.lang.String.firstUp(propertyNames[i])]();\r\n                initialPromise = this.__setInitialValue(\r\n                  currentValue,\r\n                  targetObject,\r\n                  targetPropertyChain,\r\n                  options,\r\n                  sourceObject\r\n                );\r\n              }\r\n              // bind the property\r\n              listenerIds[i] = this.__bindEventToProperty(\r\n                source,\r\n                eventNames[i],\r\n                targetObject,\r\n                targetPropertyChain,\r\n                options\r\n              );\r\n            }\r\n\r\n            // if its not the last property\r\n          } else {\r\n            // create the context for the listener\r\n            var context = {\r\n              index: i,\r\n              propertyNames: propertyNames,\r\n              sources: sources,\r\n              listenerIds: listenerIds,\r\n              arrayIndexValues: arrayIndexValues,\r\n              targetObject: targetObject,\r\n              targetPropertyChain: targetPropertyChain,\r\n              options: options,\r\n              listeners: listeners\r\n            };\r\n\r\n            // create a listener\r\n            var listener = qx.lang.Function.bind(\r\n              this.__chainListener,\r\n              this,\r\n              context\r\n            );\r\n\r\n            // store the listener for further processing\r\n            listeners.push(listener);\r\n\r\n            // add the chaining listener\r\n            listenerIds[i] = source.addListener(eventNames[i], listener);\r\n          }\r\n\r\n          // get and store the next source\r\n          if (\r\n            source[\"get\" + qx.lang.String.firstUp(propertyNames[i])] == null\r\n          ) {\r\n            source = undefined;\r\n          } else if (arrayIndexValues[i] !== \"\") {\r\n            var itemIndex =\r\n              arrayIndexValues[i] === \"last\"\r\n                ? source.length - 1\r\n                : arrayIndexValues[i];\r\n            source =\r\n              source[\"get\" + qx.lang.String.firstUp(propertyNames[i])](\r\n                itemIndex\r\n              );\r\n          } else {\r\n            source = source[\"get\" + qx.lang.String.firstUp(propertyNames[i])]();\r\n            // the value should be undefined if we can not find the last part of the property chain\r\n            if (source === null && propertyNames.length - 1 != i) {\r\n              source = undefined;\r\n            }\r\n          }\r\n          if (!source) {\r\n            // call the converter if no source could be found on binding creation\r\n            this.__setInitialValue(\r\n              source,\r\n              targetObject,\r\n              targetPropertyChain,\r\n              options,\r\n              sourceObject\r\n            );\r\n\r\n            break;\r\n          }\r\n        }\r\n      } catch (ex) {\r\n        // remove the already added listener\r\n        // go through all added listeners (source)\r\n\r\n        for (var i = 0; i < sources.length; i++) {\r\n          // check if a source is available\r\n          if (sources[i] && listenerIds[i]) {\r\n            sources[i].removeListenerById(listenerIds[i]);\r\n          }\r\n        }\r\n        var targets = targetListenerMap.targets;\r\n        var targetIds = targetListenerMap.listenerIds;\r\n        // go through all added listeners (target)\r\n        for (var i = 0; i < targets.length; i++) {\r\n          // check if a target is available\r\n          if (targets[i] && targetIds[i]) {\r\n            targets[i].removeListenerById(targetIds[i]);\r\n          }\r\n        }\r\n\r\n        throw ex;\r\n      }\r\n\r\n      // create the id map\r\n      var id = {\r\n        type: \"deepBinding\",\r\n        listenerIds: listenerIds,\r\n        sources: sources,\r\n        targetListenerIds: targetListenerMap.listenerIds,\r\n        targets: targetListenerMap.targets,\r\n        initialPromise: initialPromise\r\n      };\r\n\r\n      // store the bindings\r\n      this.__storeBinding(\r\n        id,\r\n        sourceObject,\r\n        sourcePropertyChain,\r\n        targetObject,\r\n        targetPropertyChain\r\n      );\r\n\r\n      return id;\r\n    },\r\n\r\n    /**\r\n     * Event listener for the chaining of the properties.\r\n     *\r\n     * @param context {Map} The current context for the listener.\r\n     */\r\n    __chainListener(context) {\r\n      // invoke the onUpdate method\r\n      if (context.options && context.options.onUpdate) {\r\n        context.options.onUpdate(\r\n          context.sources[context.index],\r\n          context.targetObject\r\n        );\r\n      }\r\n\r\n      // delete all listener after the current one\r\n      for (var j = context.index + 1; j < context.propertyNames.length; j++) {\r\n        // remove the old sources\r\n        var source = context.sources[j];\r\n        context.sources[j] = null;\r\n        if (!source) {\r\n          continue;\r\n        }\r\n\r\n        // remove the listeners\r\n        source.removeListenerById(context.listenerIds[j]);\r\n      }\r\n\r\n      // get the current source\r\n      var source = context.sources[context.index];\r\n      // add new once after the current one\r\n      for (var j = context.index + 1; j < context.propertyNames.length; j++) {\r\n        // get and store the new source\r\n        if (context.arrayIndexValues[j - 1] !== \"\") {\r\n          source = source[\r\n            \"get\" + qx.lang.String.firstUp(context.propertyNames[j - 1])\r\n          ](context.arrayIndexValues[j - 1]);\r\n        } else {\r\n          source =\r\n            source[\r\n              \"get\" + qx.lang.String.firstUp(context.propertyNames[j - 1])\r\n            ]();\r\n        }\r\n        context.sources[j] = source;\r\n        // reset the target object if no new source could be found\r\n        if (!source) {\r\n          // use the converter if the property chain breaks [BUG# 6880]\r\n          if (context.options && context.options.converter) {\r\n            var ignoreConverter = false;\r\n            // take care of the ignore pattern used for the controller\r\n            if (context.options.ignoreConverter) {\r\n              // the current property chain as string\r\n              var currentSourceChain = context.propertyNames\r\n                .slice(0, j)\r\n                .join(\".\");\r\n              // match for the current pattern given in the options\r\n              var match = currentSourceChain.match(\r\n                new RegExp(\"^\" + context.options.ignoreConverter)\r\n              );\r\n\r\n              ignoreConverter = match ? match.length > 0 : false;\r\n            }\r\n\r\n            if (!ignoreConverter) {\r\n              this.__setTargetValue(\r\n                context.targetObject,\r\n                context.targetPropertyChain,\r\n                context.options.converter()\r\n              );\r\n            } else {\r\n              this.__resetTargetValue(\r\n                context.targetObject,\r\n                context.targetPropertyChain\r\n              );\r\n            }\r\n          } else {\r\n            this.__resetTargetValue(\r\n              context.targetObject,\r\n              context.targetPropertyChain\r\n            );\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        // if its the last property\r\n        if (j == context.propertyNames.length - 1) {\r\n          // if its an array\r\n          if (\r\n            qx.Class.implementsInterface(source, qx.data.IListData) &&\r\n            context.arrayIndexValues[j] !== \"\"\r\n          ) {\r\n            // set the initial value\r\n            var itemIndex =\r\n              context.arrayIndexValues[j] === \"last\"\r\n                ? source.length - 1\r\n                : context.arrayIndexValues[j];\r\n            var currentValue = source.getItem(itemIndex);\r\n            this.__setInitialValue(\r\n              currentValue,\r\n              context.targetObject,\r\n              context.targetPropertyChain,\r\n              context.options,\r\n              context.sources[context.index]\r\n            );\r\n\r\n            // bind the item event to the new target\r\n            context.listenerIds[j] = this.__bindEventToProperty(\r\n              source,\r\n              \"change\",\r\n              context.targetObject,\r\n              context.targetPropertyChain,\r\n              context.options,\r\n              context.arrayIndexValues[j]\r\n            );\r\n          } else {\r\n            if (\r\n              context.propertyNames[j] != null &&\r\n              source[\r\n                \"get\" + qx.lang.String.firstUp(context.propertyNames[j])\r\n              ] != null\r\n            ) {\r\n              var currentValue =\r\n                source[\r\n                  \"get\" + qx.lang.String.firstUp(context.propertyNames[j])\r\n                ]();\r\n\r\n              this.__setInitialValue(\r\n                currentValue,\r\n                context.targetObject,\r\n                context.targetPropertyChain,\r\n                context.options,\r\n                context.sources[context.index]\r\n              );\r\n            }\r\n            var eventName = this.__getEventNameForProperty(\r\n              source,\r\n              context.propertyNames[j]\r\n            );\r\n\r\n            if (!eventName) {\r\n              context.sources[j] = null;\r\n              this.__resetTargetValue(\r\n                context.targetObject,\r\n                context.targetPropertyChain\r\n              );\r\n\r\n              return;\r\n            }\r\n            // bind the last property to the new target\r\n            context.listenerIds[j] = this.__bindEventToProperty(\r\n              source,\r\n              eventName,\r\n              context.targetObject,\r\n              context.targetPropertyChain,\r\n              context.options\r\n            );\r\n          }\r\n        } else {\r\n          // check if a listener already created\r\n          if (context.listeners[j] == null) {\r\n            var listener = qx.lang.Function.bind(\r\n              this.__chainListener,\r\n              this,\r\n              context\r\n            );\r\n\r\n            // store the listener for further processing\r\n            context.listeners.push(listener);\r\n          }\r\n          // add a new listener\r\n          if (qx.Class.implementsInterface(source, qx.data.IListData)) {\r\n            var eventName = \"change\";\r\n          } else {\r\n            var eventName = this.__getEventNameForProperty(\r\n              source,\r\n              context.propertyNames[j]\r\n            );\r\n          }\r\n\r\n          if (!eventName) {\r\n            context.sources[j] = null;\r\n            this.__resetTargetValue(\r\n              context.targetObject,\r\n              context.targetPropertyChain\r\n            );\r\n\r\n            return;\r\n          }\r\n          context.listenerIds[j] = source.addListener(\r\n            eventName,\r\n            context.listeners[j]\r\n          );\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Internal helper for setting up the listening to the changes on the\r\n     * target side of the binding. Only works if the target property is a\r\n     * property chain\r\n     *\r\n     * @param sourceObject {qx.core.Object} The source of the binding.\r\n     * @param sourcePropertyChain {String} The property chain which represents\r\n     *   the source property.\r\n     * @param targetObject {qx.core.Object} The object which the source should\r\n     *   be bind to.\r\n     * @param targetPropertyChain {String} The property name of the target\r\n     *   object.\r\n     * @param options {Map} The options map perhaps containing the user defined\r\n     *   converter.\r\n     * @return {var} A map containing the listener ids and the targets.\r\n     */\r\n    __setUpTargetBinding(\r\n      sourceObject,\r\n      sourcePropertyChain,\r\n      targetObject,\r\n      targetPropertyChain,\r\n      options\r\n    ) {\r\n      // get the property names\r\n      var propertyNames = targetPropertyChain.split(\".\");\r\n\r\n      var arrayIndexValues = this.__checkForArrayInPropertyChain(propertyNames);\r\n      var targets = [];\r\n      var listeners = [];\r\n      var listenerIds = [];\r\n      var eventNames = [];\r\n      var target = targetObject;\r\n\r\n      // go through all property names\r\n      for (var i = 0; i < propertyNames.length - 1; i++) {\r\n        // check for the array\r\n        if (arrayIndexValues[i] !== \"\") {\r\n          // push the array change event\r\n          eventNames.push(\"change\");\r\n        } else {\r\n          var eventName = this.__getEventNameForProperty(\r\n            target,\r\n            propertyNames[i]\r\n          );\r\n\r\n          if (!eventName) {\r\n            // if the event names could not be terminated,\r\n            // just ignore the target chain listening\r\n            break;\r\n          }\r\n          eventNames.push(eventName);\r\n        }\r\n\r\n        // save the current source\r\n        targets[i] = target;\r\n\r\n        // create a listener\r\n        var listener = function () {\r\n          // delete all listener after the current one\r\n          for (var j = i + 1; j < propertyNames.length - 1; j++) {\r\n            // remove the old sources\r\n            var target = targets[j];\r\n            targets[j] = null;\r\n            if (!target) {\r\n              continue;\r\n            }\r\n\r\n            // remove the listeners\r\n            target.removeListenerById(listenerIds[j]);\r\n          }\r\n\r\n          // get the current target\r\n          var target = targets[i];\r\n          // add new once after the current one\r\n          for (var j = i + 1; j < propertyNames.length - 1; j++) {\r\n            var firstUpPropName = qx.lang.String.firstUp(propertyNames[j - 1]);\r\n            // get and store the new target\r\n            if (arrayIndexValues[j - 1] !== \"\") {\r\n              var currentIndex =\r\n                arrayIndexValues[j - 1] === \"last\"\r\n                  ? target.getLength() - 1\r\n                  : arrayIndexValues[j - 1];\r\n              target = target[\"get\" + firstUpPropName](currentIndex);\r\n            } else {\r\n              target = target[\"get\" + firstUpPropName]();\r\n            }\r\n            targets[j] = target;\r\n            if (!target) {\r\n              break;\r\n            }\r\n\r\n            // check if a listener already created\r\n            if (listeners[j] == null) {\r\n              // store the listener for further processing\r\n              listeners.push(listener);\r\n            }\r\n\r\n            // add a new listener\r\n            if (qx.Class.implementsInterface(target, qx.data.IListData)) {\r\n              var eventName = \"change\";\r\n            } else {\r\n              var eventName =\r\n                qx.data.SingleValueBinding.__getEventNameForProperty(\r\n                  target,\r\n                  propertyNames[j]\r\n                );\r\n\r\n              if (!eventName) {\r\n                // if the event name could not be terminated,\r\n                // ignore the rest\r\n                break;\r\n              }\r\n            }\r\n\r\n            listenerIds[j] = target.addListener(eventName, listeners[j]);\r\n          }\r\n\r\n          qx.data.SingleValueBinding.updateTarget(\r\n            sourceObject,\r\n            sourcePropertyChain,\r\n            targetObject,\r\n            targetPropertyChain,\r\n            options\r\n          );\r\n        };\r\n\r\n        // store the listener for further processing\r\n        listeners.push(listener);\r\n\r\n        // add the chaining listener\r\n        listenerIds[i] = target.addListener(eventNames[i], listener);\r\n\r\n        var firstUpPropName = qx.lang.String.firstUp(propertyNames[i]);\r\n        // get and store the next target\r\n        if (target[\"get\" + firstUpPropName] == null) {\r\n          target = null;\r\n        } else if (arrayIndexValues[i] !== \"\") {\r\n          target = target[\"get\" + firstUpPropName](arrayIndexValues[i]);\r\n        } else {\r\n          target = target[\"get\" + firstUpPropName]();\r\n        }\r\n        if (!target) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      return { listenerIds: listenerIds, targets: targets };\r\n    },\r\n\r\n    /**\r\n     * Helper for updating the target. Gets the current set data from the source\r\n     * and set that on the target.\r\n     *\r\n     * @param sourceObject {qx.core.Object} The source of the binding.\r\n     * @param sourcePropertyChain {String} The property chain which represents\r\n     *   the source property.\r\n     * @param targetObject {qx.core.Object} The object which the source should\r\n     *   be bind to.\r\n     * @param targetPropertyChain {String} The property name of the target\r\n     *   object.\r\n     * @param options {Map} The options map perhaps containing the user defined\r\n     *   converter.\r\n     *\r\n     * @internal\r\n     */\r\n    updateTarget(\r\n      sourceObject,\r\n      sourcePropertyChain,\r\n      targetObject,\r\n      targetPropertyChain,\r\n      options\r\n    ) {\r\n      var value = this.resolvePropertyChain(sourceObject, sourcePropertyChain);\r\n\r\n      // convert the data before setting\r\n      value = qx.data.SingleValueBinding.__convertValue(\r\n        value,\r\n        targetObject,\r\n        targetPropertyChain,\r\n        options,\r\n        sourceObject\r\n      );\r\n\r\n      this.__setTargetValue(targetObject, targetPropertyChain, value);\r\n    },\r\n\r\n    /**\r\n     * Internal helper for getting the current set value at the property chain.\r\n     *\r\n     * @param o {qx.core.Object} The source of the binding.\r\n     * @param propertyChain {String} The property chain which represents\r\n     *   the source property.\r\n     * @return {var?undefined} Returns the set value if defined.\r\n     */\r\n    resolvePropertyChain(o, propertyChain) {\r\n      var properties = this.__getPropertyChainArray(propertyChain);\r\n      return this.__getTargetFromChain(o, properties, properties.length);\r\n    },\r\n\r\n    /**\r\n     * Tries to return a fitting event name to the given source object and\r\n     * property name. First, it assumes that the property name is a real property\r\n     * and therefore it checks the property definition for the event. The second\r\n     * possibility is to check if there is an event with the given name. The\r\n     * third and last possibility checked is if there is an event which is named\r\n     * change + propertyName. If this three possibilities fail, an error will be\r\n     * thrown.\r\n     *\r\n     * @param source {qx.core.Object} The source where the property is stored.\r\n     * @param propertyName {String} The name of the property.\r\n     * @return {String|null} The name of the corresponding event or null.\r\n     */\r\n    __getEventNameForProperty(source, propertyName) {\r\n      // get the current event name from the property definition\r\n      var eventName = this.__getEventForProperty(source, propertyName);\r\n      // if no event name could be found\r\n      if (eventName == null) {\r\n        // check if the propertyName is the event name\r\n        if (qx.Class.supportsEvent(source.constructor, propertyName)) {\r\n          eventName = propertyName;\r\n          // check if the change + propertyName is the event name\r\n        } else if (\r\n          qx.Class.supportsEvent(\r\n            source.constructor,\r\n            \"change\" + qx.lang.String.firstUp(propertyName)\r\n          )\r\n        ) {\r\n          eventName = \"change\" + qx.lang.String.firstUp(propertyName);\r\n        } else {\r\n          return null;\r\n        }\r\n      }\r\n      return eventName;\r\n    },\r\n\r\n    /**\r\n     * Resets the value of the given target after resolving the target property\r\n     * chain.\r\n     *\r\n     * @param targetObject {qx.core.Object} The object where the property chain\r\n     *   starts.\r\n     * @param targetPropertyChain {String} The names of the properties,\r\n     *   separated with a dot.\r\n     */\r\n    __resetTargetValue(targetObject, targetPropertyChain) {\r\n      // get the last target object of the chain\r\n      var properties = this.__getPropertyChainArray(targetPropertyChain);\r\n      var target = this.__getTargetFromChain(targetObject, properties);\r\n      if (target != null) {\r\n        // get the name of the last property\r\n        var lastProperty = properties[properties.length - 1];\r\n        // check for an array and set the value to null\r\n        var index = this.__getArrayIndex(lastProperty);\r\n        if (index) {\r\n          this.__setTargetValue(targetObject, targetPropertyChain, null);\r\n          return;\r\n        }\r\n\r\n        // try to reset the property\r\n        if (\r\n          target[\"reset\" + qx.lang.String.firstUp(lastProperty)] != undefined\r\n        ) {\r\n          target[\"reset\" + qx.lang.String.firstUp(lastProperty)]();\r\n        } else {\r\n          // fallback if no resetter is given (see bug #2456)\r\n          if (\r\n            typeof target[\"set\" + qx.lang.String.firstUp(lastProperty)] !=\r\n            \"function\"\r\n          ) {\r\n            throw new qx.core.AssertionError(\r\n              \"No setter for '\" + lastProperty + \"' on target \" + target + \".\"\r\n            );\r\n          }\r\n          target[\"set\" + qx.lang.String.firstUp(lastProperty)](null);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets the given value to the given target after resolving the\r\n     * target property chain.\r\n     *\r\n     * @param targetObject {qx.core.Object} The object where the property chain\r\n     *   starts.\r\n     * @param targetPropertyChain {String} The names of the properties,\r\n     *   separated with a dot.\r\n     * @param value {var} The value to set.\r\n     */\r\n    __setTargetValue(targetObject, targetPropertyChain, value) {\r\n      // get the last target object of the chain\r\n      var properties = this.__getPropertyChainArray(targetPropertyChain);\r\n      var target = this.__getTargetFromChain(targetObject, properties);\r\n      if (target) {\r\n        // get the name of the last property\r\n        var lastProperty = properties[properties.length - 1];\r\n\r\n        // check for array notation\r\n        var index = this.__getArrayIndex(lastProperty);\r\n        if (index) {\r\n          if (index === \"last\") {\r\n            // check for the 'last' notation\r\n            index = target.length - 1;\r\n          }\r\n          target.setItem(index, value);\r\n        } else {\r\n          if (\r\n            typeof target[\"set\" + qx.lang.String.firstUp(lastProperty)] !=\r\n            \"function\"\r\n          ) {\r\n            throw new qx.core.AssertionError(\r\n              \"No setter for '\" + lastProperty + \"' on target \" + target + \".\"\r\n            );\r\n          }\r\n          return target[\"set\" + qx.lang.String.firstUp(lastProperty)](value);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns the index from a property using bracket notation, e.g.\r\n     * \"[42]\" returns \"42\", \"[last]\" returns \"last\"\r\n     *\r\n     * @param propertyName {String} A property name\r\n     * @return {String|null} Array index or null if the property name does\r\n     * not use bracket notation\r\n     */\r\n    __getArrayIndex(propertyName) {\r\n      var arrayExp = /^\\[(\\d+|last)\\]$/;\r\n      var arrayMatch = propertyName.match(arrayExp);\r\n      if (arrayMatch) {\r\n        return arrayMatch[1];\r\n      }\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * Converts a property chain string into a list of properties and/or\r\n     * array indexes\r\n     * @param targetPropertyChain {String} property chain\r\n     * @return {String[]} Array of property names\r\n     */\r\n    __getPropertyChainArray(targetPropertyChain) {\r\n      // split properties (dot notation) and array indexes (bracket notation)\r\n      return targetPropertyChain\r\n        .replace(/\\[/g, \".[\")\r\n        .split(\".\")\r\n        .filter(function (prop) {\r\n          return prop !== \"\";\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Helper-Function resolving the object on which the last property of the\r\n     * chain should be set.\r\n     *\r\n     * @param targetObject {qx.core.Object} The object where the property chain\r\n     *   starts.\r\n     * @param targetProperties {String[]} Array containing the names of the properties\r\n     * @param index {Number?} The array index of the last property to be considered.\r\n     * Default: The last item's index\r\n     * @return {qx.core.Object|null} The object on which the last property\r\n     *   should be set.\r\n     */\r\n    __getTargetFromChain(targetObject, targetProperties, index) {\r\n      index = index || targetProperties.length - 1;\r\n      var target = targetObject;\r\n\r\n      for (var i = 0; target !== null && i < index; i++) {\r\n        try {\r\n          var property = targetProperties[i];\r\n\r\n          // array notation\r\n          var arrIndex = this.__getArrayIndex(property);\r\n          if (arrIndex) {\r\n            if (arrIndex === \"last\") {\r\n              // check for the 'last' notation\r\n              arrIndex = target.length - 1;\r\n            }\r\n            target = target.getItem(arrIndex);\r\n          } else {\r\n            target = target[\"get\" + qx.lang.String.firstUp(property)]();\r\n          }\r\n        } catch (ex) {\r\n          return null;\r\n        }\r\n      }\r\n      return target;\r\n    },\r\n\r\n    /**\r\n     * Set the given value to the target property. This method is used for\r\n     * initially set the value.\r\n     *\r\n     * @param value {var} The value to set.\r\n     * @param targetObject {qx.core.Object} The object which contains the target\r\n     *   property.\r\n     * @param targetPropertyChain {String} The name of the target property in the\r\n     *   target object.\r\n     * @param options {Map} The options map perhaps containing the user defined\r\n     *   converter.\r\n     * @param sourceObject {qx.core.Object} The source object of the binding (\r\n     *   used for the onUpdate callback).\r\n     */\r\n    __setInitialValue(\r\n      value,\r\n      targetObject,\r\n      targetPropertyChain,\r\n      options,\r\n      sourceObject\r\n    ) {\r\n      // first convert the initial value\r\n      value = this.__convertValue(\r\n        value,\r\n        targetObject,\r\n        targetPropertyChain,\r\n        options,\r\n        sourceObject\r\n      );\r\n\r\n      // check if the converted value is undefined\r\n      if (value === undefined) {\r\n        this.__resetTargetValue(targetObject, targetPropertyChain);\r\n      }\r\n      // only set the initial value if one is given (may be null)\r\n      if (value !== undefined) {\r\n        try {\r\n          var result = this.__setTargetValue(\r\n            targetObject,\r\n            targetPropertyChain,\r\n            value\r\n          );\r\n\r\n          // tell the user that the setter was invoked probably\r\n          if (options && options.onUpdate) {\r\n            options.onUpdate(sourceObject, targetObject, value);\r\n          }\r\n          return result;\r\n        } catch (e) {\r\n          if (!(e instanceof qx.core.ValidationError)) {\r\n            throw e;\r\n          }\r\n\r\n          if (options && options.onSetFail) {\r\n            options.onSetFail(e);\r\n          } else {\r\n            qx.log.Logger.warn(\r\n              \"Failed so set value \" +\r\n                value +\r\n                \" on \" +\r\n                targetObject +\r\n                \". Error message: \" +\r\n                e\r\n            );\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Checks for an array element in the given property names and adapts the\r\n     * arrays to fit the algorithm.\r\n     *\r\n     * @param propertyNames {Array} The array containing the property names.\r\n     *   Attention, this method can change this parameter!!!\r\n     * @return {Array} An array containing the values of the array properties\r\n     *   corresponding to the property names.\r\n     */\r\n    __checkForArrayInPropertyChain(propertyNames) {\r\n      // array for the values of the array properties\r\n      var arrayIndexValues = [];\r\n\r\n      // go through all properties and check for array notations\r\n      for (var i = 0; i < propertyNames.length; i++) {\r\n        var name = propertyNames[i];\r\n        // if its an array property in the chain\r\n        if (name.endsWith(\"]\")) {\r\n          // get the inner value of the array notation\r\n          var arrayIndex = name.substring(\r\n            name.indexOf(\"[\") + 1,\r\n            name.indexOf(\"]\")\r\n          );\r\n\r\n          // check the arrayIndex\r\n          if (name.indexOf(\"]\") != name.length - 1) {\r\n            throw new Error(\r\n              \"Please use only one array at a time: \" + name + \" does not work.\"\r\n            );\r\n          }\r\n          if (arrayIndex !== \"last\") {\r\n            if (arrayIndex == \"\" || isNaN(parseInt(arrayIndex, 10))) {\r\n              throw new Error(\r\n                \"No number or 'last' value has been given\" +\r\n                  \" in an array binding: \" +\r\n                  name +\r\n                  \" does not work.\"\r\n              );\r\n            }\r\n          }\r\n\r\n          // if a property is in front of the array notation\r\n          if (name.indexOf(\"[\") != 0) {\r\n            // store the property name without the array notation\r\n            propertyNames[i] = name.substring(0, name.indexOf(\"[\"));\r\n            // store the values in the array for the current iteration\r\n            arrayIndexValues[i] = \"\";\r\n            // store the properties for the next iteration (the item of the array)\r\n            arrayIndexValues[i + 1] = arrayIndex;\r\n            propertyNames.splice(i + 1, 0, \"item\");\r\n            // skip the next iteration. its the array item and its already set\r\n            i++;\r\n            // it the array notation is the beginning\r\n          } else {\r\n            // store the array index and override the entry in the property names\r\n            arrayIndexValues[i] = arrayIndex;\r\n            propertyNames.splice(i, 1, \"item\");\r\n          }\r\n        } else {\r\n          arrayIndexValues[i] = \"\";\r\n        }\r\n      }\r\n\r\n      return arrayIndexValues;\r\n    },\r\n\r\n    /**\r\n     * Internal helper method which is actually doing all bindings. That means\r\n     * that an event listener will be added to the source object which listens\r\n     * to the given event and invokes an set on the target property on the\r\n     * targetObject.\r\n     * This method does not store the binding in the internal reference store\r\n     * so it should NOT be used from outside this class. For an outside usage,\r\n     * use {@link #bind}.\r\n     *\r\n     * @param sourceObject {qx.core.Object} The source of the binding.\r\n     * @param sourceEvent {String} The event of the source object which could\r\n     *   be the change event in common but has to be an\r\n     *   {@link qx.event.type.Data} event.\r\n     * @param targetObject {qx.core.Object} The object which the source should\r\n     *   be bind to.\r\n     * @param targetProperty {String} The property name of the target object.\r\n     * @param options {Map} A map containing the options. See\r\n     *   {@link #bind} for more information.\r\n     * @param arrayIndex {String} The index of the given array if its an array\r\n     *   to bind.\r\n     *\r\n     * @return {var} Returns the internal id for that binding. This can be used\r\n     *   for referencing the binding or e.g. for removing. This is not an atomic\r\n     *   id so you can't you use it as a hash-map index. It's the id which will\r\n     *   be returned by the {@link qx.core.Object#addListener} method.\r\n     * @throws {qx.core.AssertionError} If the event is no data event or\r\n     *   there is no property definition for the target object and target\r\n     *   property.\r\n     */\r\n    __bindEventToProperty(\r\n      sourceObject,\r\n      sourceEvent,\r\n      targetObject,\r\n      targetProperty,\r\n      options,\r\n      arrayIndex\r\n    ) {\r\n      // checks\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        // check for the data event\r\n        var eventType = qx.Class.getEventType(\r\n          sourceObject.constructor,\r\n          sourceEvent\r\n        );\r\n\r\n        qx.core.Assert.assertEquals(\r\n          \"qx.event.type.Data\",\r\n          eventType,\r\n          sourceEvent +\r\n            \" is not an data (qx.event.type.Data) event on \" +\r\n            sourceObject +\r\n            \".\"\r\n        );\r\n      }\r\n\r\n      var bindListener = function (arrayIndex, e) {\r\n        // if an array value is given\r\n        if (arrayIndex !== \"\") {\r\n          //check if its the \"last\" value\r\n          if (arrayIndex === \"last\") {\r\n            arrayIndex = sourceObject.length - 1;\r\n          }\r\n\r\n          // get the data of the array\r\n          var data = sourceObject.getItem(arrayIndex);\r\n\r\n          // reset the target if the data is not set\r\n          if (data === undefined) {\r\n            qx.data.SingleValueBinding.__resetTargetValue(\r\n              targetObject,\r\n              targetProperty\r\n            );\r\n          }\r\n\r\n          // only do something if the current array has been changed\r\n          var start = e.getData().start;\r\n          var end = e.getData().end;\r\n          if (arrayIndex < start || arrayIndex > end) {\r\n            return;\r\n          }\r\n        } else {\r\n          // get the data out of the event\r\n          var data = e.getData();\r\n        }\r\n\r\n        // debug message\r\n        if (qx.core.Environment.get(\"qx.debug.databinding\")) {\r\n          qx.log.Logger.debug(\r\n            \"Binding executed from \" +\r\n              sourceObject +\r\n              \" by \" +\r\n              sourceEvent +\r\n              \" to \" +\r\n              targetObject +\r\n              \" (\" +\r\n              targetProperty +\r\n              \")\"\r\n          );\r\n\r\n          qx.log.Logger.debug(\"Data before conversion: \" + data);\r\n        }\r\n\r\n        // convert the data\r\n        data = qx.data.SingleValueBinding.__convertValue(\r\n          data,\r\n          targetObject,\r\n          targetProperty,\r\n          options,\r\n          sourceObject\r\n        );\r\n\r\n        // debug message\r\n        if (qx.core.Environment.get(\"qx.debug.databinding\")) {\r\n          qx.log.Logger.debug(\"Data after conversion: \" + data);\r\n        }\r\n\r\n        // try to set the value\r\n        var result;\r\n        try {\r\n          if (data !== undefined) {\r\n            result = qx.data.SingleValueBinding.__setTargetValue(\r\n              targetObject,\r\n              targetProperty,\r\n              data\r\n            );\r\n          } else {\r\n            result = qx.data.SingleValueBinding.__resetTargetValue(\r\n              targetObject,\r\n              targetProperty\r\n            );\r\n          }\r\n\r\n          // tell the user that the setter was invoked probably\r\n          if (options && options.onUpdate) {\r\n            options.onUpdate(sourceObject, targetObject, data);\r\n          }\r\n        } catch (ex) {\r\n          if (!(ex instanceof qx.core.ValidationError)) {\r\n            throw ex;\r\n          }\r\n\r\n          if (options && options.onSetFail) {\r\n            options.onSetFail(ex);\r\n          } else {\r\n            qx.log.Logger.warn(\r\n              \"Failed so set value \" +\r\n                data +\r\n                \" on \" +\r\n                targetObject +\r\n                \". Error message: \" +\r\n                ex\r\n            );\r\n          }\r\n        }\r\n        return result;\r\n      };\r\n\r\n      // check if an array index is given\r\n      if (!arrayIndex) {\r\n        // if not, signal it a s an empty string\r\n        arrayIndex = \"\";\r\n      }\r\n      // bind the listener function (make the array index in the listener available)\r\n      bindListener = qx.lang.Function.bind(\r\n        bindListener,\r\n        sourceObject,\r\n        arrayIndex\r\n      );\r\n\r\n      // add the listener\r\n      var id = sourceObject.addListener(sourceEvent, bindListener);\r\n\r\n      return id;\r\n    },\r\n\r\n    /**\r\n     * This method stores the given value as a binding in the internal structure\r\n     * of all bindings.\r\n     *\r\n     * @param id {var} The listener id of the id for a deeper binding.\r\n     * @param sourceObject {qx.core.Object} The source Object of the binding.\r\n     * @param sourceEvent {String} The name of the source event.\r\n     * @param targetObject {qx.core.Object} The target object.\r\n     * @param targetProperty {String} The name of the property on the target\r\n     *   object.\r\n     */\r\n    __storeBinding(\r\n      id,\r\n      sourceObject,\r\n      sourceEvent,\r\n      targetObject,\r\n      targetProperty\r\n    ) {\r\n      var hash;\r\n\r\n      // add the listener id to the internal registry\r\n      hash = sourceObject.toHashCode();\r\n      if (this.__bindings[hash] === undefined) {\r\n        this.__bindings[hash] = [];\r\n      }\r\n\r\n      var binding = [\r\n        id,\r\n        sourceObject,\r\n        sourceEvent,\r\n        targetObject,\r\n        targetProperty\r\n      ];\r\n\r\n      this.__bindings[hash].push(binding);\r\n\r\n      // add same binding data indexed by target object\r\n      hash = targetObject.toHashCode();\r\n      if (this.__bindingsByTarget[hash] === undefined) {\r\n        this.__bindingsByTarget[hash] = [];\r\n      }\r\n      this.__bindingsByTarget[hash].push(binding);\r\n    },\r\n\r\n    /**\r\n     * This method takes the given value, checks if the user has given a\r\n     * converter and converts the value to its target type. If no converter is\r\n     * given by the user, the {@link #__defaultConversion} will try to convert\r\n     * the value.\r\n     *\r\n     * @param value {var} The value which possibly should be converted.\r\n     * @param targetObject {qx.core.Object} The target object.\r\n     * @param targetPropertyChain {String} The property name of the target object.\r\n     * @param options {Map} The options map which can includes the converter.\r\n     *   For a detailed information on the map, take a look at\r\n     *   {@link #bind}.\r\n     * @param sourceObject {qx.core.Object} The source object for the binding.\r\n     *\r\n     * @return {var} The converted value. If no conversion has been done, the\r\n     *   value property will be returned.\r\n     * @throws {qx.core.AssertionError} If there is no property definition\r\n     *   of the given target object and target property.\r\n     */\r\n    __convertValue(\r\n      value,\r\n      targetObject,\r\n      targetPropertyChain,\r\n      options,\r\n      sourceObject\r\n    ) {\r\n      // do the conversion given by the user\r\n      if (options && options.converter) {\r\n        var model;\r\n        if (targetObject.getModel) {\r\n          model = targetObject.getModel();\r\n        }\r\n        return options.converter(value, model, sourceObject, targetObject);\r\n        // try default conversion\r\n      } else {\r\n        var properties = this.__getPropertyChainArray(targetPropertyChain);\r\n        var target = this.__getTargetFromChain(targetObject, properties);\r\n        var lastProperty = targetPropertyChain.substring(\r\n          targetPropertyChain.lastIndexOf(\".\") + 1,\r\n          targetPropertyChain.length\r\n        );\r\n\r\n        // if no target is currently available, return the original value\r\n        if (target == null) {\r\n          return value;\r\n        }\r\n\r\n        var propertieDefinition = qx.Class.getPropertyDefinition(\r\n          target.constructor,\r\n          lastProperty\r\n        );\r\n\r\n        var check =\r\n          propertieDefinition == null ? \"\" : propertieDefinition.check;\r\n        return this.__defaultConversion(value, check);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Helper method which tries to figure out if the given property on the\r\n     * given object does have a change event and if returns the name of it.\r\n     *\r\n     * @param sourceObject {qx.core.Object} The object to check.\r\n     * @param sourceProperty {String} The name of the property.\r\n     *\r\n     * @return {String} The name of the change event.\r\n     * @throws {qx.core.AssertionError} If there is no property definition of\r\n     *   the given object property pair.\r\n     */\r\n    __getEventForProperty(sourceObject, sourceProperty) {\r\n      // get the event name\r\n      var propertieDefinition = qx.Class.getPropertyDefinition(\r\n        sourceObject.constructor,\r\n        sourceProperty\r\n      );\r\n\r\n      if (propertieDefinition == null) {\r\n        return null;\r\n      }\r\n      return propertieDefinition.event;\r\n    },\r\n\r\n    /**\r\n     * Tries to convert the data to the type given in the targetCheck argument.\r\n     *\r\n     * @param data {var} The data to convert.\r\n     * @param targetCheck {String} The value of the check property. That usually\r\n     *   contains the target type.\r\n     * @return {Integer|String|Float} The converted data\r\n     */\r\n    __defaultConversion(data, targetCheck) {\r\n      var dataType = qx.lang.Type.getClass(data);\r\n\r\n      // to integer\r\n      if (\r\n        (dataType == \"Number\" || dataType == \"String\") &&\r\n        (targetCheck == \"Integer\" || targetCheck == \"PositiveInteger\")\r\n      ) {\r\n        data = parseInt(data, 10);\r\n      }\r\n\r\n      // to string\r\n      if (\r\n        (dataType == \"Boolean\" || dataType == \"Number\" || dataType == \"Date\") &&\r\n        targetCheck == \"String\"\r\n      ) {\r\n        data = data + \"\";\r\n      }\r\n\r\n      // to float\r\n      if (\r\n        (dataType == \"Number\" || dataType == \"String\") &&\r\n        (targetCheck == \"Number\" || targetCheck == \"PositiveNumber\")\r\n      ) {\r\n        data = parseFloat(data);\r\n      }\r\n\r\n      return data;\r\n    },\r\n\r\n    /**\r\n     * Removes the binding with the given id from the given sourceObject. The\r\n     * id has to be the id returned by any of the bind functions.\r\n     *\r\n     * @param sourceObject {qx.core.Object} The source object of the binding.\r\n     * @param id {var} The id of the binding.\r\n     * @throws {Error} If the binding could not be found.\r\n     */\r\n    removeBindingFromObject(sourceObject, id) {\r\n      // check for a deep binding\r\n      if (id.type == \"deepBinding\") {\r\n        // go through all added listeners (source)\r\n        for (var i = 0; i < id.sources.length; i++) {\r\n          // check if a source is available\r\n          if (id.sources[i]) {\r\n            if (id.listenerIds[i]) {\r\n              id.sources[i].removeListenerById(id.listenerIds[i]);\r\n            }\r\n            // If the listener id is not available, it is most likely\r\n            // caused by some hidden error situation.\r\n            // At least an error message should be displayed\r\n            else {\r\n              sourceObject.error(\r\n                \"Could not remove deep bindings. Binding id for \" +\r\n                  id.sources[i].classname +\r\n                  \" could not be found!\"\r\n              );\r\n            }\r\n          }\r\n        }\r\n        // go through all added listeners (target)\r\n        for (var i = 0; i < id.targets.length; i++) {\r\n          // check if a target is available\r\n          if (id.targets[i]) {\r\n            if (id.targetListenerIds[i]) {\r\n              id.targets[i].removeListenerById(id.targetListenerIds[i]);\r\n            }\r\n            // If the target listener id is not available, it is most likely\r\n            // caused by some hidden error situation.\r\n            // At least an error message should be displayed\r\n            else {\r\n              sourceObject.error(\r\n                \"Could not remove target listener. Listener id for target \" +\r\n                  id.targets[i].classname +\r\n                  \" could not be found!\"\r\n              );\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        // remove the listener\r\n        sourceObject.removeListenerById(id);\r\n      }\r\n\r\n      // remove the id from the internal reference system\r\n      var bindings = this.getAllBindingsForObject(sourceObject);\r\n      // check if the binding exists\r\n      if (bindings != undefined) {\r\n        for (var i = 0; i < bindings.length; i++) {\r\n          if (bindings[i][0] == id) {\r\n            // remove binding data from internal reference indexed by target object\r\n            var target = bindings[i][3];\r\n            if (this.__bindingsByTarget[target.toHashCode()]) {\r\n              qx.lang.Array.remove(\r\n                this.__bindingsByTarget[target.toHashCode()],\r\n                bindings[i]\r\n              );\r\n            }\r\n\r\n            // remove binding data from internal reference indexed by source object\r\n            var source = bindings[i][1];\r\n            if (this.__bindings[source.toHashCode()]) {\r\n              qx.lang.Array.remove(\r\n                this.__bindings[source.toHashCode()],\r\n                bindings[i]\r\n              );\r\n            }\r\n            return;\r\n          }\r\n        }\r\n      }\r\n      throw new Error(\"Binding could not be found!\");\r\n    },\r\n\r\n    /**\r\n     * Removes all bindings for the given object.\r\n     *\r\n     * @param object {qx.core.Object} The object of which the bindings should be\r\n     *   removed.\r\n     * @throws {qx.core.AssertionError} If the object is not in the internal\r\n     *   registry of the bindings.\r\n     * @throws {Error} If one of the bindings listed internally can not be\r\n     *   removed.\r\n     */\r\n    removeAllBindingsForObject(object) {\r\n      // check for the null value\r\n\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        qx.core.Assert.assertNotNull(\r\n          object,\r\n          \"Can not remove the bindings for null object!\"\r\n        );\r\n      }\r\n\r\n      // get the bindings\r\n      var bindings = this.getAllBindingsForObject(object);\r\n      if (bindings != undefined) {\r\n        // remove every binding with the removeBindingFromObject function\r\n        for (var i = bindings.length - 1; i >= 0; i--) {\r\n          this.removeBindingFromObject(object, bindings[i][0]);\r\n        }\r\n      }\r\n\r\n      var hash = object.toHashCode();\r\n      delete this.__bindings[hash];\r\n      delete this.__bindingsByTarget[hash];\r\n    },\r\n\r\n    /**\r\n     * Removes all bindings between given objects.\r\n     *\r\n     * @param object {qx.core.Object} The object of which the bindings should be\r\n     *   removed.\r\n     * @param relatedObject {qx.core.Object} The object of which related\r\n     *   bindings should be removed.\r\n     * @throws {qx.core.AssertionError} If the object is not in the internal\r\n     *   registry of the bindings.\r\n     * @throws {Error} If one of the bindings listed internally can not be\r\n     *   removed.\r\n     */\r\n    removeRelatedBindings(object, relatedObject) {\r\n      // check for the null value\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        qx.core.Assert.assertNotNull(\r\n          object,\r\n          \"Can not remove the bindings for null object!\"\r\n        );\r\n\r\n        qx.core.Assert.assertNotNull(\r\n          relatedObject,\r\n          \"Can not remove the bindings for null object!\"\r\n        );\r\n      }\r\n\r\n      // get the bindings\r\n      var bindings = this.getAllBindingsForObject(object);\r\n      if (bindings != undefined) {\r\n        // remove every binding with the removeBindingFromObject function\r\n        for (var i = bindings.length - 1; i >= 0; i--) {\r\n          var source = bindings[i][1];\r\n          var target = bindings[i][3];\r\n          if (source === relatedObject || target === relatedObject) {\r\n            this.removeBindingFromObject(object, bindings[i][0]);\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns an array which lists all bindings.\r\n     *\r\n     * @param object {qx.core.Object} The object of which the bindings should\r\n     *   be returned.\r\n     *\r\n     * @return {Array} An array of binding informations. Every binding\r\n     *   information is an array itself containing id, sourceObject,\r\n     *   sourceEvent, targetObject and targetProperty in that order.\r\n     */\r\n    getAllBindingsForObject(object) {\r\n      var hash = object.toHashCode();\r\n\r\n      // get all bindings of object as source\r\n      var sourceBindings = this.__bindings[hash];\r\n\r\n      // get all bindings of object as target\r\n      var targetBindings = this.__bindingsByTarget[hash];\r\n\r\n      if (!sourceBindings && !targetBindings) {\r\n        return [];\r\n      }\r\n      if (!sourceBindings) {\r\n        return qx.lang.Array.clone(targetBindings);\r\n      }\r\n      if (!targetBindings) {\r\n        return qx.lang.Array.clone(sourceBindings);\r\n      }\r\n\r\n      return qx.lang.Array.unique(sourceBindings.concat(targetBindings));\r\n    },\r\n\r\n    /**\r\n     * Removes all binding in the whole application. After that not a single\r\n     * binding is left.\r\n     * @deprecated {6.0} dispose and destructors are deprecated because of automatic memory management; this\r\n     * will only work for objects explicitly registered with ObjectRegistry.register\r\n     */\r\n    removeAllBindings() {\r\n      // go through all registered objects\r\n      for (var hash in this.__bindings) {\r\n        var object = qx.core.ObjectRegistry.fromHashCode(hash);\r\n        // check for the object, perhaps its already deleted\r\n        if (object == null) {\r\n          delete this.__bindings[hash];\r\n          continue;\r\n        }\r\n        this.removeAllBindingsForObject(object);\r\n      }\r\n      // reset the bindings map\r\n      this.__bindings = {};\r\n    },\r\n\r\n    /**\r\n     * Returns a map containing for every bound object an array of data binding\r\n     * information. The key of the map is the hash code of the bound objects.\r\n     * Every binding is represented by an array containing id, sourceObject,\r\n     * sourceEvent, targetObject and targetProperty.\r\n     *\r\n     * @return {Map} Map containing all bindings.\r\n     */\r\n    getAllBindings() {\r\n      return this.__bindings;\r\n    },\r\n\r\n    /**\r\n     * Debug function which shows some valuable information about the given\r\n     * binding in console. For that it uses {@link qx.log.Logger}.\r\n     *\r\n     * @param object {qx.core.Object} the source of the binding.\r\n     * @param id {var} The id of the binding.\r\n     */\r\n    showBindingInLog(object, id) {\r\n      var binding;\r\n      // go through all bindings of the given object\r\n      for (var i = 0; i < this.__bindings[object.toHashCode()].length; i++) {\r\n        // the first array item is the id\r\n        if (this.__bindings[object.toHashCode()][i][0] == id) {\r\n          binding = this.__bindings[object.toHashCode()][i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (binding === undefined) {\r\n        var message = \"Binding does not exist!\";\r\n      } else {\r\n        var message =\r\n          \"Binding from '\" +\r\n          binding[1] +\r\n          \"' (\" +\r\n          binding[2] +\r\n          \") to the object '\" +\r\n          binding[3] +\r\n          \"' (\" +\r\n          binding[4] +\r\n          \").\";\r\n      }\r\n\r\n      qx.log.Logger.debug(message);\r\n    },\r\n\r\n    /**\r\n     * Debug function which shows all bindings in the log console. To get only\r\n     * one binding in the console use {@link #showBindingInLog}\r\n     * @deprecated {6.0} qx.core.ObjectRegistry no longer stores most objects\r\n     */\r\n    showAllBindingsInLog() {\r\n      // go through all objects in the registry\r\n      for (var hash in this.__bindings) {\r\n        var object = qx.core.ObjectRegistry.fromHashCode(hash);\r\n        if (object) {\r\n          for (var i = 0; i < this.__bindings[hash].length; i++) {\r\n            this.showBindingInLog(object, this.__bindings[hash][i][0]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n});\r\n"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAS,CAACC,oBAAoB,CAACC,aAAa,CAAC;EAAhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;EACAH,EAAE,CAACI,KAAK,CAACC,MAAM,CAAC,4BAA4B,EAAE;IAC5CC,OAAO,EAAE;MACP;MACAC,SAAU,EAAE,CAAC,CAAC;MAEd;MACAC,SAAkB,EAAE,CAAC,CAAC;MAEtB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,IAAI,WAAAA,KACFC,YAAY,EACZC,mBAAmB,EACnBC,YAAY,EACZC,mBAAmB,EACnBC,OAAO,EACP;QACA;;QAQA;QACA,IAAIC,iBAAiB,GAAG,IAAI,CAACC,SAAoB,CAC/CN,YAAY,EACZC,mBAAmB,EACnBC,YAAY,EACZC,mBAAmB,EACnBC,OACF,CAAC;;QAED;QACA,IAAIG,aAAa,GAAGN,mBAAmB,CAACO,KAAK,CAAC,GAAG,CAAC;;QAElD;QACA,IAAIC,gBAAgB,GAAG,IAAI,CAACC,SAA8B,CAACH,aAAa,CAAC;QACzE,IAAII,OAAO,GAAG,EAAE;QAChB,IAAIC,SAAS,GAAG,EAAE;QAClB,IAAIC,WAAW,GAAG,EAAE;QACpB,IAAIC,UAAU,GAAG,EAAE;QACnB,IAAIC,MAAM,GAAGf,YAAY;QACzB,IAAIgB,cAA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"
}