{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__normalizations",
    "__hooks",
    "on",
    "off",
    "__isReady",
    "ready",
    "callback",
    "document",
    "readyState",
    "window",
    "setTimeout",
    "onWindowLoad",
    "module",
    "Event",
    "qxWeb",
    "wrappedCallback",
    "env",
    "get",
    "bom",
    "addNativeListener",
    "timer",
    "documentElement",
    "doScroll",
    "body",
    "error",
    "$registerEventNormalization",
    "types",
    "normalizer",
    "lang",
    "Type",
    "isArray",
    "registry",
    "i",
    "l",
    "length",
    "type",
    "isFunction",
    "push",
    "$unregisterEventNormalization",
    "Array",
    "remove",
    "$getEventNormalizationRegistry",
    "$registerEventHook",
    "registerHook",
    "unregisterHook",
    "onHooks",
    "offHooks",
    "$unregisterEventHook",
    "$getEventHookRegistry",
    "members",
    "listener",
    "context",
    "useCapture",
    "el",
    "ctx",
    "hooks",
    "typeHooks",
    "concat",
    "j",
    "m",
    "bound",
    "event",
    "normalizations",
    "x",
    "y",
    "apply",
    "bind",
    "original",
    "$$emitter",
    "Emitter",
    "$$lastlistenerId",
    "getEntryById",
    "__listener",
    "__ctx",
    "removeAll",
    "listenerType",
    "id",
    "storedListener",
    "hasStoredContext",
    "storedContext",
    "result",
    "removeNativeListener",
    "k",
    "allOff",
    "offById",
    "entry",
    "name",
    "emit",
    "data",
    "once",
    "self",
    "wrappedListener",
    "call",
    "hasListener",
    "getListeners",
    "attachedListeners",
    "undefined",
    "copyEventsTo",
    "target",
    "source",
    "targetCopy",
    "descendants",
    "getElementsByTagName",
    "forEach",
    "storage",
    "hover",
    "callbackIn",
    "callbackOut",
    "onMatchTarget",
    "eventType",
    "e",
    "eventTarget",
    "getTarget",
    "is",
    "object",
    "clone",
    "targetToMatch",
    "find",
    "isChildOf",
    "matchTarget",
    "$$matchTargetInfo",
    "offMatchTarget",
    "infos",
    "splice",
    "defer",
    "$attachAll",
    "$attachStatic"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/module/Event.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2011-2012 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Martin Wittemann (wittemann)\r\n     * Daniel Wagner (danielwagner)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * Support for native and custom events.\r\n *\r\n * @require(qx.module.Polyfill)\r\n * @require(qx.module.Environment)\r\n * @use(qx.module.event.PointerHandler)\r\n * @group (Core)\r\n */\r\nqx.Bootstrap.define(\"qx.module.Event\", {\r\n  statics: {\r\n    /**\r\n     * Event normalization registry\r\n     *\r\n     * @internal\r\n     */\r\n    __normalizations: {},\r\n\r\n    /**\r\n     * Registry of event hooks\r\n     * @internal\r\n     */\r\n    __hooks: {\r\n      on: {},\r\n      off: {}\r\n    },\r\n\r\n    __isReady: false,\r\n\r\n    /**\r\n     * Executes the given function once the document is ready.\r\n     *\r\n     * @attachStatic {qxWeb}\r\n     * @param callback {Function} callback function\r\n     */\r\n    ready(callback) {\r\n      // DOM is already ready\r\n      if (document.readyState === \"complete\") {\r\n        window.setTimeout(callback, 1);\r\n        return;\r\n      }\r\n\r\n      // listen for the load event so the callback is executed no matter what\r\n      var onWindowLoad = function () {\r\n        qx.module.Event.__isReady = true;\r\n        callback();\r\n      };\r\n\r\n      qxWeb(window).on(\"load\", onWindowLoad);\r\n\r\n      var wrappedCallback = function () {\r\n        qxWeb(window).off(\"load\", onWindowLoad);\r\n        callback();\r\n      };\r\n\r\n      // Listen for DOMContentLoaded event if available (no way to reliably detect\r\n      // support)\r\n      if (\r\n        qxWeb.env.get(\"engine.name\") !== \"mshtml\" ||\r\n        qxWeb.env.get(\"browser.documentmode\") > 8\r\n      ) {\r\n        qx.bom.Event.addNativeListener(\r\n          document,\r\n          \"DOMContentLoaded\",\r\n          wrappedCallback\r\n        );\r\n      } else {\r\n        // Continually check to see if the document is ready\r\n        var timer = function () {\r\n          // onWindowLoad already executed\r\n          if (qx.module.Event.__isReady) {\r\n            return;\r\n          }\r\n          try {\r\n            // If DOMContentLoaded is unavailable, use the trick by Diego Perini\r\n            // http://javascript.nwbox.com/IEContentLoaded/\r\n            document.documentElement.doScroll(\"left\");\r\n            if (document.body) {\r\n              wrappedCallback();\r\n            }\r\n          } catch (error) {\r\n            window.setTimeout(timer, 100);\r\n          }\r\n        };\r\n\r\n        timer();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Registers a normalization function for the given event types. Listener\r\n     * callbacks for these types will be called with the return value of the\r\n     * normalization function instead of the regular event object.\r\n     *\r\n     * The normalizer will be called with two arguments: The original event\r\n     * object and the element on which the event was triggered\r\n     *\r\n     * @attachStatic {qxWeb, $registerEventNormalization}\r\n     * @param types {String[]} List of event types to be normalized. Use an\r\n     * asterisk (<code>*</code>) to normalize all event types\r\n     * @param normalizer {Function} Normalizer function\r\n     */\r\n    $registerEventNormalization(types, normalizer) {\r\n      if (!qx.lang.Type.isArray(types)) {\r\n        types = [types];\r\n      }\r\n      var registry = qx.module.Event.__normalizations;\r\n      for (var i = 0, l = types.length; i < l; i++) {\r\n        var type = types[i];\r\n        if (qx.lang.Type.isFunction(normalizer)) {\r\n          if (!registry[type]) {\r\n            registry[type] = [];\r\n          }\r\n          registry[type].push(normalizer);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Unregisters a normalization function from the given event types.\r\n     *\r\n     * @attachStatic {qxWeb, $unregisterEventNormalization}\r\n     * @param types {String[]} List of event types\r\n     * @param normalizer {Function} Normalizer function\r\n     */\r\n    $unregisterEventNormalization(types, normalizer) {\r\n      if (!qx.lang.Type.isArray(types)) {\r\n        types = [types];\r\n      }\r\n      var registry = qx.module.Event.__normalizations;\r\n      for (var i = 0, l = types.length; i < l; i++) {\r\n        var type = types[i];\r\n        if (registry[type]) {\r\n          qx.lang.Array.remove(registry[type], normalizer);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns all registered event normalizers\r\n     *\r\n     * @attachStatic {qxWeb, $getEventNormalizationRegistry}\r\n     * @return {Map} Map of event types/normalizer functions\r\n     */\r\n    $getEventNormalizationRegistry() {\r\n      return qx.module.Event.__normalizations;\r\n    },\r\n\r\n    /**\r\n     * Registers an event hook for the given event types.\r\n     *\r\n     * @attachStatic {qxWeb, $registerEventHook}\r\n     * @param types {String[]} List of event types\r\n     * @param registerHook {Function} Hook function to be called on event registration\r\n     * @param unregisterHook {Function?} Hook function to be called on event deregistration\r\n     * @internal\r\n     */\r\n    $registerEventHook(types, registerHook, unregisterHook) {\r\n      if (!qx.lang.Type.isArray(types)) {\r\n        types = [types];\r\n      }\r\n      var onHooks = qx.module.Event.__hooks.on;\r\n      for (var i = 0, l = types.length; i < l; i++) {\r\n        var type = types[i];\r\n        if (qx.lang.Type.isFunction(registerHook)) {\r\n          if (!onHooks[type]) {\r\n            onHooks[type] = [];\r\n          }\r\n          onHooks[type].push(registerHook);\r\n        }\r\n      }\r\n      if (!unregisterHook) {\r\n        return;\r\n      }\r\n      var offHooks = qx.module.Event.__hooks.off;\r\n      for (var i = 0, l = types.length; i < l; i++) {\r\n        var type = types[i];\r\n        if (qx.lang.Type.isFunction(unregisterHook)) {\r\n          if (!offHooks[type]) {\r\n            offHooks[type] = [];\r\n          }\r\n          offHooks[type].push(unregisterHook);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Unregisters a hook from the given event types.\r\n     *\r\n     * @attachStatic {qxWeb, $unregisterEventHooks}\r\n     * @param types {String[]} List of event types\r\n     * @param registerHook {Function} Hook function to be called on event registration\r\n     * @param unregisterHook {Function?} Hook function to be called on event deregistration\r\n     * @internal\r\n     */\r\n    $unregisterEventHook(types, registerHook, unregisterHook) {\r\n      if (!qx.lang.Type.isArray(types)) {\r\n        types = [types];\r\n      }\r\n      var onHooks = qx.module.Event.__hooks.on;\r\n      for (var i = 0, l = types.length; i < l; i++) {\r\n        var type = types[i];\r\n        if (onHooks[type]) {\r\n          qx.lang.Array.remove(onHooks[type], registerHook);\r\n        }\r\n      }\r\n      if (!unregisterHook) {\r\n        return;\r\n      }\r\n      var offHooks = qx.module.Event.__hooks.off;\r\n      for (var i = 0, l = types.length; i < l; i++) {\r\n        var type = types[i];\r\n        if (offHooks[type]) {\r\n          qx.lang.Array.remove(offHooks[type], unregisterHook);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns all registered event hooks\r\n     *\r\n     * @attachStatic {qxWeb, $getEventHookRegistry}\r\n     * @return {Map} Map of event types/registration hook functions\r\n     * @internal\r\n     */\r\n    $getEventHookRegistry() {\r\n      return qx.module.Event.__hooks;\r\n    }\r\n  },\r\n\r\n  members: {\r\n    /**\r\n     * Registers a listener for the given event type on each item in the\r\n     * collection. This can be either native or custom events.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param type {String} Type of the event to listen for\r\n     * @param listener {Function} Listener callback\r\n     * @param context {Object?} Context the callback function will be executed in.\r\n     * Default: The element on which the listener was registered\r\n     * @param useCapture {Boolean?} Attach the listener to the capturing\r\n     * phase if true\r\n     * @return {qxWeb} The collection for chaining\r\n     */\r\n    on(type, listener, context, useCapture) {\r\n      for (var i = 0; i < this.length; i++) {\r\n        var el = this[i];\r\n        var ctx = context || qxWeb(el);\r\n\r\n        // call hooks\r\n        var hooks = qx.module.Event.__hooks.on;\r\n        // generic\r\n        var typeHooks = hooks[\"*\"] || [];\r\n        // type specific\r\n        if (hooks[type]) {\r\n          typeHooks = typeHooks.concat(hooks[type]);\r\n        }\r\n        for (var j = 0, m = typeHooks.length; j < m; j++) {\r\n          typeHooks[j](el, type, listener, context);\r\n        }\r\n\r\n        var bound = function (el, event) {\r\n          // apply normalizations\r\n          var registry = qx.module.Event.__normalizations;\r\n          // generic\r\n          var normalizations = registry[\"*\"] || [];\r\n          // type specific\r\n          if (registry[type]) {\r\n            normalizations = normalizations.concat(registry[type]);\r\n          }\r\n\r\n          for (var x = 0, y = normalizations.length; x < y; x++) {\r\n            event = normalizations[x](event, el, type);\r\n          }\r\n          // call original listener with normalized event\r\n          listener.apply(this, [event]);\r\n        }.bind(ctx, el);\r\n        bound.original = listener;\r\n\r\n        // add native listener\r\n        qx.bom.Event.addNativeListener(el, type, bound, useCapture);\r\n\r\n        // create an emitter if necessary\r\n        if (!el.$$emitter) {\r\n          el.$$emitter = new qx.event.Emitter();\r\n        }\r\n\r\n        el.$$lastlistenerId = el.$$emitter.on(type, bound, ctx);\r\n        // save the useCapture for removing\r\n        el.$$emitter.getEntryById(el.$$lastlistenerId).useCapture =\r\n          !!useCapture;\r\n\r\n        if (!el.__listener) {\r\n          el.__listener = {};\r\n        }\r\n        if (!el.__listener[type]) {\r\n          el.__listener[type] = {};\r\n        }\r\n        el.__listener[type][el.$$lastlistenerId] = bound;\r\n\r\n        if (!context) {\r\n          // store a reference to the dynamically created context so we know\r\n          // what to check for when removing the listener\r\n          if (!el.__ctx) {\r\n            el.__ctx = {};\r\n          }\r\n          el.__ctx[el.$$lastlistenerId] = ctx;\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Unregisters event listeners for the given type from each element in the\r\n     * collection.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param type {String} Type of the event\r\n     * @param listener {Function} Listener callback\r\n     * @param context {Object?} Listener callback context\r\n     * @param useCapture {Boolean?} Attach the listener to the capturing\r\n     * phase if true\r\n     * @return {qxWeb} The collection for chaining\r\n     */\r\n    off(type, listener, context, useCapture) {\r\n      var removeAll = listener === null && context === null;\r\n\r\n      for (var j = 0; j < this.length; j++) {\r\n        var el = this[j];\r\n\r\n        // continue if no listeners are available\r\n        if (!el.__listener) {\r\n          continue;\r\n        }\r\n\r\n        var types = [];\r\n        if (type !== null) {\r\n          types.push(type);\r\n        } else {\r\n          // no type specified, remove all listeners\r\n          for (var listenerType in el.__listener) {\r\n            types.push(listenerType);\r\n          }\r\n        }\r\n\r\n        for (var i = 0, l = types.length; i < l; i++) {\r\n          for (var id in el.__listener[types[i]]) {\r\n            var storedListener = el.__listener[types[i]][id];\r\n            if (\r\n              removeAll ||\r\n              storedListener == listener ||\r\n              storedListener.original == listener\r\n            ) {\r\n              // get the stored context\r\n              var hasStoredContext =\r\n                typeof el.__ctx !== \"undefined\" && el.__ctx[id];\r\n              var storedContext;\r\n              if (!context && hasStoredContext) {\r\n                storedContext = el.__ctx[id];\r\n              }\r\n              // remove the listener from the emitter\r\n              var result = el.$$emitter.off(\r\n                types[i],\r\n                storedListener,\r\n                storedContext || context\r\n              );\r\n\r\n              // check if it's a bound listener which means it was a native event\r\n              if (removeAll || storedListener.original == listener) {\r\n                // remove the native listener\r\n                qx.bom.Event.removeNativeListener(\r\n                  el,\r\n                  types[i],\r\n                  storedListener,\r\n                  useCapture\r\n                );\r\n              }\r\n\r\n              // BUG #9184\r\n              // only if the emitter was successfully removed also delete the key in the data structure\r\n              if (result !== null) {\r\n                delete el.__listener[types[i]][id];\r\n              }\r\n\r\n              if (hasStoredContext) {\r\n                delete el.__ctx[id];\r\n              }\r\n            }\r\n          }\r\n\r\n          // call hooks\r\n          var hooks = qx.module.Event.__hooks.off;\r\n          // generic\r\n          var typeHooks = hooks[\"*\"] || [];\r\n          // type specific\r\n          if (hooks[type]) {\r\n            typeHooks = typeHooks.concat(hooks[type]);\r\n          }\r\n          for (var k = 0, m = typeHooks.length; k < m; k++) {\r\n            typeHooks[k](el, type, listener, context);\r\n          }\r\n        }\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all event listeners (or all listeners for a given type) from the\r\n     * collection.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param type {String?} Event type. All listeners will be removed if this is undefined.\r\n     * @return {qxWeb} The collection for chaining\r\n     */\r\n    allOff(type) {\r\n      return this.off(type || null, null, null);\r\n    },\r\n\r\n    /**\r\n     * Removes the listener with the given id.\r\n     * @param id {Number} The id of the listener to remove\r\n     * @return {qxWeb} The collection for chaining.\r\n     */\r\n    offById(id) {\r\n      var entry = this[0].$$emitter.getEntryById(id);\r\n      return this.off(\r\n        entry.name,\r\n        entry.listener.original,\r\n        entry.ctx,\r\n        entry.useCapture\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Fire an event of the given type.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param type {String} Event type\r\n     * @param data {var?} Optional data that will be passed to the listener\r\n     * callback function.\r\n     * @return {qxWeb} The collection for chaining\r\n     */\r\n    emit(type, data) {\r\n      for (var j = 0; j < this.length; j++) {\r\n        var el = this[j];\r\n        if (el.$$emitter) {\r\n          el.$$emitter.emit(type, data);\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Attaches a listener for the given event that will be executed only once.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param type {String} Type of the event to listen for\r\n     * @param listener {Function} Listener callback\r\n     * @param context {Object?} Context the callback function will be executed in.\r\n     * Default: The element on which the listener was registered\r\n     * @return {qxWeb} The collection for chaining\r\n     */\r\n    once(type, listener, context) {\r\n      var self = this;\r\n      var wrappedListener = function (data) {\r\n        self.off(type, wrappedListener, context);\r\n        listener.call(this, data);\r\n      };\r\n      this.on(type, wrappedListener, context);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Checks if one or more listeners for the given event type are attached to\r\n     * the first element in the collection.\r\n     *\r\n     * *Important:* Make sure you are handing in the *identical* context object to get\r\n     * the correct result. Especially when using a collection instance this is a common pitfall.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param type {String} Event type, e.g. <code>mousedown</code>\r\n     * @param listener {Function?} Event listener to check for.\r\n     * @param context {Object?} Context object listener to check for.\r\n     * @return {Boolean} <code>true</code> if one or more listeners are attached\r\n     */\r\n    hasListener(type, listener, context) {\r\n      if (\r\n        !this[0] ||\r\n        !this[0].$$emitter ||\r\n        !this[0].$$emitter.getListeners()[type]\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      if (listener) {\r\n        var attachedListeners = this[0].$$emitter.getListeners()[type];\r\n        for (var i = 0; i < attachedListeners.length; i++) {\r\n          var hasListener = false;\r\n          if (attachedListeners[i].listener == listener) {\r\n            hasListener = true;\r\n          }\r\n          if (\r\n            attachedListeners[i].listener.original &&\r\n            attachedListeners[i].listener.original == listener\r\n          ) {\r\n            hasListener = true;\r\n          }\r\n\r\n          if (hasListener) {\r\n            if (context !== undefined) {\r\n              if (attachedListeners[i].ctx === context) {\r\n                return true;\r\n              }\r\n            } else {\r\n              return true;\r\n            }\r\n          }\r\n        }\r\n        return false;\r\n      }\r\n      return this[0].$$emitter.getListeners()[type].length > 0;\r\n    },\r\n\r\n    /**\r\n     * Copies any event listeners that are attached to the elements in the\r\n     * collection to the provided target element\r\n     *\r\n     * @internal\r\n     * @param target {Element} Element to attach the copied listeners to\r\n     */\r\n    copyEventsTo(target) {\r\n      // Copy both arrays to make sure the original collections are not manipulated.\r\n      // If e.g. the 'target' array contains a DOM node with child nodes we run into\r\n      // problems because the 'target' array is flattened within this method.\r\n      var source = this.concat();\r\n      var targetCopy = target.concat();\r\n\r\n      // get all children of source and target\r\n      for (var i = source.length - 1; i >= 0; i--) {\r\n        var descendants = source[i].getElementsByTagName(\"*\");\r\n        for (var j = 0; j < descendants.length; j++) {\r\n          source.push(descendants[j]);\r\n        }\r\n      }\r\n\r\n      for (var i = targetCopy.length - 1; i >= 0; i--) {\r\n        var descendants = targetCopy[i].getElementsByTagName(\"*\");\r\n        for (var j = 0; j < descendants.length; j++) {\r\n          targetCopy.push(descendants[j]);\r\n        }\r\n      }\r\n      // make sure no emitter object has been copied\r\n      targetCopy.forEach(function (el) {\r\n        el.$$emitter = null;\r\n      });\r\n\r\n      for (var i = 0; i < source.length; i++) {\r\n        var el = source[i];\r\n        if (!el.$$emitter) {\r\n          continue;\r\n        }\r\n        var storage = el.$$emitter.getListeners();\r\n        for (var name in storage) {\r\n          for (var j = storage[name].length - 1; j >= 0; j--) {\r\n            var listener = storage[name][j].listener;\r\n            if (listener.original) {\r\n              listener = listener.original;\r\n            }\r\n            qxWeb(targetCopy[i]).on(name, listener, storage[name][j].ctx);\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Bind one or two callbacks to the collection.\r\n     * If only the first callback is defined the collection\r\n     * does react on 'pointerover' only.\r\n     *\r\n     * @attach {qxWeb}\r\n     *\r\n     * @param callbackIn {Function} callback when hovering over\r\n     * @param callbackOut {Function?} callback when hovering out\r\n     * @return {qxWeb} The collection for chaining\r\n     */\r\n    hover(callbackIn, callbackOut) {\r\n      this.on(\"pointerover\", callbackIn, this);\r\n\r\n      if (qx.lang.Type.isFunction(callbackOut)) {\r\n        this.on(\"pointerout\", callbackOut, this);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a listener for the given type and checks if the target fulfills the selector check.\r\n     * If the check is successful the callback is executed with the target and event as arguments.\r\n     *\r\n     * @attach{qxWeb}\r\n     *\r\n     * @param eventType {String} name of the event to watch out for (attached to the document object)\r\n     * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,\r\n     * Array of DOM elements or collection\r\n     * @param callback {Function} function to call if the selector matches.\r\n     * The callback will get the target as qxWeb collection and the event as arguments\r\n     * @param context {Object?} optional context object to call the callback\r\n     * @return {qxWeb} The collection for chaining\r\n     */\r\n    onMatchTarget(eventType, target, callback, context) {\r\n      context = context !== undefined ? context : this;\r\n\r\n      var listener = function (e) {\r\n        var eventTarget = qxWeb(e.getTarget());\r\n        if (eventTarget.is(target)) {\r\n          callback.call(context, eventTarget, qxWeb.object.clone(e));\r\n        } else {\r\n          var targetToMatch =\r\n            typeof target == \"string\" ? this.find(target) : qxWeb(target);\r\n          for (var i = 0, l = targetToMatch.length; i < l; i++) {\r\n            if (eventTarget.isChildOf(qxWeb(targetToMatch[i]))) {\r\n              callback.call(context, eventTarget, qxWeb.object.clone(e));\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      // make sure to store the infos for 'offMatchTarget' at each element of the collection\r\n      // to be able to remove the listener separately\r\n      this.forEach(function (el) {\r\n        var matchTarget = {\r\n          type: eventType,\r\n          listener: listener,\r\n          callback: callback,\r\n          context: context\r\n        };\r\n\r\n        if (!el.$$matchTargetInfo) {\r\n          el.$$matchTargetInfo = [];\r\n        }\r\n        el.$$matchTargetInfo.push(matchTarget);\r\n      });\r\n\r\n      this.on(eventType, listener);\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a listener for the given type and selector check.\r\n     *\r\n     * @attach{qxWeb}\r\n     *\r\n     * @param eventType {String} name of the event to remove for\r\n     * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,\r\n     * Array of DOM elements or collection\r\n     * @param callback {Function} function to remove\r\n     * @param context {Object?} optional context object to remove\r\n     * @return {qxWeb} The collection for chaining\r\n     */\r\n    offMatchTarget(eventType, target, callback, context) {\r\n      context = context !== undefined ? context : this;\r\n\r\n      this.forEach(function (el) {\r\n        if (\r\n          el.$$matchTargetInfo &&\r\n          qxWeb.type.get(el.$$matchTargetInfo) == \"Array\"\r\n        ) {\r\n          var infos = el.$$matchTargetInfo;\r\n\r\n          for (var i = infos.length - 1; i >= 0; i--) {\r\n            var entry = infos[i];\r\n            if (\r\n              entry.type == eventType &&\r\n              entry.callback == callback &&\r\n              entry.context == context\r\n            ) {\r\n              this.off(eventType, entry.listener);\r\n              infos.splice(i, 1);\r\n            }\r\n          }\r\n\r\n          if (infos.length === 0) {\r\n            el.$$matchTargetInfo = null;\r\n          }\r\n        }\r\n      }, this);\r\n\r\n      return this;\r\n    }\r\n  },\r\n\r\n  defer(statics) {\r\n    qxWeb.$attachAll(this);\r\n    // manually attach internal $-methods as they are ignored by the previous method-call\r\n    qxWeb.$attachStatic({\r\n      $registerEventNormalization: statics.$registerEventNormalization,\r\n      $unregisterEventNormalization: statics.$unregisterEventNormalization,\r\n      $getEventNormalizationRegistry: statics.$getEventNormalizationRegistry,\r\n      $registerEventHook: statics.$registerEventHook,\r\n      $unregisterEventHook: statics.$unregisterEventHook,\r\n      $getEventHookRegistry: statics.$getEventHookRegistry\r\n    });\r\n  }\r\n});\r\n"
  ],
  "mappings": "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"
}