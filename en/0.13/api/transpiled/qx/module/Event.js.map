{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__normalizations",
    "__hooks",
    "on",
    "off",
    "__isReady",
    "ready",
    "callback",
    "document",
    "readyState",
    "window",
    "setTimeout",
    "onWindowLoad",
    "module",
    "Event",
    "qxWeb",
    "wrappedCallback",
    "env",
    "get",
    "bom",
    "addNativeListener",
    "timer",
    "documentElement",
    "doScroll",
    "body",
    "error",
    "$registerEventNormalization",
    "types",
    "normalizer",
    "lang",
    "Type",
    "isArray",
    "registry",
    "i",
    "l",
    "length",
    "type",
    "isFunction",
    "push",
    "$unregisterEventNormalization",
    "Array",
    "remove",
    "$getEventNormalizationRegistry",
    "$registerEventHook",
    "registerHook",
    "unregisterHook",
    "onHooks",
    "offHooks",
    "$unregisterEventHook",
    "$getEventHookRegistry",
    "members",
    "listener",
    "context",
    "useCapture",
    "el",
    "ctx",
    "hooks",
    "typeHooks",
    "concat",
    "j",
    "m",
    "bound",
    "event",
    "normalizations",
    "x",
    "y",
    "apply",
    "bind",
    "original",
    "$$emitter",
    "Emitter",
    "$$lastlistenerId",
    "getEntryById",
    "__listener",
    "__ctx",
    "removeAll",
    "listenerType",
    "id",
    "storedListener",
    "hasStoredContext",
    "storedContext",
    "result",
    "removeNativeListener",
    "k",
    "allOff",
    "offById",
    "entry",
    "name",
    "emit",
    "data",
    "once",
    "self",
    "wrappedListener",
    "call",
    "hasListener",
    "getListeners",
    "attachedListeners",
    "undefined",
    "copyEventsTo",
    "target",
    "source",
    "targetCopy",
    "descendants",
    "getElementsByTagName",
    "forEach",
    "storage",
    "hover",
    "callbackIn",
    "callbackOut",
    "onMatchTarget",
    "eventType",
    "e",
    "eventTarget",
    "getTarget",
    "is",
    "object",
    "clone",
    "targetToMatch",
    "find",
    "isChildOf",
    "matchTarget",
    "$$matchTargetInfo",
    "offMatchTarget",
    "infos",
    "splice",
    "defer",
    "$attachAll",
    "$attachStatic"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/module/Event.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2011-2012 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (wittemann)\n     * Daniel Wagner (danielwagner)\n\n************************************************************************ */\n\n/**\n * Support for native and custom events.\n *\n * @require(qx.module.Polyfill)\n * @require(qx.module.Environment)\n * @use(qx.module.event.PointerHandler)\n * @group (Core)\n */\nqx.Bootstrap.define(\"qx.module.Event\", {\n  statics: {\n    /**\n     * Event normalization registry\n     *\n     * @internal\n     */\n    __normalizations: {},\n\n    /**\n     * Registry of event hooks\n     * @internal\n     */\n    __hooks: {\n      on: {},\n      off: {}\n    },\n\n    __isReady: false,\n\n    /**\n     * Executes the given function once the document is ready.\n     *\n     * @attachStatic {qxWeb}\n     * @param callback {Function} callback function\n     */\n    ready(callback) {\n      // DOM is already ready\n      if (document.readyState === \"complete\") {\n        window.setTimeout(callback, 1);\n        return;\n      }\n\n      // listen for the load event so the callback is executed no matter what\n      var onWindowLoad = function () {\n        qx.module.Event.__isReady = true;\n        callback();\n      };\n\n      qxWeb(window).on(\"load\", onWindowLoad);\n\n      var wrappedCallback = function () {\n        qxWeb(window).off(\"load\", onWindowLoad);\n        callback();\n      };\n\n      // Listen for DOMContentLoaded event if available (no way to reliably detect\n      // support)\n      if (\n        qxWeb.env.get(\"engine.name\") !== \"mshtml\" ||\n        qxWeb.env.get(\"browser.documentmode\") > 8\n      ) {\n        qx.bom.Event.addNativeListener(\n          document,\n          \"DOMContentLoaded\",\n          wrappedCallback\n        );\n      } else {\n        // Continually check to see if the document is ready\n        var timer = function () {\n          // onWindowLoad already executed\n          if (qx.module.Event.__isReady) {\n            return;\n          }\n          try {\n            // If DOMContentLoaded is unavailable, use the trick by Diego Perini\n            // http://javascript.nwbox.com/IEContentLoaded/\n            document.documentElement.doScroll(\"left\");\n            if (document.body) {\n              wrappedCallback();\n            }\n          } catch (error) {\n            window.setTimeout(timer, 100);\n          }\n        };\n\n        timer();\n      }\n    },\n\n    /**\n     * Registers a normalization function for the given event types. Listener\n     * callbacks for these types will be called with the return value of the\n     * normalization function instead of the regular event object.\n     *\n     * The normalizer will be called with two arguments: The original event\n     * object and the element on which the event was triggered\n     *\n     * @attachStatic {qxWeb, $registerEventNormalization}\n     * @param types {String[]} List of event types to be normalized. Use an\n     * asterisk (<code>*</code>) to normalize all event types\n     * @param normalizer {Function} Normalizer function\n     */\n    $registerEventNormalization(types, normalizer) {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var registry = qx.module.Event.__normalizations;\n      for (var i = 0, l = types.length; i < l; i++) {\n        var type = types[i];\n        if (qx.lang.Type.isFunction(normalizer)) {\n          if (!registry[type]) {\n            registry[type] = [];\n          }\n          registry[type].push(normalizer);\n        }\n      }\n    },\n\n    /**\n     * Unregisters a normalization function from the given event types.\n     *\n     * @attachStatic {qxWeb, $unregisterEventNormalization}\n     * @param types {String[]} List of event types\n     * @param normalizer {Function} Normalizer function\n     */\n    $unregisterEventNormalization(types, normalizer) {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var registry = qx.module.Event.__normalizations;\n      for (var i = 0, l = types.length; i < l; i++) {\n        var type = types[i];\n        if (registry[type]) {\n          qx.lang.Array.remove(registry[type], normalizer);\n        }\n      }\n    },\n\n    /**\n     * Returns all registered event normalizers\n     *\n     * @attachStatic {qxWeb, $getEventNormalizationRegistry}\n     * @return {Map} Map of event types/normalizer functions\n     */\n    $getEventNormalizationRegistry() {\n      return qx.module.Event.__normalizations;\n    },\n\n    /**\n     * Registers an event hook for the given event types.\n     *\n     * @attachStatic {qxWeb, $registerEventHook}\n     * @param types {String[]} List of event types\n     * @param registerHook {Function} Hook function to be called on event registration\n     * @param unregisterHook {Function?} Hook function to be called on event deregistration\n     * @internal\n     */\n    $registerEventHook(types, registerHook, unregisterHook) {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var onHooks = qx.module.Event.__hooks.on;\n      for (var i = 0, l = types.length; i < l; i++) {\n        var type = types[i];\n        if (qx.lang.Type.isFunction(registerHook)) {\n          if (!onHooks[type]) {\n            onHooks[type] = [];\n          }\n          onHooks[type].push(registerHook);\n        }\n      }\n      if (!unregisterHook) {\n        return;\n      }\n      var offHooks = qx.module.Event.__hooks.off;\n      for (var i = 0, l = types.length; i < l; i++) {\n        var type = types[i];\n        if (qx.lang.Type.isFunction(unregisterHook)) {\n          if (!offHooks[type]) {\n            offHooks[type] = [];\n          }\n          offHooks[type].push(unregisterHook);\n        }\n      }\n    },\n\n    /**\n     * Unregisters a hook from the given event types.\n     *\n     * @attachStatic {qxWeb, $unregisterEventHooks}\n     * @param types {String[]} List of event types\n     * @param registerHook {Function} Hook function to be called on event registration\n     * @param unregisterHook {Function?} Hook function to be called on event deregistration\n     * @internal\n     */\n    $unregisterEventHook(types, registerHook, unregisterHook) {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var onHooks = qx.module.Event.__hooks.on;\n      for (var i = 0, l = types.length; i < l; i++) {\n        var type = types[i];\n        if (onHooks[type]) {\n          qx.lang.Array.remove(onHooks[type], registerHook);\n        }\n      }\n      if (!unregisterHook) {\n        return;\n      }\n      var offHooks = qx.module.Event.__hooks.off;\n      for (var i = 0, l = types.length; i < l; i++) {\n        var type = types[i];\n        if (offHooks[type]) {\n          qx.lang.Array.remove(offHooks[type], unregisterHook);\n        }\n      }\n    },\n\n    /**\n     * Returns all registered event hooks\n     *\n     * @attachStatic {qxWeb, $getEventHookRegistry}\n     * @return {Map} Map of event types/registration hook functions\n     * @internal\n     */\n    $getEventHookRegistry() {\n      return qx.module.Event.__hooks;\n    }\n  },\n\n  members: {\n    /**\n     * Registers a listener for the given event type on each item in the\n     * collection. This can be either native or custom events.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Type of the event to listen for\n     * @param listener {Function} Listener callback\n     * @param context {Object?} Context the callback function will be executed in.\n     * Default: The element on which the listener was registered\n     * @param useCapture {Boolean?} Attach the listener to the capturing\n     * phase if true\n     * @return {qxWeb} The collection for chaining\n     */\n    on(type, listener, context, useCapture) {\n      for (var i = 0; i < this.length; i++) {\n        var el = this[i];\n        var ctx = context || qxWeb(el);\n\n        // call hooks\n        var hooks = qx.module.Event.__hooks.on;\n        // generic\n        var typeHooks = hooks[\"*\"] || [];\n        // type specific\n        if (hooks[type]) {\n          typeHooks = typeHooks.concat(hooks[type]);\n        }\n        for (var j = 0, m = typeHooks.length; j < m; j++) {\n          typeHooks[j](el, type, listener, context);\n        }\n\n        var bound = function (el, event) {\n          // apply normalizations\n          var registry = qx.module.Event.__normalizations;\n          // generic\n          var normalizations = registry[\"*\"] || [];\n          // type specific\n          if (registry[type]) {\n            normalizations = normalizations.concat(registry[type]);\n          }\n\n          for (var x = 0, y = normalizations.length; x < y; x++) {\n            event = normalizations[x](event, el, type);\n          }\n          // call original listener with normalized event\n          listener.apply(this, [event]);\n        }.bind(ctx, el);\n        bound.original = listener;\n\n        // add native listener\n        qx.bom.Event.addNativeListener(el, type, bound, useCapture);\n\n        // create an emitter if necessary\n        if (!el.$$emitter) {\n          el.$$emitter = new qx.event.Emitter();\n        }\n\n        el.$$lastlistenerId = el.$$emitter.on(type, bound, ctx);\n        // save the useCapture for removing\n        el.$$emitter.getEntryById(el.$$lastlistenerId).useCapture =\n          !!useCapture;\n\n        if (!el.__listener) {\n          el.__listener = {};\n        }\n        if (!el.__listener[type]) {\n          el.__listener[type] = {};\n        }\n        el.__listener[type][el.$$lastlistenerId] = bound;\n\n        if (!context) {\n          // store a reference to the dynamically created context so we know\n          // what to check for when removing the listener\n          if (!el.__ctx) {\n            el.__ctx = {};\n          }\n          el.__ctx[el.$$lastlistenerId] = ctx;\n        }\n      }\n      return this;\n    },\n\n    /**\n     * Unregisters event listeners for the given type from each element in the\n     * collection.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Type of the event\n     * @param listener {Function} Listener callback\n     * @param context {Object?} Listener callback context\n     * @param useCapture {Boolean?} Attach the listener to the capturing\n     * phase if true\n     * @return {qxWeb} The collection for chaining\n     */\n    off(type, listener, context, useCapture) {\n      var removeAll = listener === null && context === null;\n\n      for (var j = 0; j < this.length; j++) {\n        var el = this[j];\n\n        // continue if no listeners are available\n        if (!el.__listener) {\n          continue;\n        }\n\n        var types = [];\n        if (type !== null) {\n          types.push(type);\n        } else {\n          // no type specified, remove all listeners\n          for (var listenerType in el.__listener) {\n            types.push(listenerType);\n          }\n        }\n\n        for (var i = 0, l = types.length; i < l; i++) {\n          for (var id in el.__listener[types[i]]) {\n            var storedListener = el.__listener[types[i]][id];\n            if (\n              removeAll ||\n              storedListener == listener ||\n              storedListener.original == listener\n            ) {\n              // get the stored context\n              var hasStoredContext =\n                typeof el.__ctx !== \"undefined\" && el.__ctx[id];\n              var storedContext;\n              if (!context && hasStoredContext) {\n                storedContext = el.__ctx[id];\n              }\n              // remove the listener from the emitter\n              var result = el.$$emitter.off(\n                types[i],\n                storedListener,\n                storedContext || context\n              );\n\n              // check if it's a bound listener which means it was a native event\n              if (removeAll || storedListener.original == listener) {\n                // remove the native listener\n                qx.bom.Event.removeNativeListener(\n                  el,\n                  types[i],\n                  storedListener,\n                  useCapture\n                );\n              }\n\n              // BUG #9184\n              // only if the emitter was successfully removed also delete the key in the data structure\n              if (result !== null) {\n                delete el.__listener[types[i]][id];\n              }\n\n              if (hasStoredContext) {\n                delete el.__ctx[id];\n              }\n            }\n          }\n\n          // call hooks\n          var hooks = qx.module.Event.__hooks.off;\n          // generic\n          var typeHooks = hooks[\"*\"] || [];\n          // type specific\n          if (hooks[type]) {\n            typeHooks = typeHooks.concat(hooks[type]);\n          }\n          for (var k = 0, m = typeHooks.length; k < m; k++) {\n            typeHooks[k](el, type, listener, context);\n          }\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Removes all event listeners (or all listeners for a given type) from the\n     * collection.\n     *\n     * @attach {qxWeb}\n     * @param type {String?} Event type. All listeners will be removed if this is undefined.\n     * @return {qxWeb} The collection for chaining\n     */\n    allOff(type) {\n      return this.off(type || null, null, null);\n    },\n\n    /**\n     * Removes the listener with the given id.\n     * @param id {Number} The id of the listener to remove\n     * @return {qxWeb} The collection for chaining.\n     */\n    offById(id) {\n      var entry = this[0].$$emitter.getEntryById(id);\n      return this.off(\n        entry.name,\n        entry.listener.original,\n        entry.ctx,\n        entry.useCapture\n      );\n    },\n\n    /**\n     * Fire an event of the given type.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Event type\n     * @param data {var?} Optional data that will be passed to the listener\n     * callback function.\n     * @return {qxWeb} The collection for chaining\n     */\n    emit(type, data) {\n      for (var j = 0; j < this.length; j++) {\n        var el = this[j];\n        if (el.$$emitter) {\n          el.$$emitter.emit(type, data);\n        }\n      }\n      return this;\n    },\n\n    /**\n     * Attaches a listener for the given event that will be executed only once.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Type of the event to listen for\n     * @param listener {Function} Listener callback\n     * @param context {Object?} Context the callback function will be executed in.\n     * Default: The element on which the listener was registered\n     * @return {qxWeb} The collection for chaining\n     */\n    once(type, listener, context) {\n      var self = this;\n      var wrappedListener = function (data) {\n        self.off(type, wrappedListener, context);\n        listener.call(this, data);\n      };\n      this.on(type, wrappedListener, context);\n      return this;\n    },\n\n    /**\n     * Checks if one or more listeners for the given event type are attached to\n     * the first element in the collection.\n     *\n     * *Important:* Make sure you are handing in the *identical* context object to get\n     * the correct result. Especially when using a collection instance this is a common pitfall.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Event type, e.g. <code>mousedown</code>\n     * @param listener {Function?} Event listener to check for.\n     * @param context {Object?} Context object listener to check for.\n     * @return {Boolean} <code>true</code> if one or more listeners are attached\n     */\n    hasListener(type, listener, context) {\n      if (\n        !this[0] ||\n        !this[0].$$emitter ||\n        !this[0].$$emitter.getListeners()[type]\n      ) {\n        return false;\n      }\n\n      if (listener) {\n        var attachedListeners = this[0].$$emitter.getListeners()[type];\n        for (var i = 0; i < attachedListeners.length; i++) {\n          var hasListener = false;\n          if (attachedListeners[i].listener == listener) {\n            hasListener = true;\n          }\n          if (\n            attachedListeners[i].listener.original &&\n            attachedListeners[i].listener.original == listener\n          ) {\n            hasListener = true;\n          }\n\n          if (hasListener) {\n            if (context !== undefined) {\n              if (attachedListeners[i].ctx === context) {\n                return true;\n              }\n            } else {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n      return this[0].$$emitter.getListeners()[type].length > 0;\n    },\n\n    /**\n     * Copies any event listeners that are attached to the elements in the\n     * collection to the provided target element\n     *\n     * @internal\n     * @param target {Element} Element to attach the copied listeners to\n     */\n    copyEventsTo(target) {\n      // Copy both arrays to make sure the original collections are not manipulated.\n      // If e.g. the 'target' array contains a DOM node with child nodes we run into\n      // problems because the 'target' array is flattened within this method.\n      var source = this.concat();\n      var targetCopy = target.concat();\n\n      // get all children of source and target\n      for (var i = source.length - 1; i >= 0; i--) {\n        var descendants = source[i].getElementsByTagName(\"*\");\n        for (var j = 0; j < descendants.length; j++) {\n          source.push(descendants[j]);\n        }\n      }\n\n      for (var i = targetCopy.length - 1; i >= 0; i--) {\n        var descendants = targetCopy[i].getElementsByTagName(\"*\");\n        for (var j = 0; j < descendants.length; j++) {\n          targetCopy.push(descendants[j]);\n        }\n      }\n      // make sure no emitter object has been copied\n      targetCopy.forEach(function (el) {\n        el.$$emitter = null;\n      });\n\n      for (var i = 0; i < source.length; i++) {\n        var el = source[i];\n        if (!el.$$emitter) {\n          continue;\n        }\n        var storage = el.$$emitter.getListeners();\n        for (var name in storage) {\n          for (var j = storage[name].length - 1; j >= 0; j--) {\n            var listener = storage[name][j].listener;\n            if (listener.original) {\n              listener = listener.original;\n            }\n            qxWeb(targetCopy[i]).on(name, listener, storage[name][j].ctx);\n          }\n        }\n      }\n    },\n\n    /**\n     * Bind one or two callbacks to the collection.\n     * If only the first callback is defined the collection\n     * does react on 'pointerover' only.\n     *\n     * @attach {qxWeb}\n     *\n     * @param callbackIn {Function} callback when hovering over\n     * @param callbackOut {Function?} callback when hovering out\n     * @return {qxWeb} The collection for chaining\n     */\n    hover(callbackIn, callbackOut) {\n      this.on(\"pointerover\", callbackIn, this);\n\n      if (qx.lang.Type.isFunction(callbackOut)) {\n        this.on(\"pointerout\", callbackOut, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * Adds a listener for the given type and checks if the target fulfills the selector check.\n     * If the check is successful the callback is executed with the target and event as arguments.\n     *\n     * @attach{qxWeb}\n     *\n     * @param eventType {String} name of the event to watch out for (attached to the document object)\n     * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,\n     * Array of DOM elements or collection\n     * @param callback {Function} function to call if the selector matches.\n     * The callback will get the target as qxWeb collection and the event as arguments\n     * @param context {Object?} optional context object to call the callback\n     * @return {qxWeb} The collection for chaining\n     */\n    onMatchTarget(eventType, target, callback, context) {\n      context = context !== undefined ? context : this;\n\n      var listener = function (e) {\n        var eventTarget = qxWeb(e.getTarget());\n        if (eventTarget.is(target)) {\n          callback.call(context, eventTarget, qxWeb.object.clone(e));\n        } else {\n          var targetToMatch =\n            typeof target == \"string\" ? this.find(target) : qxWeb(target);\n          for (var i = 0, l = targetToMatch.length; i < l; i++) {\n            if (eventTarget.isChildOf(qxWeb(targetToMatch[i]))) {\n              callback.call(context, eventTarget, qxWeb.object.clone(e));\n              break;\n            }\n          }\n        }\n      };\n\n      // make sure to store the infos for 'offMatchTarget' at each element of the collection\n      // to be able to remove the listener separately\n      this.forEach(function (el) {\n        var matchTarget = {\n          type: eventType,\n          listener: listener,\n          callback: callback,\n          context: context\n        };\n\n        if (!el.$$matchTargetInfo) {\n          el.$$matchTargetInfo = [];\n        }\n        el.$$matchTargetInfo.push(matchTarget);\n      });\n\n      this.on(eventType, listener);\n\n      return this;\n    },\n\n    /**\n     * Removes a listener for the given type and selector check.\n     *\n     * @attach{qxWeb}\n     *\n     * @param eventType {String} name of the event to remove for\n     * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,\n     * Array of DOM elements or collection\n     * @param callback {Function} function to remove\n     * @param context {Object?} optional context object to remove\n     * @return {qxWeb} The collection for chaining\n     */\n    offMatchTarget(eventType, target, callback, context) {\n      context = context !== undefined ? context : this;\n\n      this.forEach(function (el) {\n        if (\n          el.$$matchTargetInfo &&\n          qxWeb.type.get(el.$$matchTargetInfo) == \"Array\"\n        ) {\n          var infos = el.$$matchTargetInfo;\n\n          for (var i = infos.length - 1; i >= 0; i--) {\n            var entry = infos[i];\n            if (\n              entry.type == eventType &&\n              entry.callback == callback &&\n              entry.context == context\n            ) {\n              this.off(eventType, entry.listener);\n              infos.splice(i, 1);\n            }\n          }\n\n          if (infos.length === 0) {\n            el.$$matchTargetInfo = null;\n          }\n        }\n      }, this);\n\n      return this;\n    }\n  },\n\n  defer(statics) {\n    qxWeb.$attachAll(this);\n    // manually attach internal $-methods as they are ignored by the previous method-call\n    qxWeb.$attachStatic({\n      $registerEventNormalization: statics.$registerEventNormalization,\n      $unregisterEventNormalization: statics.$unregisterEventNormalization,\n      $getEventNormalizationRegistry: statics.$getEventNormalizationRegistry,\n      $registerEventHook: statics.$registerEventHook,\n      $unregisterEventHook: statics.$unregisterEventHook,\n      $getEventHookRegistry: statics.$getEventHookRegistry\n    });\n  }\n});\n"
  ],
  "mappings": "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",
  "ignoreList": []
}