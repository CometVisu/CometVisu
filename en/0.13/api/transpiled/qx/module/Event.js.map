{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__normalizations",
    "__hooks",
    "on",
    "off",
    "__isReady",
    "ready",
    "callback",
    "document",
    "readyState",
    "window",
    "setTimeout",
    "onWindowLoad",
    "module",
    "Event",
    "qxWeb",
    "wrappedCallback",
    "env",
    "get",
    "bom",
    "addNativeListener",
    "timer",
    "documentElement",
    "doScroll",
    "body",
    "error",
    "$registerEventNormalization",
    "types",
    "normalizer",
    "lang",
    "Type",
    "isArray",
    "registry",
    "i",
    "l",
    "length",
    "type",
    "isFunction",
    "push",
    "$unregisterEventNormalization",
    "Array",
    "remove",
    "$getEventNormalizationRegistry",
    "$registerEventHook",
    "registerHook",
    "unregisterHook",
    "onHooks",
    "offHooks",
    "$unregisterEventHook",
    "$getEventHookRegistry",
    "members",
    "listener",
    "context",
    "useCapture",
    "el",
    "ctx",
    "hooks",
    "typeHooks",
    "concat",
    "j",
    "m",
    "bound",
    "event",
    "normalizations",
    "x",
    "y",
    "apply",
    "bind",
    "original",
    "$$emitter",
    "Emitter",
    "$$lastlistenerId",
    "getEntryById",
    "__listener",
    "__ctx",
    "removeAll",
    "listenerType",
    "id",
    "storedListener",
    "hasStoredContext",
    "storedContext",
    "result",
    "removeNativeListener",
    "k",
    "allOff",
    "offById",
    "entry",
    "name",
    "emit",
    "data",
    "once",
    "self",
    "wrappedListener",
    "call",
    "hasListener",
    "getListeners",
    "attachedListeners",
    "undefined",
    "copyEventsTo",
    "target",
    "source",
    "targetCopy",
    "descendants",
    "getElementsByTagName",
    "forEach",
    "storage",
    "hover",
    "callbackIn",
    "callbackOut",
    "onMatchTarget",
    "eventType",
    "e",
    "eventTarget",
    "getTarget",
    "is",
    "object",
    "clone",
    "targetToMatch",
    "find",
    "isChildOf",
    "matchTarget",
    "$$matchTargetInfo",
    "offMatchTarget",
    "infos",
    "splice",
    "defer",
    "$attachAll",
    "$attachStatic"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/module/Event.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2011-2012 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (wittemann)\n     * Daniel Wagner (danielwagner)\n\n************************************************************************ */\n\n/**\n * Support for native and custom events.\n *\n * @require(qx.module.Polyfill)\n * @require(qx.module.Environment)\n * @use(qx.module.event.PointerHandler)\n * @group (Core)\n */\nqx.Bootstrap.define(\"qx.module.Event\", {\n  statics: {\n    /**\n     * Event normalization registry\n     *\n     * @internal\n     */\n    __normalizations: {},\n\n    /**\n     * Registry of event hooks\n     * @internal\n     */\n    __hooks: {\n      on: {},\n      off: {}\n    },\n\n    __isReady: false,\n\n    /**\n     * Executes the given function once the document is ready.\n     *\n     * @attachStatic {qxWeb}\n     * @param callback {Function} callback function\n     */\n    ready(callback) {\n      // DOM is already ready\n      if (document.readyState === \"complete\") {\n        window.setTimeout(callback, 1);\n        return;\n      }\n\n      // listen for the load event so the callback is executed no matter what\n      var onWindowLoad = function () {\n        qx.module.Event.__isReady = true;\n        callback();\n      };\n\n      qxWeb(window).on(\"load\", onWindowLoad);\n\n      var wrappedCallback = function () {\n        qxWeb(window).off(\"load\", onWindowLoad);\n        callback();\n      };\n\n      // Listen for DOMContentLoaded event if available (no way to reliably detect\n      // support)\n      if (\n        qxWeb.env.get(\"engine.name\") !== \"mshtml\" ||\n        qxWeb.env.get(\"browser.documentmode\") > 8\n      ) {\n        qx.bom.Event.addNativeListener(\n          document,\n          \"DOMContentLoaded\",\n          wrappedCallback\n        );\n      } else {\n        // Continually check to see if the document is ready\n        var timer = function () {\n          // onWindowLoad already executed\n          if (qx.module.Event.__isReady) {\n            return;\n          }\n          try {\n            // If DOMContentLoaded is unavailable, use the trick by Diego Perini\n            // http://javascript.nwbox.com/IEContentLoaded/\n            document.documentElement.doScroll(\"left\");\n            if (document.body) {\n              wrappedCallback();\n            }\n          } catch (error) {\n            window.setTimeout(timer, 100);\n          }\n        };\n\n        timer();\n      }\n    },\n\n    /**\n     * Registers a normalization function for the given event types. Listener\n     * callbacks for these types will be called with the return value of the\n     * normalization function instead of the regular event object.\n     *\n     * The normalizer will be called with two arguments: The original event\n     * object and the element on which the event was triggered\n     *\n     * @attachStatic {qxWeb, $registerEventNormalization}\n     * @param types {String[]} List of event types to be normalized. Use an\n     * asterisk (<code>*</code>) to normalize all event types\n     * @param normalizer {Function} Normalizer function\n     */\n    $registerEventNormalization(types, normalizer) {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var registry = qx.module.Event.__normalizations;\n      for (var i = 0, l = types.length; i < l; i++) {\n        var type = types[i];\n        if (qx.lang.Type.isFunction(normalizer)) {\n          if (!registry[type]) {\n            registry[type] = [];\n          }\n          registry[type].push(normalizer);\n        }\n      }\n    },\n\n    /**\n     * Unregisters a normalization function from the given event types.\n     *\n     * @attachStatic {qxWeb, $unregisterEventNormalization}\n     * @param types {String[]} List of event types\n     * @param normalizer {Function} Normalizer function\n     */\n    $unregisterEventNormalization(types, normalizer) {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var registry = qx.module.Event.__normalizations;\n      for (var i = 0, l = types.length; i < l; i++) {\n        var type = types[i];\n        if (registry[type]) {\n          qx.lang.Array.remove(registry[type], normalizer);\n        }\n      }\n    },\n\n    /**\n     * Returns all registered event normalizers\n     *\n     * @attachStatic {qxWeb, $getEventNormalizationRegistry}\n     * @return {Map} Map of event types/normalizer functions\n     */\n    $getEventNormalizationRegistry() {\n      return qx.module.Event.__normalizations;\n    },\n\n    /**\n     * Registers an event hook for the given event types.\n     *\n     * @attachStatic {qxWeb, $registerEventHook}\n     * @param types {String[]} List of event types\n     * @param registerHook {Function} Hook function to be called on event registration\n     * @param unregisterHook {Function?} Hook function to be called on event deregistration\n     * @internal\n     */\n    $registerEventHook(types, registerHook, unregisterHook) {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var onHooks = qx.module.Event.__hooks.on;\n      for (var i = 0, l = types.length; i < l; i++) {\n        var type = types[i];\n        if (qx.lang.Type.isFunction(registerHook)) {\n          if (!onHooks[type]) {\n            onHooks[type] = [];\n          }\n          onHooks[type].push(registerHook);\n        }\n      }\n      if (!unregisterHook) {\n        return;\n      }\n      var offHooks = qx.module.Event.__hooks.off;\n      for (var i = 0, l = types.length; i < l; i++) {\n        var type = types[i];\n        if (qx.lang.Type.isFunction(unregisterHook)) {\n          if (!offHooks[type]) {\n            offHooks[type] = [];\n          }\n          offHooks[type].push(unregisterHook);\n        }\n      }\n    },\n\n    /**\n     * Unregisters a hook from the given event types.\n     *\n     * @attachStatic {qxWeb, $unregisterEventHooks}\n     * @param types {String[]} List of event types\n     * @param registerHook {Function} Hook function to be called on event registration\n     * @param unregisterHook {Function?} Hook function to be called on event deregistration\n     * @internal\n     */\n    $unregisterEventHook(types, registerHook, unregisterHook) {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var onHooks = qx.module.Event.__hooks.on;\n      for (var i = 0, l = types.length; i < l; i++) {\n        var type = types[i];\n        if (onHooks[type]) {\n          qx.lang.Array.remove(onHooks[type], registerHook);\n        }\n      }\n      if (!unregisterHook) {\n        return;\n      }\n      var offHooks = qx.module.Event.__hooks.off;\n      for (var i = 0, l = types.length; i < l; i++) {\n        var type = types[i];\n        if (offHooks[type]) {\n          qx.lang.Array.remove(offHooks[type], unregisterHook);\n        }\n      }\n    },\n\n    /**\n     * Returns all registered event hooks\n     *\n     * @attachStatic {qxWeb, $getEventHookRegistry}\n     * @return {Map} Map of event types/registration hook functions\n     * @internal\n     */\n    $getEventHookRegistry() {\n      return qx.module.Event.__hooks;\n    }\n  },\n\n  members: {\n    /**\n     * Registers a listener for the given event type on each item in the\n     * collection. This can be either native or custom events.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Type of the event to listen for\n     * @param listener {Function} Listener callback\n     * @param context {Object?} Context the callback function will be executed in.\n     * Default: The element on which the listener was registered\n     * @param useCapture {Boolean?} Attach the listener to the capturing\n     * phase if true\n     * @return {qxWeb} The collection for chaining\n     */\n    on(type, listener, context, useCapture) {\n      for (var i = 0; i < this.length; i++) {\n        var el = this[i];\n        var ctx = context || qxWeb(el);\n\n        // call hooks\n        var hooks = qx.module.Event.__hooks.on;\n        // generic\n        var typeHooks = hooks[\"*\"] || [];\n        // type specific\n        if (hooks[type]) {\n          typeHooks = typeHooks.concat(hooks[type]);\n        }\n        for (var j = 0, m = typeHooks.length; j < m; j++) {\n          typeHooks[j](el, type, listener, context);\n        }\n\n        var bound = function (el, event) {\n          // apply normalizations\n          var registry = qx.module.Event.__normalizations;\n          // generic\n          var normalizations = registry[\"*\"] || [];\n          // type specific\n          if (registry[type]) {\n            normalizations = normalizations.concat(registry[type]);\n          }\n\n          for (var x = 0, y = normalizations.length; x < y; x++) {\n            event = normalizations[x](event, el, type);\n          }\n          // call original listener with normalized event\n          listener.apply(this, [event]);\n        }.bind(ctx, el);\n        bound.original = listener;\n\n        // add native listener\n        qx.bom.Event.addNativeListener(el, type, bound, useCapture);\n\n        // create an emitter if necessary\n        if (!el.$$emitter) {\n          el.$$emitter = new qx.event.Emitter();\n        }\n\n        el.$$lastlistenerId = el.$$emitter.on(type, bound, ctx);\n        // save the useCapture for removing\n        el.$$emitter.getEntryById(el.$$lastlistenerId).useCapture =\n          !!useCapture;\n\n        if (!el.__listener) {\n          el.__listener = {};\n        }\n        if (!el.__listener[type]) {\n          el.__listener[type] = {};\n        }\n        el.__listener[type][el.$$lastlistenerId] = bound;\n\n        if (!context) {\n          // store a reference to the dynamically created context so we know\n          // what to check for when removing the listener\n          if (!el.__ctx) {\n            el.__ctx = {};\n          }\n          el.__ctx[el.$$lastlistenerId] = ctx;\n        }\n      }\n      return this;\n    },\n\n    /**\n     * Unregisters event listeners for the given type from each element in the\n     * collection.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Type of the event\n     * @param listener {Function} Listener callback\n     * @param context {Object?} Listener callback context\n     * @param useCapture {Boolean?} Attach the listener to the capturing\n     * phase if true\n     * @return {qxWeb} The collection for chaining\n     */\n    off(type, listener, context, useCapture) {\n      var removeAll = listener === null && context === null;\n\n      for (var j = 0; j < this.length; j++) {\n        var el = this[j];\n\n        // continue if no listeners are available\n        if (!el.__listener) {\n          continue;\n        }\n\n        var types = [];\n        if (type !== null) {\n          types.push(type);\n        } else {\n          // no type specified, remove all listeners\n          for (var listenerType in el.__listener) {\n            types.push(listenerType);\n          }\n        }\n\n        for (var i = 0, l = types.length; i < l; i++) {\n          for (var id in el.__listener[types[i]]) {\n            var storedListener = el.__listener[types[i]][id];\n            if (\n              removeAll ||\n              storedListener == listener ||\n              storedListener.original == listener\n            ) {\n              // get the stored context\n              var hasStoredContext =\n                typeof el.__ctx !== \"undefined\" && el.__ctx[id];\n              var storedContext;\n              if (!context && hasStoredContext) {\n                storedContext = el.__ctx[id];\n              }\n              // remove the listener from the emitter\n              var result = el.$$emitter.off(\n                types[i],\n                storedListener,\n                storedContext || context\n              );\n\n              // check if it's a bound listener which means it was a native event\n              if (removeAll || storedListener.original == listener) {\n                // remove the native listener\n                qx.bom.Event.removeNativeListener(\n                  el,\n                  types[i],\n                  storedListener,\n                  useCapture\n                );\n              }\n\n              // BUG #9184\n              // only if the emitter was successfully removed also delete the key in the data structure\n              if (result !== null) {\n                delete el.__listener[types[i]][id];\n              }\n\n              if (hasStoredContext) {\n                delete el.__ctx[id];\n              }\n            }\n          }\n\n          // call hooks\n          var hooks = qx.module.Event.__hooks.off;\n          // generic\n          var typeHooks = hooks[\"*\"] || [];\n          // type specific\n          if (hooks[type]) {\n            typeHooks = typeHooks.concat(hooks[type]);\n          }\n          for (var k = 0, m = typeHooks.length; k < m; k++) {\n            typeHooks[k](el, type, listener, context);\n          }\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Removes all event listeners (or all listeners for a given type) from the\n     * collection.\n     *\n     * @attach {qxWeb}\n     * @param type {String?} Event type. All listeners will be removed if this is undefined.\n     * @return {qxWeb} The collection for chaining\n     */\n    allOff(type) {\n      return this.off(type || null, null, null);\n    },\n\n    /**\n     * Removes the listener with the given id.\n     * @param id {Number} The id of the listener to remove\n     * @return {qxWeb} The collection for chaining.\n     */\n    offById(id) {\n      var entry = this[0].$$emitter.getEntryById(id);\n      return this.off(\n        entry.name,\n        entry.listener.original,\n        entry.ctx,\n        entry.useCapture\n      );\n    },\n\n    /**\n     * Fire an event of the given type.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Event type\n     * @param data {var?} Optional data that will be passed to the listener\n     * callback function.\n     * @return {qxWeb} The collection for chaining\n     */\n    emit(type, data) {\n      for (var j = 0; j < this.length; j++) {\n        var el = this[j];\n        if (el.$$emitter) {\n          el.$$emitter.emit(type, data);\n        }\n      }\n      return this;\n    },\n\n    /**\n     * Attaches a listener for the given event that will be executed only once.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Type of the event to listen for\n     * @param listener {Function} Listener callback\n     * @param context {Object?} Context the callback function will be executed in.\n     * Default: The element on which the listener was registered\n     * @return {qxWeb} The collection for chaining\n     */\n    once(type, listener, context) {\n      var self = this;\n      var wrappedListener = function (data) {\n        self.off(type, wrappedListener, context);\n        listener.call(this, data);\n      };\n      this.on(type, wrappedListener, context);\n      return this;\n    },\n\n    /**\n     * Checks if one or more listeners for the given event type are attached to\n     * the first element in the collection.\n     *\n     * *Important:* Make sure you are handing in the *identical* context object to get\n     * the correct result. Especially when using a collection instance this is a common pitfall.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Event type, e.g. <code>mousedown</code>\n     * @param listener {Function?} Event listener to check for.\n     * @param context {Object?} Context object listener to check for.\n     * @return {Boolean} <code>true</code> if one or more listeners are attached\n     */\n    hasListener(type, listener, context) {\n      if (\n        !this[0] ||\n        !this[0].$$emitter ||\n        !this[0].$$emitter.getListeners()[type]\n      ) {\n        return false;\n      }\n\n      if (listener) {\n        var attachedListeners = this[0].$$emitter.getListeners()[type];\n        for (var i = 0; i < attachedListeners.length; i++) {\n          var hasListener = false;\n          if (attachedListeners[i].listener == listener) {\n            hasListener = true;\n          }\n          if (\n            attachedListeners[i].listener.original &&\n            attachedListeners[i].listener.original == listener\n          ) {\n            hasListener = true;\n          }\n\n          if (hasListener) {\n            if (context !== undefined) {\n              if (attachedListeners[i].ctx === context) {\n                return true;\n              }\n            } else {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n      return this[0].$$emitter.getListeners()[type].length > 0;\n    },\n\n    /**\n     * Copies any event listeners that are attached to the elements in the\n     * collection to the provided target element\n     *\n     * @internal\n     * @param target {Element} Element to attach the copied listeners to\n     */\n    copyEventsTo(target) {\n      // Copy both arrays to make sure the original collections are not manipulated.\n      // If e.g. the 'target' array contains a DOM node with child nodes we run into\n      // problems because the 'target' array is flattened within this method.\n      var source = this.concat();\n      var targetCopy = target.concat();\n\n      // get all children of source and target\n      for (var i = source.length - 1; i >= 0; i--) {\n        var descendants = source[i].getElementsByTagName(\"*\");\n        for (var j = 0; j < descendants.length; j++) {\n          source.push(descendants[j]);\n        }\n      }\n\n      for (var i = targetCopy.length - 1; i >= 0; i--) {\n        var descendants = targetCopy[i].getElementsByTagName(\"*\");\n        for (var j = 0; j < descendants.length; j++) {\n          targetCopy.push(descendants[j]);\n        }\n      }\n      // make sure no emitter object has been copied\n      targetCopy.forEach(function (el) {\n        el.$$emitter = null;\n      });\n\n      for (var i = 0; i < source.length; i++) {\n        var el = source[i];\n        if (!el.$$emitter) {\n          continue;\n        }\n        var storage = el.$$emitter.getListeners();\n        for (var name in storage) {\n          for (var j = storage[name].length - 1; j >= 0; j--) {\n            var listener = storage[name][j].listener;\n            if (listener.original) {\n              listener = listener.original;\n            }\n            qxWeb(targetCopy[i]).on(name, listener, storage[name][j].ctx);\n          }\n        }\n      }\n    },\n\n    /**\n     * Bind one or two callbacks to the collection.\n     * If only the first callback is defined the collection\n     * does react on 'pointerover' only.\n     *\n     * @attach {qxWeb}\n     *\n     * @param callbackIn {Function} callback when hovering over\n     * @param callbackOut {Function?} callback when hovering out\n     * @return {qxWeb} The collection for chaining\n     */\n    hover(callbackIn, callbackOut) {\n      this.on(\"pointerover\", callbackIn, this);\n\n      if (qx.lang.Type.isFunction(callbackOut)) {\n        this.on(\"pointerout\", callbackOut, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * Adds a listener for the given type and checks if the target fulfills the selector check.\n     * If the check is successful the callback is executed with the target and event as arguments.\n     *\n     * @attach{qxWeb}\n     *\n     * @param eventType {String} name of the event to watch out for (attached to the document object)\n     * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,\n     * Array of DOM elements or collection\n     * @param callback {Function} function to call if the selector matches.\n     * The callback will get the target as qxWeb collection and the event as arguments\n     * @param context {Object?} optional context object to call the callback\n     * @return {qxWeb} The collection for chaining\n     */\n    onMatchTarget(eventType, target, callback, context) {\n      context = context !== undefined ? context : this;\n\n      var listener = function (e) {\n        var eventTarget = qxWeb(e.getTarget());\n        if (eventTarget.is(target)) {\n          callback.call(context, eventTarget, qxWeb.object.clone(e));\n        } else {\n          var targetToMatch =\n            typeof target == \"string\" ? this.find(target) : qxWeb(target);\n          for (var i = 0, l = targetToMatch.length; i < l; i++) {\n            if (eventTarget.isChildOf(qxWeb(targetToMatch[i]))) {\n              callback.call(context, eventTarget, qxWeb.object.clone(e));\n              break;\n            }\n          }\n        }\n      };\n\n      // make sure to store the infos for 'offMatchTarget' at each element of the collection\n      // to be able to remove the listener separately\n      this.forEach(function (el) {\n        var matchTarget = {\n          type: eventType,\n          listener: listener,\n          callback: callback,\n          context: context\n        };\n\n        if (!el.$$matchTargetInfo) {\n          el.$$matchTargetInfo = [];\n        }\n        el.$$matchTargetInfo.push(matchTarget);\n      });\n\n      this.on(eventType, listener);\n\n      return this;\n    },\n\n    /**\n     * Removes a listener for the given type and selector check.\n     *\n     * @attach{qxWeb}\n     *\n     * @param eventType {String} name of the event to remove for\n     * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,\n     * Array of DOM elements or collection\n     * @param callback {Function} function to remove\n     * @param context {Object?} optional context object to remove\n     * @return {qxWeb} The collection for chaining\n     */\n    offMatchTarget(eventType, target, callback, context) {\n      context = context !== undefined ? context : this;\n\n      this.forEach(function (el) {\n        if (\n          el.$$matchTargetInfo &&\n          qxWeb.type.get(el.$$matchTargetInfo) == \"Array\"\n        ) {\n          var infos = el.$$matchTargetInfo;\n\n          for (var i = infos.length - 1; i >= 0; i--) {\n            var entry = infos[i];\n            if (\n              entry.type == eventType &&\n              entry.callback == callback &&\n              entry.context == context\n            ) {\n              this.off(eventType, entry.listener);\n              infos.splice(i, 1);\n            }\n          }\n\n          if (infos.length === 0) {\n            el.$$matchTargetInfo = null;\n          }\n        }\n      }, this);\n\n      return this;\n    }\n  },\n\n  defer(statics) {\n    qxWeb.$attachAll(this);\n    // manually attach internal $-methods as they are ignored by the previous method-call\n    qxWeb.$attachStatic({\n      $registerEventNormalization: statics.$registerEventNormalization,\n      $unregisterEventNormalization: statics.$unregisterEventNormalization,\n      $getEventNormalizationRegistry: statics.$getEventNormalizationRegistry,\n      $registerEventHook: statics.$registerEventHook,\n      $unregisterEventHook: statics.$unregisterEventHook,\n      $getEventHookRegistry: statics.$getEventHookRegistry\n    });\n  }\n});\n"
  ],
  "mappings": "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"
}