{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "EQUALITY_ATTRIBUTES",
    "__getAncestors",
    "__P_286_0",
    "selector",
    "filter",
    "ancestors",
    "i",
    "length",
    "parent",
    "dom",
    "Element",
    "getParentElement",
    "found",
    "bom",
    "Selector",
    "matches",
    "concat",
    "qxWeb",
    "$init",
    "__getElementFromArgument",
    "__P_286_1",
    "arg",
    "isString",
    "__getNodeFromArgument",
    "__P_286_2",
    "Array",
    "isNode",
    "__getAttributes",
    "__P_286_3",
    "node",
    "attributes",
    "attr",
    "name",
    "value",
    "__hierarchyHelper",
    "__P_286_4",
    "collection",
    "method",
    "all",
    "Hierarchy",
    "l",
    "push",
    "apply",
    "ret",
    "lang",
    "unique",
    "isElement",
    "Node",
    "module",
    "Traversing",
    "isNodeName",
    "nodeName",
    "isDocument",
    "isDocumentFragment",
    "getWindow",
    "isTextNode",
    "obj",
    "isText",
    "isWindow",
    "getDocument",
    "getNodeName",
    "getName",
    "getNodeText",
    "getText",
    "isBlockNode",
    "equalNodes",
    "node1",
    "node2",
    "core",
    "Environment",
    "get",
    "isEqualNode",
    "hasAttributes",
    "hasChildNodes",
    "childNodes",
    "domAttributes",
    "domAttrib",
    "node1Attributes",
    "node2Attributes",
    "j",
    "m",
    "child1",
    "child2",
    "members",
    "add",
    "el",
    "getChildren",
    "children",
    "getChildElements",
    "forEach",
    "fn",
    "ctx",
    "call",
    "getParents",
    "parents",
    "isChildOf",
    "parentCollection",
    "getAncestors",
    "len",
    "indexOf",
    "getAncestorsUntil",
    "getClosest",
    "closest",
    "findClosest",
    "current",
    "parentNode",
    "find",
    "query",
    "getContents",
    "_forEachElement",
    "item",
    "fromCollection",
    "is",
    "Type",
    "isFunction",
    "eq",
    "index",
    "slice",
    "getFirst",
    "getLast",
    "has",
    "descendants",
    "constructor",
    "contains",
    "element",
    "document",
    "getNext",
    "map",
    "getNextElementSibling",
    "getNextAll",
    "getNextUntil",
    "nextSiblings",
    "getNextSiblings",
    "getPrev",
    "getPreviousElementSibling",
    "getPrevAll",
    "getPrevUntil",
    "previousSiblings",
    "getPreviousSiblings",
    "getSiblings",
    "not",
    "res",
    "getOffsetParent",
    "Location",
    "isRendered",
    "defer",
    "$attachAll",
    "$attach"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/module/Traversing.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2011-2012 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Martin Wittemann (wittemann)\r\n     * Daniel Wagner (danielwagner)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * DOM traversal module\r\n *\r\n * @require(qx.dom.Hierarchy#getSiblings)\r\n * @require(qx.dom.Hierarchy#getNextSiblings)\r\n * @require(qx.dom.Hierarchy#getPreviousSiblings)\r\n * @require(qx.dom.Hierarchy#contains)\r\n *\r\n * @group (Core)\r\n */\r\nqx.Bootstrap.define(\"qx.module.Traversing\", {\r\n  statics: {\r\n    /**\r\n     * String attributes used to determine if two DOM nodes are equal\r\n     * as defined in <a href=\"http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode\">\r\n     * DOM Level 3</a>\r\n     */\r\n    EQUALITY_ATTRIBUTES: [\r\n      \"nodeType\",\r\n      \"nodeName\",\r\n      \"localName\",\r\n      \"namespaceURI\",\r\n      \"prefix\",\r\n      \"nodeValue\"\r\n    ],\r\n\r\n    /**\r\n     * Internal helper for getAncestors and getAncestorsUntil\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String} Selector that indicates where to stop including\r\n     * ancestor elements\r\n     * @param filter {String?null} Optional selector to match\r\n     * @return {qxWeb} Collection containing the ancestor elements\r\n     * @internal\r\n     */\r\n    __getAncestors(selector, filter) {\r\n      var ancestors = [];\r\n      for (var i = 0; i < this.length; i++) {\r\n        var parent = qx.dom.Element.getParentElement(this[i]);\r\n        while (parent) {\r\n          var found = [parent];\r\n          if (selector && qx.bom.Selector.matches(selector, found).length > 0) {\r\n            break;\r\n          }\r\n          if (filter) {\r\n            found = qx.bom.Selector.matches(filter, found);\r\n          }\r\n          ancestors = ancestors.concat(found);\r\n          parent = qx.dom.Element.getParentElement(parent);\r\n        }\r\n      }\r\n      return qxWeb.$init(ancestors, qxWeb);\r\n    },\r\n\r\n    /**\r\n     * Helper which returns the element from the given argument. If it's a collection,\r\n     * it returns it's first child. If it's a string, it tries to use the string\r\n     * as selector and returns the first child of the new collection.\r\n     * @param arg {Node|String|qxWeb} The element.\r\n     * @return {Node|var} If a node can be extracted, the node element will be return.\r\n     *   If not, at given argument will be returned.\r\n     */\r\n    __getElementFromArgument(arg) {\r\n      if (arg instanceof qxWeb) {\r\n        return arg[0];\r\n      } else if (qx.Bootstrap.isString(arg)) {\r\n        return qxWeb(arg)[0];\r\n      }\r\n      return arg;\r\n    },\r\n\r\n    /**\r\n     * Helper that attempts to convert the given argument into a DOM node\r\n     * @param arg {var} object to convert\r\n     * @return {Node|null} DOM node or null if the conversion failed\r\n     */\r\n    __getNodeFromArgument(arg) {\r\n      if (typeof arg == \"string\") {\r\n        arg = qxWeb(arg);\r\n      }\r\n\r\n      if (arg instanceof Array || arg instanceof qxWeb) {\r\n        arg = arg[0];\r\n      }\r\n\r\n      return qxWeb.isNode(arg) ? arg : null;\r\n    },\r\n\r\n    /**\r\n     * Returns a map containing the given DOM node's attribute names\r\n     * and values\r\n     *\r\n     * @param node {Node} DOM node\r\n     * @return {Map} Map of attribute names/values\r\n     */\r\n    __getAttributes(node) {\r\n      var attributes = {};\r\n\r\n      for (var attr in node.attributes) {\r\n        if (attr == \"length\") {\r\n          continue;\r\n        }\r\n        var name = node.attributes[attr].name;\r\n        var value = node.attributes[attr].value;\r\n        attributes[name] = value;\r\n      }\r\n\r\n      return attributes;\r\n    },\r\n\r\n    /**\r\n     * Helper function that iterates over a set of items and applies the given\r\n     * qx.dom.Hierarchy method to each entry, storing the results in a new Array.\r\n     * Duplicates are removed and the items are filtered if a selector is\r\n     * provided.\r\n     *\r\n     * @attach{qxWeb}\r\n     * @param collection {Array} Collection to iterate over (any Array-like object)\r\n     * @param method {String} Name of the qx.dom.Hierarchy method to apply\r\n     * @param selector {String?} Optional selector that elements to be included\r\n     * must match\r\n     * @return {Array} Result array\r\n     * @internal\r\n     */\r\n    __hierarchyHelper(collection, method, selector) {\r\n      // Iterate ourself, as we want to directly combine the result\r\n      var all = [];\r\n      var Hierarchy = qx.dom.Hierarchy;\r\n      for (var i = 0, l = collection.length; i < l; i++) {\r\n        all.push.apply(all, Hierarchy[method](collection[i]));\r\n      }\r\n\r\n      // Remove duplicates\r\n      var ret = qx.lang.Array.unique(all);\r\n\r\n      // Post reduce result by selector\r\n      if (selector) {\r\n        ret = qx.bom.Selector.matches(selector, ret);\r\n      }\r\n\r\n      return ret;\r\n    },\r\n\r\n    /**\r\n     * Checks if the given object is a DOM element\r\n     *\r\n     * @attachStatic{qxWeb}\r\n     * @param selector {Object|String|qxWeb} Object to check\r\n     * @return {Boolean} <code>true</code> if the object is a DOM element\r\n     */\r\n    isElement(selector) {\r\n      return qx.dom.Node.isElement(\r\n        qx.module.Traversing.__getElementFromArgument(selector)\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Checks if the given object is a DOM node\r\n     *\r\n     * @attachStatic{qxWeb}\r\n     * @param selector {Node|String|qxWeb} Object to check\r\n     * @return {Boolean} <code>true</code> if the object is a DOM node\r\n     */\r\n    isNode(selector) {\r\n      return qx.dom.Node.isNode(\r\n        qx.module.Traversing.__getElementFromArgument(selector)\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Whether the node has the given node name\r\n     *\r\n     * @attachStatic{qxWeb}\r\n     * @param selector {Node|String|qxWeb} the node to check\r\n     * @param  nodeName {String} the node name to check for\r\n     * @return {Boolean} <code>true</code> if the node has the given name\r\n     */\r\n    isNodeName(selector, nodeName) {\r\n      return qx.dom.Node.isNodeName(\r\n        qx.module.Traversing.__getElementFromArgument(selector),\r\n        nodeName\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Checks if the given object is a DOM document object\r\n     *\r\n     * @attachStatic{qxWeb}\r\n     * @param node {Object|qxWeb} Object to check. If the value is a qxWeb\r\n     * collection, isDocument will check the first item.\r\n     * @return {Boolean} <code>true</code> if the object is a DOM document\r\n     */\r\n    isDocument(node) {\r\n      if (node instanceof qxWeb) {\r\n        node = node[0];\r\n      }\r\n      return qx.dom.Node.isDocument(node);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given object is a DOM document fragment object\r\n     *\r\n     * @attachStatic{qxWeb}\r\n     * @param node {Object|qxWeb} Object to check. If the value is a qxWeb\r\n     * collection, isDocumentFragment will check the first item.\r\n     * @return {Boolean} <code>true</code> if the object is a DOM document fragment\r\n     */\r\n    isDocumentFragment(node) {\r\n      if (node instanceof qxWeb) {\r\n        node = node[0];\r\n      }\r\n      return qx.dom.Node.isDocumentFragment(node);\r\n    },\r\n\r\n    /**\r\n     * Returns the DOM2 <code>defaultView</code> (window) for the given node.\r\n     *\r\n     * @attachStatic{qxWeb}\r\n     * @param selector {Node|Document|Window|String|qxWeb} Node to inspect\r\n     * @return {Window} the <code>defaultView</code> for the given node\r\n     */\r\n    getWindow(selector) {\r\n      return qx.dom.Node.getWindow(\r\n        qx.module.Traversing.__getElementFromArgument(selector)\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Checks whether the given object is a DOM text node\r\n     *\r\n     * @attachStatic{qxWeb}\r\n     * @param obj {Object} the object to be tested\r\n     * @return {Boolean} <code>true</code> if the object is a textNode\r\n     */\r\n    isTextNode(obj) {\r\n      return qx.dom.Node.isText(obj);\r\n    },\r\n\r\n    /**\r\n     * Check whether the given object is a browser window object.\r\n     *\r\n     * @attachStatic{qxWeb}\r\n     * @param obj {Object|qxWeb} the object to be tested. If the value\r\n     * is a qxWeb collection, isDocument will check the first item.\r\n     * @return {Boolean} <code>true</code> if the object is a window object\r\n     */\r\n    isWindow(obj) {\r\n      if (obj instanceof qxWeb) {\r\n        obj = obj[0];\r\n      }\r\n      return qx.dom.Node.isWindow(obj);\r\n    },\r\n\r\n    /**\r\n     * Returns the owner document of the given node\r\n     *\r\n     * @attachStatic{qxWeb}\r\n     * @param selector {Node|String|qxWeb} Node to get the document for\r\n     * @return {Document|null} The document of the given DOM node\r\n     */\r\n    getDocument(selector) {\r\n      return qx.dom.Node.getDocument(\r\n        qx.module.Traversing.__getElementFromArgument(selector)\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Get the DOM node's name as a lowercase string\r\n     *\r\n     * @attachStatic{qxWeb}\r\n     * @param selector {Node|String|qxWeb} DOM Node\r\n     * @return {String} node name\r\n     */\r\n    getNodeName(selector) {\r\n      return qx.dom.Node.getName(\r\n        qx.module.Traversing.__getElementFromArgument(selector)\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Returns the text content of a node where the node type may be one of\r\n     * NODE_ELEMENT, NODE_ATTRIBUTE, NODE_TEXT, NODE_CDATA\r\n     *\r\n     * @attachStatic{qxWeb}\r\n     * @param selector {Node|String|qxWeb} the node from where the search should start. If the\r\n     * node has subnodes the text contents are recursively retrieved and joined\r\n     * @return {String} the joined text content of the given node or null if not\r\n     * appropriate.\r\n     */\r\n    getNodeText(selector) {\r\n      return qx.dom.Node.getText(\r\n        qx.module.Traversing.__getElementFromArgument(selector)\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Checks if the given node is a block node\r\n     *\r\n     * @attachStatic{qxWeb}\r\n     * @param selector {Node|String|qxWeb} the node to check\r\n     * @return {Boolean} <code>true</code> if the node is a block node\r\n     */\r\n    isBlockNode(selector) {\r\n      return qx.dom.Node.isBlockNode(\r\n        qx.module.Traversing.__getElementFromArgument(selector)\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Determines if two DOM nodes are equal as defined in the\r\n     * <a href=\"http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode\">DOM Level 3 isEqualNode spec</a>.\r\n     * Also works in legacy browsers without native <em>isEqualNode</em> support.\r\n     *\r\n     * @attachStatic{qxWeb}\r\n     * @param node1 {String|Element|Element[]|qxWeb} first object to compare\r\n     * @param node2 {String|Element|Element[]|qxWeb} second object to compare\r\n     * @return {Boolean} <code>true</code> if the nodes are equal\r\n     */\r\n    equalNodes(node1, node2) {\r\n      node1 = qx.module.Traversing.__getNodeFromArgument(node1);\r\n      node2 = qx.module.Traversing.__getNodeFromArgument(node2);\r\n\r\n      if (!node1 || !node2) {\r\n        return false;\r\n      }\r\n\r\n      if (qx.core.Environment.get(\"html.node.isequalnode\")) {\r\n        return node1.isEqualNode(node2);\r\n      } else {\r\n        if (node1 === node2) {\r\n          return true;\r\n        }\r\n\r\n        // quick attributes length check\r\n        var hasAttributes = node1.attributes && node2.attributes;\r\n        if (\r\n          hasAttributes &&\r\n          node1.attributes.length !== node2.attributes.length\r\n        ) {\r\n          return false;\r\n        }\r\n\r\n        var hasChildNodes = node1.childNodes && node2.childNodes;\r\n        // quick childNodes length check\r\n        if (\r\n          hasChildNodes &&\r\n          node1.childNodes.length !== node2.childNodes.length\r\n        ) {\r\n          return false;\r\n        }\r\n\r\n        // string attribute check\r\n        var domAttributes = qx.module.Traversing.EQUALITY_ATTRIBUTES;\r\n        for (var i = 0, l = domAttributes.length; i < l; i++) {\r\n          var domAttrib = domAttributes[i];\r\n          if (node1[domAttrib] !== node2[domAttrib]) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        // attribute values\r\n        if (hasAttributes) {\r\n          var node1Attributes = qx.module.Traversing.__getAttributes(node1);\r\n          var node2Attributes = qx.module.Traversing.__getAttributes(node2);\r\n          for (var attr in node1Attributes) {\r\n            if (node1Attributes[attr] !== node2Attributes[attr]) {\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n\r\n        // child nodes\r\n        if (hasChildNodes) {\r\n          for (var j = 0, m = node1.childNodes.length; j < m; j++) {\r\n            var child1 = node1.childNodes[j];\r\n            var child2 = node2.childNodes[j];\r\n            if (!qx.module.Traversing.equalNodes(child1, child2)) {\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n\r\n        return true;\r\n      }\r\n    }\r\n  },\r\n\r\n  members: {\r\n    __getAncestors: null,\r\n\r\n    /**\r\n     * Adds an element to the collection\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param el {Element|qxWeb} DOM element to add to the collection.\r\n     * If a collection is given, only the first element will be added\r\n     * @return {qxWeb} The collection for chaining\r\n     */\r\n    add(el) {\r\n      if (el instanceof qxWeb) {\r\n        el = el[0];\r\n      }\r\n      if (\r\n        qx.module.Traversing.isElement(el) ||\r\n        qx.module.Traversing.isDocument(el) ||\r\n        qx.module.Traversing.isWindow(el) ||\r\n        qx.module.Traversing.isDocumentFragment(el)\r\n      ) {\r\n        this.push(el);\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Gets a set of elements containing all of the unique immediate children of\r\n     * each of the matched set of elements.\r\n     * This set can be filtered with an optional expression that will cause only\r\n     * elements matching the selector to be collected.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String?null} Optional selector to match\r\n     * @return {qxWeb} Collection containing the child elements\r\n     */\r\n    getChildren(selector) {\r\n      var children = [];\r\n      for (var i = 0; i < this.length; i++) {\r\n        var found = qx.dom.Hierarchy.getChildElements(this[i]);\r\n        if (selector) {\r\n          found = qx.bom.Selector.matches(selector, found);\r\n        }\r\n        children = children.concat(found);\r\n      }\r\n      return qxWeb.$init(children, qxWeb);\r\n    },\r\n\r\n    /**\r\n     * Executes the provided callback function once for each item in the\r\n     * collection.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param fn {Function} Callback function which is called with two parameters\r\n     * <ul>\r\n     *  <li>current item - DOM node</li>\r\n     *  <li>current index - Number</li>\r\n     * </ul>\r\n     * @param ctx {Object} Context object\r\n     * @return {qxWeb} The collection for chaining\r\n     */\r\n    forEach(fn, ctx) {\r\n      for (var i = 0; i < this.length; i++) {\r\n        fn.call(ctx, this[i], i, this);\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Gets a set of elements containing the parent of each element in the\r\n     * collection.\r\n     * This set can be filtered with an optional expression that will cause only\r\n     * elements matching the selector to be collected.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String?null} Optional selector to match\r\n     * @return {qxWeb} Collection containing the parent elements\r\n     */\r\n    getParents(selector) {\r\n      var parents = [];\r\n      for (var i = 0; i < this.length; i++) {\r\n        var found = qx.dom.Element.getParentElement(this[i]);\r\n        if (selector) {\r\n          found = qx.bom.Selector.matches(selector, [found]);\r\n        }\r\n        parents = parents.concat(found);\r\n      }\r\n      return qxWeb.$init(parents, qxWeb);\r\n    },\r\n\r\n    /**\r\n     * Checks if any element of the current collection is child of any element of a given\r\n     * parent collection.\r\n     *\r\n     * @attach{qxWeb}\r\n     * @param parent {qxWeb | String} Collection or selector of the parent collection to check.\r\n     * @return {Boolean} Returns true if at least one element of the current collection is child of the parent collection\r\n     *\r\n     */\r\n    isChildOf(parent) {\r\n      if (this.length == 0) {\r\n        return false;\r\n      }\r\n      var ancestors = null,\r\n        parentCollection = qxWeb(parent),\r\n        isChildOf = false;\r\n      for (var i = 0, l = this.length; i < l && !isChildOf; i++) {\r\n        ancestors = qxWeb(this[i]).getAncestors();\r\n        for (var j = 0, len = parentCollection.length; j < len; j++) {\r\n          if (ancestors.indexOf(parentCollection[j]) != -1) {\r\n            isChildOf = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      return isChildOf;\r\n    },\r\n\r\n    /**\r\n     * Gets a set of elements containing all ancestors of each element in the\r\n     * collection.\r\n     * This set can be filtered with an optional expression that will cause only\r\n     * elements matching the selector to be collected.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param filter {String?null} Optional selector to match\r\n     * @return {qxWeb} Collection containing the ancestor elements\r\n     */\r\n    getAncestors(filter) {\r\n      return this.__getAncestors(null, filter);\r\n    },\r\n\r\n    /**\r\n     * Gets a set of elements containing all ancestors of each element in the\r\n     * collection, up to (but not including) the element matched by the provided\r\n     * selector.\r\n     * This set can be filtered with an optional expression that will cause only\r\n     * elements matching the selector to be collected.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String} Selector that indicates where to stop including\r\n     * ancestor elements\r\n     * @param filter {String?null} Optional selector to match\r\n     * @return {qxWeb} Collection containing the ancestor elements\r\n     */\r\n    getAncestorsUntil(selector, filter) {\r\n      return this.__getAncestors(selector, filter);\r\n    },\r\n\r\n    /**\r\n     * Gets a set containing the closest matching ancestor for each item in\r\n     * the collection.\r\n     * If the item itself matches, it is added to the new set. Otherwise, the\r\n     * item's parent chain will be traversed until a match is found.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String} Selector expression to match\r\n     * @return {qxWeb} New collection containing the closest matching ancestors\r\n     */\r\n    getClosest(selector) {\r\n      var closest = [];\r\n\r\n      var findClosest = function (current) {\r\n        var found = qx.bom.Selector.matches(selector, current);\r\n        if (found.length) {\r\n          closest.push(found[0]);\r\n        } else {\r\n          current = current.getParents(); // One up\r\n          if (current[0] && current[0].parentNode) {\r\n            findClosest(current);\r\n          }\r\n        }\r\n      };\r\n\r\n      for (var i = 0; i < this.length; i++) {\r\n        findClosest(qxWeb(this[i]));\r\n      }\r\n\r\n      return qxWeb.$init(closest, qxWeb);\r\n    },\r\n\r\n    /**\r\n     * Searches the child elements of each item in the collection and returns\r\n     * a new collection containing the children that match the provided selector\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String} Selector expression to match the child elements\r\n     * against\r\n     * @return {qxWeb} New collection containing the matching child elements\r\n     */\r\n    find(selector) {\r\n      var found = [];\r\n      for (var i = 0; i < this.length; i++) {\r\n        found = found.concat(qx.bom.Selector.query(selector, this[i]));\r\n      }\r\n      return qxWeb.$init(found, qxWeb);\r\n    },\r\n\r\n    /**\r\n     * Gets a new set of elements containing the child nodes of each item in the\r\n     * current set.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @return {qxWeb} New collection containing the child nodes\r\n     */\r\n    getContents() {\r\n      var found = [];\r\n      this._forEachElement(function (item) {\r\n        found = found.concat(qx.lang.Array.fromCollection(item.childNodes));\r\n      });\r\n      return qxWeb.$init(found, qxWeb);\r\n    },\r\n\r\n    /**\r\n     * Checks if at least one element in the collection passes the provided\r\n     * filter. This can be either a selector expression or a filter\r\n     * function\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String|Function} Selector expression or filter function\r\n     * @return {Boolean} <code>true</code> if at least one element matches\r\n     */\r\n    is(selector) {\r\n      if (qx.lang.Type.isFunction(selector)) {\r\n        return this.filter(selector).length > 0;\r\n      }\r\n      return !!selector && qx.bom.Selector.matches(selector, this).length > 0;\r\n    },\r\n\r\n    /**\r\n     * Reduce the set of matched elements to a single element.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param index {Number} The position of the element in the collection\r\n     * @return {qxWeb} A new collection containing one element\r\n     */\r\n    eq(index) {\r\n      return this.slice(index, +index + 1);\r\n    },\r\n\r\n    /**\r\n     * Reduces the collection to the first element.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @return {qxWeb} A new collection containing one element\r\n     */\r\n    getFirst() {\r\n      return this.slice(0, 1);\r\n    },\r\n\r\n    /**\r\n     * Reduces the collection to the last element.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @return {qxWeb} A new collection containing one element\r\n     */\r\n    getLast() {\r\n      return this.slice(this.length - 1);\r\n    },\r\n\r\n    /**\r\n     * Gets a collection containing only the elements that have descendants\r\n     * matching the given selector\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String} Selector expression\r\n     * @return {qxWeb} a new collection containing only elements with matching descendants\r\n     */\r\n    has(selector) {\r\n      var found = [];\r\n      this._forEachElement(function (item, index) {\r\n        var descendants = qx.bom.Selector.matches(\r\n          selector,\r\n          this.eq(index).getContents()\r\n        );\r\n\r\n        if (descendants.length > 0) {\r\n          found.push(item);\r\n        }\r\n      });\r\n\r\n      return qxWeb.$init(found, this.constructor);\r\n    },\r\n\r\n    /**\r\n     * Returns a new collection containing only those nodes that\r\n     * contain the given element. Also accepts a qxWeb\r\n     * collection or an Array of elements. In those cases, the first element\r\n     * in the list is used.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param element {Element|Window|Element[]|qxWeb} element to check for.\r\n     * @return {qxWeb} Collection with matching items\r\n     */\r\n    contains(element) {\r\n      // qxWeb does not inherit from Array in IE\r\n      if (element instanceof Array || element instanceof qxWeb) {\r\n        element = element[0];\r\n      }\r\n\r\n      if (!element) {\r\n        return qxWeb();\r\n      }\r\n\r\n      if (qx.dom.Node.isWindow(element)) {\r\n        element = element.document;\r\n      }\r\n\r\n      return this.filter(function (el) {\r\n        if (qx.dom.Node.isWindow(el)) {\r\n          el = el.document;\r\n        }\r\n        return qx.dom.Hierarchy.contains(el, element);\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Gets a collection containing the next sibling element of each item in\r\n     * the current set.\r\n     * This set can be filtered with an optional expression that will cause only\r\n     * elements matching the selector to be collected.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String?} Optional selector expression\r\n     * @return {qxWeb} New set containing next siblings\r\n     */\r\n    getNext(selector) {\r\n      var found = this.map(\r\n        qx.dom.Hierarchy.getNextElementSibling,\r\n        qx.dom.Hierarchy\r\n      );\r\n\r\n      if (selector) {\r\n        found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);\r\n      }\r\n      return found;\r\n    },\r\n\r\n    /**\r\n     * Gets a collection containing all following sibling elements of each\r\n     * item in the current set.\r\n     * This set can be filtered with an optional expression that will cause only\r\n     * elements matching the selector to be collected.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String?} Optional selector expression\r\n     * @return {qxWeb} New set containing following siblings\r\n     */\r\n    getNextAll(selector) {\r\n      var ret = qx.module.Traversing.__hierarchyHelper(\r\n        this,\r\n        \"getNextSiblings\",\r\n        selector\r\n      );\r\n\r\n      return qxWeb.$init(ret, qxWeb);\r\n    },\r\n\r\n    /**\r\n     * Gets a collection containing the following sibling elements of each\r\n     * item in the current set up to but not including any element that matches\r\n     * the given selector.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String?} Optional selector expression\r\n     * @return {qxWeb} New set containing following siblings\r\n     */\r\n    getNextUntil(selector) {\r\n      var found = [];\r\n      this.forEach(function (item, index) {\r\n        var nextSiblings = qx.dom.Hierarchy.getNextSiblings(item);\r\n        for (var i = 0, l = nextSiblings.length; i < l; i++) {\r\n          if (qx.bom.Selector.matches(selector, [nextSiblings[i]]).length > 0) {\r\n            break;\r\n          }\r\n          found.push(nextSiblings[i]);\r\n        }\r\n      });\r\n\r\n      return qxWeb.$init(found, qxWeb);\r\n    },\r\n\r\n    /**\r\n     * Gets a collection containing the previous sibling element of each item in\r\n     * the current set.\r\n     * This set can be filtered with an optional expression that will cause only\r\n     * elements matching the selector to be collected.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String?} Optional selector expression\r\n     * @return {qxWeb} New set containing previous siblings\r\n     */\r\n    getPrev(selector) {\r\n      var found = this.map(\r\n        qx.dom.Hierarchy.getPreviousElementSibling,\r\n        qx.dom.Hierarchy\r\n      );\r\n\r\n      if (selector) {\r\n        found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);\r\n      }\r\n      return found;\r\n    },\r\n\r\n    /**\r\n     * Gets a collection containing all preceding sibling elements of each\r\n     * item in the current set.\r\n     * This set can be filtered with an optional expression that will cause only\r\n     * elements matching the selector to be collected.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String?} Optional selector expression\r\n     * @return {qxWeb} New set containing preceding siblings\r\n     */\r\n    getPrevAll(selector) {\r\n      var ret = qx.module.Traversing.__hierarchyHelper(\r\n        this,\r\n        \"getPreviousSiblings\",\r\n        selector\r\n      );\r\n\r\n      return qxWeb.$init(ret, qxWeb);\r\n    },\r\n\r\n    /**\r\n     * Gets a collection containing the preceding sibling elements of each\r\n     * item in the current set up to but not including any element that matches\r\n     * the given selector.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String?} Optional selector expression\r\n     * @return {qxWeb} New set containing preceding siblings\r\n     */\r\n    getPrevUntil(selector) {\r\n      var found = [];\r\n      this.forEach(function (item, index) {\r\n        var previousSiblings = qx.dom.Hierarchy.getPreviousSiblings(item);\r\n        for (var i = 0, l = previousSiblings.length; i < l; i++) {\r\n          if (\r\n            qx.bom.Selector.matches(selector, [previousSiblings[i]]).length > 0\r\n          ) {\r\n            break;\r\n          }\r\n          found.push(previousSiblings[i]);\r\n        }\r\n      });\r\n\r\n      return qxWeb.$init(found, qxWeb);\r\n    },\r\n\r\n    /**\r\n     * Gets a collection containing all sibling elements of the items in the\r\n     * current set.\r\n     * This set can be filtered with an optional expression that will cause only\r\n     * elements matching the selector to be collected.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String?} Optional selector expression\r\n     * @return {qxWeb} New set containing sibling elements\r\n     */\r\n    getSiblings(selector) {\r\n      var ret = qx.module.Traversing.__hierarchyHelper(\r\n        this,\r\n        \"getSiblings\",\r\n        selector\r\n      );\r\n\r\n      return qxWeb.$init(ret, qxWeb);\r\n    },\r\n\r\n    /**\r\n     * Remove elements from the collection that do not pass the given filter.\r\n     * This can be either a selector expression or a filter function\r\n     *\r\n     * @attach {qxWeb}\r\n     * @param selector {String|Function} Selector or filter function\r\n     * @return {qxWeb} Reduced collection\r\n     */\r\n    not(selector) {\r\n      if (qx.lang.Type.isFunction(selector)) {\r\n        return this.filter(function (item, index, obj) {\r\n          return !selector(item, index, obj);\r\n        });\r\n      }\r\n\r\n      var res = qx.bom.Selector.matches(selector, this);\r\n      return this.filter(function (value) {\r\n        return res.indexOf(value) === -1;\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Gets a new collection containing the offset parent of each item in the\r\n     * current set.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @return {qxWeb} New collection containing offset parents\r\n     */\r\n    getOffsetParent() {\r\n      return this.map(qx.bom.element.Location.getOffsetParent);\r\n    },\r\n\r\n    /**\r\n     * Whether the first element in the collection is inserted into\r\n     * the document for which it was created.\r\n     *\r\n     * @attach {qxWeb}\r\n     * @return {Boolean} <code>true</code> when the element is inserted\r\n     *    into the document.\r\n     */\r\n    isRendered() {\r\n      if (!this[0]) {\r\n        return false;\r\n      }\r\n      return qx.dom.Hierarchy.isRendered(this[0]);\r\n    }\r\n  },\r\n\r\n  defer(statics) {\r\n    qxWeb.$attachAll(this);\r\n    // manually attach private method which is ignored by attachAll\r\n    qxWeb.$attach({\r\n      __getAncestors: statics.__getAncestors\r\n    });\r\n  }\r\n});\r\n"
  ],
  "mappings": "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"
}