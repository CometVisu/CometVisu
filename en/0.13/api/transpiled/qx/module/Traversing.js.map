{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "EQUALITY_ATTRIBUTES",
    "__getAncestors",
    "selector",
    "filter",
    "ancestors",
    "i",
    "length",
    "parent",
    "dom",
    "Element",
    "getParentElement",
    "found",
    "bom",
    "Selector",
    "matches",
    "concat",
    "qxWeb",
    "$init",
    "__getElementFromArgument",
    "arg",
    "isString",
    "__getNodeFromArgument",
    "Array",
    "isNode",
    "__getAttributes",
    "node",
    "attributes",
    "attr",
    "name",
    "value",
    "__hierarchyHelper",
    "collection",
    "method",
    "all",
    "Hierarchy",
    "l",
    "push",
    "apply",
    "ret",
    "lang",
    "unique",
    "isElement",
    "Node",
    "module",
    "Traversing",
    "isNodeName",
    "nodeName",
    "isDocument",
    "isDocumentFragment",
    "getWindow",
    "isTextNode",
    "obj",
    "isText",
    "isWindow",
    "getDocument",
    "getNodeName",
    "getName",
    "getNodeText",
    "getText",
    "isBlockNode",
    "equalNodes",
    "node1",
    "node2",
    "core",
    "Environment",
    "get",
    "isEqualNode",
    "hasAttributes",
    "hasChildNodes",
    "childNodes",
    "domAttributes",
    "domAttrib",
    "node1Attributes",
    "node2Attributes",
    "j",
    "m",
    "child1",
    "child2",
    "members",
    "add",
    "el",
    "getChildren",
    "children",
    "getChildElements",
    "forEach",
    "fn",
    "ctx",
    "call",
    "getParents",
    "parents",
    "isChildOf",
    "parentCollection",
    "getAncestors",
    "len",
    "indexOf",
    "getAncestorsUntil",
    "getClosest",
    "closest",
    "findClosest",
    "current",
    "parentNode",
    "find",
    "query",
    "getContents",
    "_forEachElement",
    "item",
    "fromCollection",
    "is",
    "Type",
    "isFunction",
    "eq",
    "index",
    "slice",
    "getFirst",
    "getLast",
    "has",
    "descendants",
    "constructor",
    "contains",
    "element",
    "document",
    "getNext",
    "map",
    "getNextElementSibling",
    "getNextAll",
    "getNextUntil",
    "nextSiblings",
    "getNextSiblings",
    "getPrev",
    "getPreviousElementSibling",
    "getPrevAll",
    "getPrevUntil",
    "previousSiblings",
    "getPreviousSiblings",
    "getSiblings",
    "not",
    "res",
    "getOffsetParent",
    "Location",
    "isRendered",
    "defer",
    "$attachAll",
    "$attach"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/module/Traversing.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2011-2012 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (wittemann)\n     * Daniel Wagner (danielwagner)\n\n************************************************************************ */\n\n/**\n * DOM traversal module\n *\n * @require(qx.dom.Hierarchy#getSiblings)\n * @require(qx.dom.Hierarchy#getNextSiblings)\n * @require(qx.dom.Hierarchy#getPreviousSiblings)\n * @require(qx.dom.Hierarchy#contains)\n *\n * @group (Core)\n */\nqx.Bootstrap.define(\"qx.module.Traversing\", {\n  statics: {\n    /**\n     * String attributes used to determine if two DOM nodes are equal\n     * as defined in <a href=\"http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode\">\n     * DOM Level 3</a>\n     */\n    EQUALITY_ATTRIBUTES: [\n      \"nodeType\",\n      \"nodeName\",\n      \"localName\",\n      \"namespaceURI\",\n      \"prefix\",\n      \"nodeValue\"\n    ],\n\n    /**\n     * Internal helper for getAncestors and getAncestorsUntil\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector that indicates where to stop including\n     * ancestor elements\n     * @param filter {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the ancestor elements\n     * @internal\n     */\n    __getAncestors(selector, filter) {\n      var ancestors = [];\n      for (var i = 0; i < this.length; i++) {\n        var parent = qx.dom.Element.getParentElement(this[i]);\n        while (parent) {\n          var found = [parent];\n          if (selector && qx.bom.Selector.matches(selector, found).length > 0) {\n            break;\n          }\n          if (filter) {\n            found = qx.bom.Selector.matches(filter, found);\n          }\n          ancestors = ancestors.concat(found);\n          parent = qx.dom.Element.getParentElement(parent);\n        }\n      }\n      return qxWeb.$init(ancestors, qxWeb);\n    },\n\n    /**\n     * Helper which returns the element from the given argument. If it's a collection,\n     * it returns it's first child. If it's a string, it tries to use the string\n     * as selector and returns the first child of the new collection.\n     * @param arg {Node|String|qxWeb} The element.\n     * @return {Node|var} If a node can be extracted, the node element will be return.\n     *   If not, at given argument will be returned.\n     */\n    __getElementFromArgument(arg) {\n      if (arg instanceof qxWeb) {\n        return arg[0];\n      } else if (qx.Bootstrap.isString(arg)) {\n        return qxWeb(arg)[0];\n      }\n      return arg;\n    },\n\n    /**\n     * Helper that attempts to convert the given argument into a DOM node\n     * @param arg {var} object to convert\n     * @return {Node|null} DOM node or null if the conversion failed\n     */\n    __getNodeFromArgument(arg) {\n      if (typeof arg == \"string\") {\n        arg = qxWeb(arg);\n      }\n\n      if (arg instanceof Array || arg instanceof qxWeb) {\n        arg = arg[0];\n      }\n\n      return qxWeb.isNode(arg) ? arg : null;\n    },\n\n    /**\n     * Returns a map containing the given DOM node's attribute names\n     * and values\n     *\n     * @param node {Node} DOM node\n     * @return {Map} Map of attribute names/values\n     */\n    __getAttributes(node) {\n      var attributes = {};\n\n      for (var attr in node.attributes) {\n        if (attr == \"length\") {\n          continue;\n        }\n        var name = node.attributes[attr].name;\n        var value = node.attributes[attr].value;\n        attributes[name] = value;\n      }\n\n      return attributes;\n    },\n\n    /**\n     * Helper function that iterates over a set of items and applies the given\n     * qx.dom.Hierarchy method to each entry, storing the results in a new Array.\n     * Duplicates are removed and the items are filtered if a selector is\n     * provided.\n     *\n     * @attach{qxWeb}\n     * @param collection {Array} Collection to iterate over (any Array-like object)\n     * @param method {String} Name of the qx.dom.Hierarchy method to apply\n     * @param selector {String?} Optional selector that elements to be included\n     * must match\n     * @return {Array} Result array\n     * @internal\n     */\n    __hierarchyHelper(collection, method, selector) {\n      // Iterate ourself, as we want to directly combine the result\n      var all = [];\n      var Hierarchy = qx.dom.Hierarchy;\n      for (var i = 0, l = collection.length; i < l; i++) {\n        all.push.apply(all, Hierarchy[method](collection[i]));\n      }\n\n      // Remove duplicates\n      var ret = qx.lang.Array.unique(all);\n\n      // Post reduce result by selector\n      if (selector) {\n        ret = qx.bom.Selector.matches(selector, ret);\n      }\n\n      return ret;\n    },\n\n    /**\n     * Checks if the given object is a DOM element\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Object|String|qxWeb} Object to check\n     * @return {Boolean} <code>true</code> if the object is a DOM element\n     */\n    isElement(selector) {\n      return qx.dom.Node.isElement(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Checks if the given object is a DOM node\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} Object to check\n     * @return {Boolean} <code>true</code> if the object is a DOM node\n     */\n    isNode(selector) {\n      return qx.dom.Node.isNode(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Whether the node has the given node name\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} the node to check\n     * @param  nodeName {String} the node name to check for\n     * @return {Boolean} <code>true</code> if the node has the given name\n     */\n    isNodeName(selector, nodeName) {\n      return qx.dom.Node.isNodeName(\n        qx.module.Traversing.__getElementFromArgument(selector),\n        nodeName\n      );\n    },\n\n    /**\n     * Checks if the given object is a DOM document object\n     *\n     * @attachStatic{qxWeb}\n     * @param node {Object|qxWeb} Object to check. If the value is a qxWeb\n     * collection, isDocument will check the first item.\n     * @return {Boolean} <code>true</code> if the object is a DOM document\n     */\n    isDocument(node) {\n      if (node instanceof qxWeb) {\n        node = node[0];\n      }\n      return qx.dom.Node.isDocument(node);\n    },\n\n    /**\n     * Checks if the given object is a DOM document fragment object\n     *\n     * @attachStatic{qxWeb}\n     * @param node {Object|qxWeb} Object to check. If the value is a qxWeb\n     * collection, isDocumentFragment will check the first item.\n     * @return {Boolean} <code>true</code> if the object is a DOM document fragment\n     */\n    isDocumentFragment(node) {\n      if (node instanceof qxWeb) {\n        node = node[0];\n      }\n      return qx.dom.Node.isDocumentFragment(node);\n    },\n\n    /**\n     * Returns the DOM2 <code>defaultView</code> (window) for the given node.\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|Document|Window|String|qxWeb} Node to inspect\n     * @return {Window} the <code>defaultView</code> for the given node\n     */\n    getWindow(selector) {\n      return qx.dom.Node.getWindow(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Checks whether the given object is a DOM text node\n     *\n     * @attachStatic{qxWeb}\n     * @param obj {Object} the object to be tested\n     * @return {Boolean} <code>true</code> if the object is a textNode\n     */\n    isTextNode(obj) {\n      return qx.dom.Node.isText(obj);\n    },\n\n    /**\n     * Check whether the given object is a browser window object.\n     *\n     * @attachStatic{qxWeb}\n     * @param obj {Object|qxWeb} the object to be tested. If the value\n     * is a qxWeb collection, isDocument will check the first item.\n     * @return {Boolean} <code>true</code> if the object is a window object\n     */\n    isWindow(obj) {\n      if (obj instanceof qxWeb) {\n        obj = obj[0];\n      }\n      return qx.dom.Node.isWindow(obj);\n    },\n\n    /**\n     * Returns the owner document of the given node\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} Node to get the document for\n     * @return {Document|null} The document of the given DOM node\n     */\n    getDocument(selector) {\n      return qx.dom.Node.getDocument(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Get the DOM node's name as a lowercase string\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} DOM Node\n     * @return {String} node name\n     */\n    getNodeName(selector) {\n      return qx.dom.Node.getName(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Returns the text content of a node where the node type may be one of\n     * NODE_ELEMENT, NODE_ATTRIBUTE, NODE_TEXT, NODE_CDATA\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} the node from where the search should start. If the\n     * node has subnodes the text contents are recursively retrieved and joined\n     * @return {String} the joined text content of the given node or null if not\n     * appropriate.\n     */\n    getNodeText(selector) {\n      return qx.dom.Node.getText(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Checks if the given node is a block node\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} the node to check\n     * @return {Boolean} <code>true</code> if the node is a block node\n     */\n    isBlockNode(selector) {\n      return qx.dom.Node.isBlockNode(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Determines if two DOM nodes are equal as defined in the\n     * <a href=\"http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode\">DOM Level 3 isEqualNode spec</a>.\n     * Also works in legacy browsers without native <em>isEqualNode</em> support.\n     *\n     * @attachStatic{qxWeb}\n     * @param node1 {String|Element|Element[]|qxWeb} first object to compare\n     * @param node2 {String|Element|Element[]|qxWeb} second object to compare\n     * @return {Boolean} <code>true</code> if the nodes are equal\n     */\n    equalNodes(node1, node2) {\n      node1 = qx.module.Traversing.__getNodeFromArgument(node1);\n      node2 = qx.module.Traversing.__getNodeFromArgument(node2);\n\n      if (!node1 || !node2) {\n        return false;\n      }\n\n      if (qx.core.Environment.get(\"html.node.isequalnode\")) {\n        return node1.isEqualNode(node2);\n      } else {\n        if (node1 === node2) {\n          return true;\n        }\n\n        // quick attributes length check\n        var hasAttributes = node1.attributes && node2.attributes;\n        if (\n          hasAttributes &&\n          node1.attributes.length !== node2.attributes.length\n        ) {\n          return false;\n        }\n\n        var hasChildNodes = node1.childNodes && node2.childNodes;\n        // quick childNodes length check\n        if (\n          hasChildNodes &&\n          node1.childNodes.length !== node2.childNodes.length\n        ) {\n          return false;\n        }\n\n        // string attribute check\n        var domAttributes = qx.module.Traversing.EQUALITY_ATTRIBUTES;\n        for (var i = 0, l = domAttributes.length; i < l; i++) {\n          var domAttrib = domAttributes[i];\n          if (node1[domAttrib] !== node2[domAttrib]) {\n            return false;\n          }\n        }\n\n        // attribute values\n        if (hasAttributes) {\n          var node1Attributes = qx.module.Traversing.__getAttributes(node1);\n          var node2Attributes = qx.module.Traversing.__getAttributes(node2);\n          for (var attr in node1Attributes) {\n            if (node1Attributes[attr] !== node2Attributes[attr]) {\n              return false;\n            }\n          }\n        }\n\n        // child nodes\n        if (hasChildNodes) {\n          for (var j = 0, m = node1.childNodes.length; j < m; j++) {\n            var child1 = node1.childNodes[j];\n            var child2 = node2.childNodes[j];\n            if (!qx.module.Traversing.equalNodes(child1, child2)) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      }\n    }\n  },\n\n  members: {\n    __getAncestors: null,\n\n    /**\n     * Adds an element to the collection\n     *\n     * @attach {qxWeb}\n     * @param el {Element|qxWeb} DOM element to add to the collection.\n     * If a collection is given, only the first element will be added\n     * @return {qxWeb} The collection for chaining\n     */\n    add(el) {\n      if (el instanceof qxWeb) {\n        el = el[0];\n      }\n      if (\n        qx.module.Traversing.isElement(el) ||\n        qx.module.Traversing.isDocument(el) ||\n        qx.module.Traversing.isWindow(el) ||\n        qx.module.Traversing.isDocumentFragment(el)\n      ) {\n        this.push(el);\n      }\n      return this;\n    },\n\n    /**\n     * Gets a set of elements containing all of the unique immediate children of\n     * each of the matched set of elements.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the child elements\n     */\n    getChildren(selector) {\n      var children = [];\n      for (var i = 0; i < this.length; i++) {\n        var found = qx.dom.Hierarchy.getChildElements(this[i]);\n        if (selector) {\n          found = qx.bom.Selector.matches(selector, found);\n        }\n        children = children.concat(found);\n      }\n      return qxWeb.$init(children, qxWeb);\n    },\n\n    /**\n     * Executes the provided callback function once for each item in the\n     * collection.\n     *\n     * @attach {qxWeb}\n     * @param fn {Function} Callback function which is called with two parameters\n     * <ul>\n     *  <li>current item - DOM node</li>\n     *  <li>current index - Number</li>\n     * </ul>\n     * @param ctx {Object} Context object\n     * @return {qxWeb} The collection for chaining\n     */\n    forEach(fn, ctx) {\n      for (var i = 0; i < this.length; i++) {\n        fn.call(ctx, this[i], i, this);\n      }\n      return this;\n    },\n\n    /**\n     * Gets a set of elements containing the parent of each element in the\n     * collection.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the parent elements\n     */\n    getParents(selector) {\n      var parents = [];\n      for (var i = 0; i < this.length; i++) {\n        var found = qx.dom.Element.getParentElement(this[i]);\n        if (selector) {\n          found = qx.bom.Selector.matches(selector, [found]);\n        }\n        parents = parents.concat(found);\n      }\n      return qxWeb.$init(parents, qxWeb);\n    },\n\n    /**\n     * Checks if any element of the current collection is child of any element of a given\n     * parent collection.\n     *\n     * @attach{qxWeb}\n     * @param parent {qxWeb | String} Collection or selector of the parent collection to check.\n     * @return {Boolean} Returns true if at least one element of the current collection is child of the parent collection\n     *\n     */\n    isChildOf(parent) {\n      if (this.length == 0) {\n        return false;\n      }\n      var ancestors = null,\n        parentCollection = qxWeb(parent),\n        isChildOf = false;\n      for (var i = 0, l = this.length; i < l && !isChildOf; i++) {\n        ancestors = qxWeb(this[i]).getAncestors();\n        for (var j = 0, len = parentCollection.length; j < len; j++) {\n          if (ancestors.indexOf(parentCollection[j]) != -1) {\n            isChildOf = true;\n            break;\n          }\n        }\n      }\n      return isChildOf;\n    },\n\n    /**\n     * Gets a set of elements containing all ancestors of each element in the\n     * collection.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param filter {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the ancestor elements\n     */\n    getAncestors(filter) {\n      return this.__getAncestors(null, filter);\n    },\n\n    /**\n     * Gets a set of elements containing all ancestors of each element in the\n     * collection, up to (but not including) the element matched by the provided\n     * selector.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector that indicates where to stop including\n     * ancestor elements\n     * @param filter {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the ancestor elements\n     */\n    getAncestorsUntil(selector, filter) {\n      return this.__getAncestors(selector, filter);\n    },\n\n    /**\n     * Gets a set containing the closest matching ancestor for each item in\n     * the collection.\n     * If the item itself matches, it is added to the new set. Otherwise, the\n     * item's parent chain will be traversed until a match is found.\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector expression to match\n     * @return {qxWeb} New collection containing the closest matching ancestors\n     */\n    getClosest(selector) {\n      var closest = [];\n\n      var findClosest = function (current) {\n        var found = qx.bom.Selector.matches(selector, current);\n        if (found.length) {\n          closest.push(found[0]);\n        } else {\n          current = current.getParents(); // One up\n          if (current[0] && current[0].parentNode) {\n            findClosest(current);\n          }\n        }\n      };\n\n      for (var i = 0; i < this.length; i++) {\n        findClosest(qxWeb(this[i]));\n      }\n\n      return qxWeb.$init(closest, qxWeb);\n    },\n\n    /**\n     * Searches the child elements of each item in the collection and returns\n     * a new collection containing the children that match the provided selector\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector expression to match the child elements\n     * against\n     * @return {qxWeb} New collection containing the matching child elements\n     */\n    find(selector) {\n      var found = [];\n      for (var i = 0; i < this.length; i++) {\n        found = found.concat(qx.bom.Selector.query(selector, this[i]));\n      }\n      return qxWeb.$init(found, qxWeb);\n    },\n\n    /**\n     * Gets a new set of elements containing the child nodes of each item in the\n     * current set.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} New collection containing the child nodes\n     */\n    getContents() {\n      var found = [];\n      this._forEachElement(function (item) {\n        found = found.concat(qx.lang.Array.fromCollection(item.childNodes));\n      });\n      return qxWeb.$init(found, qxWeb);\n    },\n\n    /**\n     * Checks if at least one element in the collection passes the provided\n     * filter. This can be either a selector expression or a filter\n     * function\n     *\n     * @attach {qxWeb}\n     * @param selector {String|Function} Selector expression or filter function\n     * @return {Boolean} <code>true</code> if at least one element matches\n     */\n    is(selector) {\n      if (qx.lang.Type.isFunction(selector)) {\n        return this.filter(selector).length > 0;\n      }\n      return !!selector && qx.bom.Selector.matches(selector, this).length > 0;\n    },\n\n    /**\n     * Reduce the set of matched elements to a single element.\n     *\n     * @attach {qxWeb}\n     * @param index {Number} The position of the element in the collection\n     * @return {qxWeb} A new collection containing one element\n     */\n    eq(index) {\n      return this.slice(index, +index + 1);\n    },\n\n    /**\n     * Reduces the collection to the first element.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} A new collection containing one element\n     */\n    getFirst() {\n      return this.slice(0, 1);\n    },\n\n    /**\n     * Reduces the collection to the last element.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} A new collection containing one element\n     */\n    getLast() {\n      return this.slice(this.length - 1);\n    },\n\n    /**\n     * Gets a collection containing only the elements that have descendants\n     * matching the given selector\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector expression\n     * @return {qxWeb} a new collection containing only elements with matching descendants\n     */\n    has(selector) {\n      var found = [];\n      this._forEachElement(function (item, index) {\n        var descendants = qx.bom.Selector.matches(\n          selector,\n          this.eq(index).getContents()\n        );\n\n        if (descendants.length > 0) {\n          found.push(item);\n        }\n      });\n\n      return qxWeb.$init(found, this.constructor);\n    },\n\n    /**\n     * Returns a new collection containing only those nodes that\n     * contain the given element. Also accepts a qxWeb\n     * collection or an Array of elements. In those cases, the first element\n     * in the list is used.\n     *\n     * @attach {qxWeb}\n     * @param element {Element|Window|Element[]|qxWeb} element to check for.\n     * @return {qxWeb} Collection with matching items\n     */\n    contains(element) {\n      // qxWeb does not inherit from Array in IE\n      if (element instanceof Array || element instanceof qxWeb) {\n        element = element[0];\n      }\n\n      if (!element) {\n        return qxWeb();\n      }\n\n      if (qx.dom.Node.isWindow(element)) {\n        element = element.document;\n      }\n\n      return this.filter(function (el) {\n        if (qx.dom.Node.isWindow(el)) {\n          el = el.document;\n        }\n        return qx.dom.Hierarchy.contains(el, element);\n      });\n    },\n\n    /**\n     * Gets a collection containing the next sibling element of each item in\n     * the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing next siblings\n     */\n    getNext(selector) {\n      var found = this.map(\n        qx.dom.Hierarchy.getNextElementSibling,\n        qx.dom.Hierarchy\n      );\n\n      if (selector) {\n        found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);\n      }\n      return found;\n    },\n\n    /**\n     * Gets a collection containing all following sibling elements of each\n     * item in the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing following siblings\n     */\n    getNextAll(selector) {\n      var ret = qx.module.Traversing.__hierarchyHelper(\n        this,\n        \"getNextSiblings\",\n        selector\n      );\n\n      return qxWeb.$init(ret, qxWeb);\n    },\n\n    /**\n     * Gets a collection containing the following sibling elements of each\n     * item in the current set up to but not including any element that matches\n     * the given selector.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing following siblings\n     */\n    getNextUntil(selector) {\n      var found = [];\n      this.forEach(function (item, index) {\n        var nextSiblings = qx.dom.Hierarchy.getNextSiblings(item);\n        for (var i = 0, l = nextSiblings.length; i < l; i++) {\n          if (qx.bom.Selector.matches(selector, [nextSiblings[i]]).length > 0) {\n            break;\n          }\n          found.push(nextSiblings[i]);\n        }\n      });\n\n      return qxWeb.$init(found, qxWeb);\n    },\n\n    /**\n     * Gets a collection containing the previous sibling element of each item in\n     * the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing previous siblings\n     */\n    getPrev(selector) {\n      var found = this.map(\n        qx.dom.Hierarchy.getPreviousElementSibling,\n        qx.dom.Hierarchy\n      );\n\n      if (selector) {\n        found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);\n      }\n      return found;\n    },\n\n    /**\n     * Gets a collection containing all preceding sibling elements of each\n     * item in the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing preceding siblings\n     */\n    getPrevAll(selector) {\n      var ret = qx.module.Traversing.__hierarchyHelper(\n        this,\n        \"getPreviousSiblings\",\n        selector\n      );\n\n      return qxWeb.$init(ret, qxWeb);\n    },\n\n    /**\n     * Gets a collection containing the preceding sibling elements of each\n     * item in the current set up to but not including any element that matches\n     * the given selector.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing preceding siblings\n     */\n    getPrevUntil(selector) {\n      var found = [];\n      this.forEach(function (item, index) {\n        var previousSiblings = qx.dom.Hierarchy.getPreviousSiblings(item);\n        for (var i = 0, l = previousSiblings.length; i < l; i++) {\n          if (\n            qx.bom.Selector.matches(selector, [previousSiblings[i]]).length > 0\n          ) {\n            break;\n          }\n          found.push(previousSiblings[i]);\n        }\n      });\n\n      return qxWeb.$init(found, qxWeb);\n    },\n\n    /**\n     * Gets a collection containing all sibling elements of the items in the\n     * current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing sibling elements\n     */\n    getSiblings(selector) {\n      var ret = qx.module.Traversing.__hierarchyHelper(\n        this,\n        \"getSiblings\",\n        selector\n      );\n\n      return qxWeb.$init(ret, qxWeb);\n    },\n\n    /**\n     * Remove elements from the collection that do not pass the given filter.\n     * This can be either a selector expression or a filter function\n     *\n     * @attach {qxWeb}\n     * @param selector {String|Function} Selector or filter function\n     * @return {qxWeb} Reduced collection\n     */\n    not(selector) {\n      if (qx.lang.Type.isFunction(selector)) {\n        return this.filter(function (item, index, obj) {\n          return !selector(item, index, obj);\n        });\n      }\n\n      var res = qx.bom.Selector.matches(selector, this);\n      return this.filter(function (value) {\n        return res.indexOf(value) === -1;\n      });\n    },\n\n    /**\n     * Gets a new collection containing the offset parent of each item in the\n     * current set.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} New collection containing offset parents\n     */\n    getOffsetParent() {\n      return this.map(qx.bom.element.Location.getOffsetParent);\n    },\n\n    /**\n     * Whether the first element in the collection is inserted into\n     * the document for which it was created.\n     *\n     * @attach {qxWeb}\n     * @return {Boolean} <code>true</code> when the element is inserted\n     *    into the document.\n     */\n    isRendered() {\n      if (!this[0]) {\n        return false;\n      }\n      return qx.dom.Hierarchy.isRendered(this[0]);\n    }\n  },\n\n  defer(statics) {\n    qxWeb.$attachAll(this);\n    // manually attach private method which is ignored by attachAll\n    qxWeb.$attach({\n      __getAncestors: statics.__getAncestors\n    });\n  }\n});\n"
  ],
  "mappings": "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"
}