{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "EQUALITY_ATTRIBUTES",
    "__getAncestors",
    "selector",
    "filter",
    "ancestors",
    "i",
    "length",
    "parent",
    "dom",
    "Element",
    "getParentElement",
    "found",
    "bom",
    "Selector",
    "matches",
    "concat",
    "qxWeb",
    "$init",
    "__getElementFromArgument",
    "arg",
    "isString",
    "__getNodeFromArgument",
    "Array",
    "isNode",
    "__getAttributes",
    "node",
    "attributes",
    "attr",
    "name",
    "value",
    "__hierarchyHelper",
    "collection",
    "method",
    "all",
    "Hierarchy",
    "l",
    "push",
    "apply",
    "ret",
    "lang",
    "unique",
    "isElement",
    "Node",
    "module",
    "Traversing",
    "isNodeName",
    "nodeName",
    "isDocument",
    "isDocumentFragment",
    "getWindow",
    "isTextNode",
    "obj",
    "isText",
    "isWindow",
    "getDocument",
    "getNodeName",
    "getName",
    "getNodeText",
    "getText",
    "isBlockNode",
    "equalNodes",
    "node1",
    "node2",
    "core",
    "Environment",
    "get",
    "isEqualNode",
    "hasAttributes",
    "hasChildNodes",
    "childNodes",
    "domAttributes",
    "domAttrib",
    "node1Attributes",
    "node2Attributes",
    "j",
    "m",
    "child1",
    "child2",
    "members",
    "add",
    "el",
    "getChildren",
    "children",
    "getChildElements",
    "forEach",
    "fn",
    "ctx",
    "call",
    "getParents",
    "parents",
    "isChildOf",
    "parentCollection",
    "getAncestors",
    "len",
    "indexOf",
    "getAncestorsUntil",
    "getClosest",
    "closest",
    "findClosest",
    "current",
    "parentNode",
    "find",
    "query",
    "getContents",
    "_forEachElement",
    "item",
    "fromCollection",
    "is",
    "Type",
    "isFunction",
    "eq",
    "index",
    "slice",
    "getFirst",
    "getLast",
    "has",
    "descendants",
    "constructor",
    "contains",
    "element",
    "document",
    "getNext",
    "map",
    "getNextElementSibling",
    "getNextAll",
    "getNextUntil",
    "nextSiblings",
    "getNextSiblings",
    "getPrev",
    "getPreviousElementSibling",
    "getPrevAll",
    "getPrevUntil",
    "previousSiblings",
    "getPreviousSiblings",
    "getSiblings",
    "not",
    "res",
    "getOffsetParent",
    "Location",
    "isRendered",
    "defer",
    "$attachAll",
    "$attach"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/module/Traversing.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2011-2012 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (wittemann)\n     * Daniel Wagner (danielwagner)\n\n************************************************************************ */\n\n/**\n * DOM traversal module\n *\n * @require(qx.dom.Hierarchy#getSiblings)\n * @require(qx.dom.Hierarchy#getNextSiblings)\n * @require(qx.dom.Hierarchy#getPreviousSiblings)\n * @require(qx.dom.Hierarchy#contains)\n *\n * @group (Core)\n */\nqx.Bootstrap.define(\"qx.module.Traversing\", {\n  statics: {\n    /**\n     * String attributes used to determine if two DOM nodes are equal\n     * as defined in <a href=\"http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode\">\n     * DOM Level 3</a>\n     */\n    EQUALITY_ATTRIBUTES: [\n      \"nodeType\",\n      \"nodeName\",\n      \"localName\",\n      \"namespaceURI\",\n      \"prefix\",\n      \"nodeValue\"\n    ],\n\n    /**\n     * Internal helper for getAncestors and getAncestorsUntil\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector that indicates where to stop including\n     * ancestor elements\n     * @param filter {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the ancestor elements\n     * @internal\n     */\n    __getAncestors(selector, filter) {\n      var ancestors = [];\n      for (var i = 0; i < this.length; i++) {\n        var parent = qx.dom.Element.getParentElement(this[i]);\n        while (parent) {\n          var found = [parent];\n          if (selector && qx.bom.Selector.matches(selector, found).length > 0) {\n            break;\n          }\n          if (filter) {\n            found = qx.bom.Selector.matches(filter, found);\n          }\n          ancestors = ancestors.concat(found);\n          parent = qx.dom.Element.getParentElement(parent);\n        }\n      }\n      return qxWeb.$init(ancestors, qxWeb);\n    },\n\n    /**\n     * Helper which returns the element from the given argument. If it's a collection,\n     * it returns it's first child. If it's a string, it tries to use the string\n     * as selector and returns the first child of the new collection.\n     * @param arg {Node|String|qxWeb} The element.\n     * @return {Node|var} If a node can be extracted, the node element will be return.\n     *   If not, at given argument will be returned.\n     */\n    __getElementFromArgument(arg) {\n      if (arg instanceof qxWeb) {\n        return arg[0];\n      } else if (qx.Bootstrap.isString(arg)) {\n        return qxWeb(arg)[0];\n      }\n      return arg;\n    },\n\n    /**\n     * Helper that attempts to convert the given argument into a DOM node\n     * @param arg {var} object to convert\n     * @return {Node|null} DOM node or null if the conversion failed\n     */\n    __getNodeFromArgument(arg) {\n      if (typeof arg == \"string\") {\n        arg = qxWeb(arg);\n      }\n\n      if (arg instanceof Array || arg instanceof qxWeb) {\n        arg = arg[0];\n      }\n\n      return qxWeb.isNode(arg) ? arg : null;\n    },\n\n    /**\n     * Returns a map containing the given DOM node's attribute names\n     * and values\n     *\n     * @param node {Node} DOM node\n     * @return {Map} Map of attribute names/values\n     */\n    __getAttributes(node) {\n      var attributes = {};\n\n      for (var attr in node.attributes) {\n        if (attr == \"length\") {\n          continue;\n        }\n        var name = node.attributes[attr].name;\n        var value = node.attributes[attr].value;\n        attributes[name] = value;\n      }\n\n      return attributes;\n    },\n\n    /**\n     * Helper function that iterates over a set of items and applies the given\n     * qx.dom.Hierarchy method to each entry, storing the results in a new Array.\n     * Duplicates are removed and the items are filtered if a selector is\n     * provided.\n     *\n     * @attach{qxWeb}\n     * @param collection {Array} Collection to iterate over (any Array-like object)\n     * @param method {String} Name of the qx.dom.Hierarchy method to apply\n     * @param selector {String?} Optional selector that elements to be included\n     * must match\n     * @return {Array} Result array\n     * @internal\n     */\n    __hierarchyHelper(collection, method, selector) {\n      // Iterate ourself, as we want to directly combine the result\n      var all = [];\n      var Hierarchy = qx.dom.Hierarchy;\n      for (var i = 0, l = collection.length; i < l; i++) {\n        all.push.apply(all, Hierarchy[method](collection[i]));\n      }\n\n      // Remove duplicates\n      var ret = qx.lang.Array.unique(all);\n\n      // Post reduce result by selector\n      if (selector) {\n        ret = qx.bom.Selector.matches(selector, ret);\n      }\n\n      return ret;\n    },\n\n    /**\n     * Checks if the given object is a DOM element\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Object|String|qxWeb} Object to check\n     * @return {Boolean} <code>true</code> if the object is a DOM element\n     */\n    isElement(selector) {\n      return qx.dom.Node.isElement(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Checks if the given object is a DOM node\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} Object to check\n     * @return {Boolean} <code>true</code> if the object is a DOM node\n     */\n    isNode(selector) {\n      return qx.dom.Node.isNode(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Whether the node has the given node name\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} the node to check\n     * @param  nodeName {String} the node name to check for\n     * @return {Boolean} <code>true</code> if the node has the given name\n     */\n    isNodeName(selector, nodeName) {\n      return qx.dom.Node.isNodeName(\n        qx.module.Traversing.__getElementFromArgument(selector),\n        nodeName\n      );\n    },\n\n    /**\n     * Checks if the given object is a DOM document object\n     *\n     * @attachStatic{qxWeb}\n     * @param node {Object|qxWeb} Object to check. If the value is a qxWeb\n     * collection, isDocument will check the first item.\n     * @return {Boolean} <code>true</code> if the object is a DOM document\n     */\n    isDocument(node) {\n      if (node instanceof qxWeb) {\n        node = node[0];\n      }\n      return qx.dom.Node.isDocument(node);\n    },\n\n    /**\n     * Checks if the given object is a DOM document fragment object\n     *\n     * @attachStatic{qxWeb}\n     * @param node {Object|qxWeb} Object to check. If the value is a qxWeb\n     * collection, isDocumentFragment will check the first item.\n     * @return {Boolean} <code>true</code> if the object is a DOM document fragment\n     */\n    isDocumentFragment(node) {\n      if (node instanceof qxWeb) {\n        node = node[0];\n      }\n      return qx.dom.Node.isDocumentFragment(node);\n    },\n\n    /**\n     * Returns the DOM2 <code>defaultView</code> (window) for the given node.\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|Document|Window|String|qxWeb} Node to inspect\n     * @return {Window} the <code>defaultView</code> for the given node\n     */\n    getWindow(selector) {\n      return qx.dom.Node.getWindow(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Checks whether the given object is a DOM text node\n     *\n     * @attachStatic{qxWeb}\n     * @param obj {Object} the object to be tested\n     * @return {Boolean} <code>true</code> if the object is a textNode\n     */\n    isTextNode(obj) {\n      return qx.dom.Node.isText(obj);\n    },\n\n    /**\n     * Check whether the given object is a browser window object.\n     *\n     * @attachStatic{qxWeb}\n     * @param obj {Object|qxWeb} the object to be tested. If the value\n     * is a qxWeb collection, isDocument will check the first item.\n     * @return {Boolean} <code>true</code> if the object is a window object\n     */\n    isWindow(obj) {\n      if (obj instanceof qxWeb) {\n        obj = obj[0];\n      }\n      return qx.dom.Node.isWindow(obj);\n    },\n\n    /**\n     * Returns the owner document of the given node\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} Node to get the document for\n     * @return {Document|null} The document of the given DOM node\n     */\n    getDocument(selector) {\n      return qx.dom.Node.getDocument(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Get the DOM node's name as a lowercase string\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} DOM Node\n     * @return {String} node name\n     */\n    getNodeName(selector) {\n      return qx.dom.Node.getName(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Returns the text content of a node where the node type may be one of\n     * NODE_ELEMENT, NODE_ATTRIBUTE, NODE_TEXT, NODE_CDATA\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} the node from where the search should start. If the\n     * node has subnodes the text contents are recursively retrieved and joined\n     * @return {String} the joined text content of the given node or null if not\n     * appropriate.\n     */\n    getNodeText(selector) {\n      return qx.dom.Node.getText(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Checks if the given node is a block node\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} the node to check\n     * @return {Boolean} <code>true</code> if the node is a block node\n     */\n    isBlockNode(selector) {\n      return qx.dom.Node.isBlockNode(\n        qx.module.Traversing.__getElementFromArgument(selector)\n      );\n    },\n\n    /**\n     * Determines if two DOM nodes are equal as defined in the\n     * <a href=\"http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode\">DOM Level 3 isEqualNode spec</a>.\n     * Also works in legacy browsers without native <em>isEqualNode</em> support.\n     *\n     * @attachStatic{qxWeb}\n     * @param node1 {String|Element|Element[]|qxWeb} first object to compare\n     * @param node2 {String|Element|Element[]|qxWeb} second object to compare\n     * @return {Boolean} <code>true</code> if the nodes are equal\n     */\n    equalNodes(node1, node2) {\n      node1 = qx.module.Traversing.__getNodeFromArgument(node1);\n      node2 = qx.module.Traversing.__getNodeFromArgument(node2);\n\n      if (!node1 || !node2) {\n        return false;\n      }\n\n      if (qx.core.Environment.get(\"html.node.isequalnode\")) {\n        return node1.isEqualNode(node2);\n      } else {\n        if (node1 === node2) {\n          return true;\n        }\n\n        // quick attributes length check\n        var hasAttributes = node1.attributes && node2.attributes;\n        if (\n          hasAttributes &&\n          node1.attributes.length !== node2.attributes.length\n        ) {\n          return false;\n        }\n\n        var hasChildNodes = node1.childNodes && node2.childNodes;\n        // quick childNodes length check\n        if (\n          hasChildNodes &&\n          node1.childNodes.length !== node2.childNodes.length\n        ) {\n          return false;\n        }\n\n        // string attribute check\n        var domAttributes = qx.module.Traversing.EQUALITY_ATTRIBUTES;\n        for (var i = 0, l = domAttributes.length; i < l; i++) {\n          var domAttrib = domAttributes[i];\n          if (node1[domAttrib] !== node2[domAttrib]) {\n            return false;\n          }\n        }\n\n        // attribute values\n        if (hasAttributes) {\n          var node1Attributes = qx.module.Traversing.__getAttributes(node1);\n          var node2Attributes = qx.module.Traversing.__getAttributes(node2);\n          for (var attr in node1Attributes) {\n            if (node1Attributes[attr] !== node2Attributes[attr]) {\n              return false;\n            }\n          }\n        }\n\n        // child nodes\n        if (hasChildNodes) {\n          for (var j = 0, m = node1.childNodes.length; j < m; j++) {\n            var child1 = node1.childNodes[j];\n            var child2 = node2.childNodes[j];\n            if (!qx.module.Traversing.equalNodes(child1, child2)) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      }\n    }\n  },\n\n  members: {\n    __getAncestors: null,\n\n    /**\n     * Adds an element to the collection\n     *\n     * @attach {qxWeb}\n     * @param el {Element|qxWeb} DOM element to add to the collection.\n     * If a collection is given, only the first element will be added\n     * @return {qxWeb} The collection for chaining\n     */\n    add(el) {\n      if (el instanceof qxWeb) {\n        el = el[0];\n      }\n      if (\n        qx.module.Traversing.isElement(el) ||\n        qx.module.Traversing.isDocument(el) ||\n        qx.module.Traversing.isWindow(el) ||\n        qx.module.Traversing.isDocumentFragment(el)\n      ) {\n        this.push(el);\n      }\n      return this;\n    },\n\n    /**\n     * Gets a set of elements containing all of the unique immediate children of\n     * each of the matched set of elements.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the child elements\n     */\n    getChildren(selector) {\n      var children = [];\n      for (var i = 0; i < this.length; i++) {\n        var found = qx.dom.Hierarchy.getChildElements(this[i]);\n        if (selector) {\n          found = qx.bom.Selector.matches(selector, found);\n        }\n        children = children.concat(found);\n      }\n      return qxWeb.$init(children, qxWeb);\n    },\n\n    /**\n     * Executes the provided callback function once for each item in the\n     * collection.\n     *\n     * @attach {qxWeb}\n     * @param fn {Function} Callback function which is called with two parameters\n     * <ul>\n     *  <li>current item - DOM node</li>\n     *  <li>current index - Number</li>\n     * </ul>\n     * @param ctx {Object} Context object\n     * @return {qxWeb} The collection for chaining\n     */\n    forEach(fn, ctx) {\n      for (var i = 0; i < this.length; i++) {\n        fn.call(ctx, this[i], i, this);\n      }\n      return this;\n    },\n\n    /**\n     * Gets a set of elements containing the parent of each element in the\n     * collection.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the parent elements\n     */\n    getParents(selector) {\n      var parents = [];\n      for (var i = 0; i < this.length; i++) {\n        var found = qx.dom.Element.getParentElement(this[i]);\n        if (selector) {\n          found = qx.bom.Selector.matches(selector, [found]);\n        }\n        parents = parents.concat(found);\n      }\n      return qxWeb.$init(parents, qxWeb);\n    },\n\n    /**\n     * Checks if any element of the current collection is child of any element of a given\n     * parent collection.\n     *\n     * @attach{qxWeb}\n     * @param parent {qxWeb | String} Collection or selector of the parent collection to check.\n     * @return {Boolean} Returns true if at least one element of the current collection is child of the parent collection\n     *\n     */\n    isChildOf(parent) {\n      if (this.length == 0) {\n        return false;\n      }\n      var ancestors = null,\n        parentCollection = qxWeb(parent),\n        isChildOf = false;\n      for (var i = 0, l = this.length; i < l && !isChildOf; i++) {\n        ancestors = qxWeb(this[i]).getAncestors();\n        for (var j = 0, len = parentCollection.length; j < len; j++) {\n          if (ancestors.indexOf(parentCollection[j]) != -1) {\n            isChildOf = true;\n            break;\n          }\n        }\n      }\n      return isChildOf;\n    },\n\n    /**\n     * Gets a set of elements containing all ancestors of each element in the\n     * collection.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param filter {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the ancestor elements\n     */\n    getAncestors(filter) {\n      return this.__getAncestors(null, filter);\n    },\n\n    /**\n     * Gets a set of elements containing all ancestors of each element in the\n     * collection, up to (but not including) the element matched by the provided\n     * selector.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector that indicates where to stop including\n     * ancestor elements\n     * @param filter {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the ancestor elements\n     */\n    getAncestorsUntil(selector, filter) {\n      return this.__getAncestors(selector, filter);\n    },\n\n    /**\n     * Gets a set containing the closest matching ancestor for each item in\n     * the collection.\n     * If the item itself matches, it is added to the new set. Otherwise, the\n     * item's parent chain will be traversed until a match is found.\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector expression to match\n     * @return {qxWeb} New collection containing the closest matching ancestors\n     */\n    getClosest(selector) {\n      var closest = [];\n\n      var findClosest = function (current) {\n        var found = qx.bom.Selector.matches(selector, current);\n        if (found.length) {\n          closest.push(found[0]);\n        } else {\n          current = current.getParents(); // One up\n          if (current[0] && current[0].parentNode) {\n            findClosest(current);\n          }\n        }\n      };\n\n      for (var i = 0; i < this.length; i++) {\n        findClosest(qxWeb(this[i]));\n      }\n\n      return qxWeb.$init(closest, qxWeb);\n    },\n\n    /**\n     * Searches the child elements of each item in the collection and returns\n     * a new collection containing the children that match the provided selector\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector expression to match the child elements\n     * against\n     * @return {qxWeb} New collection containing the matching child elements\n     */\n    find(selector) {\n      var found = [];\n      for (var i = 0; i < this.length; i++) {\n        found = found.concat(qx.bom.Selector.query(selector, this[i]));\n      }\n      return qxWeb.$init(found, qxWeb);\n    },\n\n    /**\n     * Gets a new set of elements containing the child nodes of each item in the\n     * current set.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} New collection containing the child nodes\n     */\n    getContents() {\n      var found = [];\n      this._forEachElement(function (item) {\n        found = found.concat(qx.lang.Array.fromCollection(item.childNodes));\n      });\n      return qxWeb.$init(found, qxWeb);\n    },\n\n    /**\n     * Checks if at least one element in the collection passes the provided\n     * filter. This can be either a selector expression or a filter\n     * function\n     *\n     * @attach {qxWeb}\n     * @param selector {String|Function} Selector expression or filter function\n     * @return {Boolean} <code>true</code> if at least one element matches\n     */\n    is(selector) {\n      if (qx.lang.Type.isFunction(selector)) {\n        return this.filter(selector).length > 0;\n      }\n      return !!selector && qx.bom.Selector.matches(selector, this).length > 0;\n    },\n\n    /**\n     * Reduce the set of matched elements to a single element.\n     *\n     * @attach {qxWeb}\n     * @param index {Number} The position of the element in the collection\n     * @return {qxWeb} A new collection containing one element\n     */\n    eq(index) {\n      return this.slice(index, +index + 1);\n    },\n\n    /**\n     * Reduces the collection to the first element.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} A new collection containing one element\n     */\n    getFirst() {\n      return this.slice(0, 1);\n    },\n\n    /**\n     * Reduces the collection to the last element.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} A new collection containing one element\n     */\n    getLast() {\n      return this.slice(this.length - 1);\n    },\n\n    /**\n     * Gets a collection containing only the elements that have descendants\n     * matching the given selector\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector expression\n     * @return {qxWeb} a new collection containing only elements with matching descendants\n     */\n    has(selector) {\n      var found = [];\n      this._forEachElement(function (item, index) {\n        var descendants = qx.bom.Selector.matches(\n          selector,\n          this.eq(index).getContents()\n        );\n\n        if (descendants.length > 0) {\n          found.push(item);\n        }\n      });\n\n      return qxWeb.$init(found, this.constructor);\n    },\n\n    /**\n     * Returns a new collection containing only those nodes that\n     * contain the given element. Also accepts a qxWeb\n     * collection or an Array of elements. In those cases, the first element\n     * in the list is used.\n     *\n     * @attach {qxWeb}\n     * @param element {Element|Window|Element[]|qxWeb} element to check for.\n     * @return {qxWeb} Collection with matching items\n     */\n    contains(element) {\n      // qxWeb does not inherit from Array in IE\n      if (element instanceof Array || element instanceof qxWeb) {\n        element = element[0];\n      }\n\n      if (!element) {\n        return qxWeb();\n      }\n\n      if (qx.dom.Node.isWindow(element)) {\n        element = element.document;\n      }\n\n      return this.filter(function (el) {\n        if (qx.dom.Node.isWindow(el)) {\n          el = el.document;\n        }\n        return qx.dom.Hierarchy.contains(el, element);\n      });\n    },\n\n    /**\n     * Gets a collection containing the next sibling element of each item in\n     * the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing next siblings\n     */\n    getNext(selector) {\n      var found = this.map(\n        qx.dom.Hierarchy.getNextElementSibling,\n        qx.dom.Hierarchy\n      );\n\n      if (selector) {\n        found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);\n      }\n      return found;\n    },\n\n    /**\n     * Gets a collection containing all following sibling elements of each\n     * item in the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing following siblings\n     */\n    getNextAll(selector) {\n      var ret = qx.module.Traversing.__hierarchyHelper(\n        this,\n        \"getNextSiblings\",\n        selector\n      );\n\n      return qxWeb.$init(ret, qxWeb);\n    },\n\n    /**\n     * Gets a collection containing the following sibling elements of each\n     * item in the current set up to but not including any element that matches\n     * the given selector.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing following siblings\n     */\n    getNextUntil(selector) {\n      var found = [];\n      this.forEach(function (item, index) {\n        var nextSiblings = qx.dom.Hierarchy.getNextSiblings(item);\n        for (var i = 0, l = nextSiblings.length; i < l; i++) {\n          if (qx.bom.Selector.matches(selector, [nextSiblings[i]]).length > 0) {\n            break;\n          }\n          found.push(nextSiblings[i]);\n        }\n      });\n\n      return qxWeb.$init(found, qxWeb);\n    },\n\n    /**\n     * Gets a collection containing the previous sibling element of each item in\n     * the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing previous siblings\n     */\n    getPrev(selector) {\n      var found = this.map(\n        qx.dom.Hierarchy.getPreviousElementSibling,\n        qx.dom.Hierarchy\n      );\n\n      if (selector) {\n        found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);\n      }\n      return found;\n    },\n\n    /**\n     * Gets a collection containing all preceding sibling elements of each\n     * item in the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing preceding siblings\n     */\n    getPrevAll(selector) {\n      var ret = qx.module.Traversing.__hierarchyHelper(\n        this,\n        \"getPreviousSiblings\",\n        selector\n      );\n\n      return qxWeb.$init(ret, qxWeb);\n    },\n\n    /**\n     * Gets a collection containing the preceding sibling elements of each\n     * item in the current set up to but not including any element that matches\n     * the given selector.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing preceding siblings\n     */\n    getPrevUntil(selector) {\n      var found = [];\n      this.forEach(function (item, index) {\n        var previousSiblings = qx.dom.Hierarchy.getPreviousSiblings(item);\n        for (var i = 0, l = previousSiblings.length; i < l; i++) {\n          if (\n            qx.bom.Selector.matches(selector, [previousSiblings[i]]).length > 0\n          ) {\n            break;\n          }\n          found.push(previousSiblings[i]);\n        }\n      });\n\n      return qxWeb.$init(found, qxWeb);\n    },\n\n    /**\n     * Gets a collection containing all sibling elements of the items in the\n     * current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing sibling elements\n     */\n    getSiblings(selector) {\n      var ret = qx.module.Traversing.__hierarchyHelper(\n        this,\n        \"getSiblings\",\n        selector\n      );\n\n      return qxWeb.$init(ret, qxWeb);\n    },\n\n    /**\n     * Remove elements from the collection that do not pass the given filter.\n     * This can be either a selector expression or a filter function\n     *\n     * @attach {qxWeb}\n     * @param selector {String|Function} Selector or filter function\n     * @return {qxWeb} Reduced collection\n     */\n    not(selector) {\n      if (qx.lang.Type.isFunction(selector)) {\n        return this.filter(function (item, index, obj) {\n          return !selector(item, index, obj);\n        });\n      }\n\n      var res = qx.bom.Selector.matches(selector, this);\n      return this.filter(function (value) {\n        return res.indexOf(value) === -1;\n      });\n    },\n\n    /**\n     * Gets a new collection containing the offset parent of each item in the\n     * current set.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} New collection containing offset parents\n     */\n    getOffsetParent() {\n      return this.map(qx.bom.element.Location.getOffsetParent);\n    },\n\n    /**\n     * Whether the first element in the collection is inserted into\n     * the document for which it was created.\n     *\n     * @attach {qxWeb}\n     * @return {Boolean} <code>true</code> when the element is inserted\n     *    into the document.\n     */\n    isRendered() {\n      if (!this[0]) {\n        return false;\n      }\n      return qx.dom.Hierarchy.isRendered(this[0]);\n    }\n  },\n\n  defer(statics) {\n    qxWeb.$attachAll(this);\n    // manually attach private method which is ignored by attachAll\n    qxWeb.$attach({\n      __getAncestors: statics.__getAncestors\n    });\n  }\n});\n"
  ],
  "mappings": "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"
}