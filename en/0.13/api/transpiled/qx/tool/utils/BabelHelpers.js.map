{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "statics",
    "collapseMemberExpression",
    "node",
    "types",
    "require",
    "done",
    "doCollapse",
    "type",
    "name",
    "argument",
    "result",
    "elements",
    "forEach",
    "element",
    "push",
    "value",
    "isIdentifier",
    "object",
    "str",
    "property",
    "computed",
    "collapseParam",
    "param",
    "idx",
    "tool",
    "utils",
    "BabelHelpers",
    "left",
    "concat",
    "Error",
    "collectJson",
    "isProperties",
    "jsonPath",
    "nextJsonPath",
    "properties",
    "prop",
    "key",
    "elem",
    "Function",
    "operator",
    "tmp",
    "console",
    "warn",
    "loc",
    "start",
    "line",
    "column",
    "getJsDoc",
    "comment",
    "_comment$value",
    "lang",
    "Type",
    "isArray",
    "slice",
    "raw",
    "split",
    "compiler",
    "jsdoc",
    "Parser",
    "parseComment"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/tool/utils/BabelHelpers.js"
  ],
  "sourcesContent": [
    "qx.Class.define(\"qx.tool.utils.BabelHelpers\", {\n  extend: qx.core.Object,\n\n  statics: {\n    /**\n     * Helper method that collapses the MemberExpression into a string\n     * @param node\n     * @returns {string}\n     */\n    collapseMemberExpression(node) {\n      const types = require(\"@babel/types\");\n\n      var done = false;\n      function doCollapse(node) {\n        if (node.type == \"ThisExpression\") {\n          return \"this\";\n        }\n        if (node.type == \"Identifier\") {\n          return node.name;\n        }\n        if (node.type == \"RestElement\") {\n          return \"...\" + doCollapse(node.argument);\n        }\n        if (node.type == \"ArrayExpression\") {\n          var result = [];\n          node.elements.forEach(element => result.push(doCollapse(element)));\n          return result;\n        }\n        if (node.type === \"StringLiteral\") {\n          return node.value;\n        }\n        if (node.type != \"MemberExpression\") {\n          return \"(\" + node.type + \")\";\n        }\n        if (types.isIdentifier(node.object)) {\n          let str = node.object.name;\n          if (node.property.name) {\n            str += \".\" + node.property.name;\n          } else {\n            done = true;\n          }\n          return str;\n        }\n        var str;\n        if (node.object.type == \"ArrayExpression\") {\n          str = \"[]\";\n        } else {\n          str = doCollapse(node.object);\n        }\n        if (done) {\n          return str;\n        }\n        // `computed` is set if the expression is a subscript, eg `abc[def]`\n        if (node.computed) {\n          done = true;\n        } else if (node.property.name) {\n          str += \".\" + node.property.name;\n        } else {\n          done = true;\n        }\n        return str;\n      }\n\n      return doCollapse(node);\n    },\n\n    /**\n     * Helper method that collapses the MemberExpression into a string\n     * @param param\n     * @param {number} idx\n     * @returns {string}\n     */\n    collapseParam(param, idx) {\n      switch (param.type) {\n        case \"Identifier\":\n          return param.name;\n\n        case \"AssignmentPattern\":\n          return qx.tool.utils.BabelHelpers.collapseParam(param.left, idx);\n\n        case \"RestElement\":\n          return (\n            \"...\" +\n            qx.tool.utils.BabelHelpers.collapseParam(param.argument, idx)\n          );\n\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n          return `arg${idx}`;\n      }\n\n      throw new Error(\n        `collapseParam: ${param.type} not useable as a parameter`\n      );\n    },\n\n    /**\n     * Collects JSON data as best as possible - it will not output anything which is not valid JSON, eg it\n     * will not collect function expressions\n     *\n     * @param {*} node\n     * @param {*} isProperties\n     * @param {*} jsonPath\n     * @returns\n     */\n    collectJson(node, isProperties, jsonPath) {\n      var result;\n\n      if (node.type == \"ObjectExpression\") {\n        result = {};\n        let nextJsonPath = jsonPath ? jsonPath + \".\" : \"\";\n        node.properties.forEach(function (prop) {\n          var key = prop.key.name;\n          if (prop.type == \"ObjectMethod\") {\n            result[key] = \"[[ ObjectMethod Function ]]\";\n          } else {\n            var value = qx.tool.utils.BabelHelpers.collectJson(\n              prop.value,\n              isProperties,\n              nextJsonPath + key\n            );\n\n            result[key] = value;\n          }\n        });\n      } else if (\n        node.type == \"Literal\" ||\n        node.type == \"StringLiteral\" ||\n        node.type == \"BooleanLiteral\" ||\n        node.type == \"NumericLiteral\" ||\n        node.type == \"NullLiteral\"\n      ) {\n        if (typeof node.value == \"string\") {\n          let isIdentifier = false;\n          if (\n            isProperties &&\n            (jsonPath === \"apply\" ||\n              jsonPath === \"transform\" ||\n              jsonPath === \"isEqual\")\n          ) {\n            isIdentifier = true;\n          }\n        }\n        result = node.value;\n      } else if (node.type == \"ArrayExpression\") {\n        result = [];\n        node.elements.forEach(function (elem) {\n          result.push(\n            qx.tool.utils.BabelHelpers.collectJson(elem, isProperties)\n          );\n        });\n      } else if (node.type == \"Identifier\") {\n        result = node.name;\n      } else if (\n        node.type == \"CallExpression\" ||\n        node.type == \"FunctionExpression\" ||\n        node.type == \"ArrowFunctionExpression\"\n      ) {\n        result = new Function(\"[[ Function ]]\");\n      } else if (node.type == \"MemberExpression\") {\n        result = qx.tool.utils.BabelHelpers.collapseMemberExpression(node);\n      } else if (node.type == \"UnaryExpression\") {\n        if (node.operator == \"-\") {\n          let tmp = qx.tool.utils.BabelHelpers.collectJson(\n            node.argument,\n            isProperties\n          );\n\n          if (typeof tmp == \"number\") {\n            return tmp * -1;\n          }\n        } else if (node.operator == \"!\") {\n          let tmp = qx.tool.utils.BabelHelpers.collectJson(\n            node.argument,\n            isProperties\n          );\n\n          if (typeof tmp == \"boolean\") {\n            return !tmp;\n          }\n        }\n        result = \"[[ UnaryExpression ]]\";\n      } else if (\n        node.type == \"NewExpression\" ||\n        node.type == \"BinaryExpression\"\n      ) {\n        result = \"[[ \" + node.type + \" ]]\";\n      } else {\n        console.warn(\n          \"Cannot interpret AST \" +\n            node.type +\n            \" at \" +\n            (node.loc\n              ? \" [\" + node.loc.start.line + \",\" + node.loc.start.column + \"]\"\n              : \"\")\n        );\n\n        result = null;\n      }\n      return result;\n    },\n\n    /**\n     * Extracts and parses JSDoc\n     *\n     * @param {*} comment\n     * @returns\n     */\n    getJsDoc(comment) {\n      if (!comment) {\n        return null;\n      }\n      if (qx.lang.Type.isArray(comment)) {\n        comment = comment.slice(-1)[0];\n      }\n      const result = {\n        raw: comment.value?.split(\"\\n\")\n      };\n\n      const tmp = qx.tool.compiler.jsdoc.Parser.parseComment(comment.value);\n      for (const key in tmp) {\n        result[key] = tmp[key];\n      }\n\n      return result;\n    }\n  }\n});\n"
  ],
  "mappings": ";;;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAS,CAACC,oBAAoB,CAACC,aAAa,CAAC;EAAhDH,EAAE,CAACI,KAAK,CAACC,MAAM,CAAC,4BAA4B,EAAE;IAC5CC,MAAM,EAAEN,EAAE,CAACO,IAAI,CAACC,MAAM;IAEtBC,OAAO,EAAE;MACP;AACJ;AACA;AACA;AACA;MACIC,wBAAwB,WAAAA,yBAACC,IAAI,EAAE;QAC7B,IAAMC,KAAK,GAAGC,OAAO,CAAC,cAAc,CAAC;QAErC,IAAIC,IAAI,GAAG,KAAK;QAChB,SAASC,UAAUA,CAACJ,IAAI,EAAE;UACxB,IAAIA,IAAI,CAACK,IAAI,IAAI,gBAAgB,EAAE;YACjC,OAAO,MAAM;UACf;UACA,IAAIL,IAAI,CAACK,IAAI,IAAI,YAAY,EAAE;YAC7B,OAAOL,IAAI,CAACM,IAAI;UAClB;UACA,IAAIN,IAAI,CAACK,IAAI,IAAI,aAAa,EAAE;YAC9B,OAAO,KAAK,GAAGD,UAAU,CAACJ,IAAI,CAACO,QAAQ,CAAC;UAC1C;UACA,IAAIP,IAAI,CAACK,IAAI,IAAI,iBAAiB,EAAE;YAClC,IAAIG,MAAM,GAAG,EAAE;YACfR,IAAI,CAACS,QAAQ,CAACC,OAAO,CAAC,UAAAC,OAAO;cAAA,OAAIH,MAAM,CAACI,IAAI,CAACR,UAAU,CAACO,OAAO,CAAC,CAAC;YAAA,EAAC;YAClE,OAAOH,MAAM;UACf;UACA,IAAIR,IAAI,CAACK,IAAI,KAAK,eAAe,EAAE;YACjC,OAAOL,IAAI,CAACa,KAAK;UACnB;UACA,IAAIb,IAAI,CAACK,IAAI,IAAI,kBAAkB,EAAE;YACnC,OAAO,GAAG,GAAGL,IAAI,CAACK,IAAI,GAAG,GAAG;UAC9B;UACA,IAAIJ,KAAK,CAACa,YAAY,CAACd,IAAI,CAACe,MAAM,CAAC,EAAE;YACnC,IAAIC,IAAG,GAAGhB,IAAI,CAACe,MAAM,CAACT,IAAI;YAC1B,IAAIN,IAAI,CAACiB,QAAQ,CAACX,IAAI,EAAE;cACtBU,IAAG,IAAI,GAAG,GAAGhB,IAAI,CAACiB,QAAQ,CAACX,IAAI;YACjC,CAAC,MAAM;cACLH,IAAI,GAAG,IAAI;YACb;YACA,OAAOa,IAAG;UACZ;UACA,IAAIA,GAAG;UACP,IAAIhB,IAAI,CAACe,MAAM,CAACV,IAAI,IAAI,iBAAiB,EAAE;YACzCW,GAAG,GAAG,IAAI;UACZ,CAAC,MAAM;YACLA,GAAG,GAAGZ,UAAU,CAACJ,IAAI,CAACe,MAAM,CAAC;UAC/B;UACA,IAAIZ,IAAI,EAAE;YACR,OAAOa,GAAG;UACZ;UACA;UACA,IAAIhB,IAAI,CAACkB,QAAQ,EAAE;YACjBf,IAAI,GAAG,IAAI;UACb,CAAC,MAAM,IAAIH,IAAI,CAACiB,QAAQ,CAACX,IAAI,EAAE;YAC7BU,GAAG,IAAI,GAAG,GAAGhB,IAAI,CAACiB,QAAQ,CAACX,IAAI;UACjC,CAAC,MAAM;YACLH,IAAI,GAAG,IAAI;UACb;UACA,OAAOa,GAAG;QACZ;QAEA,OAAOZ,UAAU,CAACJ,IAAI,CAAC;MACzB,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;MACImB,aAAa,WAAAA,cAACC,KAAK,EAAEC,GAAG,EAAE;QACxB,QAAQD,KAAK,CAACf,IAAI;UAChB,KAAK,YAAY;YACf,OAAOe,KAAK,CAACd,IAAI;UAEnB,KAAK,mBAAmB;YACtB,OAAOjB,EAAE,CAACiC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACL,aAAa,CAACC,KAAK,CAACK,IAAI,EAAEJ,GAAG,CAAC;UAElE,KAAK,aAAa;YAChB,OACE,KAAK,GACLhC,EAAE,CAACiC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACL,aAAa,CAACC,KAAK,CAACb,QAAQ,EAAEc,GAAG,CAAC;UAGjE,KAAK,eAAe;UACpB,KAAK,cAAc;YACjB,aAAAK,MAAA,CAAaL,GAAG;QACpB;QAEA,MAAM,IAAIM,KAAK,mBAAAD,MAAA,CACKN,KAAK,CAACf,IAAI,gCAC9B,CAAC;MACH,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIuB,WAAW,WAAAA,YAAC5B,IAAI,EAAE6B,YAAY,EAAEC,QAAQ,EAAE;QACxC,IAAItB,MAAM;QAEV,IAAIR,IAAI,CAACK,IAAI,IAAI,kBAAkB,EAAE;UACnCG,MAAM,GAAG,CAAC,CAAC;UACX,IAAIuB,YAAY,GAAGD,QAAQ,GAAGA,QAAQ,GAAG,GAAG,GAAG,EAAE;UACjD9B,IAAI,CAACgC,UAAU,CAACtB,OAAO,CAAC,UAAUuB,IAAI,EAAE;YACtC,IAAIC,GAAG,GAAGD,IAAI,CAACC,GAAG,CAAC5B,IAAI;YACvB,IAAI2B,IAAI,CAAC5B,IAAI,IAAI,cAAc,EAAE;cAC/BG,MAAM,CAAC0B,GAAG,CAAC,GAAG,6BAA6B;YAC7C,CAAC,MAAM;cACL,IAAIrB,KAAK,GAAGxB,EAAE,CAACiC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACI,WAAW,CAChDK,IAAI,CAACpB,KAAK,EACVgB,YAAY,EACZE,YAAY,GAAGG,GACjB,CAAC;cAED1B,MAAM,CAAC0B,GAAG,CAAC,GAAGrB,KAAK;YACrB;UACF,CAAC,CAAC;QACJ,CAAC,MAAM,IACLb,IAAI,CAACK,IAAI,IAAI,SAAS,IACtBL,IAAI,CAACK,IAAI,IAAI,eAAe,IAC5BL,IAAI,CAACK,IAAI,IAAI,gBAAgB,IAC7BL,IAAI,CAACK,IAAI,IAAI,gBAAgB,IAC7BL,IAAI,CAACK,IAAI,IAAI,aAAa,EAC1B;UACA,IAAI,OAAOL,IAAI,CAACa,KAAK,IAAI,QAAQ,EAAE;YACjC,IAAIC,YAAY,GAAG,KAAK;YACxB,IACEe,YAAY,KACXC,QAAQ,KAAK,OAAO,IACnBA,QAAQ,KAAK,WAAW,IACxBA,QAAQ,KAAK,SAAS,CAAC,EACzB;cACAhB,YAAY,GAAG,IAAI;YACrB;UACF;UACAN,MAAM,GAAGR,IAAI,CAACa,KAAK;QACrB,CAAC,MAAM,IAAIb,IAAI,CAACK,IAAI,IAAI,iBAAiB,EAAE;UACzCG,MAAM,GAAG,EAAE;UACXR,IAAI,CAACS,QAAQ,CAACC,OAAO,CAAC,UAAUyB,IAAI,EAAE;YACpC3B,MAAM,CAACI,IAAI,CACTvB,EAAE,CAACiC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACI,WAAW,CAACO,IAAI,EAAEN,YAAY,CAC3D,CAAC;UACH,CAAC,CAAC;QACJ,CAAC,MAAM,IAAI7B,IAAI,CAACK,IAAI,IAAI,YAAY,EAAE;UACpCG,MAAM,GAAGR,IAAI,CAACM,IAAI;QACpB,CAAC,MAAM,IACLN,IAAI,CAACK,IAAI,IAAI,gBAAgB,IAC7BL,IAAI,CAACK,IAAI,IAAI,oBAAoB,IACjCL,IAAI,CAACK,IAAI,IAAI,yBAAyB,EACtC;UACAG,MAAM,GAAG,IAAI4B,QAAQ,CAAC,gBAAgB,CAAC;QACzC,CAAC,MAAM,IAAIpC,IAAI,CAACK,IAAI,IAAI,kBAAkB,EAAE;UAC1CG,MAAM,GAAGnB,EAAE,CAACiC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACzB,wBAAwB,CAACC,IAAI,CAAC;QACpE,CAAC,MAAM,IAAIA,IAAI,CAACK,IAAI,IAAI,iBAAiB,EAAE;UACzC,IAAIL,IAAI,CAACqC,QAAQ,IAAI,GAAG,EAAE;YACxB,IAAIC,GAAG,GAAGjD,EAAE,CAACiC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACI,WAAW,CAC9C5B,IAAI,CAACO,QAAQ,EACbsB,YACF,CAAC;YAED,IAAI,OAAOS,GAAG,IAAI,QAAQ,EAAE;cAC1B,OAAOA,GAAG,GAAG,CAAC,CAAC;YACjB;UACF,CAAC,MAAM,IAAItC,IAAI,CAACqC,QAAQ,IAAI,GAAG,EAAE;YAC/B,IAAIC,IAAG,GAAGjD,EAAE,CAACiC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACI,WAAW,CAC9C5B,IAAI,CAACO,QAAQ,EACbsB,YACF,CAAC;YAED,IAAI,OAAOS,IAAG,IAAI,SAAS,EAAE;cAC3B,OAAO,CAACA,IAAG;YACb;UACF;UACA9B,MAAM,GAAG,uBAAuB;QAClC,CAAC,MAAM,IACLR,IAAI,CAACK,IAAI,IAAI,eAAe,IAC5BL,IAAI,CAACK,IAAI,IAAI,kBAAkB,EAC/B;UACAG,MAAM,GAAG,KAAK,GAAGR,IAAI,CAACK,IAAI,GAAG,KAAK;QACpC,CAAC,MAAM;UACLkC,OAAO,CAACC,IAAI,CACV,uBAAuB,GACrBxC,IAAI,CAACK,IAAI,GACT,MAAM,IACLL,IAAI,CAACyC,GAAG,GACL,IAAI,GAAGzC,IAAI,CAACyC,GAAG,CAACC,KAAK,CAACC,IAAI,GAAG,GAAG,GAAG3C,IAAI,CAACyC,GAAG,CAACC,KAAK,CAACE,MAAM,GAAG,GAAG,GAC9D,EAAE,CACV,CAAC;UAEDpC,MAAM,GAAG,IAAI;QACf;QACA,OAAOA,MAAM;MACf,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;MACIqC,QAAQ,WAAAA,SAACC,OAAO,EAAE;QAAA,IAAAC,cAAA;QAChB,IAAI,CAACD,OAAO,EAAE;UACZ,OAAO,IAAI;QACb;QACA,IAAIzD,EAAE,CAAC2D,IAAI,CAACC,IAAI,CAACC,OAAO,CAACJ,OAAO,CAAC,EAAE;UACjCA,OAAO,GAAGA,OAAO,CAACK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAChC;QACA,IAAM3C,MAAM,GAAG;UACb4C,GAAG,GAAAL,cAAA,GAAED,OAAO,CAACjC,KAAK,cAAAkC,cAAA,uBAAbA,cAAA,CAAeM,KAAK,CAAC,IAAI;QAChC,CAAC;QAED,IAAMf,GAAG,GAAGjD,EAAE,CAACiC,IAAI,CAACgC,QAAQ,CAACC,KAAK,CAACC,MAAM,CAACC,YAAY,CAACX,OAAO,CAACjC,KAAK,CAAC;QACrE,KAAK,IAAMqB,GAAG,IAAII,GAAG,EAAE;UACrB9B,MAAM,CAAC0B,GAAG,CAAC,GAAGI,GAAG,CAACJ,GAAG,CAAC;QACxB;QAEA,OAAO1B,MAAM;MACf;IACF;EACF,CAAC,CAAC;EAnOFnB,EAAE,CAACiC,IAAI,CAACC,KAAK,CAACC,YAAY,CAAChC,aAAa,GAAGA,aAAa;AAAC",
  "ignoreList": []
}