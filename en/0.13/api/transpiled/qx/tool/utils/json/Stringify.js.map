{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "statics",
    "prettyPrint",
    "ast",
    "writer",
    "tool",
    "utils",
    "json",
    "Writer",
    "writeNode",
    "node",
    "type",
    "comments",
    "leadingComments",
    "write",
    "indent",
    "children",
    "forEach",
    "child",
    "index",
    "key",
    "value",
    "length",
    "trailingComments",
    "rawValue",
    "Error",
    "buffer",
    "reprint",
    "object",
    "prettyPojo",
    "tokenizer",
    "obj",
    "lang",
    "Type",
    "isArray",
    "elem",
    "first",
    "oldIndent",
    "matchIndent",
    "name",
    "resetIndent",
    "prettyPojoProperty",
    "startTokenIndex",
    "writeTokensUntil",
    "token",
    "tokens",
    "pretty",
    "str",
    "Stringify",
    "maxEndToken",
    "endToken",
    "undefined",
    "startToken",
    "isPlainObject",
    "childAstLookup",
    "childPropertyLookup",
    "i",
    "Tokenizer",
    "tokenTypes",
    "COMMA",
    "isLiteral",
    "isSameLiteral",
    "COMMENT",
    "WHITESPACE",
    "astToObject",
    "settings",
    "result",
    "push",
    "_typeof",
    "proto",
    "getPrototypeOf",
    "prototype"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/tool/utils/json/Stringify.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n *\n *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python\n *    toolchain\n *\n *    https://github.com/qooxdoo/qooxdoo\n *\n *    Copyright:\n *      2011-2019 Zenesis Limited, http://www.zenesis.com\n *\n *    License:\n *      MIT: https://opensource.org/licenses/MIT\n *\n *      This software is provided under the same licensing terms as Qooxdoo,\n *      please see the LICENSE file in the Qooxdoo project's top-level directory\n *      for details.\n *\n *    Authors:\n *      * John Spackman (john.spackman@zenesis.com, @johnspackman)\n *\n * *********************************************************************** */\n\n/* eslint-disable no-redeclare */\n\n/**\n * Stringify\n */\nqx.Class.define(\"qx.tool.utils.json.Stringify\", {\n  extend: qx.core.Object,\n\n  statics: {\n    /**\n     * Pretty prints an AST tree\n     */\n    prettyPrint(ast) {\n      var writer = new qx.tool.utils.json.Writer();\n\n      /**\n       * Writes a node, used recursively\n       */\n      function writeNode(node) {\n        switch (node.type) {\n          case \"object\":\n            writer.comments(node.leadingComments);\n            writer.write(\"{\\n\").indent(+1);\n            node.children.forEach(function (child, index) {\n              if (index > 0) {\n                writer.write(\",\\n\");\n              }\n              writer.write('\"' + child.key.value + '\" : ');\n              writeNode(child.value);\n            });\n            if (node.children.length) {\n              writer.write(\"\\n\");\n            }\n            writer.comments(node.trailingComments);\n            writer.indent(-1).write(\"}\");\n            break;\n\n          case \"array\":\n            writer.comments(node.leadingComments);\n            writer.write(\"[\\n\").indent(+1);\n            node.children.forEach(function (child, index) {\n              if (index > 0) {\n                writer.write(\",\\n\");\n              }\n              writeNode(child.value);\n            });\n            if (node.children.length) {\n              writer.write(\"\\n\");\n            }\n            writer.comments(node.trailingComments);\n            writer.indent(-1).write(\"]\\n\");\n            break;\n\n          case \"property\":\n            writeNode(node.key);\n            writer.write(\" : \");\n            writeNode(node.value);\n            break;\n\n          case \"identifier\":\n            writer.write('\"' + node.value + '\"');\n            break;\n\n          case \"literal\":\n            writer.comments(node.leadingComments);\n            writer.write(node.rawValue);\n            writer.comments(node.trailingComments);\n            break;\n\n          default:\n            throw new Error(\"Unexpected node type '\" + node.type + \"'\");\n        }\n      }\n\n      writeNode(ast);\n\n      return writer.buffer;\n    },\n\n    /**\n     * Prints an object out, using the AST to preserve formatting and whitespace\n     * (and include comments) wherever possible.  Any parts of the object which\n     * do not have a corresponding AST tree will be pretty printed\n     *\n     * This is only really suitable for amendments to the object graph because\n     * preserving formatting & comments relies on a 1:1 comparison between the\n     * AST and the object.  This means that if you move a subset of an object to\n     * another part of the object graph, it will be seen as a deletion of one\n     * subset and a brand new subset - you will loose all comments as well as\n     * layout.\n     *\n     * @param object {Object}\n     * @param ast {Tokenizer}\n     * @return {String}\n     */\n    reprint(object, ast) {\n      var writer = new qx.tool.utils.json.Writer();\n\n      if (!ast) {\n        prettyPojo(object);\n        return writer.buffer;\n      }\n      var tokenizer = ast.tokenizer;\n\n      /*\n       * Pretty prints any old POJO or native value\n       */\n      function prettyPojo(obj) {\n        if (typeof obj == \"string\") {\n          writer.write('\"' + obj + '\"');\n        } else if (typeof obj == \"number\") {\n          writer.write(obj);\n        } else if (typeof obj == \"boolean\") {\n          writer.write(obj ? \"true\" : \"false\");\n        } else if (qx.lang.Type.isArray(obj)) {\n          writer.write(\"[ \");\n          obj.forEach(function (elem, index) {\n            if (index != 0) {\n              writer.write(\", \");\n            }\n            prettyPojo(elem);\n          });\n          writer.write(\" ]\");\n        } else {\n          var first = true;\n          var oldIndent = writer.matchIndent();\n          writer.write(\"{\\n\").indent(+1);\n          for (var name in obj) {\n            if (!first) {\n              writer.write(\",\\n\");\n            }\n            writer.write('\"' + name + '\": ');\n            prettyPojo(obj[name]);\n            first = false;\n          }\n          writer.write(\"\\n\").indent(-1).write(\"}\");\n          writer.resetIndent(oldIndent);\n        }\n      }\n\n      /*\n       * Pretty prints a key:value pair\n       */\n      function prettyPojoProperty(key, value) {\n        writer.write('\"' + key + '\": ');\n        prettyPojo(value);\n      }\n\n      /*\n       * Writes tokens which underly the AST, up to a given index\n       */\n      var startTokenIndex = 0;\n      function writeTokensUntil(index) {\n        if (startTokenIndex > -1) {\n          while (startTokenIndex < index) {\n            var token = tokenizer.tokens[startTokenIndex];\n            writer.write(token.rawValue || token.value);\n            startTokenIndex++;\n          }\n        }\n      }\n\n      /*\n       * Writes an object, comparing it with the AST node.  Used recursively\n       */\n      function writeNode(object, node) {\n        /*\n         * Pretty prints a node to the writer\n         */\n        function pretty(node) {\n          var str = qx.tool.utils.json.Stringify.prettyPrint(node);\n          writer.write(str);\n          startTokenIndex = -1;\n        }\n\n        /*\n         * Calculates the largest endToken\n         *\n         * @param endToken {Number} current largest endToken, or -1 for none\n         * @param node {AST Node}\n         */\n        function maxEndToken(endToken, node) {\n          var index;\n          if (node.endToken !== undefined) {\n            index = node.endToken;\n          } else if (node.startToken !== undefined) {\n            index = node.startToken;\n          } else {\n            return endToken;\n          }\n          if (endToken > index) {\n            return endToken;\n          }\n          return index;\n        }\n\n        // No startToken?  Then it was not parsed, pretty print it\n        if (node.startToken === undefined) {\n          pretty(node);\n          return;\n        }\n\n        switch (node.type) {\n          case \"object\":\n            // If it's not the correct type, then pretty print\n            if (!qx.tool.utils.json.Stringify.isPlainObject(object)) {\n              prettyPojo(object);\n              return;\n            }\n\n            // Create lookups\n            var childAstLookup = {};\n            node.children.forEach(function (child, index) {\n              childAstLookup[child.key.value] = child;\n            });\n            var childPropertyLookup = {};\n            for (var name in object) {\n              childPropertyLookup[name] = object[name];\n            }\n\n            // Opening brace\n            writeTokensUntil(node.startToken + 1);\n\n            // Output known children first\n            var endToken = -1;\n            var first = true;\n            for (var i = 0; i < node.children.length; i++) {\n              var child = node.children[i];\n              var key = child.key.value;\n              var value = object[key];\n\n              // Deleted a child?\n              if (value === undefined) {\n                writeTokensUntil(child.key.startToken);\n                startTokenIndex = child.value.endToken + 1;\n                if (first && i < node.children.length - 1) {\n                  while (\n                    tokenizer.tokens[startTokenIndex].type !=\n                    qx.tool.utils.json.Tokenizer.tokenTypes.COMMA\n                  ) {\n                    startTokenIndex++;\n                  }\n                  startTokenIndex++;\n                }\n                continue;\n              }\n\n              first = false;\n              endToken = maxEndToken(endToken, child.value);\n\n              // Write existing property\n              writeTokensUntil(child.value.startToken);\n              writeNode(value, child.value);\n              delete childPropertyLookup[key];\n            }\n\n            // Added properties\n            var first = node.children.length === 0;\n            var oldIndent = writer.matchIndent();\n            for (var name in childPropertyLookup) {\n              if (!first) {\n                writer.write(\",\\n\");\n                first = false;\n              }\n              prettyPojoProperty(name, childPropertyLookup[name]);\n            }\n\n            // Unindent and output the closing brace\n            writer.resetIndent(oldIndent);\n            if (endToken === -1) {\n              startTokenIndex = node.endToken;\n            } else {\n              startTokenIndex = endToken + 1;\n            }\n            writeTokensUntil(node.endToken + 1);\n            break;\n\n          case \"array\":\n            if (!qx.lang.Type.isArray(object)) {\n              prettyPojo(object);\n              return;\n            }\n\n            // Opening brace\n            writeTokensUntil(node.startToken + 1);\n\n            for (var i = 0; i < object.length; i++) {\n              var child =\n                i < node.children.length ? node.children[i] : undefined;\n              if (child !== undefined) {\n                writeTokensUntil(child.startToken);\n                writeNode(object[i], child);\n                startTokenIndex = child.endToken + 1;\n              } else {\n                var oldIndent = writer.matchIndent();\n                if (i != 0) {\n                  writer.write(\",\\n\");\n                }\n                prettyPojo(object[i]);\n                writer.resetIndent(oldIndent);\n                //startTokenIndex = node.endToken;\n              }\n            }\n\n            // Closing brace\n            writeTokensUntil(node.endToken + 1);\n            break;\n\n          case \"property\":\n            break;\n\n          case \"literal\":\n            // Check type\n            if (!qx.tool.utils.json.Stringify.isLiteral(object)) {\n              prettyPojo(object);\n              startTokenIndex = node.endToken + 1;\n              return;\n            }\n\n            // If it has not changed, then use the AST\n            if (qx.tool.utils.json.Stringify.isSameLiteral(node, object)) {\n              writeTokensUntil(node.startToken + 1);\n\n              // New value, but try and preserve prefix comment & whitespace\n            } else {\n              writeTokensUntil(node.startToken);\n              if (typeof object === \"string\") {\n                writer.write('\"' + object + '\"');\n              } else {\n                writer.write(object);\n              }\n              startTokenIndex = node.startToken + 1;\n            }\n            break;\n\n          default:\n            throw new Error(\"Unexpected node type '\" + node.type + \"'\");\n        }\n      }\n\n      // Go\n      writeNode(object, ast);\n\n      // Append any whitespace or comments which trail the JSON\n      if (startTokenIndex > -1) {\n        while (startTokenIndex < tokenizer.tokens.length) {\n          var token = tokenizer.tokens[startTokenIndex++];\n          if (\n            token.type != qx.tool.utils.json.Tokenizer.tokenTypes.COMMENT &&\n            token.type != qx.tool.utils.json.Tokenizer.tokenTypes.WHITESPACE\n          ) {\n            break;\n          }\n          writer.write(token.rawValue || token.value);\n        }\n      }\n\n      return writer.buffer;\n    },\n\n    /**\n     * Converts an AST into an ordinary POJO\n     */\n    astToObject(ast, settings) {\n      function writeNode(node) {\n        var result;\n\n        switch (node.type) {\n          case \"object\":\n            result = {};\n            node.children.forEach(function (child, index) {\n              result[child.key.value] = writeNode(child.value);\n            });\n            break;\n\n          case \"array\":\n            result = [];\n            node.children.forEach(function (child, index) {\n              result.push(writeNode(child));\n            });\n            break;\n\n          case \"literal\":\n            result = node.value;\n            break;\n\n          default:\n            throw new Error(\"Unexpected node type '\" + node.type + \"'\");\n        }\n\n        return result;\n      }\n\n      return writeNode(ast);\n    },\n\n    /**\n     * Detects whether the value is a native object\n     *\n     * @param obj {Object}\n     * @returns boolean\n     */\n    isPlainObject(obj) {\n      if (typeof obj === \"object\" && obj !== null) {\n        var proto = Object.getPrototypeOf(obj);\n        return proto === Object.prototype || proto === null;\n      }\n\n      return false;\n    },\n\n    /**\n     * Detects whether the value is a literal value\n     *\n     * @param obj {Object}\n     * @returns boolean\n     */\n    isLiteral(obj) {\n      if (\n        obj === null ||\n        typeof obj === \"string\" ||\n        typeof obj === \"number\" ||\n        typeof obj === \"boolean\"\n      ) {\n        return true;\n      }\n      return false;\n    },\n\n    /**\n     * Compares a node to see if it is the same as a literal value\n     */\n    isSameLiteral(node, object) {\n      if (node.rawValue === null && object === null) {\n        return true;\n      }\n      if (\n        (node.rawValue !== null && object === null) ||\n        (node.rawValue === null && object !== null)\n      ) {\n        return false;\n      }\n      if (typeof node.value !== typeof object) {\n        return false;\n      }\n      if (typeof node.value === \"string\") {\n        return node.value === object;\n      }\n      return node.rawValue == object;\n    }\n  }\n});\n"
  ],
  "mappings": ";;;;;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAS,CAACC,oBAAoB,CAACC,aAAa,CAAC;EAAhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;;EAEA;AACA;AACA;EACAH,EAAE,CAACI,KAAK,CAACC,MAAM,CAAC,8BAA8B,EAAE;IAC9CC,MAAM,EAAEN,EAAE,CAACO,IAAI,CAACC,MAAM;IAEtBC,OAAO,EAAE;MACP;AACJ;AACA;MACIC,WAAW,WAAAA,YAACC,GAAG,EAAE;QACf,IAAIC,MAAM,GAAG,IAAIZ,EAAE,CAACa,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,MAAM,CAAC,CAAC;;QAE5C;AACN;AACA;QACM,SAASC,SAASA,CAACC,IAAI,EAAE;UACvB,QAAQA,IAAI,CAACC,IAAI;YACf,KAAK,QAAQ;cACXP,MAAM,CAACQ,QAAQ,CAACF,IAAI,CAACG,eAAe,CAAC;cACrCT,MAAM,CAACU,KAAK,CAAC,KAAK,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC;cAC9BL,IAAI,CAACM,QAAQ,CAACC,OAAO,CAAC,UAAUC,KAAK,EAAEC,KAAK,EAAE;gBAC5C,IAAIA,KAAK,GAAG,CAAC,EAAE;kBACbf,MAAM,CAACU,KAAK,CAAC,KAAK,CAAC;gBACrB;gBACAV,MAAM,CAACU,KAAK,CAAC,GAAG,GAAGI,KAAK,CAACE,GAAG,CAACC,KAAK,GAAG,MAAM,CAAC;gBAC5CZ,SAAS,CAACS,KAAK,CAACG,KAAK,CAAC;cACxB,CAAC,CAAC;cACF,IAAIX,IAAI,CAACM,QAAQ,CAACM,MAAM,EAAE;gBACxBlB,MAAM,CAACU,KAAK,CAAC,IAAI,CAAC;cACpB;cACAV,MAAM,CAACQ,QAAQ,CAACF,IAAI,CAACa,gBAAgB,CAAC;cACtCnB,MAAM,CAACW,MAAM,CAAC,CAAC,CAAC,CAAC,CAACD,KAAK,CAAC,GAAG,CAAC;cAC5B;YAEF,KAAK,OAAO;cACVV,MAAM,CAACQ,QAAQ,CAACF,IAAI,CAACG,eAAe,CAAC;cACrCT,MAAM,CAACU,KAAK,CAAC,KAAK,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC;cAC9BL,IAAI,CAACM,QAAQ,CAACC,OAAO,CAAC,UAAUC,KAAK,EAAEC,KAAK,EAAE;gBAC5C,IAAIA,KAAK,GAAG,CAAC,EAAE;kBACbf,MAAM,CAACU,KAAK,CAAC,KAAK,CAAC;gBACrB;gBACAL,SAAS,CAACS,KAAK,CAACG,KAAK,CAAC;cACxB,CAAC,CAAC;cACF,IAAIX,IAAI,CAACM,QAAQ,CAACM,MAAM,EAAE;gBACxBlB,MAAM,CAACU,KAAK,CAAC,IAAI,CAAC;cACpB;cACAV,MAAM,CAACQ,QAAQ,CAACF,IAAI,CAACa,gBAAgB,CAAC;cACtCnB,MAAM,CAACW,MAAM,CAAC,CAAC,CAAC,CAAC,CAACD,KAAK,CAAC,KAAK,CAAC;cAC9B;YAEF,KAAK,UAAU;cACbL,SAAS,CAACC,IAAI,CAACU,GAAG,CAAC;cACnBhB,MAAM,CAACU,KAAK,CAAC,KAAK,CAAC;cACnBL,SAAS,CAACC,IAAI,CAACW,KAAK,CAAC;cACrB;YAEF,KAAK,YAAY;cACfjB,MAAM,CAACU,KAAK,CAAC,GAAG,GAAGJ,IAAI,CAACW,KAAK,GAAG,GAAG,CAAC;cACpC;YAEF,KAAK,SAAS;cACZjB,MAAM,CAACQ,QAAQ,CAACF,IAAI,CAACG,eAAe,CAAC;cACrCT,MAAM,CAACU,KAAK,CAACJ,IAAI,CAACc,QAAQ,CAAC;cAC3BpB,MAAM,CAACQ,QAAQ,CAACF,IAAI,CAACa,gBAAgB,CAAC;cACtC;YAEF;cACE,MAAM,IAAIE,KAAK,CAAC,wBAAwB,GAAGf,IAAI,CAACC,IAAI,GAAG,GAAG,CAAC;UAC/D;QACF;QAEAF,SAAS,CAACN,GAAG,CAAC;QAEd,OAAOC,MAAM,CAACsB,MAAM;MACtB,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,OAAO,WAAAA,QAACC,MAAM,EAAEzB,GAAG,EAAE;QACnB,IAAIC,MAAM,GAAG,IAAIZ,EAAE,CAACa,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,MAAM,CAAC,CAAC;QAE5C,IAAI,CAACL,GAAG,EAAE;UACR0B,UAAU,CAACD,MAAM,CAAC;UAClB,OAAOxB,MAAM,CAACsB,MAAM;QACtB;QACA,IAAII,SAAS,GAAG3B,GAAG,CAAC2B,SAAS;;QAE7B;AACN;AACA;QACM,SAASD,UAAUA,CAACE,GAAG,EAAE;UACvB,IAAI,OAAOA,GAAG,IAAI,QAAQ,EAAE;YAC1B3B,MAAM,CAACU,KAAK,CAAC,GAAG,GAAGiB,GAAG,GAAG,GAAG,CAAC;UAC/B,CAAC,MAAM,IAAI,OAAOA,GAAG,IAAI,QAAQ,EAAE;YACjC3B,MAAM,CAACU,KAAK,CAACiB,GAAG,CAAC;UACnB,CAAC,MAAM,IAAI,OAAOA,GAAG,IAAI,SAAS,EAAE;YAClC3B,MAAM,CAACU,KAAK,CAACiB,GAAG,GAAG,MAAM,GAAG,OAAO,CAAC;UACtC,CAAC,MAAM,IAAIvC,EAAE,CAACwC,IAAI,CAACC,IAAI,CAACC,OAAO,CAACH,GAAG,CAAC,EAAE;YACpC3B,MAAM,CAACU,KAAK,CAAC,IAAI,CAAC;YAClBiB,GAAG,CAACd,OAAO,CAAC,UAAUkB,IAAI,EAAEhB,KAAK,EAAE;cACjC,IAAIA,KAAK,IAAI,CAAC,EAAE;gBACdf,MAAM,CAACU,KAAK,CAAC,IAAI,CAAC;cACpB;cACAe,UAAU,CAACM,IAAI,CAAC;YAClB,CAAC,CAAC;YACF/B,MAAM,CAACU,KAAK,CAAC,IAAI,CAAC;UACpB,CAAC,MAAM;YACL,IAAIsB,KAAK,GAAG,IAAI;YAChB,IAAIC,SAAS,GAAGjC,MAAM,CAACkC,WAAW,CAAC,CAAC;YACpClC,MAAM,CAACU,KAAK,CAAC,KAAK,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC;YAC9B,KAAK,IAAIwB,IAAI,IAAIR,GAAG,EAAE;cACpB,IAAI,CAACK,KAAK,EAAE;gBACVhC,MAAM,CAACU,KAAK,CAAC,KAAK,CAAC;cACrB;cACAV,MAAM,CAACU,KAAK,CAAC,GAAG,GAAGyB,IAAI,GAAG,KAAK,CAAC;cAChCV,UAAU,CAACE,GAAG,CAACQ,IAAI,CAAC,CAAC;cACrBH,KAAK,GAAG,KAAK;YACf;YACAhC,MAAM,CAACU,KAAK,CAAC,IAAI,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC,CAACD,KAAK,CAAC,GAAG,CAAC;YACxCV,MAAM,CAACoC,WAAW,CAACH,SAAS,CAAC;UAC/B;QACF;;QAEA;AACN;AACA;QACM,SAASI,kBAAkBA,CAACrB,GAAG,EAAEC,KAAK,EAAE;UACtCjB,MAAM,CAACU,KAAK,CAAC,GAAG,GAAGM,GAAG,GAAG,KAAK,CAAC;UAC/BS,UAAU,CAACR,KAAK,CAAC;QACnB;;QAEA;AACN;AACA;QACM,IAAIqB,eAAe,GAAG,CAAC;QACvB,SAASC,gBAAgBA,CAACxB,KAAK,EAAE;UAC/B,IAAIuB,eAAe,GAAG,CAAC,CAAC,EAAE;YACxB,OAAOA,eAAe,GAAGvB,KAAK,EAAE;cAC9B,IAAIyB,KAAK,GAAGd,SAAS,CAACe,MAAM,CAACH,eAAe,CAAC;cAC7CtC,MAAM,CAACU,KAAK,CAAC8B,KAAK,CAACpB,QAAQ,IAAIoB,KAAK,CAACvB,KAAK,CAAC;cAC3CqB,eAAe,EAAE;YACnB;UACF;QACF;;QAEA;AACN;AACA;QACM,SAASjC,SAASA,CAACmB,MAAM,EAAElB,IAAI,EAAE;UAC/B;AACR;AACA;UACQ,SAASoC,MAAMA,CAACpC,IAAI,EAAE;YACpB,IAAIqC,GAAG,GAAGvD,EAAE,CAACa,IAAI,CAACC,KAAK,CAACC,IAAI,CAACyC,SAAS,CAAC9C,WAAW,CAACQ,IAAI,CAAC;YACxDN,MAAM,CAACU,KAAK,CAACiC,GAAG,CAAC;YACjBL,eAAe,GAAG,CAAC,CAAC;UACtB;;UAEA;AACR;AACA;AACA;AACA;AACA;UACQ,SAASO,WAAWA,CAACC,QAAQ,EAAExC,IAAI,EAAE;YACnC,IAAIS,KAAK;YACT,IAAIT,IAAI,CAACwC,QAAQ,KAAKC,SAAS,EAAE;cAC/BhC,KAAK,GAAGT,IAAI,CAACwC,QAAQ;YACvB,CAAC,MAAM,IAAIxC,IAAI,CAAC0C,UAAU,KAAKD,SAAS,EAAE;cACxChC,KAAK,GAAGT,IAAI,CAAC0C,UAAU;YACzB,CAAC,MAAM;cACL,OAAOF,QAAQ;YACjB;YACA,IAAIA,QAAQ,GAAG/B,KAAK,EAAE;cACpB,OAAO+B,QAAQ;YACjB;YACA,OAAO/B,KAAK;UACd;;UAEA;UACA,IAAIT,IAAI,CAAC0C,UAAU,KAAKD,SAAS,EAAE;YACjCL,MAAM,CAACpC,IAAI,CAAC;YACZ;UACF;UAEA,QAAQA,IAAI,CAACC,IAAI;YACf,KAAK,QAAQ;cACX;cACA,IAAI,CAACnB,EAAE,CAACa,IAAI,CAACC,KAAK,CAACC,IAAI,CAACyC,SAAS,CAACK,aAAa,CAACzB,MAAM,CAAC,EAAE;gBACvDC,UAAU,CAACD,MAAM,CAAC;gBAClB;cACF;;cAEA;cACA,IAAI0B,cAAc,GAAG,CAAC,CAAC;cACvB5C,IAAI,CAACM,QAAQ,CAACC,OAAO,CAAC,UAAUC,KAAK,EAAEC,KAAK,EAAE;gBAC5CmC,cAAc,CAACpC,KAAK,CAACE,GAAG,CAACC,KAAK,CAAC,GAAGH,KAAK;cACzC,CAAC,CAAC;cACF,IAAIqC,mBAAmB,GAAG,CAAC,CAAC;cAC5B,KAAK,IAAIhB,IAAI,IAAIX,MAAM,EAAE;gBACvB2B,mBAAmB,CAAChB,IAAI,CAAC,GAAGX,MAAM,CAACW,IAAI,CAAC;cAC1C;;cAEA;cACAI,gBAAgB,CAACjC,IAAI,CAAC0C,UAAU,GAAG,CAAC,CAAC;;cAErC;cACA,IAAIF,QAAQ,GAAG,CAAC,CAAC;cACjB,IAAId,KAAK,GAAG,IAAI;cAChB,KAAK,IAAIoB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9C,IAAI,CAACM,QAAQ,CAACM,MAAM,EAAEkC,CAAC,EAAE,EAAE;gBAC7C,IAAItC,KAAK,GAAGR,IAAI,CAACM,QAAQ,CAACwC,CAAC,CAAC;gBAC5B,IAAIpC,GAAG,GAAGF,KAAK,CAACE,GAAG,CAACC,KAAK;gBACzB,IAAIA,KAAK,GAAGO,MAAM,CAACR,GAAG,CAAC;;gBAEvB;gBACA,IAAIC,KAAK,KAAK8B,SAAS,EAAE;kBACvBR,gBAAgB,CAACzB,KAAK,CAACE,GAAG,CAACgC,UAAU,CAAC;kBACtCV,eAAe,GAAGxB,KAAK,CAACG,KAAK,CAAC6B,QAAQ,GAAG,CAAC;kBAC1C,IAAId,KAAK,IAAIoB,CAAC,GAAG9C,IAAI,CAACM,QAAQ,CAACM,MAAM,GAAG,CAAC,EAAE;oBACzC,OACEQ,SAAS,CAACe,MAAM,CAACH,eAAe,CAAC,CAAC/B,IAAI,IACtCnB,EAAE,CAACa,IAAI,CAACC,KAAK,CAACC,IAAI,CAACkD,SAAS,CAACC,UAAU,CAACC,KAAK,EAC7C;sBACAjB,eAAe,EAAE;oBACnB;oBACAA,eAAe,EAAE;kBACnB;kBACA;gBACF;gBAEAN,KAAK,GAAG,KAAK;gBACbc,QAAQ,GAAGD,WAAW,CAACC,QAAQ,EAAEhC,KAAK,CAACG,KAAK,CAAC;;gBAE7C;gBACAsB,gBAAgB,CAACzB,KAAK,CAACG,KAAK,CAAC+B,UAAU,CAAC;gBACxC3C,SAAS,CAACY,KAAK,EAAEH,KAAK,CAACG,KAAK,CAAC;gBAC7B,OAAOkC,mBAAmB,CAACnC,GAAG,CAAC;cACjC;;cAEA;cACA,IAAIgB,KAAK,GAAG1B,IAAI,CAACM,QAAQ,CAACM,MAAM,KAAK,CAAC;cACtC,IAAIe,SAAS,GAAGjC,MAAM,CAACkC,WAAW,CAAC,CAAC;cACpC,KAAK,IAAIC,IAAI,IAAIgB,mBAAmB,EAAE;gBACpC,IAAI,CAACnB,KAAK,EAAE;kBACVhC,MAAM,CAACU,KAAK,CAAC,KAAK,CAAC;kBACnBsB,KAAK,GAAG,KAAK;gBACf;gBACAK,kBAAkB,CAACF,IAAI,EAAEgB,mBAAmB,CAAChB,IAAI,CAAC,CAAC;cACrD;;cAEA;cACAnC,MAAM,CAACoC,WAAW,CAACH,SAAS,CAAC;cAC7B,IAAIa,QAAQ,KAAK,CAAC,CAAC,EAAE;gBACnBR,eAAe,GAAGhC,IAAI,CAACwC,QAAQ;cACjC,CAAC,MAAM;gBACLR,eAAe,GAAGQ,QAAQ,GAAG,CAAC;cAChC;cACAP,gBAAgB,CAACjC,IAAI,CAACwC,QAAQ,GAAG,CAAC,CAAC;cACnC;YAEF,KAAK,OAAO;cACV,IAAI,CAAC1D,EAAE,CAACwC,IAAI,CAACC,IAAI,CAACC,OAAO,CAACN,MAAM,CAAC,EAAE;gBACjCC,UAAU,CAACD,MAAM,CAAC;gBAClB;cACF;;cAEA;cACAe,gBAAgB,CAACjC,IAAI,CAAC0C,UAAU,GAAG,CAAC,CAAC;cAErC,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5B,MAAM,CAACN,MAAM,EAAEkC,CAAC,EAAE,EAAE;gBACtC,IAAItC,KAAK,GACPsC,CAAC,GAAG9C,IAAI,CAACM,QAAQ,CAACM,MAAM,GAAGZ,IAAI,CAACM,QAAQ,CAACwC,CAAC,CAAC,GAAGL,SAAS;gBACzD,IAAIjC,KAAK,KAAKiC,SAAS,EAAE;kBACvBR,gBAAgB,CAACzB,KAAK,CAACkC,UAAU,CAAC;kBAClC3C,SAAS,CAACmB,MAAM,CAAC4B,CAAC,CAAC,EAAEtC,KAAK,CAAC;kBAC3BwB,eAAe,GAAGxB,KAAK,CAACgC,QAAQ,GAAG,CAAC;gBACtC,CAAC,MAAM;kBACL,IAAIb,SAAS,GAAGjC,MAAM,CAACkC,WAAW,CAAC,CAAC;kBACpC,IAAIkB,CAAC,IAAI,CAAC,EAAE;oBACVpD,MAAM,CAACU,KAAK,CAAC,KAAK,CAAC;kBACrB;kBACAe,UAAU,CAACD,MAAM,CAAC4B,CAAC,CAAC,CAAC;kBACrBpD,MAAM,CAACoC,WAAW,CAACH,SAAS,CAAC;kBAC7B;gBACF;cACF;;cAEA;cACAM,gBAAgB,CAACjC,IAAI,CAACwC,QAAQ,GAAG,CAAC,CAAC;cACnC;YAEF,KAAK,UAAU;cACb;YAEF,KAAK,SAAS;cACZ;cACA,IAAI,CAAC1D,EAAE,CAACa,IAAI,CAACC,KAAK,CAACC,IAAI,CAACyC,SAAS,CAACY,SAAS,CAAChC,MAAM,CAAC,EAAE;gBACnDC,UAAU,CAACD,MAAM,CAAC;gBAClBc,eAAe,GAAGhC,IAAI,CAACwC,QAAQ,GAAG,CAAC;gBACnC;cACF;;cAEA;cACA,IAAI1D,EAAE,CAACa,IAAI,CAACC,KAAK,CAACC,IAAI,CAACyC,SAAS,CAACa,aAAa,CAACnD,IAAI,EAAEkB,MAAM,CAAC,EAAE;gBAC5De,gBAAgB,CAACjC,IAAI,CAAC0C,UAAU,GAAG,CAAC,CAAC;;gBAErC;cACF,CAAC,MAAM;gBACLT,gBAAgB,CAACjC,IAAI,CAAC0C,UAAU,CAAC;gBACjC,IAAI,OAAOxB,MAAM,KAAK,QAAQ,EAAE;kBAC9BxB,MAAM,CAACU,KAAK,CAAC,GAAG,GAAGc,MAAM,GAAG,GAAG,CAAC;gBAClC,CAAC,MAAM;kBACLxB,MAAM,CAACU,KAAK,CAACc,MAAM,CAAC;gBACtB;gBACAc,eAAe,GAAGhC,IAAI,CAAC0C,UAAU,GAAG,CAAC;cACvC;cACA;YAEF;cACE,MAAM,IAAI3B,KAAK,CAAC,wBAAwB,GAAGf,IAAI,CAACC,IAAI,GAAG,GAAG,CAAC;UAC/D;QACF;;QAEA;QACAF,SAAS,CAACmB,MAAM,EAAEzB,GAAG,CAAC;;QAEtB;QACA,IAAIuC,eAAe,GAAG,CAAC,CAAC,EAAE;UACxB,OAAOA,eAAe,GAAGZ,SAAS,CAACe,MAAM,CAACvB,MAAM,EAAE;YAChD,IAAIsB,KAAK,GAAGd,SAAS,CAACe,MAAM,CAACH,eAAe,EAAE,CAAC;YAC/C,IACEE,KAAK,CAACjC,IAAI,IAAInB,EAAE,CAACa,IAAI,CAACC,KAAK,CAACC,IAAI,CAACkD,SAAS,CAACC,UAAU,CAACI,OAAO,IAC7DlB,KAAK,CAACjC,IAAI,IAAInB,EAAE,CAACa,IAAI,CAACC,KAAK,CAACC,IAAI,CAACkD,SAAS,CAACC,UAAU,CAACK,UAAU,EAChE;cACA;YACF;YACA3D,MAAM,CAACU,KAAK,CAAC8B,KAAK,CAACpB,QAAQ,IAAIoB,KAAK,CAACvB,KAAK,CAAC;UAC7C;QACF;QAEA,OAAOjB,MAAM,CAACsB,MAAM;MACtB,CAAC;MAED;AACJ;AACA;MACIsC,WAAW,WAAAA,YAAC7D,GAAG,EAAE8D,QAAQ,EAAE;QACzB,SAASxD,SAASA,CAACC,IAAI,EAAE;UACvB,IAAIwD,MAAM;UAEV,QAAQxD,IAAI,CAACC,IAAI;YACf,KAAK,QAAQ;cACXuD,MAAM,GAAG,CAAC,CAAC;cACXxD,IAAI,CAACM,QAAQ,CAACC,OAAO,CAAC,UAAUC,KAAK,EAAEC,KAAK,EAAE;gBAC5C+C,MAAM,CAAChD,KAAK,CAACE,GAAG,CAACC,KAAK,CAAC,GAAGZ,SAAS,CAACS,KAAK,CAACG,KAAK,CAAC;cAClD,CAAC,CAAC;cACF;YAEF,KAAK,OAAO;cACV6C,MAAM,GAAG,EAAE;cACXxD,IAAI,CAACM,QAAQ,CAACC,OAAO,CAAC,UAAUC,KAAK,EAAEC,KAAK,EAAE;gBAC5C+C,MAAM,CAACC,IAAI,CAAC1D,SAAS,CAACS,KAAK,CAAC,CAAC;cAC/B,CAAC,CAAC;cACF;YAEF,KAAK,SAAS;cACZgD,MAAM,GAAGxD,IAAI,CAACW,KAAK;cACnB;YAEF;cACE,MAAM,IAAII,KAAK,CAAC,wBAAwB,GAAGf,IAAI,CAACC,IAAI,GAAG,GAAG,CAAC;UAC/D;UAEA,OAAOuD,MAAM;QACf;QAEA,OAAOzD,SAAS,CAACN,GAAG,CAAC;MACvB,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;MACIkD,aAAa,WAAAA,cAACtB,GAAG,EAAE;QACjB,IAAIqC,OAAA,CAAOrC,GAAG,MAAK,QAAQ,IAAIA,GAAG,KAAK,IAAI,EAAE;UAC3C,IAAIsC,KAAK,GAAGrE,MAAM,CAACsE,cAAc,CAACvC,GAAG,CAAC;UACtC,OAAOsC,KAAK,KAAKrE,MAAM,CAACuE,SAAS,IAAIF,KAAK,KAAK,IAAI;QACrD;QAEA,OAAO,KAAK;MACd,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;MACIT,SAAS,WAAAA,UAAC7B,GAAG,EAAE;QACb,IACEA,GAAG,KAAK,IAAI,IACZ,OAAOA,GAAG,KAAK,QAAQ,IACvB,OAAOA,GAAG,KAAK,QAAQ,IACvB,OAAOA,GAAG,KAAK,SAAS,EACxB;UACA,OAAO,IAAI;QACb;QACA,OAAO,KAAK;MACd,CAAC;MAED;AACJ;AACA;MACI8B,aAAa,WAAAA,cAACnD,IAAI,EAAEkB,MAAM,EAAE;QAC1B,IAAIlB,IAAI,CAACc,QAAQ,KAAK,IAAI,IAAII,MAAM,KAAK,IAAI,EAAE;UAC7C,OAAO,IAAI;QACb;QACA,IACGlB,IAAI,CAACc,QAAQ,KAAK,IAAI,IAAII,MAAM,KAAK,IAAI,IACzClB,IAAI,CAACc,QAAQ,KAAK,IAAI,IAAII,MAAM,KAAK,IAAK,EAC3C;UACA,OAAO,KAAK;QACd;QACA,IAAIwC,OAAA,CAAO1D,IAAI,CAACW,KAAK,MAAA+C,OAAA,CAAYxC,MAAM,GAAE;UACvC,OAAO,KAAK;QACd;QACA,IAAI,OAAOlB,IAAI,CAACW,KAAK,KAAK,QAAQ,EAAE;UAClC,OAAOX,IAAI,CAACW,KAAK,KAAKO,MAAM;QAC9B;QACA,OAAOlB,IAAI,CAACc,QAAQ,IAAII,MAAM;MAChC;IACF;EACF,CAAC,CAAC;EAzdFpC,EAAE,CAACa,IAAI,CAACC,KAAK,CAACC,IAAI,CAACyC,SAAS,CAACrD,aAAa,GAAGA,aAAa;AAAC",
  "ignoreList": []
}