(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.compiler.targets.meta.PackageJavascript": {
        "construct": true
      },
      "qx.lang.Type": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2021 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * ************************************************************************/

  var path = require("upath");
  var fs = require("fs");

  /**
   * A Package is a collection of files and resources, used by either the boot process
   * or by one or more Parts
   */
  qx.Class.define("qx.tool.compiler.targets.meta.Package", {
    extend: qx.core.Object,
    /**
     * Constructor
     */
    construct: function construct(appMeta, packageIndex) {
      qx.core.Object.constructor.call(this);
      this.__P_505_0 = appMeta;
      this.__P_505_1 = packageIndex;
      this.__P_505_2 = [];
      this.__P_505_3 = {};
      this.__P_505_4 = {};
      this.__P_505_5 = [];
      this.__P_505_6 = [];
      this.__P_505_7 = new qx.tool.compiler.targets.meta.PackageJavascript(this.__P_505_0, this);
    },
    properties: {
      /** Whether to embed all the javascript into the one, main package .js file */
      embedAllJavascript: {
        init: false,
        check: "Boolean"
      },
      /** If true, this is generated on the fly and needs to be output */
      needsWriteToDisk: {
        init: true,
        check: "Boolean",
        apply: "_applyNeedsWriteToDisk"
      }
    },
    members: {
      /** @type {AppMeta} the AppMeta instance */
      __P_505_0: null,
      /** @type {Integer} the package index, 0 == boot package */
      __P_505_1: -1,
      /** @type {qx.tool.compiler.resources.Asset[]} assets to be included in this package */
      __P_505_2: null,
      /** @type {Map} locale data, indexed by locale ID */
      __P_505_3: null,
      /** @type {Map} translations, indexed by message ID */
      __P_505_4: null,
      /** @type {String[]} array of class names loaded by this package */
      __P_505_6: null,
      /** @type {AbstractJavascriptMeta[]} array of Javascript sources loaded by this package */
      __P_505_5: null,
      /** @type {AbstractJavascriptMeta} the javascript generated by this package */
      __P_505_7: null,
      /**
       * Detects whether this package is empty; packages can be added for a number
       * of reasons, but sometimes they don't actually end up with anything in them.
       *
       * Note that this is used to suppress the generation of an additional `package-*.js`
       * file in the output, and just means that the content of the file should be embedded
       * (or ignored) instead of written into that package file; however, there can still
       * be script files which need to be loaded by this package (and that is handled by
       * the index.js file)
       *
       * @return {Boolean}
       */
      isEmpty: function isEmpty() {
        if (this.__P_505_2.length > 0) {
          return false;
        }
        for (var localeId in this.__P_505_3) {
          if (this.__P_505_3[localeId]) {
            return false;
          }
        }
        for (var _localeId in this.__P_505_4) {
          if (this.__P_505_4[_localeId]) {
            return false;
          }
        }
        if (this.isEmbedAllJavascript()) {
          if (this.__P_505_5.length > 0) {
            return false;
          }
        }
        return true;
      },
      /**
       * Returns the package index
       *
       * @return {Integer}
       */
      getPackageIndex: function getPackageIndex() {
        return this.__P_505_1;
      },
      /**
       * Adds an asset, expected to be unique
       *
       * @param asset {qx.tool.compiler.resources.Asset}
       */
      addAsset: function addAsset(asset) {
        this.__P_505_2.push(asset);
      },
      /**
       * Returns the array of assets
       *
       * @return {qx.tool.compiler.resources.Asset[]}
       */
      getAssets: function getAssets() {
        return this.__P_505_2;
      },
      /**
       * Adds locale data
       *
       * @param localeId {String}
       * @param localeData {Object}
       */
      addLocale: function addLocale(localeId, localeData) {
        this.__P_505_3[localeId] = localeData;
      },
      /**
       * Returns locale data, as a map where the key is the locale ID
       *
       * @return {Map}
       */
      getLocales: function getLocales() {
        return this.__P_505_3;
      },
      /**
       * Adds a translation
       *
       * @param localeId {String} locale ID
       * @param entry {Object} translation
       */
      addTranslationEntry: function addTranslationEntry(localeId, entry) {
        var translations = this.__P_505_4[localeId];
        if (!translations) {
          this.__P_505_4[localeId] = translations = {};
        }
        var msgstr = entry.msgstr;
        if (!qx.lang.Type.isArray(msgstr)) {
          msgstr = [msgstr];
        }
        if (msgstr[0]) {
          translations[entry.msgid] = msgstr[0];
        }
        if (entry.msgid_plural && msgstr[1]) {
          translations[entry.msgid_plural] = msgstr[1];
        }
      },
      /**
       * Returns a map of all translations, indexed by Locale ID
       *
       * @return {Object}
       */
      getTranslations: function getTranslations() {
        return this.__P_505_4;
      },
      /**
       * Adds a Javascript to be loaded by this package.  You typically need to
       * call `addClassname` also.
       *
       * @param jsMeta {AbstractJavascriptMeta}
       */
      addJavascriptMeta: function addJavascriptMeta(jsMeta) {
        this.__P_505_5.push(jsMeta);
      },
      /**
       * Returns a list of all Javascripts to be loaded by this package
       *
       * @return {AbstractJavascriptMeta[]}
       */
      getJavascriptMetas: function getJavascriptMetas() {
        return this.__P_505_5;
      },
      /**
       * Removes a Javascript
       *
       * @param jsMeta {AbstractJavascriptMeta} the javascript to remove
       */
      removeJavascriptMeta: function removeJavascriptMeta(jsMeta) {
        qx.lang.Array.remove(this.__P_505_5, jsMeta);
      },
      /**
       * Adds a classname to the list which is loaded by this package; this does not
       * cause the code to be loaded, @see {addJavascriptMeta}.
       *
       * @param classname {String}
       */
      addClassname: function addClassname(classname) {
        this.__P_505_6.push(classname);
      },
      /**
       * Returns a list of all classnames
       *
       * @return {String[]}
       */
      getClassnames: function getClassnames() {
        return this.__P_505_6;
      },
      /**
       * Returns the AbstractJavascriptMeta for this Package
       *
       * @return {AbstractJavascriptMeta}
       */
      getJavascript: function getJavascript() {
        return this.__P_505_7;
      },
      /**
       * Writes the data into the configuration which is passed to the loader template
       *
       * @param packages {Object} the `qx.$$packages` object data
       */
      serializeInto: function serializeInto(packages) {
        var _this = this;
        var data = packages[String(this.__P_505_1)] = {
          uris: []
        };
        var appRoot = this.__P_505_0.getApplicationRoot();
        var target = this.__P_505_0.getTarget();
        var privateArtifacts = target.isPrivateArtifacts() && this.__P_505_0.getApplication().getType() == "browser";
        var transpiledDir = path.join(target.getOutputDir(), "transpiled");
        var resourceDir = path.join(target.getOutputDir(), "resource");
        var toUri = function toUri(filename) {
          if (privateArtifacts && (filename.startsWith(transpiledDir) || filename.startsWith(resourceDir))) {
            var _uri = path.relative(target.getOutputDir(), filename);
            return _uri;
          }
          var uri = path.relative(appRoot, filename);
          if (_this.__P_505_0.isAddTimestampsToUrls()) {
            var stat = fs.statSync(filename, {
              throwIfNoEntry: false
            });
            if (stat) {
              uri += "?" + stat.mtimeMs;
            }
            return uri;
          } else {
            return uri;
          }
        };
        if (!this.isEmbedAllJavascript()) {
          data.uris = this.__P_505_5.map(function (js) {
            return toUri(js.getFilename());
          });
        }
        if (this.isNeedsWriteToDisk()) {
          data.uris.unshift(toUri(this.__P_505_7.getFilename()));
        }
      },
      /**
       * Apply for needsWriteToDisk property
       */
      _applyNeedsWriteToDisk: function _applyNeedsWriteToDisk(value) {
        this.__P_505_7.setNeedsWriteToDisk(value);
      }
    }
  });
  qx.tool.compiler.targets.meta.Package.$$dbClassInfo = $$dbClassInfo;
})();

//# sourceMappingURL=Package.js.map?dt=1726089070312