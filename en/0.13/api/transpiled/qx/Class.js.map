{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__Property",
    "core",
    "Property",
    "name",
    "config",
    "__defineImpl",
    "ex",
    "Class",
    "$$brokenClassDefinitions",
    "__P_98_1",
    "include",
    "getClass",
    "implement",
    "implicitType",
    "hasOwnProperty",
    "type",
    "clazz",
    "__createClass",
    "extend",
    "construct",
    "destruct",
    "forEach",
    "id",
    "__attachAnno",
    "properties",
    "__addProperties",
    "members",
    "__addMembers",
    "events",
    "__addEvents",
    "i",
    "l",
    "length",
    "__addMixin",
    "Error",
    "environment",
    "key",
    "Environment",
    "add",
    "__addInterface",
    "defer",
    "self",
    "addPendingDefer",
    "getByName",
    "classname",
    "prototype",
    "undefine",
    "$$registry",
    "ns",
    "split",
    "objects",
    "window",
    "push",
    "last",
    "parent",
    "isFunction",
    "objectGetLength",
    "isDefined",
    "util",
    "OOUtil",
    "classIsDefined",
    "getTotalNumber",
    "mixin",
    "patch",
    "isClass",
    "obj",
    "$$type",
    "constructor",
    "isSubClassOf",
    "superClass",
    "getPropertyDefinition",
    "getProperties",
    "list",
    "$$properties",
    "apply",
    "Object",
    "keys",
    "superclass",
    "getByProperty",
    "hasProperty",
    "getEventType",
    "supportsEvent",
    "hasOwnMixin",
    "$$includes",
    "indexOf",
    "getByMixin",
    "$$flatIncludes",
    "getMixins",
    "hasMixin",
    "hasOwnInterface",
    "iface",
    "$$implements",
    "getByInterface",
    "getInterfaces",
    "$$flatImplements",
    "hasInterface",
    "implementsInterface",
    "Interface",
    "objectImplements",
    "classImplements",
    "getInstance",
    "$$instance",
    "$$allowconstruct",
    "getSubclasses",
    "subclasses",
    "registry",
    "genericToString",
    "__allowedKeys",
    "select",
    "__staticAllowedKeys",
    "__validateConfig",
    "_true",
    "allowed",
    "_typeof",
    "maps",
    "undefined",
    "$$hash",
    "isObject",
    "a",
    "Mixin",
    "checkCompatibility",
    "message",
    "substr",
    "settings",
    "variants",
    "_default",
    "__validateAbstractInterfaces",
    "$$classtype",
    "interfaces",
    "assert",
    "__P_98_3",
    "group",
    "anno",
    "$$annotations",
    "lang",
    "Type",
    "isArray",
    "__P_98_2",
    "mixins",
    "isStrictMode",
    "setDisplayNames",
    "__createDefaultConstructor",
    "__wrapConstructor",
    "setDisplayName",
    "staticValue",
    "charAt",
    "basename",
    "createNamespace",
    "toString",
    "extendClass",
    "$$destructor",
    "__P_98_6",
    "$$events",
    "__P_98_4",
    "proto",
    "refine",
    "init",
    "event",
    "async",
    "inheritable",
    "$$inheritable",
    "$$refreshInheritables",
    "attachRefreshInheritables",
    "attachMethods",
    "__validateProperty",
    "has",
    "existingProperty",
    "warn",
    "$$allowedGroupKeys",
    "$$allowedKeys",
    "transform",
    "check",
    "isString",
    "__P_98_5",
    "base",
    "wrap",
    "member",
    "annoKey",
    "substring",
    "$$install",
    "Function",
    "create",
    "always",
    "__P_98_8",
    "flatten",
    "__P_98_7",
    "entry",
    "$$members",
    "__P_98_13",
    "defaultConstructor",
    "arguments",
    "__P_98_14",
    "wrapper",
    "retval",
    "$$original",
    "$$constructor"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/Class.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Sebastian Werner (wpbasti)\r\n     * Andreas Ecker (ecker)\r\n     * John Spackman (john.spackman@zenesis.com)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * This class is one of the most important parts of qooxdoo's\r\n * object-oriented features.\r\n *\r\n * Its {@link #define} method is used to create qooxdoo classes.\r\n *\r\n * Each instance of a class defined by {@link #define} has\r\n * the following keys attached to the constructor and the prototype:\r\n *\r\n * <table>\r\n * <tr><th><code>classname</code></th><td>The fully-qualified name of the class (e.g. <code>\"qx.ui.core.Widget\"</code>).</td></tr>\r\n * <tr><th><code>basename</code></th><td>The namespace part of the class name (e.g. <code>\"qx.ui.core\"</code>).</td></tr>\r\n * <tr><th><code>constructor</code></th><td>A reference to the constructor of the class.</td></tr>\r\n * <tr><th><code>superclass</code></th><td>A reference to the constructor of the super class.</td></tr>\r\n * </table>\r\n *\r\n * Each method may access static members of the same class by using\r\n * <code>this.self(arguments)</code> ({@link qx.core.Object#self}):\r\n * <pre class='javascript'>\r\n * statics : { FOO : \"bar\" },\r\n * members: {\r\n *   baz: function(x) {\r\n *     this.self(arguments).FOO;\r\n *     ...\r\n *   }\r\n * }\r\n * </pre>\r\n *\r\n * Each overriding method may call the overridden method by using\r\n * <code>this.base(arguments [, ...])</code> ({@link qx.core.Object#base}). This is also true for calling\r\n * the constructor of the superclass.\r\n * <pre class='javascript'>\r\n * members: {\r\n *   foo: function(x) {\r\n *     this.base(arguments, x);\r\n *     ...\r\n *   }\r\n * }\r\n * </pre>\r\n *\r\n * By using <code>qx.Class</code> within an app, the native JS data types are\r\n * conveniently polyfilled according to {@link qx.lang.normalize}.\r\n *\r\n * Annotations can be added to classes, constructors, destructors, and methods, properties, and statics -\r\n * see <code>qx.Annotation</code> for examples and means access annotations at runtime.\r\n *\r\n * @require(qx.Interface)\r\n * @require(qx.Mixin)\r\n * @require(qx.lang.normalize.Array)\r\n * @require(qx.lang.normalize.Date)\r\n * @require(qx.lang.normalize.Error)\r\n * @require(qx.lang.normalize.Function)\r\n * @require(qx.lang.normalize.String)\r\n * @require(qx.lang.normalize.Object)\r\n * @require(qx.lang.normalize.Number)\r\n */\r\nqx.Bootstrap.define(\"qx.Class\", {\r\n  statics: {\r\n    /**\r\n     * A static reference to the property implementation in the case it\r\n     * should be included.\r\n     */\r\n    __Property: qx.core.Environment.get(\"module.property\")\r\n      ? qx.core.Property\r\n      : null,\r\n\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n       PUBLIC METHODS\r\n    ---------------------------------------------------------------------------\r\n    */\r\n\r\n    /**\r\n     * Define a new class using the qooxdoo class system. This sets up the\r\n     * namespace for the class and generates the class from the definition map.\r\n     *\r\n     * Example:\r\n     * <pre class='javascript'>\r\n     * qx.Class.define(\"name\",\r\n     * {\r\n     *   extend : Object, // superclass\r\n     *   implement : [Interfaces],\r\n     *   include : [Mixins],\r\n     *\r\n     *   statics:\r\n     *   {\r\n     *     CONSTANT : 3.141,\r\n     *\r\n     *     publicMethod: function() {},\r\n     *     _protectedMethod: function() {},\r\n     *     __privateMethod: function() {}\r\n     *   },\r\n     *\r\n     *   properties:\r\n     *   {\r\n     *     \"tabIndex\": { check: \"Number\", init : -1 }\r\n     *   },\r\n     *\r\n     *   members:\r\n     *   {\r\n     *     publicField: \"foo\",\r\n     *     publicMethod: function() {},\r\n     *\r\n     *     _protectedField: \"bar\",\r\n     *     _protectedMethod: function() {},\r\n     *\r\n     *     __privateField: \"baz\",\r\n     *     __privateMethod: function() {}\r\n     *   }\r\n     * });\r\n     * </pre>\r\n     *\r\n     * @param name {String?null} Name of the class. If <code>null</code>, the class\r\n     *   will not be added to any namespace which could be handy for testing.\r\n     * @param config {Map ? null} Class definition structure. The configuration map has the following keys:\r\n     *     <table>\r\n     *       <tr><th>Name</th><th>Type</th><th>Description</th></tr>\r\n     *       <tr><th>type</th><td>String</td><td>\r\n     *           Type of the class. Valid types are \"abstract\", \"static\" and \"singleton\".\r\n     *           If unset it defaults to a regular non-static class.\r\n     *       </td></tr>\r\n     *       <tr><th>extend</th><td>Class</td><td>The super class the current class inherits from.</td></tr>\r\n     *       <tr><th>implement</th><td>Interface | Interface[]</td><td>Single interface or array of interfaces the class implements.</td></tr>\r\n     *       <tr><th>include</th><td>Mixin | Mixin[]</td><td>Single mixin or array of mixins, which will be merged into the class.</td></tr>\r\n     *       <tr><th>construct</th><td>Function</td><td>The constructor of the class.</td></tr>\r\n     *       <tr><th>statics</th><td>Map</td><td>Map of static members of the class.</td></tr>\r\n     *       <tr><th>properties</th><td>Map</td><td>Map of property definitions. For a description of the format of a property definition see\r\n     *           {@link qx.core.Property}.</td></tr>\r\n     *       <tr><th>members</th><td>Map</td><td>Map of instance members of the class.</td></tr>\r\n     *       <tr><th>environment</th><td>Map</td><td>Map of environment settings for this class. For a description of the format of a setting see\r\n     *           {@link qx.core.Environment}.</td></tr>\r\n     *       <tr><th>events</th><td>Map</td><td>\r\n     *           Map of events the class fires. The keys are the names of the events and the values are the\r\n     *           corresponding event type class names.\r\n     *       </td></tr>\r\n     *       <tr><th>defer</th><td>Function</td><td>Function that is called at the end of processing the class declaration. It allows access to the declared statics, members and properties.</td></tr>\r\n     *       <tr><th>destruct</th><td>Function</td><td>The destructor of the class.</td></tr>\r\n     *     </table>\r\n     * @return {Class} The defined class\r\n     */\r\n    define(name, config) {\r\n      try {\r\n        return this.__defineImpl(name, config);\r\n      } catch (ex) {\r\n        qx.Class.$$brokenClassDefinitions = true;\r\n        throw ex;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Implementation behind `define` - this exists just for the simplicity of wrapping an exception\r\n     * handler around the code\r\n     *\r\n     * @param {String} name @see `define()`\r\n     * @param {*} config @see `define()`\r\n     * @returns  @see `define()`\r\n     */\r\n    __defineImpl(name, config) {\r\n      if (!config) {\r\n        config = {};\r\n      }\r\n\r\n      // Normalize include to array\r\n      if (\r\n        config.include &&\r\n        !(qx.Bootstrap.getClass(config.include) === \"Array\")\r\n      ) {\r\n        config.include = [config.include];\r\n      }\r\n\r\n      // Normalize implement to array\r\n      if (\r\n        config.implement &&\r\n        !(qx.Bootstrap.getClass(config.implement) === \"Array\")\r\n      ) {\r\n        config.implement = [config.implement];\r\n      }\r\n\r\n      // Normalize type\r\n      var implicitType = false;\r\n      if (!config.hasOwnProperty(\"extend\") && !config.type) {\r\n        config.type = \"static\";\r\n        implicitType = true;\r\n      }\r\n\r\n      // Validate incoming data\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        try {\r\n          this.__validateConfig(name, config);\r\n        } catch (ex) {\r\n          if (implicitType) {\r\n            ex.message =\r\n              'Assumed static class because no \"extend\" key was found. ' +\r\n              ex.message;\r\n          }\r\n          throw ex;\r\n        }\r\n      }\r\n\r\n      // Create the class\r\n      var clazz = this.__createClass(\r\n        name,\r\n        config.type,\r\n        config.extend,\r\n        config.statics,\r\n        config.construct,\r\n        config.destruct,\r\n        config.include\r\n      );\r\n\r\n      // Initialise class and constructor/destructor annotations\r\n      [\"@\", \"@construct\", \"@destruct\"].forEach(function (id) {\r\n        this.__attachAnno(clazz, id, null, config[id]);\r\n      }, this);\r\n\r\n      // Members, properties, events and mixins are only allowed for non-static classes\r\n      if (config.extend) {\r\n        // Attach properties\r\n        if (config.properties) {\r\n          this.__addProperties(clazz, config.properties, true);\r\n        }\r\n\r\n        // Attach members\r\n        if (config.members) {\r\n          this.__addMembers(clazz, config.members, true, true, false);\r\n        }\r\n\r\n        // Process events\r\n        if (config.events) {\r\n          this.__addEvents(clazz, config.events, true);\r\n        }\r\n\r\n        // Include mixins\r\n        // Must be the last here to detect conflicts\r\n        if (config.include) {\r\n          for (var i = 0, l = config.include.length; i < l; i++) {\r\n            this.__addMixin(clazz, config.include[i], false);\r\n          }\r\n        }\r\n      }\r\n      // If config has a 'extend' key but it's null or undefined\r\n      else if (\r\n        config.hasOwnProperty(\"extend\") &&\r\n        qx.core.Environment.get(\"qx.debug\")\r\n      ) {\r\n        throw new Error('\"extend\" parameter is null or undefined');\r\n      }\r\n\r\n      // Process environment\r\n      if (config.environment) {\r\n        for (var key in config.environment) {\r\n          qx.core.Environment.add(key, config.environment[key]);\r\n        }\r\n      }\r\n\r\n      // Interface support for non-static classes\r\n      if (config.implement) {\r\n        for (var i = 0, l = config.implement.length; i < l; i++) {\r\n          this.__addInterface(clazz, config.implement[i]);\r\n        }\r\n      }\r\n\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.__validateAbstractInterfaces(clazz);\r\n      }\r\n\r\n      // Process defer\r\n      if (config.defer) {\r\n        config.defer.self = clazz;\r\n        qx.Bootstrap.addPendingDefer(clazz, function () {\r\n          clazz = qx.Class.getByName(clazz.classname);\r\n          config.defer(clazz, clazz.prototype, {\r\n            add(name, config) {\r\n              // build pseudo properties map\r\n              var properties = {};\r\n              properties[name] = config;\r\n\r\n              // execute generic property handler\r\n              qx.Class.__addProperties(clazz, properties, true);\r\n            }\r\n          });\r\n        });\r\n      }\r\n\r\n      return clazz;\r\n    },\r\n\r\n    /**\r\n     * Removes a class from qooxdoo defined by {@link #define}\r\n     *\r\n     * @param name {String} Name of the class\r\n     */\r\n    undefine(name) {\r\n      // first, delete the class from the registry\r\n      delete this.$$registry[name];\r\n      // delete the class reference from the namespaces and all empty namespaces\r\n      var ns = name.split(\".\");\r\n      // build up an array containing all namespace objects including window\r\n      var objects = [window];\r\n      for (var i = 0; i < ns.length; i++) {\r\n        objects.push(objects[i][ns[i]]);\r\n      }\r\n\r\n      // go through all objects and check for the constructor or empty namespaces\r\n      for (var i = objects.length - 1; i >= 1; i--) {\r\n        var last = objects[i];\r\n        var parent = objects[i - 1];\r\n        if (\r\n          // The class being undefined, but parent classes in case it is a nested class that is being undefined\r\n          (i == objects.length - 1 && qx.Bootstrap.isFunction(last)) ||\r\n          qx.Bootstrap.objectGetLength(last) === 0\r\n        ) {\r\n          delete parent[ns[i - 1]];\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Whether the given class exists\r\n     *\r\n     * @signature function(name)\r\n     * @param name {String} class name to check\r\n     * @return {Boolean} true if class exists\r\n     */\r\n    isDefined: qx.util.OOUtil.classIsDefined,\r\n\r\n    /**\r\n     * Determine the total number of classes\r\n     *\r\n     * @return {Number} the total number of classes\r\n     */\r\n    getTotalNumber() {\r\n      return qx.Bootstrap.objectGetLength(this.$$registry);\r\n    },\r\n\r\n    /**\r\n     * Find a class by its name\r\n     *\r\n     * @signature function(name)\r\n     * @param name {String} class name to resolve\r\n     * @return {Class} the class\r\n     */\r\n    getByName: qx.Bootstrap.getByName,\r\n\r\n    /**\r\n     * Include all features of the given mixin into the class. The mixin must\r\n     * not include any methods or properties that are already available in the\r\n     * class. This would only be possible using the {@link #patch} method.\r\n     *\r\n     * @param clazz {Class} An existing class which should be augmented by including a mixin.\r\n     * @param mixin {Mixin} The mixin to be included.\r\n     */\r\n    include(clazz, mixin) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        if (!mixin) {\r\n          throw new Error(\r\n            \"The mixin to include into class '\" +\r\n              clazz.classname +\r\n              \"' is undefined/null!\"\r\n          );\r\n        }\r\n\r\n        qx.Mixin.isCompatible(mixin, clazz);\r\n      }\r\n\r\n      qx.Class.__addMixin(clazz, mixin, false);\r\n    },\r\n\r\n    /**\r\n     * Include all features of the given mixin into the class. The mixin may\r\n     * include features, which are already defined in the target class. Existing\r\n     * features of equal name will be overwritten.\r\n     * Please keep in mind that this functionality is not intended for regular\r\n     * use, but as a formalized way (and a last resort) in order to patch\r\n     * existing classes.\r\n     *\r\n     * <b>WARNING</b>: You may break working classes and features.\r\n     *\r\n     * @param clazz {Class} An existing class which should be modified by including a mixin.\r\n     * @param mixin {Mixin} The mixin to be included.\r\n     * @return {Class} the new class definition\r\n     */\r\n    patch(clazz, mixin) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        if (!mixin) {\r\n          throw new Error(\r\n            \"The mixin to patch class '\" +\r\n              clazz.classname +\r\n              \"' is undefined/null!\"\r\n          );\r\n        }\r\n\r\n        qx.Mixin.isCompatible(mixin, clazz);\r\n      }\r\n\r\n      qx.Class.__addMixin(clazz, mixin, true);\r\n      return qx.Class.getByName(clazz.classname);\r\n    },\r\n\r\n    /**\r\n     * Detects whether the object is a Class (and not an instance of a class)\r\n     *\r\n     *  @param obj {Object?} the object to inspect\r\n     *  @return {Boolean} true if it is a class, false if it is anything else\r\n     */\r\n    isClass(obj) {\r\n      return obj && obj.$$type === \"Class\" && obj.constructor === obj;\r\n    },\r\n\r\n    /**\r\n     * Whether a class is a direct or indirect sub class of another class,\r\n     * or both classes coincide.\r\n     *\r\n     * @param clazz {Class} the class to check.\r\n     * @param superClass {Class} the potential super class\r\n     * @return {Boolean} whether clazz is a sub class of superClass.\r\n     */\r\n    isSubClassOf(clazz, superClass) {\r\n      if (!clazz) {\r\n        return false;\r\n      }\r\n\r\n      if (clazz == superClass) {\r\n        return true;\r\n      }\r\n\r\n      if (clazz.prototype instanceof superClass) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Returns the definition of the given property. Returns null\r\n     * if the property does not exist.\r\n     *\r\n     * @signature function(clazz, name)\r\n     * @param clazz {Class} class to check\r\n     * @param name {String} name of the class to check for\r\n     * @return {Map|null} whether the object support the given event.\r\n     */\r\n    getPropertyDefinition: qx.util.OOUtil.getPropertyDefinition,\r\n\r\n    /**\r\n     * Returns a list of all properties supported by the given class\r\n     *\r\n     * @param clazz {Class} Class to query\r\n     * @return {String[]} List of all property names\r\n     */\r\n    getProperties(clazz) {\r\n      var list = [];\r\n\r\n      while (clazz) {\r\n        if (clazz.$$properties) {\r\n          list.push.apply(list, Object.keys(clazz.$$properties));\r\n        }\r\n\r\n        clazz = clazz.superclass;\r\n      }\r\n\r\n      return list;\r\n    },\r\n\r\n    /**\r\n     * Returns the class or one of its superclasses which contains the\r\n     * declaration for the given property in its class definition. Returns null\r\n     * if the property is not specified anywhere.\r\n     *\r\n     * @param clazz {Class} class to look for the property\r\n     * @param name {String} name of the property\r\n     * @return {Class|null} The class which includes the property\r\n     */\r\n    getByProperty(clazz, name) {\r\n      while (clazz) {\r\n        if (clazz.$$properties && clazz.$$properties[name]) {\r\n          return clazz;\r\n        }\r\n\r\n        clazz = clazz.superclass;\r\n      }\r\n\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * Whether a class has the given property\r\n     *\r\n     * @signature function(clazz, name)\r\n     * @param clazz {Class} class to check\r\n     * @param name {String} name of the property to check for\r\n     * @return {Boolean} whether the class includes the given property.\r\n     */\r\n    hasProperty: qx.util.OOUtil.hasProperty,\r\n\r\n    /**\r\n     * Returns the event type of the given event. Returns null if\r\n     * the event does not exist.\r\n     *\r\n     * @signature function(clazz, name)\r\n     * @param clazz {Class} class to check\r\n     * @param name {String} name of the event\r\n     * @return {String|null} Event type of the given event.\r\n     */\r\n    getEventType: qx.util.OOUtil.getEventType,\r\n\r\n    /**\r\n     * Whether a class supports the given event type\r\n     *\r\n     * @signature function(clazz, name)\r\n     * @param clazz {Class} class to check\r\n     * @param name {String} name of the event to check for\r\n     * @return {Boolean} whether the class supports the given event.\r\n     */\r\n    supportsEvent: qx.util.OOUtil.supportsEvent,\r\n\r\n    /**\r\n     * Whether a class directly includes a mixin.\r\n     *\r\n     * @param clazz {Class} class to check\r\n     * @param mixin {Mixin} the mixin to check for\r\n     * @return {Boolean} whether the class includes the mixin directly.\r\n     */\r\n    hasOwnMixin(clazz, mixin) {\r\n      return clazz.$$includes && clazz.$$includes.indexOf(mixin) !== -1;\r\n    },\r\n\r\n    /**\r\n     * Returns the class or one of its superclasses which contains the\r\n     * declaration for the given mixin. Returns null if the mixin is not\r\n     * specified anywhere.\r\n     *\r\n     * @param clazz {Class} class to look for the mixin\r\n     * @param mixin {Mixin} mixin to look for\r\n     * @return {Class|null} The class which directly includes the given mixin\r\n     */\r\n    getByMixin(clazz, mixin) {\r\n      var list, i, l;\r\n\r\n      while (clazz) {\r\n        if (clazz.$$includes) {\r\n          list = clazz.$$flatIncludes;\r\n\r\n          for (i = 0, l = list.length; i < l; i++) {\r\n            if (list[i] === mixin) {\r\n              return clazz;\r\n            }\r\n          }\r\n        }\r\n\r\n        clazz = clazz.superclass;\r\n      }\r\n\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * Returns a list of all mixins available in a given class.\r\n     *\r\n     * @signature function(clazz)\r\n     * @param clazz {Class} class which should be inspected\r\n     * @return {Mixin[]} array of mixins this class uses\r\n     */\r\n    getMixins: qx.util.OOUtil.getMixins,\r\n\r\n    /**\r\n     * Whether a given class or any of its superclasses includes a given mixin.\r\n     *\r\n     * @param clazz {Class} class to check\r\n     * @param mixin {Mixin} the mixin to check for\r\n     * @return {Boolean} whether the class includes the mixin.\r\n     */\r\n    hasMixin(clazz, mixin) {\r\n      return !!this.getByMixin(clazz, mixin);\r\n    },\r\n\r\n    /**\r\n     * Whether a given class directly includes an interface.\r\n     *\r\n     * This function will only return \"true\" if the interface was defined\r\n     * in the class declaration ({@link qx.Class#define}) using the \"implement\"\r\n     * key.\r\n     *\r\n     * @param clazz {Class} class or instance to check\r\n     * @param iface {Interface} the interface to check for\r\n     * @return {Boolean} whether the class includes the mixin directly.\r\n     */\r\n    hasOwnInterface(clazz, iface) {\r\n      return clazz.$$implements && clazz.$$implements.indexOf(iface) !== -1;\r\n    },\r\n\r\n    /**\r\n     * Returns the class or one of its super classes which contains the\r\n     * declaration of the given interface. Returns null if the interface is not\r\n     * specified anywhere.\r\n     *\r\n     * @signature function(clazz, iface)\r\n     * @param clazz {Class} class to look for the interface\r\n     * @param iface {Interface} interface to look for\r\n     * @return {Class|null} the class which directly implements the given interface\r\n     */\r\n    getByInterface: qx.util.OOUtil.getByInterface,\r\n\r\n    /**\r\n     * Returns a list of all interfaces a given class has to implement.\r\n     *\r\n     * @param clazz {Class} class which should be inspected\r\n     * @return {Interface[]} array of interfaces this class implements\r\n     */\r\n    getInterfaces(clazz) {\r\n      var list = [];\r\n\r\n      while (clazz) {\r\n        if (clazz.$$implements) {\r\n          list.push.apply(list, clazz.$$flatImplements);\r\n        }\r\n\r\n        clazz = clazz.superclass;\r\n      }\r\n\r\n      return list;\r\n    },\r\n\r\n    /**\r\n     * Whether a given class or any of its super classes includes a given interface.\r\n     *\r\n     * This function will return \"true\" if the interface was defined\r\n     * in the class declaration ({@link qx.Class#define}) of the class\r\n     * or any of its super classes using the \"implement\"\r\n     * key.\r\n     *\r\n     * @signature function(clazz, iface)\r\n     * @param clazz {Class} class to check\r\n     * @param iface {Interface} the interface to check for\r\n     * @return {Boolean} whether the class includes the interface.\r\n     */\r\n    hasInterface: qx.util.OOUtil.hasInterface,\r\n\r\n    /**\r\n     * Whether a given class complies to an interface.\r\n     *\r\n     * Checks whether all methods defined in the interface are\r\n     * implemented. The class does not need to implement\r\n     * the interface explicitly in the <code>extend</code> key.\r\n     *\r\n     * @param obj {Object} class to check\r\n     * @param iface {Interface} the interface to check for\r\n     * @return {Boolean} whether the class conforms to the interface.\r\n     */\r\n    implementsInterface(obj, iface) {\r\n      var clazz = obj.constructor;\r\n\r\n      if (this.hasInterface(clazz, iface)) {\r\n        return true;\r\n      }\r\n\r\n      if (qx.Interface.objectImplements(obj, iface)) {\r\n        return true;\r\n      }\r\n\r\n      if (qx.Interface.classImplements(clazz, iface)) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Helper method to handle singletons\r\n     *\r\n     * @internal\r\n     * @return {Object} The singleton instance\r\n     */\r\n    getInstance() {\r\n      if (this.$$instance === null) {\r\n        throw new Error(\r\n          \"Singleton instance of \" +\r\n            this +\r\n            \" is requested, but not ready yet. This is most likely due to a recursive call in the constructor path.\"\r\n        );\r\n      }\r\n\r\n      if (!this.$$instance) {\r\n        this.$$allowconstruct = true;\r\n        this.$$instance = null; // null means \"object is being created\"; needed for another call of getInstance() during instantiation\r\n        this.$$instance = new this();\r\n        delete this.$$allowconstruct;\r\n      }\r\n\r\n      return this.$$instance;\r\n    },\r\n\r\n    /**\r\n     * Retreive all subclasses of a given class\r\n     *\r\n     * @param clazz {Class} the class which should be inspected\r\n     *\r\n     * @return {Object} class name hash holding the references to the subclasses or null if the class does not exist.\r\n     */\r\n    getSubclasses(clazz) {\r\n      if (!clazz) {\r\n        return null;\r\n      }\r\n\r\n      var subclasses = {};\r\n      var registry = qx.Class.$$registry;\r\n\r\n      for (var name in registry) {\r\n        if (registry[name].superclass && registry[name].superclass == clazz) {\r\n          subclasses[name] = registry[name];\r\n        }\r\n      }\r\n\r\n      return subclasses;\r\n    },\r\n\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n       PRIVATE/INTERNAL BASICS\r\n    ---------------------------------------------------------------------------\r\n    */\r\n\r\n    /**\r\n     * This method will be attached to all classes to return\r\n     * a nice identifier for them.\r\n     *\r\n     * @internal\r\n     * @return {String} The class identifier\r\n     */\r\n    genericToString() {\r\n      return \"[Class \" + this.classname + \"]\";\r\n    },\r\n\r\n    /** Stores all defined classes */\r\n    $$registry: qx.Bootstrap.$$registry,\r\n\r\n    /** @type {Map} allowed keys in non-static class definition */\r\n    __allowedKeys: qx.core.Environment.select(\"qx.debug\", {\r\n      true: {\r\n        \"@\": \"object\",\r\n        \"@construct\": \"object\",\r\n        \"@destruct\": \"object\",\r\n        type: \"string\", // String\r\n        extend: \"function\", // Function\r\n        implement: \"object\", // Interface[]\r\n        include: \"object\", // Mixin[]\r\n        construct: \"function\", // Function\r\n        statics: \"object\", // Map\r\n        properties: \"object\", // Map\r\n        members: \"object\", // Map\r\n        environment: \"object\", // Map\r\n        events: \"object\", // Map\r\n        defer: \"function\", // Function\r\n        destruct: \"function\" // Function\r\n      },\r\n\r\n      default: null\r\n    }),\r\n\r\n    /** @type {Map} allowed keys in static class definition */\r\n    __staticAllowedKeys: qx.core.Environment.select(\"qx.debug\", {\r\n      true: {\r\n        \"@\": \"object\",\r\n        type: \"string\", // String\r\n        statics: \"object\", // Map\r\n        environment: \"object\", // Map\r\n        defer: \"function\" // Function\r\n      },\r\n\r\n      default: null\r\n    }),\r\n\r\n    /**\r\n     * Validates an incoming configuration and checks for proper keys and values\r\n     *\r\n     * @signature function(name, config)\r\n     * @param name {String} The name of the class\r\n     * @param config {Map} Configuration map\r\n     */\r\n    __validateConfig: qx.core.Environment.select(\"qx.debug\", {\r\n      true(name, config) {\r\n        // Validate type\r\n        if (\r\n          config.type &&\r\n          !(\r\n            config.type === \"static\" ||\r\n            config.type === \"abstract\" ||\r\n            config.type === \"singleton\"\r\n          )\r\n        ) {\r\n          throw new Error(\r\n            'Invalid type \"' +\r\n              config.type +\r\n              '\" definition for class \"' +\r\n              name +\r\n              '\"!'\r\n          );\r\n        }\r\n\r\n        // Validate non-static class on the \"extend\" key\r\n        if (config.type && config.type !== \"static\" && !config.extend) {\r\n          throw new Error(\r\n            'Invalid config in class \"' +\r\n              name +\r\n              '\"! Every non-static class has to extend at least the \"qx.core.Object\" class.'\r\n          );\r\n        }\r\n\r\n        // Validate keys\r\n        var allowed =\r\n          config.type === \"static\"\r\n            ? this.__staticAllowedKeys\r\n            : this.__allowedKeys;\r\n        for (var key in config) {\r\n          if (!allowed[key]) {\r\n            throw new Error(\r\n              'The configuration key \"' +\r\n                key +\r\n                '\" in class \"' +\r\n                name +\r\n                '\" is not allowed!'\r\n            );\r\n          }\r\n\r\n          if (config[key] == null) {\r\n            throw new Error(\r\n              'Invalid key \"' +\r\n                key +\r\n                '\" in class \"' +\r\n                name +\r\n                '\"! The value is undefined/null!'\r\n            );\r\n          }\r\n\r\n          if (typeof config[key] !== allowed[key]) {\r\n            throw new Error(\r\n              'Invalid type of key \"' +\r\n                key +\r\n                '\" in class \"' +\r\n                name +\r\n                '\"! The type of the key must be \"' +\r\n                allowed[key] +\r\n                '\"!'\r\n            );\r\n          }\r\n        }\r\n\r\n        // Validate maps\r\n        var maps = [\r\n          \"statics\",\r\n          \"properties\",\r\n          \"members\",\r\n          \"environment\",\r\n          \"settings\",\r\n          \"variants\",\r\n          \"events\"\r\n        ];\r\n\r\n        for (var i = 0, l = maps.length; i < l; i++) {\r\n          var key = maps[i];\r\n\r\n          if (\r\n            config[key] !== undefined &&\r\n            (config[key].$$hash !== undefined ||\r\n              !qx.Bootstrap.isObject(config[key]))\r\n          ) {\r\n            throw new Error(\r\n              'Invalid key \"' +\r\n                key +\r\n                '\" in class \"' +\r\n                name +\r\n                '\"! The value needs to be a map!'\r\n            );\r\n          }\r\n        }\r\n\r\n        // Validate include definition\r\n        if (config.include) {\r\n          if (qx.Bootstrap.getClass(config.include) === \"Array\") {\r\n            for (var i = 0, a = config.include, l = a.length; i < l; i++) {\r\n              if (a[i] == null || a[i].$$type !== \"Mixin\") {\r\n                throw new Error(\r\n                  'The include definition in class \"' +\r\n                    name +\r\n                    '\" contains an invalid mixin at position ' +\r\n                    i +\r\n                    \": \" +\r\n                    a[i]\r\n                );\r\n              }\r\n            }\r\n          } else {\r\n            throw new Error(\r\n              'Invalid include definition in class \"' +\r\n                name +\r\n                '\"! Only mixins and arrays of mixins are allowed!'\r\n            );\r\n          }\r\n        }\r\n\r\n        // Validate implement definition\r\n        if (config.implement) {\r\n          if (qx.Bootstrap.getClass(config.implement) === \"Array\") {\r\n            for (var i = 0, a = config.implement, l = a.length; i < l; i++) {\r\n              if (a[i] == null || a[i].$$type !== \"Interface\") {\r\n                throw new Error(\r\n                  'The implement definition in class \"' +\r\n                    name +\r\n                    '\" contains an invalid interface at position ' +\r\n                    i +\r\n                    \": \" +\r\n                    a[i]\r\n                );\r\n              }\r\n            }\r\n          } else {\r\n            throw new Error(\r\n              'Invalid implement definition in class \"' +\r\n                name +\r\n                '\"! Only interfaces and arrays of interfaces are allowed!'\r\n            );\r\n          }\r\n        }\r\n\r\n        // Check mixin compatibility\r\n        if (config.include) {\r\n          try {\r\n            qx.Mixin.checkCompatibility(config.include);\r\n          } catch (ex) {\r\n            throw new Error(\r\n              'Error in include definition of class \"' +\r\n                name +\r\n                '\"! ' +\r\n                ex.message\r\n            );\r\n          }\r\n        }\r\n\r\n        // Validate environment\r\n        if (config.environment) {\r\n          for (var key in config.environment) {\r\n            if (\r\n              key.substr(0, key.indexOf(\".\")) !=\r\n              name.substr(0, name.indexOf(\".\"))\r\n            ) {\r\n              throw new Error(\r\n                'Forbidden environment setting \"' +\r\n                  key +\r\n                  '\" found in \"' +\r\n                  name +\r\n                  '\". It is forbidden to define a ' +\r\n                  \"environment setting for an external namespace!\"\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        // Validate settings\r\n        if (config.settings) {\r\n          for (var key in config.settings) {\r\n            if (\r\n              key.substr(0, key.indexOf(\".\")) !=\r\n              name.substr(0, name.indexOf(\".\"))\r\n            ) {\r\n              throw new Error(\r\n                'Forbidden setting \"' +\r\n                  key +\r\n                  '\" found in \"' +\r\n                  name +\r\n                  '\". It is forbidden to define a default setting for an external namespace!'\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        // Validate variants\r\n        if (config.variants) {\r\n          for (var key in config.variants) {\r\n            if (\r\n              key.substr(0, key.indexOf(\".\")) !=\r\n              name.substr(0, name.indexOf(\".\"))\r\n            ) {\r\n              throw new Error(\r\n                'Forbidden variant \"' +\r\n                  key +\r\n                  '\" found in \"' +\r\n                  name +\r\n                  '\". It is forbidden to define a variant for an external namespace!'\r\n              );\r\n            }\r\n          }\r\n        }\r\n      },\r\n\r\n      default(name, config) {}\r\n    }),\r\n\r\n    /**\r\n     * Validates the interfaces required by abstract base classes\r\n     *\r\n     * @signature function(clazz)\r\n     * @param clazz {Class} The configured class.\r\n     */\r\n    __validateAbstractInterfaces: qx.core.Environment.select(\"qx.debug\", {\r\n      true(clazz) {\r\n        var superclass = clazz.superclass;\r\n        while (superclass) {\r\n          if (superclass.$$classtype !== \"abstract\") {\r\n            break;\r\n          }\r\n\r\n          var interfaces = superclass.$$implements;\r\n          if (interfaces) {\r\n            for (var i = 0; i < interfaces.length; i++) {\r\n              qx.Interface.assert(clazz, interfaces[i], true);\r\n            }\r\n          }\r\n          superclass = superclass.superclass;\r\n        }\r\n      },\r\n\r\n      default(clazz) {}\r\n    }),\r\n\r\n    /**\r\n     * Attaches an annotation to a class\r\n     *\r\n     * @param clazz {Map} Static methods or fields\r\n     * @param group {String} Group name\r\n     * @param key {String} Name of the annotated item\r\n     * @param anno {Object} Annotation object\r\n     */\r\n    __attachAnno(clazz, group, key, anno) {\r\n      if (anno !== undefined) {\r\n        if (clazz.$$annotations === undefined) {\r\n          clazz.$$annotations = {};\r\n          clazz.$$annotations[group] = {};\r\n        } else if (clazz.$$annotations[group] === undefined) {\r\n          clazz.$$annotations[group] = {};\r\n        }\r\n\r\n        if (!qx.lang.Type.isArray(anno)) {\r\n          anno = [anno];\r\n        }\r\n\r\n        if (key) {\r\n          clazz.$$annotations[group][key] = anno;\r\n        } else {\r\n          clazz.$$annotations[group] = anno;\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Creates a class by type. Supports modern inheritance etc.\r\n     *\r\n     * @param name {String} Full name of the class\r\n     * @param type {String} type of the class, i.e. \"static\", \"abstract\" or \"singleton\"\r\n     * @param extend {Class} Superclass to inherit from\r\n     * @param statics {Map} Static methods or fields\r\n     * @param construct {Function} Constructor of the class\r\n     * @param destruct {Function} Destructor of the class\r\n     * @param mixins {Mixin[]} array of mixins of the class\r\n     * @return {Class} The generated class\r\n     */\r\n    __createClass(name, type, extend, statics, construct, destruct, mixins) {\r\n      var isStrictMode = function () {\r\n        return typeof this == \"undefined\";\r\n      };\r\n\r\n      var clazz;\r\n\r\n      if (!extend && qx.core.Environment.get(\"qx.aspects\") == false) {\r\n        // Create empty/non-empty class\r\n        clazz = statics || {};\r\n        qx.Bootstrap.setDisplayNames(clazz, name);\r\n      } else {\r\n        clazz = {};\r\n\r\n        if (extend) {\r\n          // Create default constructor\r\n          if (!construct) {\r\n            construct = this.__createDefaultConstructor();\r\n          }\r\n\r\n          clazz = this.__wrapConstructor(construct, name, type);\r\n\r\n          // Add singleton getInstance()\r\n          if (type === \"singleton\") {\r\n            clazz.getInstance = this.getInstance;\r\n          }\r\n\r\n          qx.Bootstrap.setDisplayName(construct, name, \"constructor\");\r\n        }\r\n\r\n        // Copy statics\r\n        if (statics) {\r\n          qx.Bootstrap.setDisplayNames(statics, name);\r\n\r\n          var key;\r\n\r\n          for (var i = 0, a = Object.keys(statics), l = a.length; i < l; i++) {\r\n            key = a[i];\r\n            var staticValue = statics[key];\r\n\r\n            if (qx.core.Environment.get(\"qx.debug\")) {\r\n              if (key.charAt(0) === \"@\") {\r\n                if (statics[key.substring(1)] === undefined) {\r\n                  throw new Error(\r\n                    'Annonation for static \"' +\r\n                      key.substring(1) +\r\n                      '\" of Class \"' +\r\n                      clazz.classname +\r\n                      '\" does not exist!'\r\n                  );\r\n                }\r\n                if (key.charAt(1) === \"_\" && key.charAt(2) === \"_\") {\r\n                  throw new Error(\r\n                    'Cannot annotate private static \"' +\r\n                      key.substring(1) +\r\n                      '\" of Class \"' +\r\n                      clazz.classname\r\n                  );\r\n                }\r\n              }\r\n            }\r\n            if (key.charAt(0) === \"@\") {\r\n              continue;\r\n            }\r\n\r\n            if (qx.core.Environment.get(\"qx.aspects\")) {\r\n              if (staticValue instanceof Function) {\r\n                staticValue = qx.core.Aspect.wrap(\r\n                  name + \".\" + key,\r\n                  staticValue,\r\n                  \"static\"\r\n                );\r\n              }\r\n\r\n              clazz[key] = staticValue;\r\n            } else {\r\n              clazz[key] = staticValue;\r\n            }\r\n\r\n            // Attach annotations\r\n            this.__attachAnno(clazz, \"statics\", key, statics[\"@\" + key]);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Create namespace\r\n      var basename = name ? qx.Bootstrap.createNamespace(name, clazz) : \"\";\r\n\r\n      // Store names in constructor/object\r\n      clazz.classname = name;\r\n      if (!isStrictMode()) {\r\n        try {\r\n          clazz.name = name;\r\n        } catch (ex) {\r\n          // Nothing\r\n        }\r\n      }\r\n      clazz.basename = basename;\r\n\r\n      // Store type info\r\n      clazz.$$type = \"Class\";\r\n      if (type) {\r\n        clazz.$$classtype = type;\r\n      }\r\n\r\n      // Attach toString\r\n      if (!clazz.hasOwnProperty(\"toString\")) {\r\n        clazz.toString = this.genericToString;\r\n      }\r\n\r\n      if (extend) {\r\n        qx.Bootstrap.extendClass(clazz, construct, extend, name, basename);\r\n\r\n        // Store destruct onto class\r\n        if (destruct) {\r\n          if (qx.core.Environment.get(\"qx.aspects\")) {\r\n            destruct = qx.core.Aspect.wrap(name, destruct, \"destructor\");\r\n          }\r\n\r\n          clazz.$$destructor = destruct;\r\n          qx.Bootstrap.setDisplayName(destruct, name, \"destruct\");\r\n        }\r\n      }\r\n\r\n      // Store class reference in global class registry\r\n      this.$$registry[name] = clazz;\r\n\r\n      // Return final class object\r\n      return clazz;\r\n    },\r\n\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n       PRIVATE ADD HELPERS\r\n    ---------------------------------------------------------------------------\r\n    */\r\n\r\n    /**\r\n     * Attach events to the class\r\n     *\r\n     * @param clazz {Class} class to add the events to\r\n     * @param events {Map} map of event names the class fires.\r\n     * @param patch {Boolean ? false} Enable redefinition of event type?\r\n     */\r\n    __addEvents(clazz, events, patch) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        if (\r\n          typeof events !== \"object\" ||\r\n          qx.Bootstrap.getClass(events) === \"Array\"\r\n        ) {\r\n          throw new Error(\r\n            clazz.classname + \": the events must be defined as map!\"\r\n          );\r\n        }\r\n\r\n        for (var key in events) {\r\n          if (typeof events[key] !== \"string\") {\r\n            throw new Error(\r\n              clazz.classname +\r\n                \"/\" +\r\n                key +\r\n                \": the event value needs to be a string with the class name of the event object which will be fired.\"\r\n            );\r\n          }\r\n        }\r\n\r\n        // Compare old and new event type/value if patching is disabled\r\n        if (clazz.$$events && patch !== true) {\r\n          for (var key in events) {\r\n            if (\r\n              clazz.$$events[key] !== undefined &&\r\n              clazz.$$events[key] !== events[key]\r\n            ) {\r\n              throw new Error(\r\n                clazz.classname +\r\n                  \"/\" +\r\n                  key +\r\n                  \": the event value/type cannot be changed from \" +\r\n                  clazz.$$events[key] +\r\n                  \" to \" +\r\n                  events[key]\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (clazz.$$events) {\r\n        for (var key in events) {\r\n          clazz.$$events[key] = events[key];\r\n        }\r\n      } else {\r\n        clazz.$$events = events;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Attach properties to classes\r\n     *\r\n     * @param clazz {Class} class to add the properties to\r\n     * @param properties {Map} map of properties\r\n     * @param patch {Boolean ? false} Overwrite property with the limitations of a property\r\n               which means you are able to refine but not to replace (esp. for new properties)\r\n     */\r\n    __addProperties(clazz, properties, patch) {\r\n      // check for the property module\r\n      if (!qx.core.Environment.get(\"module.property\")) {\r\n        throw new Error(\"Property module disabled.\");\r\n      }\r\n\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        if (qx.Bootstrap.isQxCoreObject(properties)) {\r\n          throw new Error(\"Invalid 'properties' for \" + clazz.classname);\r\n        }\r\n      }\r\n\r\n      var config;\r\n\r\n      if (patch === undefined) {\r\n        patch = false;\r\n      }\r\n\r\n      var proto = clazz.prototype;\r\n\r\n      for (var name in properties) {\r\n        config = properties[name];\r\n\r\n        // Check incoming configuration\r\n        if (qx.core.Environment.get(\"qx.debug\")) {\r\n          this.__validateProperty(clazz, name, config, patch);\r\n        }\r\n\r\n        // Store name into configuration\r\n        config.name = name;\r\n\r\n        // Add config to local registry\r\n        if (!config.refine) {\r\n          if (clazz.$$properties === undefined) {\r\n            clazz.$$properties = {};\r\n          }\r\n\r\n          clazz.$$properties[name] = config;\r\n        }\r\n\r\n        // Store init value to prototype. This makes it possible to\r\n        // overwrite this value in derived classes.\r\n        if (config.init !== undefined) {\r\n          clazz.prototype[\"$$init_\" + name] = config.init;\r\n        }\r\n\r\n        // register event name\r\n        if (config.event !== undefined) {\r\n          // break if no events layer loaded\r\n          if (!qx.core.Environment.get(\"module.events\")) {\r\n            throw new Error(\"Events module not enabled.\");\r\n          }\r\n          var event = {};\r\n          event[config.event] = \"qx.event.type.Data\";\r\n          if (config.async) {\r\n            event[config.event + \"Async\"] = \"qx.event.type.Data\";\r\n          }\r\n          this.__addEvents(clazz, event, patch);\r\n        }\r\n\r\n        // Remember inheritable properties\r\n        if (config.inheritable) {\r\n          this.__Property.$$inheritable[name] = true;\r\n          if (!proto.$$refreshInheritables) {\r\n            this.__Property.attachRefreshInheritables(clazz);\r\n          }\r\n        }\r\n\r\n        if (!config.refine) {\r\n          this.__Property.attachMethods(clazz, name, config);\r\n        }\r\n\r\n        // Add annotations\r\n        this.__attachAnno(clazz, \"properties\", name, config[\"@\"]);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Validates the given property\r\n     *\r\n     * @signature function(clazz, name, config, patch)\r\n     * @param clazz {Class} class to add property to\r\n     * @param name {String} name of the property\r\n     * @param config {Map} configuration map\r\n     * @param patch {Boolean ? false} enable refine/patch?\r\n     */\r\n    __validateProperty: qx.core.Environment.select(\"qx.debug\", {\r\n      true(clazz, name, config, patch) {\r\n        // check for properties\r\n        if (!qx.core.Environment.get(\"module.property\")) {\r\n          throw new Error(\"Property module disabled.\");\r\n        }\r\n\r\n        var has = this.hasProperty(clazz, name);\r\n\r\n        if (has) {\r\n          var existingProperty = this.getPropertyDefinition(clazz, name);\r\n\r\n          if (\r\n            config.refine &&\r\n            existingProperty.init === undefined &&\r\n            existingProperty[\"@\"] === undefined\r\n          ) {\r\n            this.warn(\r\n              \"Refine a property when there is previously no init or annotations defined. Property '\" +\r\n                name +\r\n                \"' of class '\" +\r\n                clazz.classname +\r\n                \"'.\"\r\n            );\r\n          }\r\n        }\r\n\r\n        if (!has && config.refine) {\r\n          throw new Error(\r\n            \"Could not refine non-existent property: '\" +\r\n              name +\r\n              \"' of class: '\" +\r\n              clazz.classname +\r\n              \"'!\"\r\n          );\r\n        }\r\n\r\n        if (has && !patch) {\r\n          throw new Error(\r\n            \"Class \" +\r\n              clazz.classname +\r\n              \" already has a property: \" +\r\n              name +\r\n              \"!\"\r\n          );\r\n        }\r\n\r\n        if (has && patch) {\r\n          if (!config.refine) {\r\n            throw new Error(\r\n              'Could not refine property \"' +\r\n                name +\r\n                '\" without a \"refine\" flag in the property definition! This class: ' +\r\n                clazz.classname +\r\n                \", original class: \" +\r\n                this.getByProperty(clazz, name).classname +\r\n                \".\"\r\n            );\r\n          }\r\n\r\n          for (var key in config) {\r\n            if (key !== \"init\" && key !== \"refine\" && key !== \"@\") {\r\n              throw new Error(\r\n                \"Class \" +\r\n                  clazz.classname +\r\n                  \" could not refine property: \" +\r\n                  name +\r\n                  \"! Key: \" +\r\n                  key +\r\n                  \" could not be refined!\"\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        // Check 0.7 keys\r\n        var allowed = config.group\r\n          ? this.__Property.$$allowedGroupKeys\r\n          : this.__Property.$$allowedKeys;\r\n        for (var key in config) {\r\n          if (allowed[key] === undefined) {\r\n            throw new Error(\r\n              'The configuration key \"' +\r\n                key +\r\n                '\" of property \"' +\r\n                name +\r\n                '\" in class \"' +\r\n                clazz.classname +\r\n                '\" is not allowed!'\r\n            );\r\n          }\r\n\r\n          if (config[key] === undefined) {\r\n            throw new Error(\r\n              'Invalid key \"' +\r\n                key +\r\n                '\" of property \"' +\r\n                name +\r\n                '\" in class \"' +\r\n                clazz.classname +\r\n                '\"! The value is undefined: ' +\r\n                config[key]\r\n            );\r\n          }\r\n\r\n          if (allowed[key] !== null && typeof config[key] !== allowed[key]) {\r\n            throw new Error(\r\n              'Invalid type of key \"' +\r\n                key +\r\n                '\" of property \"' +\r\n                name +\r\n                '\" in class \"' +\r\n                clazz.classname +\r\n                '\"! The type of the key must be \"' +\r\n                allowed[key] +\r\n                '\"!'\r\n            );\r\n          }\r\n        }\r\n\r\n        if (config.transform != null) {\r\n          if (!(typeof config.transform === \"string\")) {\r\n            throw new Error(\r\n              'Invalid transform definition of property \"' +\r\n                name +\r\n                '\" in class \"' +\r\n                clazz.classname +\r\n                '\"! Needs to be a String.'\r\n            );\r\n          }\r\n        }\r\n\r\n        if (config.check != null) {\r\n          if (\r\n            !qx.Bootstrap.isString(config.check) &&\r\n            !qx.Bootstrap.isArray(config.check) &&\r\n            !qx.Bootstrap.isFunction(config.check)\r\n          ) {\r\n            throw new Error(\r\n              'Invalid check definition of property \"' +\r\n                name +\r\n                '\" in class \"' +\r\n                clazz.classname +\r\n                '\"! Needs to be a String, Array or Function.'\r\n            );\r\n          }\r\n        }\r\n      },\r\n\r\n      default: null\r\n    }),\r\n\r\n    /**\r\n     * Attach members to a class\r\n     *\r\n     * @param clazz {Class} clazz to add members to\r\n     * @param members {Map} The map of members to attach\r\n     * @param patch {Boolean ? false} Enable patching of\r\n     * @param base {Boolean ? true} Attach base flag to mark function as members\r\n     *     of this class\r\n     * @param wrap {Boolean ? false} Whether the member method should be wrapped.\r\n     *     this is needed to allow base calls in patched mixin members.\r\n     */\r\n    __addMembers(clazz, members, patch, base, wrap) {\r\n      var proto = clazz.prototype;\r\n      var key, member;\r\n      qx.Bootstrap.setDisplayNames(members, clazz.classname + \".prototype\");\r\n\r\n      for (var i = 0, a = Object.keys(members), l = a.length; i < l; i++) {\r\n        key = a[i];\r\n        member = members[key];\r\n\r\n        if (qx.core.Environment.get(\"qx.debug\")) {\r\n          if (key.charAt(0) === \"@\") {\r\n            var annoKey = key.substring(1);\r\n            if (\r\n              members[annoKey] === undefined &&\r\n              proto[annoKey] === undefined\r\n            ) {\r\n              throw new Error(\r\n                'Annonation for \"' +\r\n                  annoKey +\r\n                  '\" of Class \"' +\r\n                  clazz.classname +\r\n                  '\" does not exist!'\r\n              );\r\n            }\r\n            if (key.charAt(1) === \"_\" && key.charAt(2) === \"_\") {\r\n              throw new Error(\r\n                'Cannot annotate private member \"' +\r\n                  key.substring(1) +\r\n                  '\" of Class \"' +\r\n                  clazz.classname\r\n              );\r\n            }\r\n          } else {\r\n            if (\r\n              proto[key] !== undefined &&\r\n              key.charAt(0) === \"_\" &&\r\n              key.charAt(1) === \"_\"\r\n            ) {\r\n              throw new Error(\r\n                'Overwriting private member \"' +\r\n                  key +\r\n                  '\" of Class \"' +\r\n                  clazz.classname +\r\n                  '\" is not allowed!'\r\n              );\r\n            }\r\n\r\n            if (patch !== true && proto.hasOwnProperty(key)) {\r\n              throw new Error(\r\n                'Overwriting member \"' +\r\n                  key +\r\n                  '\" of Class \"' +\r\n                  clazz.classname +\r\n                  '\" is not allowed!'\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        // Annotations are not members\r\n        if (key.charAt(0) === \"@\") {\r\n          var annoKey = key.substring(1);\r\n          if (members[annoKey] === undefined) {\r\n            this.__attachAnno(clazz, \"members\", annoKey, members[key]);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        // If it's a property accessor, we need to install it now so that this.base can refer to it\r\n        if (proto[key] != undefined && proto[key].$$install) {\r\n          proto[key].$$install();\r\n        }\r\n\r\n        // Added helper stuff to functions\r\n        // Hint: Could not use typeof function because RegExp objects are functions, too\r\n        // Protect to apply base property and aspect support on special attributes e.g.\r\n        // classes which are function like as well.\r\n        if (\r\n          base !== false &&\r\n          member instanceof Function &&\r\n          member.$$type == null\r\n        ) {\r\n          // If the class has it's own implementation, we need to remember that method in the\r\n          //  mixed-in method's `.base`; wrap the method with a closure so that it can have a\r\n          //  `.base` set, if we were to set `member.base` it would mean that the mixin can\r\n          //  only be added into one class\r\n          if (wrap) {\r\n            if (proto[key]) {\r\n              member = qx.lang.Function.create(member, { always: true });\r\n            }\r\n            member.self = clazz;\r\n          }\r\n          member.base = proto[key];\r\n\r\n          if (qx.core.Environment.get(\"qx.aspects\")) {\r\n            member = qx.core.Aspect.wrap(\r\n              clazz.classname + \".\" + key,\r\n              member,\r\n              \"member\"\r\n            );\r\n          }\r\n        }\r\n\r\n        // Attach member\r\n        proto[key] = member;\r\n\r\n        // Attach annotations\r\n        this.__attachAnno(clazz, \"members\", key, members[\"@\" + key]);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Add a single interface to a class\r\n     *\r\n     * @param clazz {Class} class to add interface to\r\n     * @param iface {Interface} the Interface to add\r\n     */\r\n    __addInterface(clazz, iface) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        if (!clazz || !iface) {\r\n          throw new Error(\"Incomplete parameters!\");\r\n        }\r\n\r\n        // This differs from mixins, we only check if the interface is already\r\n        // directly used by this class. It is allowed however, to have an interface\r\n        // included multiple times by extends in the interfaces etc.\r\n        if (this.hasOwnInterface(clazz, iface)) {\r\n          throw new Error(\r\n            'Interface \"' +\r\n              iface.name +\r\n              '\" is already used by Class \"' +\r\n              clazz.classname +\r\n              \"!\"\r\n          );\r\n        }\r\n\r\n        // Check interface and wrap members\r\n        if (clazz.$$classtype !== \"abstract\") {\r\n          qx.Interface.assert(clazz, iface, true);\r\n        }\r\n      }\r\n\r\n      // Store interface reference\r\n      var list = qx.Interface.flatten([iface]);\r\n      if (clazz.$$implements) {\r\n        clazz.$$implements.push(iface);\r\n        clazz.$$flatImplements.push.apply(clazz.$$flatImplements, list);\r\n      } else {\r\n        clazz.$$implements = [iface];\r\n        clazz.$$flatImplements = list;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Include all features of the mixin into the given class, recursively.\r\n     *\r\n     * @param clazz {Class} The class onto which the mixin should be attached.\r\n     * @param mixin {Mixin} Include all features of this mixin\r\n     * @param patch {Boolean} Overwrite existing fields, functions and properties\r\n     */\r\n    __addMixin(clazz, mixin, patch) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        if (!clazz || !mixin) {\r\n          throw new Error(\"Incomplete parameters!\");\r\n        }\r\n      }\r\n\r\n      if (this.hasMixin(clazz, mixin)) {\r\n        return;\r\n      }\r\n\r\n      // Attach content\r\n      var list = qx.Mixin.flatten([mixin]);\r\n      var entry;\r\n\r\n      for (var i = 0, l = list.length; i < l; i++) {\r\n        entry = list[i];\r\n\r\n        // Attach events\r\n        if (entry.$$events) {\r\n          this.__addEvents(clazz, entry.$$events, patch);\r\n        }\r\n\r\n        // Attach properties (Properties are already readonly themselves, no patch handling needed)\r\n        if (entry.$$properties) {\r\n          this.__addProperties(clazz, entry.$$properties, patch);\r\n        }\r\n\r\n        // Attach members (Respect patch setting, but dont apply base variables)\r\n        if (entry.$$members) {\r\n          this.__addMembers(clazz, entry.$$members, patch, patch, patch);\r\n        }\r\n      }\r\n\r\n      // Store mixin reference\r\n      if (clazz.$$includes) {\r\n        clazz.$$includes.push(mixin);\r\n        clazz.$$flatIncludes.push.apply(clazz.$$flatIncludes, list);\r\n      } else {\r\n        clazz.$$includes = [mixin];\r\n        clazz.$$flatIncludes = list;\r\n      }\r\n    },\r\n\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n       PRIVATE FUNCTION HELPERS\r\n    ---------------------------------------------------------------------------\r\n    */\r\n\r\n    /**\r\n     * Returns the default constructor.\r\n     * This constructor just calls the constructor of the base class.\r\n     *\r\n     * @return {Function} The default constructor.\r\n     */\r\n    __createDefaultConstructor() {\r\n      function defaultConstructor() {\r\n        defaultConstructor.base.apply(this, arguments);\r\n      }\r\n\r\n      return defaultConstructor;\r\n    },\r\n\r\n    /**\r\n     * Generate a wrapper of the original class constructor in order to enable\r\n     * some of the advanced OO features (e.g. abstract class, singleton, mixins)\r\n     *\r\n     * @param construct {Function} the original constructor\r\n     * @param name {String} name of the class\r\n     * @param type {String} the user specified class type\r\n     * @return {Function} The wrapped constructor\r\n     */\r\n    __wrapConstructor(construct, name, type) {\r\n      var wrapper = function () {\r\n        var clazz = wrapper;\r\n\r\n        if (qx.core.Environment.get(\"qx.debug\")) {\r\n          // new keyword check\r\n          if (!(this instanceof clazz)) {\r\n            throw new Error(\r\n              \"Please initialize '\" + name + \"' objects using the new keyword!\"\r\n            );\r\n          }\r\n\r\n          // add abstract and singleton checks\r\n          if (type === \"abstract\") {\r\n            if (this.classname === name) {\r\n              throw new Error(\r\n                \"The class ',\" +\r\n                  name +\r\n                  \"' is abstract! It is not possible to instantiate it.\"\r\n              );\r\n            }\r\n          } else if (type === \"singleton\") {\r\n            if (!clazz.$$allowconstruct) {\r\n              throw new Error(\r\n                \"The class '\" +\r\n                  name +\r\n                  \"' is a singleton! It is not possible to instantiate it directly. Use the static getInstance() method instead.\"\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        // Execute default constructor\r\n        var retval = clazz.$$original.apply(this, arguments);\r\n\r\n        // Initialize local mixins\r\n        if (clazz.$$includes) {\r\n          var mixins = clazz.$$flatIncludes;\r\n          for (var i = 0, l = mixins.length; i < l; i++) {\r\n            if (mixins[i].$$constructor) {\r\n              mixins[i].$$constructor.apply(this, arguments);\r\n            }\r\n          }\r\n        }\r\n\r\n        if (qx.core.Environment.get(\"qx.debug\")) {\r\n          // Mark instance as initialized\r\n          if (this.classname === name) {\r\n            this.$$initialized = true;\r\n          }\r\n        }\r\n\r\n        // Return optional return value\r\n        return retval;\r\n      };\r\n\r\n      if (qx.core.Environment.get(\"qx.aspects\")) {\r\n        var aspectWrapper = qx.core.Aspect.wrap(name, wrapper, \"constructor\");\r\n        wrapper.$$original = construct;\r\n        wrapper.constructor = aspectWrapper;\r\n        wrapper = aspectWrapper;\r\n      }\r\n\r\n      // Store original constructor\r\n      wrapper.$$original = construct;\r\n\r\n      // Store wrapper into constructor (needed for base calls etc.)\r\n      construct.wrapper = wrapper;\r\n\r\n      // Return generated wrapper\r\n      return wrapper;\r\n    }\r\n  },\r\n\r\n  defer() {\r\n    // Binding of already loaded bootstrap classes\r\n    if (qx.core.Environment.get(\"qx.aspects\")) {\r\n      for (var classname in qx.Bootstrap.$$registry) {\r\n        var statics = qx.Bootstrap.$$registry[classname];\r\n\r\n        for (var key in statics) {\r\n          // only functions, no regexps\r\n          if (statics[key] instanceof Function) {\r\n            statics[key] = qx.core.Aspect.wrap(\r\n              classname + \".\" + key,\r\n              statics[key],\r\n              \"static\"\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n});\r\n"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAS,CAACC,oBAAoB,CAACC,aAAa,CAAC;EAAhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAH,EAAE,CAACC,SAAS,CAACG,MAAM,CAAC,UAAU,EAAE;IAC9BC,OAAO,EAAE;MACP;AACJ;AACA;AACA;MACIC,QAAU,EAAE,OACRN,EAAE,CAACO,IAAI,CAACC,QAAQ,GAChB,IAAI;MAER;AACJ;AACA;AACA;AACA;MAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIJ,MAAM,WAAAA,OAACK,IAAI,EAAEC,MAAM,EAAE;QACnB,IAAI;UACF,OAAO,IAAI,CAACC,QAAY,CAACF,IAAI,EAAEC,MAAM,CAAC;QACxC,CAAC,CAAC,OAAOE,EAAE,EAAE;UACXZ,EAAE,CAACa,KAAK,CAACC,wBAAwB,GAAG,IAAI;UACxC,MAAM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"
}