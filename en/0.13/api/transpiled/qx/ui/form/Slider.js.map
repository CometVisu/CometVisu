{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/compiler/node_modules/@qooxdoo/framework/source/class/qx/ui/form/Slider.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "ui",
    "core",
    "Widget",
    "implement",
    "form",
    "IForm",
    "INumberForm",
    "IRange",
    "include",
    "MForm",
    "construct",
    "orientation",
    "_setLayout",
    "layout",
    "Canvas",
    "addListener",
    "_onKeyPress",
    "_onRoll",
    "_onPointerDown",
    "_onPointerUp",
    "_onUpdate",
    "_onStopEvent",
    "setOrientation",
    "initOrientation",
    "events",
    "changeValue",
    "slideAnimationEnd",
    "properties",
    "appearance",
    "refine",
    "init",
    "focusable",
    "check",
    "apply",
    "value",
    "nullable",
    "minimum",
    "event",
    "maximum",
    "singleStep",
    "pageStep",
    "knobFactor",
    "members",
    "__sliderLocation",
    "__knobLocation",
    "__knobSize",
    "__dragMode",
    "__dragOffset",
    "__trackingMode",
    "__trackingDirection",
    "__trackingEnd",
    "__timer",
    "__dragTimer",
    "__lastValueEvent",
    "__dragValue",
    "__scrollAnimationframe",
    "_forwardStates",
    "invalid",
    "renderLayout",
    "left",
    "top",
    "width",
    "height",
    "_updateKnobPosition",
    "_createChildControlImpl",
    "id",
    "hash",
    "control",
    "_onPointerOver",
    "_onPointerOut",
    "_add",
    "e",
    "addState",
    "removeState",
    "getPointerType",
    "axis",
    "getOrientation",
    "delta",
    "getDelta",
    "direction",
    "slideBy",
    "getSingleStep",
    "stop",
    "isHorizontal",
    "backward",
    "forward",
    "getKeyIdentifier",
    "slideForward",
    "slideBack",
    "slidePageForward",
    "slidePageBack",
    "slideToBegin",
    "slideToEnd",
    "__isHorizontal",
    "knob",
    "getChildControl",
    "locationProperty",
    "cursorLocation",
    "getDocumentLeft",
    "getDocumentTop",
    "decorator",
    "getDecorator",
    "theme",
    "manager",
    "Decoration",
    "getInstance",
    "resolve",
    "decoratorPadding",
    "getInsets",
    "padding",
    "getPaddingLeft",
    "getPaddingTop",
    "sliderLocation",
    "bom",
    "element",
    "Location",
    "get",
    "getContentElement",
    "getDomElement",
    "knobLocation",
    "getTarget",
    "Timer",
    "_fireValue",
    "start",
    "__computeTrackingEnd",
    "_onInterval",
    "_onPointerMove",
    "capture",
    "stopPropagation",
    "releaseCapture",
    "getType",
    "deltaSlider",
    "deltaPosition",
    "positionSlider",
    "_valueToPosition",
    "getValue",
    "getBounds",
    "removeListener",
    "dragStop",
    "position",
    "slideTo",
    "_positionToValue",
    "getPageStep",
    "getMinimum",
    "getMaximum",
    "availSize",
    "getInnerSize",
    "knobSize",
    "sizeProperty",
    "_updateKnobSize",
    "__slidingSpace",
    "min",
    "max",
    "old",
    "step",
    "method",
    "Math",
    "avail",
    "percent",
    "range",
    "round",
    "_setKnobPosition",
    "dec",
    "content",
    "getPadding",
    "setStyle",
    "getKnobFactor",
    "setWidth",
    "setHeight",
    "duration",
    "offset",
    "stopSlideAnimation",
    "__animateTo",
    "updatePosition",
    "setValue",
    "__normalizeValue",
    "cancelSequence",
    "to",
    "from",
    "AnimationFrame",
    "on",
    "timePassed",
    "parseInt",
    "fireEvent",
    "startSequence",
    "_applyOrientation",
    "setLayoutProperties",
    "right",
    "bottom",
    "_applyKnobFactor",
    "resetWidth",
    "resetHeight",
    "_applyValue",
    "type",
    "Data",
    "resetValue",
    "tmp",
    "_applyMinimum",
    "_applyMaximum",
    "Slider"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * The Slider widget provides a vertical or horizontal slider.\n *\n * The Slider is the classic widget for controlling a bounded value.\n * It lets the user move a slider handle along a horizontal or vertical\n * groove and translates the handle's position into an integer value\n * within the defined range.\n *\n * The Slider has very few of its own functions.\n * The most useful functions are slideTo() to set the slider directly to some\n * value; setSingleStep(), setPageStep() to set the steps; and setMinimum()\n * and setMaximum() to define the range of the slider.\n *\n * A slider accepts focus on Tab and provides both a mouse wheel and\n * a keyboard interface. The keyboard interface is the following:\n *\n * * Left/Right move a horizontal slider by one single step.\n * * Up/Down move a vertical slider by one single step.\n * * PageUp moves up one page.\n * * PageDown moves down one page.\n * * Home moves to the start (minimum).\n * * End moves to the end (maximum).\n *\n * Here are the main properties of the class:\n *\n * # <code>value</code>: The bounded integer that {@link qx.ui.form.INumberForm}\n * maintains.\n * # <code>minimum</code>: The lowest possible value.\n * # <code>maximum</code>: The highest possible value.\n * # <code>singleStep</code>: The smaller of two natural steps that an abstract\n * sliders provides and typically corresponds to the user pressing an arrow key.\n * # <code>pageStep</code>: The larger of two natural steps that an abstract\n * slider provides and typically corresponds to the user pressing PageUp or\n * PageDown.\n *\n * @childControl knob {qx.ui.core.Widget} knob to set the value of the slider\n */\nqx.Class.define(\"qx.ui.form.Slider\",\n{\n  extend : qx.ui.core.Widget,\n  implement : [\n    qx.ui.form.IForm,\n    qx.ui.form.INumberForm,\n    qx.ui.form.IRange\n  ],\n  include : [qx.ui.form.MForm],\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  /**\n   * @param orientation {String?\"horizontal\"} Configure the\n   * {@link #orientation} property\n   */\n  construct : function(orientation)\n  {\n    this.base(arguments);\n\n    // Force canvas layout\n    this._setLayout(new qx.ui.layout.Canvas());\n\n    // Add listeners\n    this.addListener(\"keypress\", this._onKeyPress);\n    this.addListener(\"roll\", this._onRoll);\n    this.addListener(\"pointerdown\", this._onPointerDown);\n    this.addListener(\"pointerup\", this._onPointerUp);\n    this.addListener(\"losecapture\", this._onPointerUp);\n    this.addListener(\"resize\", this._onUpdate);\n\n    // Stop events\n    this.addListener(\"contextmenu\", this._onStopEvent);\n    this.addListener(\"tap\", this._onStopEvent);\n    this.addListener(\"dbltap\", this._onStopEvent);\n\n    // Initialize orientation\n    if (orientation != null) {\n      this.setOrientation(orientation);\n    } else {\n      this.initOrientation();\n    }\n  },\n\n\n  /*\n  *****************************************************************************\n     EVENTS\n  *****************************************************************************\n  */\n\n  events : {\n    /**\n     * Change event for the value.\n     */\n    changeValue: 'qx.event.type.Data',\n\n    /** Fired as soon as the slide animation ended. */\n    slideAnimationEnd: 'qx.event.type.Event'\n  },\n\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties :\n  {\n    // overridden\n    appearance :\n    {\n      refine : true,\n      init : \"slider\"\n    },\n\n\n    // overridden\n    focusable :\n    {\n      refine : true,\n      init : true\n    },\n\n\n    /** Whether the slider is horizontal or vertical. */\n    orientation :\n    {\n      check : [ \"horizontal\", \"vertical\" ],\n      init : \"horizontal\",\n      apply : \"_applyOrientation\"\n    },\n\n\n    /**\n     * The current slider value.\n     *\n     * Strictly validates according to {@link #minimum} and {@link #maximum}.\n     * Do not apply any value correction to the incoming value. If you depend\n     * on this, please use {@link #slideTo} instead.\n     */\n    value :\n    {\n      check : \"typeof value==='number'&&value>=this.getMinimum()&&value<=this.getMaximum()\",\n      init : 0,\n      apply : \"_applyValue\",\n      nullable: true\n    },\n\n\n    /**\n     * The minimum slider value (may be negative). This value must be smaller\n     * than {@link #maximum}.\n     */\n    minimum :\n    {\n      check : \"Integer\",\n      init : 0,\n      apply : \"_applyMinimum\",\n      event: \"changeMinimum\"\n    },\n\n\n    /**\n     * The maximum slider value (may be negative). This value must be larger\n     * than {@link #minimum}.\n     */\n    maximum :\n    {\n      check : \"Integer\",\n      init : 100,\n      apply : \"_applyMaximum\",\n      event : \"changeMaximum\"\n    },\n\n\n    /**\n     * The amount to increment on each event. Typically corresponds\n     * to the user pressing an arrow key.\n     */\n    singleStep :\n    {\n      check : \"Integer\",\n      init : 1\n    },\n\n\n    /**\n     * The amount to increment on each event. Typically corresponds\n     * to the user pressing <code>PageUp</code> or <code>PageDown</code>.\n     */\n    pageStep :\n    {\n      check : \"Integer\",\n      init : 10\n    },\n\n\n    /**\n     * Factor to apply to the width/height of the knob in relation\n     * to the dimension of the underlying area.\n     */\n    knobFactor :\n    {\n      check : \"Number\",\n      apply : \"_applyKnobFactor\",\n      nullable : true\n    }\n  },\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n\n    __sliderLocation : null,\n    __knobLocation : null,\n    __knobSize : null,\n    __dragMode : null,\n    __dragOffset : null,\n    __trackingMode : null,\n    __trackingDirection : null,\n    __trackingEnd : null,\n    __timer : null,\n\n    // event delay stuff during drag\n    __dragTimer: null,\n    __lastValueEvent: null,\n    __dragValue: null,\n\n    __scrollAnimationframe : null,\n\n\n    // overridden\n    /**\n     * @lint ignoreReferenceField(_forwardStates)\n     */\n    _forwardStates : {\n      invalid : true\n    },\n\n\n    // overridden\n    renderLayout : function(left, top, width, height) {\n      this.base(arguments, left, top, width, height);\n      // make sure the layout engine does not override the knob position\n      this._updateKnobPosition();\n    },\n\n\n    // overridden\n    _createChildControlImpl : function(id, hash)\n    {\n      var control;\n\n      switch(id)\n      {\n        case \"knob\":\n          control = new qx.ui.core.Widget();\n\n          control.addListener(\"resize\", this._onUpdate, this);\n          control.addListener(\"pointerover\", this._onPointerOver);\n          control.addListener(\"pointerout\", this._onPointerOut);\n          this._add(control);\n          break;\n      }\n\n      return control || this.base(arguments, id);\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT HANDLER\n    ---------------------------------------------------------------------------\n    */\n\n\n    /**\n     * Event handler for pointerover events at the knob child control.\n     *\n     * Adds the 'hovered' state\n     *\n     * @param e {qx.event.type.Pointer} Incoming pointer event\n     */\n    _onPointerOver : function(e) {\n      this.addState(\"hovered\");\n    },\n\n\n    /**\n     * Event handler for pointerout events at the knob child control.\n     *\n     * Removes the 'hovered' state\n     *\n     * @param e {qx.event.type.Pointer} Incoming pointer event\n     */\n    _onPointerOut : function(e) {\n      this.removeState(\"hovered\");\n    },\n\n\n    /**\n     * Listener of roll event\n     *\n     * @param e {qx.event.type.Roll} Incoming event object\n     */\n    _onRoll : function(e)\n    {\n      // only wheel\n      if (e.getPointerType() != \"wheel\") {\n        return;\n      }\n\n      var axis = this.getOrientation() === \"horizontal\" ? \"x\" : \"y\";\n      var delta = e.getDelta()[axis];\n\n      var direction =  delta > 0 ? 1 : delta < 0 ? -1 : 0;\n      this.slideBy(direction * this.getSingleStep());\n\n      e.stop();\n    },\n\n\n    /**\n     * Event handler for keypress events.\n     *\n     * Adds support for arrow keys, page up, page down, home and end keys.\n     *\n     * @param e {qx.event.type.KeySequence} Incoming keypress event\n     */\n    _onKeyPress : function(e)\n    {\n      var isHorizontal = this.getOrientation() === \"horizontal\";\n      var backward = isHorizontal ? \"Left\" : \"Up\";\n      var forward = isHorizontal ? \"Right\" : \"Down\";\n\n      switch(e.getKeyIdentifier())\n      {\n        case forward:\n          this.slideForward();\n          break;\n\n        case backward:\n          this.slideBack();\n          break;\n\n        case \"PageDown\":\n          this.slidePageForward(100);\n          break;\n\n        case \"PageUp\":\n          this.slidePageBack(100);\n          break;\n\n        case \"Home\":\n          this.slideToBegin(200);\n          break;\n\n        case \"End\":\n          this.slideToEnd(200);\n          break;\n\n        default:\n          return;\n      }\n\n      // Stop processed events\n      e.stop();\n    },\n\n\n    /**\n     * Listener of pointerdown event. Initializes drag or tracking mode.\n     *\n     * @param e {qx.event.type.Pointer} Incoming event object\n     */\n    _onPointerDown : function(e)\n    {\n      // this can happen if the user releases the button while dragging outside\n      // of the browser viewport\n      if (this.__dragMode) {\n        return;\n      }\n\n      var isHorizontal = this.__isHorizontal;\n      var knob = this.getChildControl(\"knob\");\n\n      var locationProperty = isHorizontal ? \"left\" : \"top\";\n\n      var cursorLocation = isHorizontal ? e.getDocumentLeft() : e.getDocumentTop();\n\n      var decorator = this.getDecorator();\n      decorator = qx.theme.manager.Decoration.getInstance().resolve(decorator);\n      if (isHorizontal) {\n        var decoratorPadding = decorator ? decorator.getInsets().left : 0;\n        var padding = (this.getPaddingLeft() || 0) + decoratorPadding;\n      } else {\n        var decoratorPadding = decorator ? decorator.getInsets().top : 0;\n        var padding = (this.getPaddingTop() || 0) + decoratorPadding;\n      }\n\n      var sliderLocation = this.__sliderLocation = qx.bom.element.Location.get(this.getContentElement().getDomElement())[locationProperty];\n      sliderLocation += padding;\n\n      var knobLocation = this.__knobLocation = qx.bom.element.Location.get(knob.getContentElement().getDomElement())[locationProperty];\n\n      if (e.getTarget() === knob)\n      {\n        // Switch into drag mode\n        this.__dragMode = true;\n        if (!this.__dragTimer){\n          // create a timer to fire delayed dragging events if dragging stops.\n          this.__dragTimer = new qx.event.Timer(100);\n          this.__dragTimer.addListener(\"interval\", this._fireValue, this);\n        }\n        this.__dragTimer.start();\n        // Compute dragOffset (includes both: inner position of the widget and\n        // cursor position on knob)\n        this.__dragOffset = cursorLocation + sliderLocation - knobLocation;\n\n        // add state\n        knob.addState(\"pressed\");\n      }\n      else\n      {\n        // Switch into tracking mode\n        this.__trackingMode = true;\n\n        // Detect tracking direction\n        this.__trackingDirection = cursorLocation <= knobLocation ? -1 : 1;\n\n        // Compute end value\n        this.__computeTrackingEnd(e);\n\n        // Directly call interval method once\n        this._onInterval();\n\n        // Initialize timer (when needed)\n        if (!this.__timer)\n        {\n          this.__timer = new qx.event.Timer(100);\n          this.__timer.addListener(\"interval\", this._onInterval, this);\n        }\n\n        // Start timer\n        this.__timer.start();\n      }\n\n      // Register move listener\n      this.addListener(\"pointermove\", this._onPointerMove);\n\n      // Activate capturing\n      this.capture();\n\n      // Stop event\n      e.stopPropagation();\n    },\n\n\n    /**\n     * Listener of pointerup event. Used for cleanup of previously\n     * initialized modes.\n     *\n     * @param e {qx.event.type.Pointer} Incoming event object\n     */\n    _onPointerUp : function(e)\n    {\n      if (this.__dragMode)\n      {\n        // Release capture mode\n        this.releaseCapture();\n\n        // Cleanup status flags\n        delete this.__dragMode;\n\n        // as we come out of drag mode, make\n        // sure content gets synced\n        this.__dragTimer.stop();\n        this._fireValue();\n\n        delete this.__dragOffset;\n\n        // remove state\n        this.getChildControl(\"knob\").removeState(\"pressed\");\n\n        // it's necessary to check whether the cursor is over the knob widget to be able to\n        // to decide whether to remove the 'hovered' state.\n        if (e.getType() === \"pointerup\")\n        {\n          var deltaSlider;\n          var deltaPosition;\n          var positionSlider;\n\n          if (this.__isHorizontal)\n          {\n            deltaSlider = e.getDocumentLeft() - (this._valueToPosition(this.getValue()) + this.__sliderLocation);\n\n            positionSlider = qx.bom.element.Location.get(this.getContentElement().getDomElement())[\"top\"];\n            deltaPosition = e.getDocumentTop() - (positionSlider + this.getChildControl(\"knob\").getBounds().top);\n          }\n          else\n          {\n            deltaSlider = e.getDocumentTop() - (this._valueToPosition(this.getValue()) + this.__sliderLocation);\n\n            positionSlider = qx.bom.element.Location.get(this.getContentElement().getDomElement())[\"left\"];\n            deltaPosition = e.getDocumentLeft() - (positionSlider + this.getChildControl(\"knob\").getBounds().left);\n          }\n\n          if (deltaPosition < 0 || deltaPosition > this.__knobSize ||\n              deltaSlider < 0 || deltaSlider > this.__knobSize) {\n            this.getChildControl(\"knob\").removeState(\"hovered\");\n          }\n        }\n\n      }\n      else if (this.__trackingMode)\n      {\n        // Stop timer interval\n        this.__timer.stop();\n\n        // Release capture mode\n        this.releaseCapture();\n\n        // Cleanup status flags\n        delete this.__trackingMode;\n        delete this.__trackingDirection;\n        delete this.__trackingEnd;\n      }\n\n      // Remove move listener again\n      this.removeListener(\"pointermove\", this._onPointerMove);\n\n      // Stop event\n      if (e.getType() === \"pointerup\") {\n        e.stopPropagation();\n      }\n    },\n\n\n    /**\n     * Listener of pointermove event for the knob. Only used in drag mode.\n     *\n     * @param e {qx.event.type.Pointer} Incoming event object\n     */\n    _onPointerMove : function(e)\n    {\n      if (this.__dragMode)\n      {\n        var dragStop = this.__isHorizontal ?\n          e.getDocumentLeft() : e.getDocumentTop();\n        var position = dragStop - this.__dragOffset;\n\n        this.slideTo(this._positionToValue(position));\n      }\n      else if (this.__trackingMode)\n      {\n        // Update tracking end on pointermove\n        this.__computeTrackingEnd(e);\n      }\n\n      // Stop event\n      e.stopPropagation();\n    },\n\n\n    /**\n     * Listener of interval event by the internal timer. Only used\n     * in tracking sequences.\n     *\n     * @param e {qx.event.type.Event} Incoming event object\n     */\n    _onInterval : function(e)\n    {\n      // Compute new value\n      var value = this.getValue() + (this.__trackingDirection * this.getPageStep());\n\n      // Limit value\n      if (value < this.getMinimum()) {\n        value = this.getMinimum();\n      } else if (value > this.getMaximum()) {\n        value = this.getMaximum();\n      }\n\n      // Stop at tracking position (where the pointer is pressed down)\n      var slideBack = this.__trackingDirection == -1;\n      if ((slideBack && value <= this.__trackingEnd) || (!slideBack && value >= this.__trackingEnd)) {\n        value = this.__trackingEnd;\n      }\n\n      // Finally slide to the desired position\n      this.slideTo(value);\n    },\n\n\n    /**\n     * Listener of resize event for both the slider itself and the knob.\n     *\n     * @param e {qx.event.type.Data} Incoming event object\n     */\n    _onUpdate : function(e)\n    {\n      // Update sliding space\n      var availSize = this.getInnerSize();\n      var knobSize = this.getChildControl(\"knob\").getBounds();\n      var sizeProperty = this.__isHorizontal ? \"width\" : \"height\";\n\n      // Sync knob size\n      this._updateKnobSize();\n\n      // Store knob size\n      this.__slidingSpace = availSize[sizeProperty] - knobSize[sizeProperty];\n      this.__knobSize = knobSize[sizeProperty];\n\n      // Update knob position (sliding space must be updated first)\n      this._updateKnobPosition();\n    },\n\n\n\n\n\n\n    /*\n    ---------------------------------------------------------------------------\n      UTILS\n    ---------------------------------------------------------------------------\n    */\n\n    /** @type {Boolean} Whether the slider is laid out horizontally */\n    __isHorizontal : false,\n\n\n    /**\n     * @type {Integer} Available space for knob to slide on, computed on resize of\n     * the widget\n     */\n    __slidingSpace : 0,\n\n\n    /**\n     * Computes the value where the tracking should end depending on\n     * the current pointer position.\n     *\n     * @param e {qx.event.type.Pointer} Incoming pointer event\n     */\n    __computeTrackingEnd : function(e)\n    {\n      var isHorizontal = this.__isHorizontal;\n      var cursorLocation = isHorizontal ? e.getDocumentLeft() : e.getDocumentTop();\n      var sliderLocation = this.__sliderLocation;\n      var knobLocation = this.__knobLocation;\n      var knobSize = this.__knobSize;\n\n      // Compute relative position\n      var position = cursorLocation - sliderLocation;\n      if (cursorLocation >= knobLocation) {\n        position -= knobSize;\n      }\n\n      // Compute stop value\n      var value = this._positionToValue(position);\n\n      var min = this.getMinimum();\n      var max = this.getMaximum();\n\n      if (value < min) {\n        value = min;\n      } else if (value > max) {\n        value = max;\n      } else {\n        var old = this.getValue();\n        var step = this.getPageStep();\n        var method = this.__trackingDirection < 0 ? \"floor\" : \"ceil\";\n\n        // Fix to page step\n        value = old + (Math[method]((value - old) / step) * step);\n      }\n\n      // Store value when undefined, otherwise only when it follows the\n      // current direction e.g. goes up or down\n      if (this.__trackingEnd == null || (this.__trackingDirection == -1 && value <= this.__trackingEnd) || (this.__trackingDirection == 1 && value >= this.__trackingEnd)) {\n        this.__trackingEnd = value;\n      }\n    },\n\n\n    /**\n     * Converts the given position to a value.\n     *\n     * Does not respect single or page step.\n     *\n     * @param position {Integer} Position to use\n     * @return {Integer} Resulting value (rounded)\n     */\n    _positionToValue : function(position)\n    {\n      // Reading available space\n      var avail = this.__slidingSpace;\n\n      // Protect undefined value (before initial resize) and division by zero\n      if (avail == null || avail == 0) {\n        return 0;\n      }\n\n      // Compute and limit percent\n      var percent = position / avail;\n      if (percent < 0) {\n        percent = 0;\n      } else if (percent > 1) {\n        percent = 1;\n      }\n\n      // Compute range\n      var range = this.getMaximum() - this.getMinimum();\n\n      // Compute value\n      return this.getMinimum() + Math.round(range * percent);\n    },\n\n\n    /**\n     * Converts the given value to a position to place\n     * the knob to.\n     *\n     * @param value {Integer} Value to use\n     * @return {Integer} Computed position (rounded)\n     */\n    _valueToPosition : function(value)\n    {\n      // Reading available space\n      var avail = this.__slidingSpace;\n      if (avail == null) {\n        return 0;\n      }\n\n      // Computing range\n      var range = this.getMaximum() - this.getMinimum();\n\n      // Protect division by zero\n      if (range == 0) {\n        return 0;\n      }\n\n      // Translating value to distance from minimum\n      var value = value - this.getMinimum();\n\n      // Compute and limit percent\n      var percent = value / range;\n      if (percent < 0) {\n        percent = 0;\n      } else if (percent > 1) {\n        percent = 1;\n      }\n\n      // Compute position from available space and percent\n      return Math.round(avail * percent);\n    },\n\n\n    /**\n     * Updates the knob position following the currently configured\n     * value. Useful on reflows where the dimensions of the slider\n     * itself have been modified.\n     *\n     */\n    _updateKnobPosition : function() {\n      this._setKnobPosition(this._valueToPosition(this.getValue()));\n    },\n\n\n    /**\n     * Moves the knob to the given position.\n     *\n     * @param position {Integer} Any valid position (needs to be\n     *   greater or equal than zero)\n     */\n    _setKnobPosition : function(position)\n    {\n      // Use the DOM Element to prevent unnecessary layout recalculations\n      var knob = this.getChildControl(\"knob\");\n      var dec = this.getDecorator();\n      dec = qx.theme.manager.Decoration.getInstance().resolve(dec);\n      var content = knob.getContentElement();\n      if (this.__isHorizontal) {\n        if (dec && dec.getPadding()) {\n          position += dec.getPadding().left;\n        }\n        position += this.getPaddingLeft() || 0;\n        content.setStyle(\"left\", position+\"px\", true);\n      } else {\n        if (dec && dec.getPadding()) {\n          position += dec.getPadding().top;\n        }\n        position += this.getPaddingTop() || 0;\n        content.setStyle(\"top\", position+\"px\", true);\n      }\n    },\n\n\n    /**\n     * Reconfigures the size of the knob depending on\n     * the optionally defined {@link #knobFactor}.\n     *\n     */\n    _updateKnobSize : function()\n    {\n      // Compute knob size\n      var knobFactor = this.getKnobFactor();\n      if (knobFactor == null) {\n        return;\n      }\n\n      // Ignore when not rendered yet\n      var avail = this.getInnerSize();\n      if (avail == null) {\n        return;\n      }\n\n      // Read size property\n      if (this.__isHorizontal) {\n        this.getChildControl(\"knob\").setWidth(Math.round(knobFactor * avail.width));\n      } else {\n        this.getChildControl(\"knob\").setHeight(Math.round(knobFactor * avail.height));\n      }\n    },\n\n\n\n\n\n    /*\n    ---------------------------------------------------------------------------\n      SLIDE METHODS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Slides backward to the minimum value\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    slideToBegin : function(duration) {\n      this.slideTo(this.getMinimum(), duration);\n    },\n\n\n    /**\n     * Slides forward to the maximum value\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    slideToEnd : function(duration) {\n      this.slideTo(this.getMaximum(), duration);\n    },\n\n\n    /**\n     * Slides forward (right or bottom depending on orientation)\n     *\n     */\n    slideForward : function() {\n      this.slideBy(this.getSingleStep());\n    },\n\n\n    /**\n     * Slides backward (to left or top depending on orientation)\n     *\n     */\n    slideBack : function() {\n      this.slideBy(-this.getSingleStep());\n    },\n\n\n    /**\n     * Slides a page forward (to right or bottom depending on orientation)\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    slidePageForward : function(duration) {\n      this.slideBy(this.getPageStep(), duration);\n    },\n\n\n    /**\n     * Slides a page backward (to left or top depending on orientation)\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    slidePageBack : function(duration) {\n      this.slideBy(-this.getPageStep(), duration);\n    },\n\n\n    /**\n     * Slides by the given offset.\n     *\n     * This method works with the value, not with the coordinate.\n     *\n     * @param offset {Integer} Offset to scroll by\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    slideBy : function(offset, duration) {\n      this.slideTo(this.getValue() + offset, duration);\n    },\n\n\n    /**\n     * Slides to the given value\n     *\n     * This method works with the value, not with the coordinate.\n     *\n     * @param value {Integer} Scroll to a value between the defined\n     *   minimum and maximum.\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    slideTo : function(value, duration)\n    {\n      this.stopSlideAnimation();\n\n      if (duration) {\n        this.__animateTo(value, duration);\n      } else {\n        this.updatePosition(value);\n      }\n    },\n\n\n    /**\n     * Updates the position property considering the minimum and maximum values.\n     * @param value {Number} The new position.\n     */\n    updatePosition : function(value) {\n      this.setValue(this.__normalizeValue(value));\n    },\n\n\n    /**\n     * In case a slide animation is currently running, it will be stopped.\n     * If not, the method does nothing.\n     */\n    stopSlideAnimation : function() {\n      if (this.__scrollAnimationframe) {\n        this.__scrollAnimationframe.cancelSequence();\n        this.__scrollAnimationframe = null;\n      }\n    },\n\n\n    /**\n     * Internal helper to normalize the given value concerning the minimum\n     * and maximum value.\n     * @param value {Number} The value to normalize.\n     * @return {Number} The normalized value.\n     */\n    __normalizeValue : function(value) {\n      // Bring into allowed range or fix to single step grid\n      if (value < this.getMinimum()) {\n        value = this.getMinimum();\n      } else if (value > this.getMaximum()) {\n        value = this.getMaximum();\n      } else {\n        value = this.getMinimum() + Math.round((value - this.getMinimum()) / this.getSingleStep()) * this.getSingleStep();\n      }\n      return value;\n    },\n\n\n    /**\n     * Animation helper which takes care of the animated slide.\n     * @param to {Number} The target value.\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    __animateTo : function(to, duration) {\n      to = this.__normalizeValue(to);\n      var from = this.getValue();\n\n      this.__scrollAnimationframe = new qx.bom.AnimationFrame();\n\n      this.__scrollAnimationframe.on(\"frame\", function(timePassed) {\n        this.setValue(parseInt(timePassed/duration * (to - from) + from));\n      }, this);\n\n      this.__scrollAnimationframe.on(\"end\", function() {\n        this.setValue(to);\n        this.__scrollAnimationframe = null;\n        this.fireEvent(\"slideAnimationEnd\");\n      }, this);\n\n      this.__scrollAnimationframe.startSequence(duration);\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      PROPERTY APPLY ROUTINES\n    ---------------------------------------------------------------------------\n    */\n\n    // property apply\n    _applyOrientation : function(value, old)\n    {\n      var knob = this.getChildControl(\"knob\");\n\n      // Update private flag for faster access\n      this.__isHorizontal = value === \"horizontal\";\n\n      // Toggle states and knob layout\n      if (this.__isHorizontal)\n      {\n        this.removeState(\"vertical\");\n        knob.removeState(\"vertical\");\n\n        this.addState(\"horizontal\");\n        knob.addState(\"horizontal\");\n\n        knob.setLayoutProperties({top:0, right:null, bottom:0});\n      }\n      else\n      {\n        this.removeState(\"horizontal\");\n        knob.removeState(\"horizontal\");\n\n        this.addState(\"vertical\");\n        knob.addState(\"vertical\");\n\n        knob.setLayoutProperties({right:0, bottom:null, left:0});\n      }\n\n      // Sync knob position\n      this._updateKnobPosition();\n    },\n\n\n    // property apply\n    _applyKnobFactor : function(value, old)\n    {\n      if (value != null)\n      {\n        this._updateKnobSize();\n      }\n      else\n      {\n        if (this.__isHorizontal) {\n          this.getChildControl(\"knob\").resetWidth();\n        } else {\n          this.getChildControl(\"knob\").resetHeight();\n        }\n      }\n    },\n\n\n    // property apply\n    _applyValue : function(value, old) {\n      if (value != null) {\n        this._updateKnobPosition();\n        if (this.__dragMode) {\n          this.__dragValue = [value,old];\n        } else {\n          this.fireEvent(\"changeValue\", qx.event.type.Data, [value,old]);\n        }\n      } else {\n        this.resetValue();\n      }\n    },\n\n\n    /**\n     * Helper for applyValue which fires the changeValue event.\n     */\n    _fireValue: function(){\n      if (!this.__dragValue){\n        return;\n      }\n      var tmp = this.__dragValue;\n      this.__dragValue = null;\n      this.fireEvent(\"changeValue\", qx.event.type.Data, tmp);\n    },\n\n\n    // property apply\n    _applyMinimum : function(value, old)\n    {\n      if (this.getValue() < value) {\n        this.setValue(value);\n      }\n\n      this._updateKnobPosition();\n    },\n\n\n    // property apply\n    _applyMaximum : function(value, old)\n    {\n      if (this.getValue() > value) {\n        this.setValue(value);\n      }\n\n      this._updateKnobPosition();\n    }\n  }\n});\n"
  ]
}