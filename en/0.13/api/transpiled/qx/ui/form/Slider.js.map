{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "ui",
    "core",
    "Widget",
    "implement",
    "form",
    "IForm",
    "INumberForm",
    "IRange",
    "include",
    "MForm",
    "construct",
    "orientation",
    "_setLayout",
    "layout",
    "Canvas",
    "getContentElement",
    "setAttribute",
    "addListener",
    "_onKeyPress",
    "_onRoll",
    "_onPointerDown",
    "_onPointerUp",
    "_onUpdate",
    "_onStopEvent",
    "setOrientation",
    "initOrientation",
    "events",
    "changeValue",
    "slideAnimationEnd",
    "properties",
    "appearance",
    "refine",
    "init",
    "focusable",
    "check",
    "apply",
    "value",
    "nullable",
    "minimum",
    "event",
    "maximum",
    "singleStep",
    "pageStep",
    "knobFactor",
    "members",
    "__sliderLocation",
    "__knobLocation",
    "__knobSize",
    "__dragMode",
    "__dragOffset",
    "__trackingMode",
    "__trackingDirection",
    "__trackingEnd",
    "__timer",
    "__dragTimer",
    "__lastValueEvent",
    "__dragValue",
    "__scrollAnimationframe",
    "_forwardStates",
    "invalid",
    "renderLayout",
    "left",
    "top",
    "width",
    "height",
    "_updateKnobPosition",
    "_createChildControlImpl",
    "id",
    "hash",
    "control",
    "_onPointerOver",
    "_onPointerOut",
    "_add",
    "e",
    "addState",
    "removeState",
    "getPointerType",
    "axis",
    "getOrientation",
    "delta",
    "getDelta",
    "direction",
    "slideBy",
    "getSingleStep",
    "stop",
    "isHorizontal",
    "backward",
    "forward",
    "getKeyIdentifier",
    "slideForward",
    "slideBack",
    "slidePageForward",
    "slidePageBack",
    "slideToBegin",
    "slideToEnd",
    "__isHorizontal",
    "knob",
    "getChildControl",
    "locationProperty",
    "cursorLocation",
    "getDocumentLeft",
    "getDocumentTop",
    "decorator",
    "getDecorator",
    "theme",
    "manager",
    "Decoration",
    "getInstance",
    "resolve",
    "decoratorPadding",
    "getInsets",
    "padding",
    "getPaddingLeft",
    "getPaddingTop",
    "sliderLocation",
    "bom",
    "element",
    "Location",
    "get",
    "getDomElement",
    "knobLocation",
    "getTarget",
    "Timer",
    "_fireValue",
    "start",
    "__computeTrackingEnd",
    "_onInterval",
    "_onPointerMove",
    "capture",
    "stopPropagation",
    "releaseCapture",
    "getType",
    "deltaSlider",
    "deltaPosition",
    "positionSlider",
    "_valueToPosition",
    "getValue",
    "getBounds",
    "removeListener",
    "dragStop",
    "position",
    "slideTo",
    "_positionToValue",
    "getPageStep",
    "getMinimum",
    "getMaximum",
    "availSize",
    "getInnerSize",
    "knobSize",
    "sizeProperty",
    "_updateKnobSize",
    "__slidingSpace",
    "min",
    "max",
    "old",
    "step",
    "method",
    "Math",
    "avail",
    "percent",
    "range",
    "round",
    "_setKnobPosition",
    "dec",
    "content",
    "getPadding",
    "setStyle",
    "getKnobFactor",
    "setWidth",
    "setHeight",
    "duration",
    "offset",
    "stopSlideAnimation",
    "__animateTo",
    "updatePosition",
    "setValue",
    "__normalizeValue",
    "cancelSequence",
    "to",
    "from",
    "AnimationFrame",
    "on",
    "timePassed",
    "parseInt",
    "fireEvent",
    "startSequence",
    "_applyOrientation",
    "setLayoutProperties",
    "right",
    "bottom",
    "_applyKnobFactor",
    "resetWidth",
    "resetHeight",
    "_applyValue",
    "type",
    "Data",
    "resetValue",
    "tmp",
    "_applyMinimum",
    "_applyMaximum",
    "Slider"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/form/Slider.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * The Slider widget provides a vertical or horizontal slider.\n *\n * The Slider is the classic widget for controlling a bounded value.\n * It lets the user move a slider handle along a horizontal or vertical\n * groove and translates the handle's position into an integer value\n * within the defined range.\n *\n * The Slider has very few of its own functions.\n * The most useful functions are slideTo() to set the slider directly to some\n * value; setSingleStep(), setPageStep() to set the steps; and setMinimum()\n * and setMaximum() to define the range of the slider.\n *\n * A slider accepts focus on Tab and provides both a mouse wheel and\n * a keyboard interface. The keyboard interface is the following:\n *\n * * Left/Right move a horizontal slider by one single step.\n * * Up/Down move a vertical slider by one single step.\n * * PageUp moves up one page.\n * * PageDown moves down one page.\n * * Home moves to the start (minimum).\n * * End moves to the end (maximum).\n *\n * Here are the main properties of the class:\n *\n * # <code>value</code>: The bounded integer that {@link qx.ui.form.INumberForm}\n * maintains.\n * # <code>minimum</code>: The lowest possible value.\n * # <code>maximum</code>: The highest possible value.\n * # <code>singleStep</code>: The smaller of two natural steps that an abstract\n * sliders provides and typically corresponds to the user pressing an arrow key.\n * # <code>pageStep</code>: The larger of two natural steps that an abstract\n * slider provides and typically corresponds to the user pressing PageUp or\n * PageDown.\n *\n * @childControl knob {qx.ui.core.Widget} knob to set the value of the slider\n */\nqx.Class.define(\"qx.ui.form.Slider\", {\n  extend: qx.ui.core.Widget,\n  implement: [qx.ui.form.IForm, qx.ui.form.INumberForm, qx.ui.form.IRange],\n\n  include: [qx.ui.form.MForm],\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  /**\n   * @param orientation {String?\"horizontal\"} Configure the\n   * {@link #orientation} property\n   */\n  construct(orientation) {\n    super();\n\n    // Force canvas layout\n    this._setLayout(new qx.ui.layout.Canvas());\n\n    // ARIA attrs\n    this.getContentElement().setAttribute(\"role\", \"slider\");\n\n    // Add listeners\n    this.addListener(\"keypress\", this._onKeyPress, this);\n    this.addListener(\"roll\", this._onRoll, this);\n    this.addListener(\"pointerdown\", this._onPointerDown, this);\n    this.addListener(\"pointerup\", this._onPointerUp, this);\n    this.addListener(\"losecapture\", this._onPointerUp, this);\n    this.addListener(\"resize\", this._onUpdate, this);\n\n    // Stop events\n    this.addListener(\"contextmenu\", this._onStopEvent, this);\n    this.addListener(\"tap\", this._onStopEvent, this);\n    this.addListener(\"dbltap\", this._onStopEvent, this);\n\n    // Initialize orientation\n    if (orientation != null) {\n      this.setOrientation(orientation);\n    } else {\n      this.initOrientation();\n    }\n  },\n\n  /*\n  *****************************************************************************\n     EVENTS\n  *****************************************************************************\n  */\n\n  events: {\n    /**\n     * Change event for the value.\n     */\n    changeValue: \"qx.event.type.Data\",\n\n    /** Fired as soon as the slide animation ended. */\n    slideAnimationEnd: \"qx.event.type.Event\"\n  },\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties: {\n    // overridden\n    appearance: {\n      refine: true,\n      init: \"slider\"\n    },\n\n    // overridden\n    focusable: {\n      refine: true,\n      init: true\n    },\n\n    /** Whether the slider is horizontal or vertical. */\n    orientation: {\n      check: [\"horizontal\", \"vertical\"],\n      init: \"horizontal\",\n      apply: \"_applyOrientation\"\n    },\n\n    /**\n     * The current slider value.\n     *\n     * Strictly validates according to {@link #minimum} and {@link #maximum}.\n     * Do not apply any value correction to the incoming value. If you depend\n     * on this, please use {@link #slideTo} instead.\n     */\n    value: {\n      check:\n        \"typeof value==='number'&&value>=this.getMinimum()&&value<=this.getMaximum()\",\n      init: 0,\n      apply: \"_applyValue\",\n      nullable: true\n    },\n\n    /**\n     * The minimum slider value (may be negative). This value must be smaller\n     * than {@link #maximum}.\n     */\n    minimum: {\n      check: \"Integer\",\n      init: 0,\n      apply: \"_applyMinimum\",\n      event: \"changeMinimum\"\n    },\n\n    /**\n     * The maximum slider value (may be negative). This value must be larger\n     * than {@link #minimum}.\n     */\n    maximum: {\n      check: \"Integer\",\n      init: 100,\n      apply: \"_applyMaximum\",\n      event: \"changeMaximum\"\n    },\n\n    /**\n     * The amount to increment on each event. Typically corresponds\n     * to the user pressing an arrow key.\n     */\n    singleStep: {\n      check: \"Integer\",\n      init: 1\n    },\n\n    /**\n     * The amount to increment on each event. Typically corresponds\n     * to the user pressing <code>PageUp</code> or <code>PageDown</code>.\n     */\n    pageStep: {\n      check: \"Integer\",\n      init: 10\n    },\n\n    /**\n     * Factor to apply to the width/height of the knob in relation\n     * to the dimension of the underlying area.\n     */\n    knobFactor: {\n      check: \"Number\",\n      apply: \"_applyKnobFactor\",\n      nullable: true\n    }\n  },\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members: {\n    __sliderLocation: null,\n    __knobLocation: null,\n    __knobSize: null,\n    __dragMode: null,\n    __dragOffset: null,\n    __trackingMode: null,\n    __trackingDirection: null,\n    __trackingEnd: null,\n    __timer: null,\n\n    // event delay stuff during drag\n    __dragTimer: null,\n    __lastValueEvent: null,\n    __dragValue: null,\n\n    __scrollAnimationframe: null,\n\n    // overridden\n    /**\n     * @lint ignoreReferenceField(_forwardStates)\n     */\n    _forwardStates: {\n      invalid: true\n    },\n\n    // overridden\n    renderLayout(left, top, width, height) {\n      super.renderLayout(left, top, width, height);\n      // make sure the layout engine does not override the knob position\n      this._updateKnobPosition();\n    },\n\n    // overridden\n    _createChildControlImpl(id, hash) {\n      var control;\n\n      switch (id) {\n        case \"knob\":\n          control = new qx.ui.core.Widget();\n\n          control.addListener(\"resize\", this._onUpdate, this);\n          control.addListener(\"pointerover\", this._onPointerOver, this);\n          control.addListener(\"pointerout\", this._onPointerOut, this);\n          this._add(control);\n          break;\n      }\n\n      return control || super._createChildControlImpl(id);\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT HANDLER\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Event handler for pointerover events at the knob child control.\n     *\n     * Adds the 'hovered' state\n     *\n     * @param e {qx.event.type.Pointer} Incoming pointer event\n     */\n    _onPointerOver(e) {\n      this.addState(\"hovered\");\n    },\n\n    /**\n     * Event handler for pointerout events at the knob child control.\n     *\n     * Removes the 'hovered' state\n     *\n     * @param e {qx.event.type.Pointer} Incoming pointer event\n     */\n    _onPointerOut(e) {\n      this.removeState(\"hovered\");\n    },\n\n    /**\n     * Listener of roll event\n     *\n     * @param e {qx.event.type.Roll} Incoming event object\n     */\n    _onRoll(e) {\n      // only wheel\n      if (e.getPointerType() != \"wheel\") {\n        return;\n      }\n\n      var axis = this.getOrientation() === \"horizontal\" ? \"x\" : \"y\";\n      var delta = e.getDelta()[axis];\n\n      var direction = delta > 0 ? 1 : delta < 0 ? -1 : 0;\n      this.slideBy(direction * this.getSingleStep());\n\n      e.stop();\n    },\n\n    /**\n     * Event handler for keypress events.\n     *\n     * Adds support for arrow keys, page up, page down, home and end keys.\n     *\n     * @param e {qx.event.type.KeySequence} Incoming keypress event\n     */\n    _onKeyPress(e) {\n      var isHorizontal = this.getOrientation() === \"horizontal\";\n      var backward = isHorizontal ? \"Left\" : \"Up\";\n      var forward = isHorizontal ? \"Right\" : \"Down\";\n\n      switch (e.getKeyIdentifier()) {\n        case forward:\n          this.slideForward();\n          break;\n\n        case backward:\n          this.slideBack();\n          break;\n\n        case \"PageDown\":\n          this.slidePageForward(100);\n          break;\n\n        case \"PageUp\":\n          this.slidePageBack(100);\n          break;\n\n        case \"Home\":\n          this.slideToBegin(200);\n          break;\n\n        case \"End\":\n          this.slideToEnd(200);\n          break;\n\n        default:\n          return;\n      }\n\n      // Stop processed events\n      e.stop();\n    },\n\n    /**\n     * Listener of pointerdown event. Initializes drag or tracking mode.\n     *\n     * @param e {qx.event.type.Pointer} Incoming event object\n     */\n    _onPointerDown(e) {\n      // this can happen if the user releases the button while dragging outside\n      // of the browser viewport\n      if (this.__dragMode) {\n        return;\n      }\n\n      var isHorizontal = this.__isHorizontal;\n      var knob = this.getChildControl(\"knob\");\n\n      var locationProperty = isHorizontal ? \"left\" : \"top\";\n\n      var cursorLocation = isHorizontal\n        ? e.getDocumentLeft()\n        : e.getDocumentTop();\n\n      var decorator = this.getDecorator();\n      decorator = qx.theme.manager.Decoration.getInstance().resolve(decorator);\n      if (isHorizontal) {\n        var decoratorPadding = decorator ? decorator.getInsets().left : 0;\n        var padding = (this.getPaddingLeft() || 0) + decoratorPadding;\n      } else {\n        var decoratorPadding = decorator ? decorator.getInsets().top : 0;\n        var padding = (this.getPaddingTop() || 0) + decoratorPadding;\n      }\n\n      var sliderLocation = (this.__sliderLocation = qx.bom.element.Location.get(\n        this.getContentElement().getDomElement()\n      )[locationProperty]);\n      sliderLocation += padding;\n\n      var knobLocation = (this.__knobLocation = qx.bom.element.Location.get(\n        knob.getContentElement().getDomElement()\n      )[locationProperty]);\n\n      if (e.getTarget() === knob) {\n        // Switch into drag mode\n        this.__dragMode = true;\n        if (!this.__dragTimer) {\n          // create a timer to fire delayed dragging events if dragging stops.\n          this.__dragTimer = new qx.event.Timer(100);\n          this.__dragTimer.addListener(\"interval\", this._fireValue, this);\n        }\n        this.__dragTimer.start();\n        // Compute dragOffset (includes both: inner position of the widget and\n        // cursor position on knob)\n        this.__dragOffset = cursorLocation + sliderLocation - knobLocation;\n\n        // add state\n        knob.addState(\"pressed\");\n      } else {\n        // Switch into tracking mode\n        this.__trackingMode = true;\n\n        // Detect tracking direction\n        this.__trackingDirection = cursorLocation <= knobLocation ? -1 : 1;\n\n        // Compute end value\n        this.__computeTrackingEnd(e);\n\n        // Directly call interval method once\n        this._onInterval();\n\n        // Initialize timer (when needed)\n        if (!this.__timer) {\n          this.__timer = new qx.event.Timer(100);\n          this.__timer.addListener(\"interval\", this._onInterval, this);\n        }\n\n        // Start timer\n        this.__timer.start();\n      }\n\n      // Register move listener\n      this.addListener(\"pointermove\", this._onPointerMove, this);\n\n      // Activate capturing\n      this.capture();\n\n      // Stop event\n      e.stopPropagation();\n    },\n\n    /**\n     * Listener of pointerup event. Used for cleanup of previously\n     * initialized modes.\n     *\n     * @param e {qx.event.type.Pointer} Incoming event object\n     */\n    _onPointerUp(e) {\n      if (this.__dragMode) {\n        // Release capture mode\n        this.releaseCapture();\n\n        // Cleanup status flags\n        delete this.__dragMode;\n\n        // as we come out of drag mode, make\n        // sure content gets synced\n        this.__dragTimer.stop();\n        this._fireValue();\n\n        delete this.__dragOffset;\n\n        // remove state\n        this.getChildControl(\"knob\").removeState(\"pressed\");\n\n        // it's necessary to check whether the cursor is over the knob widget to be able to\n        // to decide whether to remove the 'hovered' state.\n        if (e.getType() === \"pointerup\") {\n          var deltaSlider;\n          var deltaPosition;\n          var positionSlider;\n\n          if (this.__isHorizontal) {\n            deltaSlider =\n              e.getDocumentLeft() -\n              (this._valueToPosition(this.getValue()) + this.__sliderLocation);\n\n            positionSlider = qx.bom.element.Location.get(\n              this.getContentElement().getDomElement()\n            )[\"top\"];\n            deltaPosition =\n              e.getDocumentTop() -\n              (positionSlider + this.getChildControl(\"knob\").getBounds().top);\n          } else {\n            deltaSlider =\n              e.getDocumentTop() -\n              (this._valueToPosition(this.getValue()) + this.__sliderLocation);\n\n            positionSlider = qx.bom.element.Location.get(\n              this.getContentElement().getDomElement()\n            )[\"left\"];\n            deltaPosition =\n              e.getDocumentLeft() -\n              (positionSlider + this.getChildControl(\"knob\").getBounds().left);\n          }\n\n          if (\n            deltaPosition < 0 ||\n            deltaPosition > this.__knobSize ||\n            deltaSlider < 0 ||\n            deltaSlider > this.__knobSize\n          ) {\n            this.getChildControl(\"knob\").removeState(\"hovered\");\n          }\n        }\n      } else if (this.__trackingMode) {\n        // Stop timer interval\n        this.__timer.stop();\n\n        // Release capture mode\n        this.releaseCapture();\n\n        // Cleanup status flags\n        delete this.__trackingMode;\n        delete this.__trackingDirection;\n        delete this.__trackingEnd;\n      }\n\n      // Remove move listener again\n      this.removeListener(\"pointermove\", this._onPointerMove, this);\n\n      // Stop event\n      if (e.getType() === \"pointerup\") {\n        e.stopPropagation();\n      }\n    },\n\n    /**\n     * Listener of pointermove event for the knob. Only used in drag mode.\n     *\n     * @param e {qx.event.type.Pointer} Incoming event object\n     */\n    _onPointerMove(e) {\n      if (this.__dragMode) {\n        var dragStop = this.__isHorizontal\n          ? e.getDocumentLeft()\n          : e.getDocumentTop();\n        var position = dragStop - this.__dragOffset;\n\n        this.slideTo(this._positionToValue(position));\n      } else if (this.__trackingMode) {\n        // Update tracking end on pointermove\n        this.__computeTrackingEnd(e);\n      }\n\n      // Stop event\n      e.stopPropagation();\n    },\n\n    /**\n     * Listener of interval event by the internal timer. Only used\n     * in tracking sequences.\n     *\n     * @param e {qx.event.type.Event} Incoming event object\n     */\n    _onInterval(e) {\n      // Compute new value\n      var value =\n        this.getValue() + this.__trackingDirection * this.getPageStep();\n\n      // Limit value\n      if (value < this.getMinimum()) {\n        value = this.getMinimum();\n      } else if (value > this.getMaximum()) {\n        value = this.getMaximum();\n      }\n\n      // Stop at tracking position (where the pointer is pressed down)\n      var slideBack = this.__trackingDirection == -1;\n      if (\n        (slideBack && value <= this.__trackingEnd) ||\n        (!slideBack && value >= this.__trackingEnd)\n      ) {\n        value = this.__trackingEnd;\n      }\n\n      // Finally slide to the desired position\n      this.slideTo(value);\n    },\n\n    /**\n     * Listener of resize event for both the slider itself and the knob.\n     *\n     * @param e {qx.event.type.Data} Incoming event object\n     */\n    _onUpdate(e) {\n      // Update sliding space\n      var availSize = this.getInnerSize();\n      var knobSize = this.getChildControl(\"knob\").getBounds();\n      var sizeProperty = this.__isHorizontal ? \"width\" : \"height\";\n\n      // Sync knob size\n      this._updateKnobSize();\n\n      // Store knob size\n      this.__slidingSpace = availSize[sizeProperty] - knobSize[sizeProperty];\n      this.__knobSize = knobSize[sizeProperty];\n\n      // Update knob position (sliding space must be updated first)\n      this._updateKnobPosition();\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n      UTILS\n    ---------------------------------------------------------------------------\n    */\n\n    /** @type {Boolean} Whether the slider is laid out horizontally */\n    __isHorizontal: false,\n\n    /**\n     * @type {Integer} Available space for knob to slide on, computed on resize of\n     * the widget\n     */\n    __slidingSpace: 0,\n\n    /**\n     * Computes the value where the tracking should end depending on\n     * the current pointer position.\n     *\n     * @param e {qx.event.type.Pointer} Incoming pointer event\n     */\n    __computeTrackingEnd(e) {\n      var isHorizontal = this.__isHorizontal;\n      var cursorLocation = isHorizontal\n        ? e.getDocumentLeft()\n        : e.getDocumentTop();\n      var sliderLocation = this.__sliderLocation;\n      var knobLocation = this.__knobLocation;\n      var knobSize = this.__knobSize;\n\n      // Compute relative position\n      var position = cursorLocation - sliderLocation;\n      if (cursorLocation >= knobLocation) {\n        position -= knobSize;\n      }\n\n      // Compute stop value\n      var value = this._positionToValue(position);\n\n      var min = this.getMinimum();\n      var max = this.getMaximum();\n\n      if (value < min) {\n        value = min;\n      } else if (value > max) {\n        value = max;\n      } else {\n        var old = this.getValue();\n        var step = this.getPageStep();\n        var method = this.__trackingDirection < 0 ? \"floor\" : \"ceil\";\n\n        // Fix to page step\n        value = old + Math[method]((value - old) / step) * step;\n      }\n\n      // Store value when undefined, otherwise only when it follows the\n      // current direction e.g. goes up or down\n      if (\n        this.__trackingEnd == null ||\n        (this.__trackingDirection == -1 && value <= this.__trackingEnd) ||\n        (this.__trackingDirection == 1 && value >= this.__trackingEnd)\n      ) {\n        this.__trackingEnd = value;\n      }\n    },\n\n    /**\n     * Converts the given position to a value.\n     *\n     * Does not respect single or page step.\n     *\n     * @param position {Integer} Position to use\n     * @return {Integer} Resulting value (rounded)\n     */\n    _positionToValue(position) {\n      // Reading available space\n      var avail = this.__slidingSpace;\n\n      // Protect undefined value (before initial resize) and division by zero\n      if (avail == null || avail == 0) {\n        return 0;\n      }\n\n      // Compute and limit percent\n      var percent = position / avail;\n      if (percent < 0) {\n        percent = 0;\n      } else if (percent > 1) {\n        percent = 1;\n      }\n\n      // Compute range\n      var range = this.getMaximum() - this.getMinimum();\n\n      // Compute value\n      return this.getMinimum() + Math.round(range * percent);\n    },\n\n    /**\n     * Converts the given value to a position to place\n     * the knob to.\n     *\n     * @param value {Integer} Value to use\n     * @return {Integer} Computed position (rounded)\n     */\n    _valueToPosition(value) {\n      // Reading available space\n      var avail = this.__slidingSpace;\n      if (avail == null) {\n        return 0;\n      }\n\n      // Computing range\n      var range = this.getMaximum() - this.getMinimum();\n\n      // Protect division by zero\n      if (range == 0) {\n        return 0;\n      }\n\n      // Translating value to distance from minimum\n      var value = value - this.getMinimum();\n\n      // Compute and limit percent\n      var percent = value / range;\n      if (percent < 0) {\n        percent = 0;\n      } else if (percent > 1) {\n        percent = 1;\n      }\n\n      // Compute position from available space and percent\n      return Math.round(avail * percent);\n    },\n\n    /**\n     * Updates the knob position following the currently configured\n     * value. Useful on reflows where the dimensions of the slider\n     * itself have been modified.\n     *\n     */\n    _updateKnobPosition() {\n      this._setKnobPosition(this._valueToPosition(this.getValue()));\n    },\n\n    /**\n     * Moves the knob to the given position.\n     *\n     * @param position {Integer} Any valid position (needs to be\n     *   greater or equal than zero)\n     */\n    _setKnobPosition(position) {\n      // Use the DOM Element to prevent unnecessary layout recalculations\n      var knob = this.getChildControl(\"knob\");\n      var dec = this.getDecorator();\n      dec = qx.theme.manager.Decoration.getInstance().resolve(dec);\n      var content = knob.getContentElement();\n      if (this.__isHorizontal) {\n        if (dec && dec.getPadding()) {\n          position += dec.getPadding().left;\n        }\n        position += this.getPaddingLeft() || 0;\n        content.setStyle(\"left\", position + \"px\", true);\n      } else {\n        if (dec && dec.getPadding()) {\n          position += dec.getPadding().top;\n        }\n        position += this.getPaddingTop() || 0;\n        content.setStyle(\"top\", position + \"px\", true);\n      }\n    },\n\n    /**\n     * Reconfigures the size of the knob depending on\n     * the optionally defined {@link #knobFactor}.\n     *\n     */\n    _updateKnobSize() {\n      // Compute knob size\n      var knobFactor = this.getKnobFactor();\n      if (knobFactor == null) {\n        return;\n      }\n\n      // Ignore when not rendered yet\n      var avail = this.getInnerSize();\n      if (avail == null) {\n        return;\n      }\n\n      // Read size property\n      if (this.__isHorizontal) {\n        this.getChildControl(\"knob\").setWidth(\n          Math.round(knobFactor * avail.width)\n        );\n      } else {\n        this.getChildControl(\"knob\").setHeight(\n          Math.round(knobFactor * avail.height)\n        );\n      }\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n      SLIDE METHODS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Slides backward to the minimum value\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    slideToBegin(duration) {\n      this.slideTo(this.getMinimum(), duration);\n    },\n\n    /**\n     * Slides forward to the maximum value\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    slideToEnd(duration) {\n      this.slideTo(this.getMaximum(), duration);\n    },\n\n    /**\n     * Slides forward (right or bottom depending on orientation)\n     *\n     */\n    slideForward() {\n      this.slideBy(this.getSingleStep());\n    },\n\n    /**\n     * Slides backward (to left or top depending on orientation)\n     *\n     */\n    slideBack() {\n      this.slideBy(-this.getSingleStep());\n    },\n\n    /**\n     * Slides a page forward (to right or bottom depending on orientation)\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    slidePageForward(duration) {\n      this.slideBy(this.getPageStep(), duration);\n    },\n\n    /**\n     * Slides a page backward (to left or top depending on orientation)\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    slidePageBack(duration) {\n      this.slideBy(-this.getPageStep(), duration);\n    },\n\n    /**\n     * Slides by the given offset.\n     *\n     * This method works with the value, not with the coordinate.\n     *\n     * @param offset {Integer} Offset to scroll by\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    slideBy(offset, duration) {\n      this.slideTo(this.getValue() + offset, duration);\n    },\n\n    /**\n     * Slides to the given value\n     *\n     * This method works with the value, not with the coordinate.\n     *\n     * @param value {Integer} Scroll to a value between the defined\n     *   minimum and maximum.\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    slideTo(value, duration) {\n      this.stopSlideAnimation();\n\n      if (duration) {\n        this.__animateTo(value, duration);\n      } else {\n        this.updatePosition(value);\n      }\n    },\n\n    /**\n     * Updates the position property considering the minimum and maximum values.\n     * @param value {Number} The new position.\n     */\n    updatePosition(value) {\n      this.setValue(this.__normalizeValue(value));\n    },\n\n    /**\n     * In case a slide animation is currently running, it will be stopped.\n     * If not, the method does nothing.\n     */\n    stopSlideAnimation() {\n      if (this.__scrollAnimationframe) {\n        this.__scrollAnimationframe.cancelSequence();\n        this.__scrollAnimationframe = null;\n      }\n    },\n\n    /**\n     * Internal helper to normalize the given value concerning the minimum\n     * and maximum value.\n     * @param value {Number} The value to normalize.\n     * @return {Number} The normalized value.\n     */\n    __normalizeValue(value) {\n      // Bring into allowed range or fix to single step grid\n      if (value < this.getMinimum()) {\n        value = this.getMinimum();\n      } else if (value > this.getMaximum()) {\n        value = this.getMaximum();\n      } else {\n        value =\n          this.getMinimum() +\n          Math.round((value - this.getMinimum()) / this.getSingleStep()) *\n            this.getSingleStep();\n      }\n      return value;\n    },\n\n    /**\n     * Animation helper which takes care of the animated slide.\n     * @param to {Number} The target value.\n     * @param duration {Number} The time in milliseconds the slide to should take.\n     */\n    __animateTo(to, duration) {\n      to = this.__normalizeValue(to);\n      var from = this.getValue();\n\n      this.__scrollAnimationframe = new qx.bom.AnimationFrame();\n\n      this.__scrollAnimationframe.on(\n        \"frame\",\n        function (timePassed) {\n          this.setValue(parseInt((timePassed / duration) * (to - from) + from));\n        },\n        this\n      );\n\n      this.__scrollAnimationframe.on(\n        \"end\",\n        function () {\n          this.setValue(to);\n          this.__scrollAnimationframe = null;\n          this.fireEvent(\"slideAnimationEnd\");\n        },\n        this\n      );\n\n      this.__scrollAnimationframe.startSequence(duration);\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n      PROPERTY APPLY ROUTINES\n    ---------------------------------------------------------------------------\n    */\n\n    // property apply\n    _applyOrientation(value, old) {\n      // ARIA attrs\n      this.getContentElement().setAttribute(\"aria-orientation\", value);\n\n      var knob = this.getChildControl(\"knob\");\n\n      // Update private flag for faster access\n      this.__isHorizontal = value === \"horizontal\";\n\n      // Toggle states and knob layout\n      if (this.__isHorizontal) {\n        this.removeState(\"vertical\");\n        knob.removeState(\"vertical\");\n\n        this.addState(\"horizontal\");\n        knob.addState(\"horizontal\");\n\n        knob.setLayoutProperties({ top: 0, right: null, bottom: 0 });\n      } else {\n        this.removeState(\"horizontal\");\n        knob.removeState(\"horizontal\");\n\n        this.addState(\"vertical\");\n        knob.addState(\"vertical\");\n\n        knob.setLayoutProperties({ right: 0, bottom: null, left: 0 });\n      }\n\n      // Sync knob position\n      this._updateKnobPosition();\n    },\n\n    // property apply\n    _applyKnobFactor(value, old) {\n      if (value != null) {\n        this._updateKnobSize();\n      } else {\n        if (this.__isHorizontal) {\n          this.getChildControl(\"knob\").resetWidth();\n        } else {\n          this.getChildControl(\"knob\").resetHeight();\n        }\n      }\n    },\n\n    // property apply\n    _applyValue(value, old) {\n      if (value != null) {\n        // ARIA attrs\n        this.getContentElement().setAttribute(\"aria-valuenow\", value);\n\n        this._updateKnobPosition();\n        if (this.__dragMode) {\n          this.__dragValue = [value, old];\n        } else {\n          this.fireEvent(\"changeValue\", qx.event.type.Data, [value, old]);\n        }\n      } else {\n        this.resetValue();\n      }\n    },\n\n    /**\n     * Helper for applyValue which fires the changeValue event.\n     */\n    _fireValue() {\n      if (!this.__dragValue) {\n        return;\n      }\n      var tmp = this.__dragValue;\n      this.__dragValue = null;\n      this.fireEvent(\"changeValue\", qx.event.type.Data, tmp);\n    },\n\n    // property apply\n    _applyMinimum(value, old) {\n      // ARIA attrs\n      this.getContentElement().setAttribute(\"aria-valuemin\", value);\n\n      if (this.getValue() < value) {\n        this.setValue(value);\n      }\n\n      this._updateKnobPosition();\n    },\n\n    // property apply\n    _applyMaximum(value, old) {\n      // ARIA attrs\n      this.getContentElement().setAttribute(\"aria-valuemax\", value);\n\n      if (this.getValue() > value) {\n        this.setValue(value);\n      }\n\n      this._updateKnobPosition();\n    }\n  }\n});\n"
  ],
  "mappings": "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"
}