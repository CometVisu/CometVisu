{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "constructor",
    "call",
    "__formItems",
    "__asyncResults",
    "setRequiredFieldMessage",
    "locale",
    "Manager",
    "tr",
    "events",
    "changeValid",
    "complete",
    "properties",
    "validator",
    "check",
    "init",
    "nullable",
    "invalidMessage",
    "requiredFieldMessage",
    "context",
    "members",
    "__valid",
    "__syncValid",
    "add",
    "formItem",
    "__supportsInvalid",
    "Error",
    "__supportsSingleSelection",
    "getValue",
    "dataEntry",
    "item",
    "valid",
    "push",
    "remove",
    "items",
    "i",
    "len",
    "length",
    "splice",
    "getItems",
    "validate",
    "validatorResult",
    "_validateRequired",
    "_validateItem",
    "formValid",
    "__validateForm",
    "lang",
    "Type",
    "isBoolean",
    "_setValid",
    "isEmpty",
    "fireEvent",
    "getRequired",
    "getSelection",
    "__supportsDataBindingSelection",
    "getLength",
    "value",
    "setValid",
    "individualMessage",
    "getRequiredInvalidMessage",
    "message",
    "getRequiredFieldMessage",
    "setInvalidMessage",
    "__isAsyncValidator",
    "toHashCode",
    "undefined",
    "e",
    "ValidationError",
    "type",
    "BaseError",
    "DEFAULTMESSAGE",
    "getComment",
    "__P_375_6",
    "formValidator",
    "getValidator",
    "getContext",
    "validateForm",
    "__P_375_8",
    "async",
    "isFunction",
    "isSubClassOf",
    "ui",
    "form",
    "validation",
    "AsyncValidator",
    "__P_375_4",
    "clazz",
    "hasInterface",
    "IForm",
    "__P_375_5",
    "ISingleSelection",
    "__P_375_7",
    "data",
    "controller",
    "ISelection",
    "_showToolTip",
    "oldValue",
    "fireDataEvent",
    "tooltip",
    "getInstance",
    "getSharedErrorTooltip",
    "firstInvalid",
    "isValid",
    "getContentLocation",
    "isSeeable",
    "msg",
    "getInvalidMessage",
    "Environment",
    "get",
    "setLabel",
    "getPlaceMethod",
    "location",
    "top",
    "getOffsetTop",
    "placeToPoint",
    "left",
    "right",
    "placeToWidget",
    "show",
    "exclude",
    "getValid",
    "getInvalidMessages",
    "messages",
    "getInvalidFormItems",
    "res",
    "reset",
    "setItemValid",
    "__checkValidationComplete",
    "setFormValid",
    "__P_375_9",
    "hash",
    "currentResult",
    "destruct",
    "environment"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/form/validation/Manager.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Martin Wittemann (martinwittemann)\r\n\r\n************************************************************************ */\r\n/**\r\n * This validation manager is responsible for validation of forms.\r\n *\r\n * @ignore(qx.ui.tooltip)\r\n * @ignore(qx.ui.tooltip.Manager.*)\r\n */\r\nqx.Class.define(\"qx.ui.form.validation.Manager\", {\r\n  extend: qx.core.Object,\r\n\r\n  construct() {\r\n    super();\r\n\r\n    // storage for all form items\r\n    this.__formItems = [];\r\n    // storage for all results of async validation calls\r\n    this.__asyncResults = {};\r\n    // set the default required field message\r\n    this.setRequiredFieldMessage(\r\n      qx.locale.Manager.tr(\"This field is required\")\r\n    );\r\n  },\r\n\r\n  events: {\r\n    /**\r\n     * Change event for the valid state.\r\n     */\r\n    changeValid: \"qx.event.type.Data\",\r\n\r\n    /**\r\n     * Signals that the validation is done. This is not needed on synchronous\r\n     * validation (validation is done right after the call) but very important\r\n     * in the case an asynchronous validator will be used.\r\n     */\r\n    complete: \"qx.event.type.Event\"\r\n  },\r\n\r\n  properties: {\r\n    /**\r\n     * The validator of the form itself. You can set a function (for\r\n     * synchronous validation) or a {@link qx.ui.form.validation.AsyncValidator}.\r\n     * In both cases, the function can have all added form items as first\r\n     * argument and the manager as a second argument. The manager should be used\r\n     * to set the {@link #invalidMessage}.\r\n     *\r\n     * Keep in mind that the validator is optional if you don't need the\r\n     * validation in the context of the whole form.\r\n     * @type {Function | AsyncValidator}\r\n     */\r\n    validator: {\r\n      check:\r\n        \"value instanceof Function || qx.Class.isSubClassOf(value.constructor, qx.ui.form.validation.AsyncValidator)\",\r\n      init: null,\r\n      nullable: true\r\n    },\r\n\r\n    /**\r\n     * The invalid message stores the message why the form validation\r\n     * failed. It will be added to the array returned by\r\n     * {@link #getInvalidMessages}.\r\n     */\r\n    invalidMessage: {\r\n      check: \"String\",\r\n      init: \"\"\r\n    },\r\n\r\n    /**\r\n     * This message will be shown if a required field is empty and no individual\r\n     * {@link qx.ui.form.MForm#requiredInvalidMessage} is given.\r\n     */\r\n    requiredFieldMessage: {\r\n      check: \"String\",\r\n      init: \"\"\r\n    },\r\n\r\n    /**\r\n     * The context for the form validation.\r\n     */\r\n    context: {\r\n      nullable: true\r\n    }\r\n  },\r\n\r\n  members: {\r\n    __formItems: null,\r\n    __valid: null,\r\n    __asyncResults: null,\r\n    __syncValid: null,\r\n\r\n    /**\r\n     * Add a form item to the validation manager.\r\n     *\r\n     * The form item has to implement at least two interfaces:\r\n     * <ol>\r\n     *   <li>The {@link qx.ui.form.IForm} Interface</li>\r\n     *   <li>One of the following interfaces:\r\n     *     <ul>\r\n     *       <li>{@link qx.ui.form.IBooleanForm}</li>\r\n     *       <li>{@link qx.ui.form.IColorForm}</li>\r\n     *       <li>{@link qx.ui.form.IDateForm}</li>\r\n     *       <li>{@link qx.ui.form.INumberForm}</li>\r\n     *       <li>{@link qx.ui.form.IStringForm}</li>\r\n     *     </ul>\r\n     *   </li>\r\n     * </ol>\r\n     * The validator can be a synchronous or asynchronous validator. In\r\n     * both cases the validator can either returns a boolean or fire an\r\n     * {@link qx.core.ValidationError}. For synchronous validation, a plain\r\n     * JavaScript function should be used. For all asynchronous validations,\r\n     * a {@link qx.ui.form.validation.AsyncValidator} is needed to wrap the\r\n     * plain function.\r\n     *\r\n     * @param formItem {qx.ui.core.Widget} The form item to add.\r\n     * @param validator {Function | qx.ui.form.validation.AsyncValidator}\r\n     *   The validator.\r\n     * @param context {var?null} The context of the validator.\r\n     */\r\n    add(formItem, validator, context) {\r\n      // check for the form API\r\n      if (!this.__supportsInvalid(formItem)) {\r\n        throw new Error(\"Added widget not supported.\");\r\n      }\r\n      // check for the data type\r\n      if (this.__supportsSingleSelection(formItem) && !formItem.getValue) {\r\n        // check for a validator\r\n        if (validator != null) {\r\n          throw new Error(\r\n            \"Widgets supporting selection can only be validated \" +\r\n              \"in the form validator\"\r\n          );\r\n        }\r\n      }\r\n      var dataEntry = {\r\n        item: formItem,\r\n        validator: validator,\r\n        valid: null,\r\n        context: context\r\n      };\r\n\r\n      this.__formItems.push(dataEntry);\r\n    },\r\n\r\n    /**\r\n     * Remove a form item from the validation manager.\r\n     *\r\n     * @param formItem {qx.ui.core.Widget} The form item to remove.\r\n     * @return {qx.ui.core.Widget?null} The removed form item or\r\n     *  <code>null</code> if the item could not be found.\r\n     */\r\n    remove(formItem) {\r\n      var items = this.__formItems;\r\n\r\n      for (var i = 0, len = items.length; i < len; i++) {\r\n        if (formItem === items[i].item) {\r\n          items.splice(i, 1);\r\n          return formItem;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * Returns registered form items from the validation manager.\r\n     *\r\n     * @return {Array} The form items which will be validated.\r\n     */\r\n    getItems() {\r\n      var items = [];\r\n      for (var i = 0; i < this.__formItems.length; i++) {\r\n        items.push(this.__formItems[i].item);\r\n      }\r\n      return items;\r\n    },\r\n\r\n    /**\r\n     * Invokes the validation. If only synchronous validators are set, the\r\n     * result of the whole validation is available at the end of the method\r\n     * and can be returned. If an asynchronous validator is set, the result\r\n     * is still unknown at the end of this method so nothing will be returned.\r\n     * In both cases, a {@link #complete} event will be fired if the validation\r\n     * has ended. The result of the validation can then be accessed with the\r\n     * {@link #getValid} method.\r\n     *\r\n     * @return {Boolean|undefined} The validation result, if available.\r\n     */\r\n    validate() {\r\n      var valid = true;\r\n      this.__syncValid = true; // collaboration of all synchronous validations\r\n      var items = [];\r\n\r\n      // check all validators for the added form items\r\n      for (var i = 0; i < this.__formItems.length; i++) {\r\n        var formItem = this.__formItems[i].item;\r\n        var validator = this.__formItems[i].validator;\r\n\r\n        // store the items in case of form validation\r\n        items.push(formItem);\r\n\r\n        // ignore all form items without a validator\r\n        if (validator == null) {\r\n          // check for the required property\r\n          var validatorResult = this._validateRequired(formItem);\r\n          valid = valid && validatorResult;\r\n          this.__syncValid = validatorResult && this.__syncValid;\r\n          continue;\r\n        }\r\n\r\n        var validatorResult = this._validateItem(\r\n          this.__formItems[i],\r\n          formItem.getValue()\r\n        );\r\n\r\n        // keep that order to ensure that null is returned on async cases\r\n        valid = validatorResult && valid;\r\n        if (validatorResult != null) {\r\n          this.__syncValid = validatorResult && this.__syncValid;\r\n        }\r\n      }\r\n\r\n      // check the form validator (be sure to invoke it even if the form\r\n      // items are already false, so keep the order!)\r\n      var formValid = this.__validateForm(items);\r\n      if (qx.lang.Type.isBoolean(formValid)) {\r\n        this.__syncValid = formValid && this.__syncValid;\r\n      }\r\n      valid = formValid && valid;\r\n\r\n      this._setValid(valid);\r\n\r\n      if (qx.lang.Object.isEmpty(this.__asyncResults)) {\r\n        this.fireEvent(\"complete\");\r\n      }\r\n      return valid;\r\n    },\r\n\r\n    /**\r\n     * Checks if the form item is required. If so, the value is checked\r\n     * and the result will be returned. If the form item is not required, true\r\n     * will be returned.\r\n     *\r\n     * @param formItem {qx.ui.core.Widget} The form item to check.\r\n     * @return {var} Validation result\r\n     */\r\n    _validateRequired(formItem) {\r\n      if (formItem.getRequired()) {\r\n        var validatorResult;\r\n        // if its a widget supporting the selection\r\n        if (this.__supportsSingleSelection(formItem)) {\r\n          validatorResult = !!formItem.getSelection()[0];\r\n        } else if (this.__supportsDataBindingSelection(formItem)) {\r\n          validatorResult = formItem.getSelection().getLength() > 0;\r\n        } else {\r\n          var value = formItem.getValue();\r\n          validatorResult = !!value || value === 0;\r\n        }\r\n        formItem.setValid(validatorResult);\r\n        var individualMessage = formItem.getRequiredInvalidMessage();\r\n        var message = individualMessage\r\n          ? individualMessage\r\n          : this.getRequiredFieldMessage();\r\n        formItem.setInvalidMessage(message);\r\n        return validatorResult;\r\n      }\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Validates a form item. This method handles the differences of\r\n     * synchronous and asynchronous validation and returns the result of the\r\n     * validation if possible (synchronous cases). If the validation is\r\n     * asynchronous, null will be returned.\r\n     *\r\n     * @param dataEntry {Object} The map stored in {@link #add}\r\n     * @param value {var} The currently set value\r\n     * @return {Boolean|null} Validation result or <code>null</code> for async\r\n     * validation\r\n     */\r\n    _validateItem(dataEntry, value) {\r\n      var formItem = dataEntry.item;\r\n      var context = dataEntry.context;\r\n      var validator = dataEntry.validator;\r\n\r\n      // check for asynchronous validation\r\n      if (this.__isAsyncValidator(validator)) {\r\n        // used to check if all async validations are done\r\n        this.__asyncResults[formItem.toHashCode()] = null;\r\n        validator.validate(formItem, formItem.getValue(), this, context);\r\n        return null;\r\n      }\r\n\r\n      var validatorResult = null;\r\n\r\n      try {\r\n        var validatorResult = validator.call(context || this, value, formItem);\r\n        if (validatorResult === undefined) {\r\n          validatorResult = true;\r\n        }\r\n      } catch (e) {\r\n        if (e instanceof qx.core.ValidationError) {\r\n          validatorResult = false;\r\n          if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {\r\n            var invalidMessage = e.message;\r\n          } else {\r\n            var invalidMessage = e.getComment();\r\n          }\r\n          formItem.setInvalidMessage(invalidMessage);\r\n        } else {\r\n          throw e;\r\n        }\r\n      }\r\n\r\n      formItem.setValid(validatorResult);\r\n      dataEntry.valid = validatorResult;\r\n\r\n      return validatorResult;\r\n    },\r\n\r\n    /**\r\n     * Validates the form. It checks for asynchronous validation and handles\r\n     * the differences to synchronous validation. If no form validator is given,\r\n     * true will be returned. If a synchronous validator is given, the\r\n     * validation result will be returned. In asynchronous cases, null will be\r\n     * returned cause the result is not available.\r\n     *\r\n     * @param items {qx.ui.core.Widget[]} An array of all form items.\r\n     * @return {Boolean|null} description\r\n     */\r\n    __validateForm(items) {\r\n      var formValidator = this.getValidator();\r\n      var context = this.getContext() || this;\r\n\r\n      if (formValidator == null) {\r\n        return true;\r\n      }\r\n\r\n      // reset the invalidMessage\r\n      this.setInvalidMessage(\"\");\r\n\r\n      if (this.__isAsyncValidator(formValidator)) {\r\n        this.__asyncResults[this.toHashCode()] = null;\r\n        formValidator.validateForm(items, this, context);\r\n        return null;\r\n      }\r\n\r\n      try {\r\n        var formValid = formValidator.call(context, items, this);\r\n        if (formValid === undefined) {\r\n          formValid = true;\r\n        }\r\n      } catch (e) {\r\n        if (e instanceof qx.core.ValidationError) {\r\n          formValid = false;\r\n\r\n          if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {\r\n            var invalidMessage = e.message;\r\n          } else {\r\n            var invalidMessage = e.getComment();\r\n          }\r\n          this.setInvalidMessage(invalidMessage);\r\n        } else {\r\n          throw e;\r\n        }\r\n      }\r\n      return formValid;\r\n    },\r\n\r\n    /**\r\n     * Helper function which checks, if the given validator is synchronous\r\n     * or asynchronous.\r\n     *\r\n     * @param validator {Function|qx.ui.form.validation.AsyncValidator}\r\n     *   The validator to check.\r\n     * @return {Boolean} True, if the given validator is asynchronous.\r\n     */\r\n    __isAsyncValidator(validator) {\r\n      var async = false;\r\n      if (!qx.lang.Type.isFunction(validator)) {\r\n        async = qx.Class.isSubClassOf(\r\n          validator.constructor,\r\n          qx.ui.form.validation.AsyncValidator\r\n        );\r\n      }\r\n      return async;\r\n    },\r\n\r\n    /**\r\n     * Returns true, if the given item implements the {@link qx.ui.form.IForm}\r\n     * interface.\r\n     *\r\n     * @param formItem {qx.core.Object} The item to check.\r\n     * @return {Boolean} true, if the given item implements the\r\n     *   necessary interface.\r\n     */\r\n    __supportsInvalid(formItem) {\r\n      var clazz = formItem.constructor;\r\n      return qx.Class.hasInterface(clazz, qx.ui.form.IForm);\r\n    },\r\n\r\n    /**\r\n     * Returns true, if the given item implements the\r\n     * {@link qx.ui.core.ISingleSelection} interface.\r\n     *\r\n     * @param formItem {qx.core.Object} The item to check.\r\n     * @return {Boolean} true, if the given item implements the\r\n     *   necessary interface.\r\n     */\r\n    __supportsSingleSelection(formItem) {\r\n      var clazz = formItem.constructor;\r\n      return qx.Class.hasInterface(clazz, qx.ui.core.ISingleSelection);\r\n    },\r\n\r\n    /**\r\n     * Returns true, if the given item implements the\r\n     * {@link qx.data.controller.ISelection} interface.\r\n     *\r\n     * @param formItem {qx.core.Object} The item to check.\r\n     * @return {Boolean} true, if the given item implements the\r\n     *   necessary interface.\r\n     */\r\n    __supportsDataBindingSelection(formItem) {\r\n      var clazz = formItem.constructor;\r\n      return qx.Class.hasInterface(clazz, qx.data.controller.ISelection);\r\n    },\r\n\r\n    /**\r\n     * Sets the valid state of the manager. It generates the event if\r\n     * necessary and stores the new value.\r\n     *\r\n     * @param value {Boolean|null} The new valid state of the manager.\r\n     */\r\n    _setValid(value) {\r\n      this._showToolTip(value);\r\n      var oldValue = this.__valid;\r\n      this.__valid = value;\r\n      // check for the change event\r\n      if (oldValue != value) {\r\n        this.fireDataEvent(\"changeValid\", value, oldValue);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Responsible for showing a tooltip in case the validation is done for\r\n     * widgets based on qx.ui.core.Widget.\r\n     * @param valid {Boolean} <code>false</code>, if the tooltip should be shown\r\n     */\r\n    _showToolTip(valid) {\r\n      // ignore if we don't have a tooltip manager e.g. mobile apps\r\n      if (!qx.ui.tooltip || !qx.ui.tooltip.Manager) {\r\n        return;\r\n      }\r\n      var tooltip = qx.ui.tooltip.Manager.getInstance().getSharedErrorTooltip();\r\n\r\n      if (!valid) {\r\n        var firstInvalid;\r\n        for (var i = 0; i < this.__formItems.length; i++) {\r\n          var item = this.__formItems[i].item;\r\n          if (!item.isValid()) {\r\n            firstInvalid = item;\r\n            // only for desktop widgets\r\n            if (!item.getContentLocation) {\r\n              return;\r\n            }\r\n            // only consider items on the screen\r\n            if (item.isSeeable() === false) {\r\n              continue;\r\n            }\r\n\r\n            let msg = item.getInvalidMessage();\r\n            if (\r\n              msg &&\r\n              qx.core.Environment.get(\r\n                \"qx.ui.form.validation.Manager.allowDefaultInvalidMessage\"\r\n              )\r\n            ) {\r\n              msg = qx.locale.Manager.tr(\"Invalid field\");\r\n            } else if (qx.core.Environment.get(\"qx.debug\")) {\r\n              this.assertTrue(msg != null && msg.length > 0);\r\n            }\r\n            tooltip.setLabel(msg);\r\n\r\n            if (tooltip.getPlaceMethod() == \"mouse\") {\r\n              var location = item.getContentLocation();\r\n              var top = location.top - tooltip.getOffsetTop();\r\n              tooltip.placeToPoint({ left: location.right, top: top });\r\n            } else {\r\n              tooltip.placeToWidget(item);\r\n            }\r\n\r\n            tooltip.show();\r\n            return;\r\n          }\r\n        }\r\n      } else {\r\n        tooltip.exclude();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns the valid state of the manager.\r\n     *\r\n     * @return {Boolean|null} The valid state of the manager.\r\n     */\r\n    getValid() {\r\n      return this.__valid;\r\n    },\r\n\r\n    /**\r\n     * Returns the valid state of the manager.\r\n     *\r\n     * @return {Boolean|null} The valid state of the manager.\r\n     */\r\n    isValid() {\r\n      return this.getValid();\r\n    },\r\n\r\n    /**\r\n     * Returns an array of all invalid messages of the invalid form items and\r\n     * the form manager itself.\r\n     *\r\n     * @return {String[]} All invalid messages.\r\n     */\r\n    getInvalidMessages() {\r\n      var messages = [];\r\n      // combine the messages of all form items\r\n      for (var i = 0; i < this.__formItems.length; i++) {\r\n        var formItem = this.__formItems[i].item;\r\n        if (!formItem.getValid()) {\r\n          let msg = formItem.getInvalidMessage();\r\n          if (\r\n            !msg &&\r\n            qx.core.Environment.get(\r\n              \"qx.ui.form.validation.Manager.allowDefaultInvalidMessage\"\r\n            )\r\n          ) {\r\n            msg = qx.locale.Manager.tr(\"Invalid field\");\r\n          } else if (qx.core.Environment.get(\"qx.debug\")) {\r\n            this.assertTrue(msg !== null && msg.length > 0);\r\n          }\r\n          messages.push(msg);\r\n        }\r\n      }\r\n\r\n      // add the forms fail message\r\n      if (!this.isValid()) {\r\n        let msg = this.getInvalidMessage();\r\n        if (msg != \"\") {\r\n          messages.push(msg);\r\n        }\r\n      }\r\n\r\n      return messages;\r\n    },\r\n\r\n    /**\r\n     * Selects invalid form items\r\n     *\r\n     * @return {Array} invalid form items\r\n     */\r\n    getInvalidFormItems() {\r\n      var res = [];\r\n      for (var i = 0; i < this.__formItems.length; i++) {\r\n        var formItem = this.__formItems[i].item;\r\n        if (!formItem.getValid()) {\r\n          res.push(formItem);\r\n        }\r\n      }\r\n\r\n      return res;\r\n    },\r\n\r\n    /**\r\n     * Resets the validator.\r\n     */\r\n    reset() {\r\n      // reset all form items\r\n      for (var i = 0; i < this.__formItems.length; i++) {\r\n        var dataEntry = this.__formItems[i];\r\n        // set the field to valid\r\n        dataEntry.item.setValid(true);\r\n      }\r\n      // set the manager to its initial valid value\r\n      this.__valid = null;\r\n      this._showToolTip(true);\r\n    },\r\n\r\n    /**\r\n     * Internal helper method to set the given item to valid for asynchronous\r\n     * validation calls. This indirection is used to determinate if the\r\n     * validation process is completed or if other asynchronous validators\r\n     * are still validating. {@link #__checkValidationComplete} checks if the\r\n     * validation is complete and will be called at the end of this method.\r\n     *\r\n     * @param formItem {qx.ui.core.Widget} The form item to set the valid state.\r\n     * @param valid {Boolean} The valid state for the form item.\r\n     *\r\n     * @internal\r\n     */\r\n    setItemValid(formItem, valid) {\r\n      // store the result\r\n      this.__asyncResults[formItem.toHashCode()] = valid;\r\n      formItem.setValid(valid);\r\n      this.__checkValidationComplete();\r\n    },\r\n\r\n    /**\r\n     * Internal helper method to set the form manager to valid for asynchronous\r\n     * validation calls. This indirection is used to determinate if the\r\n     * validation process is completed or if other asynchronous validators\r\n     * are still validating. {@link #__checkValidationComplete} checks if the\r\n     * validation is complete and will be called at the end of this method.\r\n     *\r\n     * @param valid {Boolean} The valid state for the form manager.\r\n     *\r\n     * @internal\r\n     */\r\n    setFormValid(valid) {\r\n      this.__asyncResults[this.toHashCode()] = valid;\r\n      this.__checkValidationComplete();\r\n    },\r\n\r\n    /**\r\n     * Checks if all asynchronous validators have validated so the result\r\n     * is final and the {@link #complete} event can be fired. If that's not\r\n     * the case, nothing will happen in the method.\r\n     */\r\n    __checkValidationComplete() {\r\n      var valid = this.__syncValid;\r\n\r\n      // check if all async validators are done\r\n      for (var hash in this.__asyncResults) {\r\n        var currentResult = this.__asyncResults[hash];\r\n        valid = currentResult && valid;\r\n        // the validation is not done so just do nothing\r\n        if (currentResult == null) {\r\n          return;\r\n        }\r\n      }\r\n      // set the actual valid state of the manager\r\n      this._setValid(valid);\r\n      // reset the results\r\n      this.__asyncResults = {};\r\n      // fire the complete event (no entry in the results with null)\r\n      this.fireEvent(\"complete\");\r\n    }\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     DESTRUCTOR\r\n  *****************************************************************************\r\n  */\r\n  destruct() {\r\n    this._showToolTip(true);\r\n    this.__formItems = null;\r\n  },\r\n\r\n  environment: {\r\n    // Whether to assume a default \"Invalid Field\" message for invalid fields; if false, an\r\n    //  exception will be raised if invalid fields do not have an `invalidMessage`\r\n    \"qx.ui.form.validation.Manager.allowDefaultInvalidMessage\": true\r\n  }\r\n});\r\n"
  ],
  "mappings": "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"
}