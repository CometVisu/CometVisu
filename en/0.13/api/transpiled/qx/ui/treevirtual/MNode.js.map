{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Mixin",
    "define",
    "members",
    "nodeGet",
    "nodeReference",
    "getTableModel",
    "getData",
    "Error",
    "nodeToggleOpened",
    "node",
    "nodeId",
    "setState",
    "bOpened",
    "nodeSetState",
    "attributes",
    "nodeSetLabel",
    "label",
    "nodeGetLabel",
    "nodeSetSelected",
    "b",
    "bSelected",
    "nodeGetSelected",
    "nodeOpenAll",
    "model",
    "forEach",
    "setData",
    "nodeCloseAll",
    "_nodeSetOpenedInternal",
    "opened",
    "cascade",
    "isRecursed",
    "children",
    "child",
    "nodeSetOpened",
    "nodeGetOpened",
    "nodeSetHideOpenClose",
    "bHideOpenClose",
    "nodeGetHideOpenClose",
    "nodeSetIcon",
    "path",
    "icon",
    "nodeGetIcon",
    "nodeSetSelectedIcon",
    "iconSelected",
    "nodeGetSelectedIcon",
    "nodeSetCellStyle",
    "style",
    "cellStyle",
    "nodeGetCellStyle",
    "nodeSetLabelStyle",
    "labelStyle",
    "nodeGetLabelStyle",
    "ui",
    "treevirtual",
    "MNode"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/treevirtual/MNode.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * Utility functions for working with nodes.  These methods allow reference\n * to a node by either the object itself or the object's node id.\n */\nqx.Mixin.define(\"qx.ui.treevirtual.MNode\", {\n  members: {\n    /**\n     * Get a node object given its node id.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node to have its opened/closed state toggled.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.).\n     *\n     * @return {Object}\n     *   If the nodeReference is a node object itself, that same node object\n     *   is returned (identity).  Otherwise, the node object is looked up\n     *   using the specified node id.\n     */\n    nodeGet(nodeReference) {\n      if (typeof nodeReference == \"object\") {\n        return nodeReference;\n      } else if (typeof nodeReference == \"number\") {\n        return this.getTableModel().getData()[nodeReference];\n      } else {\n        throw new Error(\"Expected node object or node id\");\n      }\n    },\n\n    /**\n     * Toggle the opened state of the node: if the node is opened, close\n     * it; if it is closed, open it.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node to have its opened/closed state toggled.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     */\n    nodeToggleOpened(nodeReference) {\n      var node;\n      var nodeId;\n\n      if (typeof nodeReference == \"object\") {\n        node = nodeReference;\n        nodeId = node.nodeId;\n      } else if (typeof nodeReference == \"number\") {\n        nodeId = nodeReference;\n        node = this.getTableModel().getData()[nodeId];\n      } else {\n        throw new Error(\"Expected node object or node id\");\n      }\n\n      this.getTableModel().setState(nodeId, { bOpened: !node.bOpened });\n    },\n\n    /**\n     * Set state attributes of a tree node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which attributes are being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param attributes {Map}\n     *   Map with the node properties to be set.  The map may contain any of\n     *   the properties described in\n     *   {@link qx.ui.treevirtual.SimpleTreeDataModel}\n     *\n     */\n    nodeSetState(nodeReference, attributes) {\n      var nodeId;\n\n      if (typeof nodeReference == \"object\") {\n        nodeId = nodeReference.nodeId;\n      } else if (typeof nodeReference == \"number\") {\n        nodeId = nodeReference;\n      } else {\n        throw new Error(\"Expected node object or node id\");\n      }\n\n      this.getTableModel().setState(nodeId, attributes);\n    },\n\n    /**\n     * Set the label for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the label is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param label {String}\n     *   The new label for the specified node\n     *\n     */\n    nodeSetLabel(nodeReference, label) {\n      this.nodeSetState(nodeReference, { label: label });\n    },\n\n    /**\n     * Get the label for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the label is being retrieved.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {String}\n     *   The label for the specified node\n     */\n    nodeGetLabel(nodeReference) {\n      var node = this.nodeGet(nodeReference);\n      return node.label;\n    },\n\n    /**\n     * Set the selected state for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the selected state is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param b {Boolean}\n     *   The new selected state for the specified node.\n     *\n     */\n    nodeSetSelected(nodeReference, b) {\n      this.nodeSetState(nodeReference, { bSelected: b });\n    },\n\n    /**\n     * Get the selected state for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the selected state is being retrieved.  The node\n     *   can be represented either by the node object, or the node id (as\n     *   would have been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {Boolean}\n     *   The selected state for the specified node.\n     */\n    nodeGetSelected(nodeReference) {\n      var node = this.nodeGet(nodeReference);\n      return node.bSelected;\n    },\n\n    /**\n     * Opens all nodes in the tree with minimal redraw\n     */\n    nodeOpenAll() {\n      var model = this.getTableModel();\n      model.getData().forEach(node => {\n        if (node) {\n          model.setState(node.nodeId, { bOpened: true }, true);\n        }\n      });\n      model.setData();\n    },\n\n    /**\n     * Closes all nodes in the tree with minimal redraw\n     */\n    nodeCloseAll() {\n      var model = this.getTableModel();\n      model.getData().forEach(node => {\n        if (node) {\n          model.setState(node.nodeId, { bOpened: false }, true);\n        }\n      });\n      model.setData();\n    },\n\n    /**\n     * Internal call to set the opened state for a node. (Note that this method has no effect\n     * if the requested state is the same as the current state.)\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the opened state is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param opened {Boolean}\n     *   The new opened state for the specified node.\n     *\n     * @param cascade {Boolean}\n     *   Whether to descend the tree changing opened state of all children\n     *\n     * @param isRecursed {Boolean?}\n     *   For internal use when cascading to determine outer level and call setData\n     */\n    _nodeSetOpenedInternal(nodeReference, opened, cascade, isRecursed) {\n      var node;\n\n      if (typeof nodeReference == \"object\") {\n        node = nodeReference;\n      } else if (typeof nodeReference == \"number\") {\n        node = this.getTableModel().getData()[nodeReference];\n      } else {\n        throw new Error(\"Expected node object or node id\");\n      }\n\n      // Only set new state if not already in the requested state, since\n      // setting new state involves dispatching events.\n      if (opened != node.bOpened) {\n        this.getTableModel().setState(node.nodeId, { bOpened: opened }, true);\n      }\n      if (cascade) {\n        node.children.forEach(child =>\n          this._nodeSetOpenedInternal(child, opened, cascade, true)\n        );\n      }\n      if (!cascade || !isRecursed) {\n        this.getTableModel().setData();\n      }\n    },\n    /**\n     * Set the opened state for a node.  (Note that this method has no effect\n     * if the requested state is the same as the current state.)\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the opened state is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param opened {Boolean}\n     *   The new opened state for the specified node.\n     *\n     * @param cascade {Boolean}\n     *   Whether to descend the tree changing opened state of all children\n     */\n    nodeSetOpened(nodeReference, opened, cascade) {\n      this._nodeSetOpenedInternal(nodeReference, opened, cascade, false);\n    },\n\n    /**\n     * Get the opened state for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the opened state is being retrieved.  The node can\n     *   be represented either by the node object, or the node id (as would\n     *   have been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {Boolean}\n     *   The opened state for the specified node.\n     */\n    nodeGetOpened(nodeReference) {\n      var node = this.nodeGet(nodeReference);\n      return node.bOpened;\n    },\n\n    /**\n     * Set the hideOpenClose state for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the hideOpenClose state is being set.  The node\n     *   can be represented either by the node object, or the node id (as\n     *   would have been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param b {Boolean}\n     *   The new hideOpenClose state for the specified node.\n     *\n     */\n    nodeSetHideOpenClose(nodeReference, b) {\n      this.nodeSetState(nodeReference, { bHideOpenClose: b });\n    },\n\n    /**\n     * Get the hideOpenClose state for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the hideOpenClose state is being retrieved.  The\n     *   node can be represented either by the node object, or the node id (as\n     *   would have been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {Boolean}\n     *   The new hideOpenClose state for the specified node.\n     */\n    nodeGetHideOpenClose(nodeReference) {\n      var node = this.nodeGet(nodeReference);\n      return node.bHideOpenClose;\n    },\n\n    /**\n     * Set the icon for a node when in its unselected (normal) state.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the icon is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param path {String}\n     *   The path to the icon to be used when the node is not selected\n     *\n     */\n    nodeSetIcon(nodeReference, path) {\n      this.nodeSetState(nodeReference, { icon: path });\n    },\n\n    /**\n     * Get the icon for a node when in its unselected (normal) state.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the icon is being retrieved.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {String}\n     *   The path to the icon to be used when the node is not selected, if a\n     *   path has been previously provided (i.e. not using the default icon).\n     */\n    nodeGetIcon(nodeReference) {\n      var node = this.nodeGet(nodeReference);\n      return node.icon;\n    },\n\n    /**\n     * Set the icon for a node when in its selected state.\n     * <p>\n     * NOTE: As of 13 Mar 2009, this feature is disabled by default, by\n     *       virtue of the fact that the tree's \"alwaysUpdateCells\" property\n     *       has a setting of 'false' now instead of 'true'. Setting this\n     *       property to true allows the icon to change upon selection, but\n     *       causes problems such as single clicks not always selecting a\n     *       row, and, in IE, double click operations failing\n     *       completely. (For more information, see bugs 605 and 2021.) To\n     *       re-enable the option to have an unique icon that is displayed\n     *       when the node is selected, issue\n     *       <code>tree.setAlwaysUpdateCells(true);</code>\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the icon is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param path {String}\n     *   The path to the icon to be used when the node is selected\n     *\n     */\n    nodeSetSelectedIcon(nodeReference, path) {\n      this.nodeSetState(nodeReference, { iconSelected: path });\n    },\n\n    /**\n     * Get the icon for a node when in its selected state.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the icon is being retrieved.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {String}\n     *   The path to the icon to be used when the node is selected, if a path\n     *   has been previously provided (i.e. not using the default icon).\n     */\n    nodeGetSelectedIcon(nodeReference) {\n      var node = this.nodeGet(nodeReference);\n      return node.iconSelected;\n    },\n\n    /**\n     * Set the cell style for a node\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the cell style is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param style {String}\n     *   The CSS style to be applied for the tree column cell for this node,\n     *   if a style has been previously provided (i.e. not using the default\n     *   style).\n     *\n     */\n\n    nodeSetCellStyle(nodeReference, style) {\n      this.nodeSetState(nodeReference, { cellStyle: style });\n    },\n\n    /**\n     * Get the cell style for a node\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the cell style is being retrieved.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {String}\n     *   The CSS style being applied for the tree column cell for this node.\n     */\n    nodeGetCellStyle(nodeReference) {\n      var node = this.nodeGet(nodeReference);\n      return node.cellStyle;\n    },\n\n    /**\n     * Set the label style for a node\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the label style is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param style {String}\n     *   The CSS style to be applied for the label for this node.\n     *\n     */\n    nodeSetLabelStyle(nodeReference, style) {\n      this.nodeSetState(nodeReference, { labelStyle: style });\n    },\n\n    /**\n     * Get the label style for a node\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the label style is being retrieved.  The node can\n     *   be represented either by the node object, or the node id (as would\n     *   have been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {String}\n     *   The CSS style being applied for the label for this node, if a style\n     *   has been previously provided (i.e. not using the default style).\n     */\n    nodeGetLabelStyle(nodeReference) {\n      var node = this.nodeGet(nodeReference);\n      return node.cellStyle;\n    }\n  }\n});\n"
  ],
  "mappings": "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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,mBAAmB,+BAACtC,aAAa,EAAEmC,IAAI,EAAE;QACvC,IAAI,CAAC1B,YAAY,CAACT,aAAa,EAAE;UAAEuC,YAAY,EAAEJ;QAAK,CAAC,CAAC;MAC1D,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIK,mBAAmB,+BAACxC,aAAa,EAAE;QACjC,IAAIK,IAAI,GAAG,IAAI,CAACN,OAAO,CAACC,aAAa,CAAC;QACtC,OAAOK,IAAI,CAACkC,YAAY;MAC1B,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MAEIE,gBAAgB,4BAACzC,aAAa,EAAE0C,KAAK,EAAE;QACrC,IAAI,CAACjC,YAAY,CAACT,aAAa,EAAE;UAAE2C,SAAS,EAAED;QAAM,CAAC,CAAC;MACxD,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,gBAAgB,4BAAC5C,aAAa,EAAE;QAC9B,IAAIK,IAAI,GAAG,IAAI,CAACN,OAAO,CAACC,aAAa,CAAC;QACtC,OAAOK,IAAI,CAACsC,SAAS;MACvB,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,iBAAiB,6BAAC7C,aAAa,EAAE0C,KAAK,EAAE;QACtC,IAAI,CAACjC,YAAY,CAACT,aAAa,EAAE;UAAE8C,UAAU,EAAEJ;QAAM,CAAC,CAAC;MACzD,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIK,iBAAiB,6BAAC/C,aAAa,EAAE;QAC/B,IAAIK,IAAI,GAAG,IAAI,CAACN,OAAO,CAACC,aAAa,CAAC;QACtC,OAAOK,IAAI,CAACsC,SAAS;MACvB;IACF;EACF,CAAC,CAAC;EA/bFnD,EAAE,CAACwD,EAAE,CAACC,WAAW,CAACC,KAAK,CAACvD,aAAa,GAAGA,aAAa;AAAC"
}