{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Mixin",
    "define",
    "members",
    "nodeGet",
    "nodeReference",
    "_typeof",
    "getTableModel",
    "getData",
    "Error",
    "nodeToggleOpened",
    "node",
    "nodeId",
    "setState",
    "bOpened",
    "nodeSetState",
    "attributes",
    "nodeSetLabel",
    "label",
    "nodeGetLabel",
    "nodeSetSelected",
    "b",
    "bSelected",
    "nodeGetSelected",
    "nodeOpenAll",
    "model",
    "forEach",
    "setData",
    "nodeCloseAll",
    "_nodeSetOpenedInternal",
    "opened",
    "cascade",
    "isRecursed",
    "_this",
    "children",
    "child",
    "nodeSetOpened",
    "nodeGetOpened",
    "nodeSetHideOpenClose",
    "bHideOpenClose",
    "nodeGetHideOpenClose",
    "nodeSetIcon",
    "path",
    "icon",
    "nodeGetIcon",
    "nodeSetSelectedIcon",
    "iconSelected",
    "nodeGetSelectedIcon",
    "nodeSetCellStyle",
    "style",
    "cellStyle",
    "nodeGetCellStyle",
    "nodeSetLabelStyle",
    "labelStyle",
    "nodeGetLabelStyle",
    "ui",
    "treevirtual",
    "MNode"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/treevirtual/MNode.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2007 Derrell Lipman\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Derrell Lipman (derrell)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * Utility functions for working with nodes.  These methods allow reference\r\n * to a node by either the object itself or the object's node id.\r\n */\r\nqx.Mixin.define(\"qx.ui.treevirtual.MNode\", {\r\n  members: {\r\n    /**\r\n     * Get a node object given its node id.\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node to have its opened/closed state toggled.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.).\r\n     *\r\n     * @return {Object}\r\n     *   If the nodeReference is a node object itself, that same node object\r\n     *   is returned (identity).  Otherwise, the node object is looked up\r\n     *   using the specified node id.\r\n     */\r\n    nodeGet(nodeReference) {\r\n      if (typeof nodeReference == \"object\") {\r\n        return nodeReference;\r\n      } else if (typeof nodeReference == \"number\") {\r\n        return this.getTableModel().getData()[nodeReference];\r\n      } else {\r\n        throw new Error(\"Expected node object or node id\");\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Toggle the opened state of the node: if the node is opened, close\r\n     * it; if it is closed, open it.\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node to have its opened/closed state toggled.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     */\r\n    nodeToggleOpened(nodeReference) {\r\n      var node;\r\n      var nodeId;\r\n\r\n      if (typeof nodeReference == \"object\") {\r\n        node = nodeReference;\r\n        nodeId = node.nodeId;\r\n      } else if (typeof nodeReference == \"number\") {\r\n        nodeId = nodeReference;\r\n        node = this.getTableModel().getData()[nodeId];\r\n      } else {\r\n        throw new Error(\"Expected node object or node id\");\r\n      }\r\n\r\n      this.getTableModel().setState(nodeId, { bOpened: !node.bOpened });\r\n    },\r\n\r\n    /**\r\n     * Set state attributes of a tree node.\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which attributes are being set.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @param attributes {Map}\r\n     *   Map with the node properties to be set.  The map may contain any of\r\n     *   the properties described in\r\n     *   {@link qx.ui.treevirtual.SimpleTreeDataModel}\r\n     *\r\n     */\r\n    nodeSetState(nodeReference, attributes) {\r\n      var nodeId;\r\n\r\n      if (typeof nodeReference == \"object\") {\r\n        nodeId = nodeReference.nodeId;\r\n      } else if (typeof nodeReference == \"number\") {\r\n        nodeId = nodeReference;\r\n      } else {\r\n        throw new Error(\"Expected node object or node id\");\r\n      }\r\n\r\n      this.getTableModel().setState(nodeId, attributes);\r\n    },\r\n\r\n    /**\r\n     * Set the label for a node.\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the label is being set.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @param label {String}\r\n     *   The new label for the specified node\r\n     *\r\n     */\r\n    nodeSetLabel(nodeReference, label) {\r\n      this.nodeSetState(nodeReference, { label: label });\r\n    },\r\n\r\n    /**\r\n     * Get the label for a node.\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the label is being retrieved.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @return {String}\r\n     *   The label for the specified node\r\n     */\r\n    nodeGetLabel(nodeReference) {\r\n      var node = this.nodeGet(nodeReference);\r\n      return node.label;\r\n    },\r\n\r\n    /**\r\n     * Set the selected state for a node.\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the selected state is being set.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @param b {Boolean}\r\n     *   The new selected state for the specified node.\r\n     *\r\n     */\r\n    nodeSetSelected(nodeReference, b) {\r\n      this.nodeSetState(nodeReference, { bSelected: b });\r\n    },\r\n\r\n    /**\r\n     * Get the selected state for a node.\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the selected state is being retrieved.  The node\r\n     *   can be represented either by the node object, or the node id (as\r\n     *   would have been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @return {Boolean}\r\n     *   The selected state for the specified node.\r\n     */\r\n    nodeGetSelected(nodeReference) {\r\n      var node = this.nodeGet(nodeReference);\r\n      return node.bSelected;\r\n    },\r\n\r\n    /**\r\n     * Opens all nodes in the tree with minimal redraw\r\n     */\r\n    nodeOpenAll() {\r\n      var model = this.getTableModel();\r\n      model.getData().forEach(node => {\r\n        if (node) {\r\n          model.setState(node.nodeId, { bOpened: true }, true);\r\n        }\r\n      });\r\n      model.setData();\r\n    },\r\n\r\n    /**\r\n     * Closes all nodes in the tree with minimal redraw\r\n     */\r\n    nodeCloseAll() {\r\n      var model = this.getTableModel();\r\n      model.getData().forEach(node => {\r\n        if (node) {\r\n          model.setState(node.nodeId, { bOpened: false }, true);\r\n        }\r\n      });\r\n      model.setData();\r\n    },\r\n\r\n    /**\r\n     * Internal call to set the opened state for a node. (Note that this method has no effect\r\n     * if the requested state is the same as the current state.)\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the opened state is being set.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @param opened {Boolean}\r\n     *   The new opened state for the specified node.\r\n     *\r\n     * @param cascade {Boolean}\r\n     *   Whether to descend the tree changing opened state of all children\r\n     *\r\n     * @param isRecursed {Boolean?}\r\n     *   For internal use when cascading to determine outer level and call setData\r\n     */\r\n    _nodeSetOpenedInternal(nodeReference, opened, cascade, isRecursed) {\r\n      var node;\r\n\r\n      if (typeof nodeReference == \"object\") {\r\n        node = nodeReference;\r\n      } else if (typeof nodeReference == \"number\") {\r\n        node = this.getTableModel().getData()[nodeReference];\r\n      } else {\r\n        throw new Error(\"Expected node object or node id\");\r\n      }\r\n\r\n      // Only set new state if not already in the requested state, since\r\n      // setting new state involves dispatching events.\r\n      if (opened != node.bOpened) {\r\n        this.getTableModel().setState(node.nodeId, { bOpened: opened }, true);\r\n      }\r\n      if (cascade) {\r\n        node.children.forEach(child =>\r\n          this._nodeSetOpenedInternal(child, opened, cascade, true)\r\n        );\r\n      }\r\n      if (!cascade || !isRecursed) {\r\n        this.getTableModel().setData();\r\n      }\r\n    },\r\n    /**\r\n     * Set the opened state for a node.  (Note that this method has no effect\r\n     * if the requested state is the same as the current state.)\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the opened state is being set.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @param opened {Boolean}\r\n     *   The new opened state for the specified node.\r\n     *\r\n     * @param cascade {Boolean}\r\n     *   Whether to descend the tree changing opened state of all children\r\n     */\r\n    nodeSetOpened(nodeReference, opened, cascade) {\r\n      this._nodeSetOpenedInternal(nodeReference, opened, cascade, false);\r\n    },\r\n\r\n    /**\r\n     * Get the opened state for a node.\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the opened state is being retrieved.  The node can\r\n     *   be represented either by the node object, or the node id (as would\r\n     *   have been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @return {Boolean}\r\n     *   The opened state for the specified node.\r\n     */\r\n    nodeGetOpened(nodeReference) {\r\n      var node = this.nodeGet(nodeReference);\r\n      return node.bOpened;\r\n    },\r\n\r\n    /**\r\n     * Set the hideOpenClose state for a node.\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the hideOpenClose state is being set.  The node\r\n     *   can be represented either by the node object, or the node id (as\r\n     *   would have been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @param b {Boolean}\r\n     *   The new hideOpenClose state for the specified node.\r\n     *\r\n     */\r\n    nodeSetHideOpenClose(nodeReference, b) {\r\n      this.nodeSetState(nodeReference, { bHideOpenClose: b });\r\n    },\r\n\r\n    /**\r\n     * Get the hideOpenClose state for a node.\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the hideOpenClose state is being retrieved.  The\r\n     *   node can be represented either by the node object, or the node id (as\r\n     *   would have been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @return {Boolean}\r\n     *   The new hideOpenClose state for the specified node.\r\n     */\r\n    nodeGetHideOpenClose(nodeReference) {\r\n      var node = this.nodeGet(nodeReference);\r\n      return node.bHideOpenClose;\r\n    },\r\n\r\n    /**\r\n     * Set the icon for a node when in its unselected (normal) state.\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the icon is being set.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @param path {String}\r\n     *   The path to the icon to be used when the node is not selected\r\n     *\r\n     */\r\n    nodeSetIcon(nodeReference, path) {\r\n      this.nodeSetState(nodeReference, { icon: path });\r\n    },\r\n\r\n    /**\r\n     * Get the icon for a node when in its unselected (normal) state.\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the icon is being retrieved.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @return {String}\r\n     *   The path to the icon to be used when the node is not selected, if a\r\n     *   path has been previously provided (i.e. not using the default icon).\r\n     */\r\n    nodeGetIcon(nodeReference) {\r\n      var node = this.nodeGet(nodeReference);\r\n      return node.icon;\r\n    },\r\n\r\n    /**\r\n     * Set the icon for a node when in its selected state.\r\n     * <p>\r\n     * NOTE: As of 13 Mar 2009, this feature is disabled by default, by\r\n     *       virtue of the fact that the tree's \"alwaysUpdateCells\" property\r\n     *       has a setting of 'false' now instead of 'true'. Setting this\r\n     *       property to true allows the icon to change upon selection, but\r\n     *       causes problems such as single clicks not always selecting a\r\n     *       row, and, in IE, double click operations failing\r\n     *       completely. (For more information, see bugs 605 and 2021.) To\r\n     *       re-enable the option to have an unique icon that is displayed\r\n     *       when the node is selected, issue\r\n     *       <code>tree.setAlwaysUpdateCells(true);</code>\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the icon is being set.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @param path {String}\r\n     *   The path to the icon to be used when the node is selected\r\n     *\r\n     */\r\n    nodeSetSelectedIcon(nodeReference, path) {\r\n      this.nodeSetState(nodeReference, { iconSelected: path });\r\n    },\r\n\r\n    /**\r\n     * Get the icon for a node when in its selected state.\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the icon is being retrieved.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @return {String}\r\n     *   The path to the icon to be used when the node is selected, if a path\r\n     *   has been previously provided (i.e. not using the default icon).\r\n     */\r\n    nodeGetSelectedIcon(nodeReference) {\r\n      var node = this.nodeGet(nodeReference);\r\n      return node.iconSelected;\r\n    },\r\n\r\n    /**\r\n     * Set the cell style for a node\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the cell style is being set.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @param style {String}\r\n     *   The CSS style to be applied for the tree column cell for this node,\r\n     *   if a style has been previously provided (i.e. not using the default\r\n     *   style).\r\n     *\r\n     */\r\n\r\n    nodeSetCellStyle(nodeReference, style) {\r\n      this.nodeSetState(nodeReference, { cellStyle: style });\r\n    },\r\n\r\n    /**\r\n     * Get the cell style for a node\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the cell style is being retrieved.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @return {String}\r\n     *   The CSS style being applied for the tree column cell for this node.\r\n     */\r\n    nodeGetCellStyle(nodeReference) {\r\n      var node = this.nodeGet(nodeReference);\r\n      return node.cellStyle;\r\n    },\r\n\r\n    /**\r\n     * Set the label style for a node\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the label style is being set.  The node can be\r\n     *   represented either by the node object, or the node id (as would have\r\n     *   been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @param style {String}\r\n     *   The CSS style to be applied for the label for this node.\r\n     *\r\n     */\r\n    nodeSetLabelStyle(nodeReference, style) {\r\n      this.nodeSetState(nodeReference, { labelStyle: style });\r\n    },\r\n\r\n    /**\r\n     * Get the label style for a node\r\n     *\r\n     * @param nodeReference {Object | Integer}\r\n     *   The node for which the label style is being retrieved.  The node can\r\n     *   be represented either by the node object, or the node id (as would\r\n     *   have been returned by addBranch(), addLeaf(), etc.)\r\n     *\r\n     * @return {String}\r\n     *   The CSS style being applied for the label for this node, if a style\r\n     *   has been previously provided (i.e. not using the default style).\r\n     */\r\n    nodeGetLabelStyle(nodeReference) {\r\n      var node = this.nodeGet(nodeReference);\r\n      return node.cellStyle;\r\n    }\r\n  }\r\n});\r\n"
  ],
  "mappings": ";;;;;;;;;;EAAAA,EAAE,CAACC,SAAS,CAACC,oBAAoB,CAACC,aAAa,CAAC;EAAhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;AACA;EACAH,EAAE,CAACI,KAAK,CAACC,MAAM,CAAC,yBAAyB,EAAE;IACzCC,OAAO,EAAE;MACP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,OAAO,WAAAA,QAACC,aAAa,EAAE;QACrB,IAAIC,OAAA,CAAOD,aAAa,KAAI,QAAQ,EAAE;UACpC,OAAOA,aAAa;QACtB,CAAC,MAAM,IAAI,OAAOA,aAAa,IAAI,QAAQ,EAAE;UAC3C,OAAO,IAAI,CAACE,aAAa,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,CAACH,aAAa,CAAC;QACtD,CAAC,MAAM;UACL,MAAM,IAAII,KAAK,CAAC,iCAAiC,CAAC;QACpD;MACF,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,gBAAgB,WAAAA,iBAACL,aAAa,EAAE;QAC9B,IAAIM,IAAI;QACR,IAAIC,MAAM;QAEV,IAAIN,OAAA,CAAOD,aAAa,KAAI,QAAQ,EAAE;UACpCM,IAAI,GAAGN,aAAa;UACpBO,MAAM,GAAGD,IAAI,CAACC,MAAM;QACtB,CAAC,MAAM,IAAI,OAAOP,aAAa,IAAI,QAAQ,EAAE;UAC3CO,MAAM,GAAGP,aAAa;UACtBM,IAAI,GAAG,IAAI,CAACJ,aAAa,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,CAACI,MAAM,CAAC;QAC/C,CAAC,MAAM;UACL,MAAM,IAAIH,KAAK,CAAC,iCAAiC,CAAC;QACpD;QAEA,IAAI,CAACF,aAAa,CAAC,CAAC,CAACM,QAAQ,CAACD,MAAM,EAAE;UAAEE,OAAO,EAAE,CAACH,IAAI,CAACG;QAAQ,CAAC,CAAC;MACnE,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,YAAY,WAAAA,aAACV,aAAa,EAAEW,UAAU,EAAE;QACtC,IAAIJ,MAAM;QAEV,IAAIN,OAAA,CAAOD,aAAa,KAAI,QAAQ,EAAE;UACpCO,MAAM,GAAGP,aAAa,CAACO,MAAM;QAC/B,CAAC,MAAM,IAAI,OAAOP,aAAa,IAAI,QAAQ,EAAE;UAC3CO,MAAM,GAAGP,aAAa;QACxB,CAAC,MAAM;UACL,MAAM,IAAII,KAAK,CAAC,iCAAiC,CAAC;QACpD;QAEA,IAAI,CAACF,aAAa,CAAC,CAAC,CAACM,QAAQ,CAACD,MAAM,EAAEI,UAAU,CAAC;MACnD,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,YAAY,WAAAA,aAACZ,aAAa,EAAEa,KAAK,EAAE;QACjC,IAAI,CAACH,YAAY,CAACV,aAAa,EAAE;UAAEa,KAAK,EAAEA;QAAM,CAAC,CAAC;MACpD,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,YAAY,WAAAA,aAACd,aAAa,EAAE;QAC1B,IAAIM,IAAI,GAAG,IAAI,CAACP,OAAO,CAACC,aAAa,CAAC;QACtC,OAAOM,IAAI,CAACO,KAAK;MACnB,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,eAAe,WAAAA,gBAACf,aAAa,EAAEgB,CAAC,EAAE;QAChC,IAAI,CAACN,YAAY,CAACV,aAAa,EAAE;UAAEiB,SAAS,EAAED;QAAE,CAAC,CAAC;MACpD,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,eAAe,WAAAA,gBAAClB,aAAa,EAAE;QAC7B,IAAIM,IAAI,GAAG,IAAI,CAACP,OAAO,CAACC,aAAa,CAAC;QACtC,OAAOM,IAAI,CAACW,SAAS;MACvB,CAAC;MAED;AACJ;AACA;MACIE,WAAW,WAAAA,YAAA,EAAG;QACZ,IAAIC,KAAK,GAAG,IAAI,CAAClB,aAAa,CAAC,CAAC;QAChCkB,KAAK,CAACjB,OAAO,CAAC,CAAC,CAACkB,OAAO,CAAC,UAAAf,IAAI,EAAI;UAC9B,IAAIA,IAAI,EAAE;YACRc,KAAK,CAACZ,QAAQ,CAACF,IAAI,CAACC,MAAM,EAAE;cAAEE,OAAO,EAAE;YAAK,CAAC,EAAE,IAAI,CAAC;UACtD;QACF,CAAC,CAAC;QACFW,KAAK,CAACE,OAAO,CAAC,CAAC;MACjB,CAAC;MAED;AACJ;AACA;MACIC,YAAY,WAAAA,aAAA,EAAG;QACb,IAAIH,KAAK,GAAG,IAAI,CAAClB,aAAa,CAAC,CAAC;QAChCkB,KAAK,CAACjB,OAAO,CAAC,CAAC,CAACkB,OAAO,CAAC,UAAAf,IAAI,EAAI;UAC9B,IAAIA,IAAI,EAAE;YACRc,KAAK,CAACZ,QAAQ,CAACF,IAAI,CAACC,MAAM,EAAE;cAAEE,OAAO,EAAE;YAAM,CAAC,EAAE,IAAI,CAAC;UACvD;QACF,CAAC,CAAC;QACFW,KAAK,CAACE,OAAO,CAAC,CAAC;MACjB,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,sBAAsB,WAAAA,uBAACxB,aAAa,EAAEyB,MAAM,EAAEC,OAAO,EAAEC,UAAU,EAAE;QAAA,IAAAC,KAAA;QACjE,IAAItB,IAAI;QAER,IAAIL,OAAA,CAAOD,aAAa,KAAI,QAAQ,EAAE;UACpCM,IAAI,GAAGN,aAAa;QACtB,CAAC,MAAM,IAAI,OAAOA,aAAa,IAAI,QAAQ,EAAE;UAC3CM,IAAI,GAAG,IAAI,CAACJ,aAAa,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,CAACH,aAAa,CAAC;QACtD,CAAC,MAAM;UACL,MAAM,IAAII,KAAK,CAAC,iCAAiC,CAAC;QACpD;;QAEA;QACA;QACA,IAAIqB,MAAM,IAAInB,IAAI,CAACG,OAAO,EAAE;UAC1B,IAAI,CAACP,aAAa,CAAC,CAAC,CAACM,QAAQ,CAACF,IAAI,CAACC,MAAM,EAAE;YAAEE,OAAO,EAAEgB;UAAO,CAAC,EAAE,IAAI,CAAC;QACvE;QACA,IAAIC,OAAO,EAAE;UACXpB,IAAI,CAACuB,QAAQ,CAACR,OAAO,CAAC,UAAAS,KAAK;YAAA,OACzBF,KAAI,CAACJ,sBAAsB,CAACM,KAAK,EAAEL,MAAM,EAAEC,OAAO,EAAE,IAAI,CAAC;UAAA,CAC3D,CAAC;QACH;QACA,IAAI,CAACA,OAAO,IAAI,CAACC,UAAU,EAAE;UAC3B,IAAI,CAACzB,aAAa,CAAC,CAAC,CAACoB,OAAO,CAAC,CAAC;QAChC;MACF,CAAC;MACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIS,aAAa,WAAAA,cAAC/B,aAAa,EAAEyB,MAAM,EAAEC,OAAO,EAAE;QAC5C,IAAI,CAACF,sBAAsB,CAACxB,aAAa,EAAEyB,MAAM,EAAEC,OAAO,EAAE,KAAK,CAAC;MACpE,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIM,aAAa,WAAAA,cAAChC,aAAa,EAAE;QAC3B,IAAIM,IAAI,GAAG,IAAI,CAACP,OAAO,CAACC,aAAa,CAAC;QACtC,OAAOM,IAAI,CAACG,OAAO;MACrB,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIwB,oBAAoB,WAAAA,qBAACjC,aAAa,EAAEgB,CAAC,EAAE;QACrC,IAAI,CAACN,YAAY,CAACV,aAAa,EAAE;UAAEkC,cAAc,EAAElB;QAAE,CAAC,CAAC;MACzD,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACImB,oBAAoB,WAAAA,qBAACnC,aAAa,EAAE;QAClC,IAAIM,IAAI,GAAG,IAAI,CAACP,OAAO,CAACC,aAAa,CAAC;QACtC,OAAOM,IAAI,CAAC4B,cAAc;MAC5B,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,WAAW,WAAAA,YAACpC,aAAa,EAAEqC,IAAI,EAAE;QAC/B,IAAI,CAAC3B,YAAY,CAACV,aAAa,EAAE;UAAEsC,IAAI,EAAED;QAAK,CAAC,CAAC;MAClD,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,WAAW,WAAAA,YAACvC,aAAa,EAAE;QACzB,IAAIM,IAAI,GAAG,IAAI,CAACP,OAAO,CAACC,aAAa,CAAC;QACtC,OAAOM,IAAI,CAACgC,IAAI;MAClB,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,mBAAmB,WAAAA,oBAACxC,aAAa,EAAEqC,IAAI,EAAE;QACvC,IAAI,CAAC3B,YAAY,CAACV,aAAa,EAAE;UAAEyC,YAAY,EAAEJ;QAAK,CAAC,CAAC;MAC1D,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIK,mBAAmB,WAAAA,oBAAC1C,aAAa,EAAE;QACjC,IAAIM,IAAI,GAAG,IAAI,CAACP,OAAO,CAACC,aAAa,CAAC;QACtC,OAAOM,IAAI,CAACmC,YAAY;MAC1B,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MAEIE,gBAAgB,WAAAA,iBAAC3C,aAAa,EAAE4C,KAAK,EAAE;QACrC,IAAI,CAAClC,YAAY,CAACV,aAAa,EAAE;UAAE6C,SAAS,EAAED;QAAM,CAAC,CAAC;MACxD,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,gBAAgB,WAAAA,iBAAC9C,aAAa,EAAE;QAC9B,IAAIM,IAAI,GAAG,IAAI,CAACP,OAAO,CAACC,aAAa,CAAC;QACtC,OAAOM,IAAI,CAACuC,SAAS;MACvB,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,iBAAiB,WAAAA,kBAAC/C,aAAa,EAAE4C,KAAK,EAAE;QACtC,IAAI,CAAClC,YAAY,CAACV,aAAa,EAAE;UAAEgD,UAAU,EAAEJ;QAAM,CAAC,CAAC;MACzD,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIK,iBAAiB,WAAAA,kBAACjD,aAAa,EAAE;QAC/B,IAAIM,IAAI,GAAG,IAAI,CAACP,OAAO,CAACC,aAAa,CAAC;QACtC,OAAOM,IAAI,CAACuC,SAAS;MACvB;IACF;EACF,CAAC,CAAC;EA/bFrD,EAAE,CAAC0D,EAAE,CAACC,WAAW,CAACC,KAAK,CAACzD,aAAa,GAAGA,aAAa;AAAC"
}