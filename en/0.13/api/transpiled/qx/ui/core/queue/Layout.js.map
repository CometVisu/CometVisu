{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "statics",
    "__queue",
    "__nesting",
    "remove",
    "widget",
    "toHashCode",
    "add",
    "ui",
    "core",
    "queue",
    "Manager",
    "scheduleFlush",
    "isScheduled",
    "flush",
    "__getSortedQueue",
    "i",
    "length",
    "hasValidLayout",
    "isRootWidget",
    "hasUserBounds",
    "hint",
    "getSizeHint",
    "renderLayout",
    "width",
    "height",
    "bounds",
    "getBounds",
    "left",
    "top",
    "getNestingLevel",
    "cache",
    "level",
    "parent",
    "$$parent",
    "leveldown",
    "__getLevelGroupedWidgets",
    "__P_324_3",
    "VisibilityQueue",
    "Visibility",
    "levels",
    "hash",
    "isVisible",
    "__P_324_2",
    "sortedQueue",
    "push",
    "invalidateLayoutCache",
    "oldSizeHint",
    "newSizeHint",
    "hintChanged",
    "minWidth",
    "maxWidth",
    "minHeight",
    "maxHeight",
    "getLayoutParent",
    "Layout"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/core/queue/Layout.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Sebastian Werner (wpbasti)\r\n     * Fabian Jakobs (fjakobs)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * The layout queue manages all widgets, which need a recalculation of their\r\n * layout. The {@link #flush} method computes the layout of all queued widgets\r\n * and their dependent widgets.\r\n */\r\nqx.Class.define(\"qx.ui.core.queue.Layout\", {\r\n  statics: {\r\n    /** @type {Map} This contains all the queued widgets for the next flush. */\r\n    __queue: {},\r\n\r\n    /** Nesting level cache **/\r\n    __nesting: {},\r\n\r\n    /**\r\n     * Clears the widget from the internal queue. Normally only used\r\n     * during interims disposes of one or a few widgets.\r\n     *\r\n     * @param widget {qx.ui.core.Widget} The widget to clear\r\n     */\r\n    remove(widget) {\r\n      delete this.__queue[widget.toHashCode()];\r\n    },\r\n\r\n    /**\r\n     * Mark a widget's layout as invalid and add its layout root to\r\n     * the queue.\r\n     *\r\n     * Should only be used by {@link qx.ui.core.Widget}.\r\n     *\r\n     * @param widget {qx.ui.core.Widget} Widget to add.\r\n     */\r\n    add(widget) {\r\n      this.__queue[widget.toHashCode()] = widget;\r\n      qx.ui.core.queue.Manager.scheduleFlush(\"layout\");\r\n    },\r\n\r\n    /**\r\n     * Check whether the queue has scheduled changes for a widget.\r\n     * Note that the layout parent can have changes scheduled that\r\n     * affect the children widgets.\r\n     *\r\n     * @param widget {qx.ui.core.Widget} Widget to check.\r\n     * @return {Boolean} Whether the widget given has layout changes queued.\r\n     */\r\n    isScheduled(widget) {\r\n      return !!this.__queue[widget.toHashCode()];\r\n    },\r\n\r\n    /**\r\n     * Update the layout of all widgets, which layout is marked as invalid.\r\n     *\r\n     * This is used exclusively by the {@link qx.ui.core.queue.Manager}.\r\n     *\r\n     */\r\n    flush() {\r\n      // get sorted widgets to (re-)layout\r\n      var queue = this.__getSortedQueue();\r\n\r\n      // iterate in reversed order to process widgets with the smallest nesting\r\n      // level first because these may affect the inner lying children\r\n      for (var i = queue.length - 1; i >= 0; i--) {\r\n        var widget = queue[i];\r\n\r\n        // continue if a relayout of one of the root's parents has made the\r\n        // layout valid\r\n        if (widget.hasValidLayout()) {\r\n          continue;\r\n        }\r\n\r\n        // overflow areas or qx.ui.root.*\r\n        if (widget.isRootWidget() && !widget.hasUserBounds()) {\r\n          // This is a real root widget. Set its size to its preferred size.\r\n          var hint = widget.getSizeHint();\r\n          widget.renderLayout(0, 0, hint.width, hint.height);\r\n        } else {\r\n          // This is an inner item of layout changes. Do a relayout of its\r\n          // children without changing its position and size.\r\n          var bounds = widget.getBounds();\r\n          if (bounds) {\r\n            widget.renderLayout(\r\n              bounds.left,\r\n              bounds.top,\r\n              bounds.width,\r\n              bounds.height\r\n            );\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Get the widget's nesting level. Top level widgets have a nesting level\r\n     * of <code>0</code>.\r\n     *\r\n     * @param widget {qx.ui.core.Widget} The widget to query.\r\n     * @return {Integer} The nesting level\r\n     */\r\n    getNestingLevel(widget) {\r\n      var cache = this.__nesting;\r\n      var level = 0;\r\n      var parent = widget;\r\n\r\n      // Detecting level\r\n      while (true) {\r\n        if (cache[parent.toHashCode()] != null) {\r\n          level += cache[parent.toHashCode()];\r\n          break;\r\n        }\r\n\r\n        if (!parent.$$parent) {\r\n          break;\r\n        }\r\n\r\n        parent = parent.$$parent;\r\n        level += 1;\r\n      }\r\n\r\n      // Update the processed hierarchy (runs from inner to outer)\r\n      var leveldown = level;\r\n      while (widget && widget !== parent) {\r\n        cache[widget.toHashCode()] = leveldown--;\r\n        widget = widget.$$parent;\r\n      }\r\n\r\n      return level;\r\n    },\r\n\r\n    /**\r\n     * Group widget by their nesting level.\r\n     *\r\n     * @return {Map[]} A sparse array. Each entry of the array contains a widget\r\n     *     map with all widgets of the same level as the array index.\r\n     */\r\n    __getLevelGroupedWidgets() {\r\n      var VisibilityQueue = qx.ui.core.queue.Visibility;\r\n\r\n      // clear cache\r\n      this.__nesting = {};\r\n\r\n      // sparse level array\r\n      var levels = [];\r\n      var queue = this.__queue;\r\n      var widget, level;\r\n\r\n      for (var hash in queue) {\r\n        widget = queue[hash];\r\n\r\n        if (VisibilityQueue.isVisible(widget)) {\r\n          level = this.getNestingLevel(widget);\r\n\r\n          // create hierarchy\r\n          if (!levels[level]) {\r\n            levels[level] = {};\r\n          }\r\n\r\n          // store widget in level map\r\n          levels[level][hash] = widget;\r\n\r\n          // remove widget from layout queue\r\n          delete queue[hash];\r\n        }\r\n      }\r\n\r\n      return levels;\r\n    },\r\n\r\n    /**\r\n     * Compute all layout roots of the given widgets. Layout roots are either\r\n     * root widgets or widgets, which preferred size has not changed by the\r\n     * layout changes of its children.\r\n     *\r\n     * This function returns the roots ordered by their nesting factors. The\r\n     * layout with the largest nesting level comes first.\r\n     *\r\n     * @return {qx.ui.core.Widget[]} Ordered list or layout roots.\r\n     */\r\n    __getSortedQueue() {\r\n      var sortedQueue = [];\r\n      var levels = this.__getLevelGroupedWidgets();\r\n\r\n      for (var level = levels.length - 1; level >= 0; level--) {\r\n        // Ignore empty levels (levels is an sparse array)\r\n        if (!levels[level]) {\r\n          continue;\r\n        }\r\n\r\n        for (var hash in levels[level]) {\r\n          var widget = levels[level][hash];\r\n\r\n          // This is a real layout root. Add it directly to the list\r\n          if (level == 0 || widget.isRootWidget() || widget.hasUserBounds()) {\r\n            sortedQueue.push(widget);\r\n            widget.invalidateLayoutCache();\r\n            continue;\r\n          }\r\n\r\n          // compare old size hint to new size hint\r\n          var oldSizeHint = widget.getSizeHint(false);\r\n\r\n          if (oldSizeHint) {\r\n            widget.invalidateLayoutCache();\r\n            var newSizeHint = widget.getSizeHint();\r\n\r\n            var hintChanged =\r\n              !widget.getBounds() ||\r\n              oldSizeHint.minWidth !== newSizeHint.minWidth ||\r\n              oldSizeHint.width !== newSizeHint.width ||\r\n              oldSizeHint.maxWidth !== newSizeHint.maxWidth ||\r\n              oldSizeHint.minHeight !== newSizeHint.minHeight ||\r\n              oldSizeHint.height !== newSizeHint.height ||\r\n              oldSizeHint.maxHeight !== newSizeHint.maxHeight;\r\n          } else {\r\n            hintChanged = true;\r\n          }\r\n\r\n          if (hintChanged) {\r\n            // Since the level is > 0, the widget must\r\n            // have a parent != null.\r\n            var parent = widget.getLayoutParent();\r\n            if (!levels[level - 1]) {\r\n              levels[level - 1] = {};\r\n            }\r\n\r\n            levels[level - 1][parent.toHashCode()] = parent;\r\n          } else {\r\n            // this is an internal layout root since its own preferred size\r\n            // has not changed.\r\n            sortedQueue.push(widget);\r\n          }\r\n        }\r\n      }\r\n\r\n      return sortedQueue;\r\n    }\r\n  }\r\n});\r\n"
  ],
  "mappings": "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"
}