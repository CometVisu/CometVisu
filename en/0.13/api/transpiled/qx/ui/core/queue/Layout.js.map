{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "statics",
    "__queue",
    "__nesting",
    "remove",
    "widget",
    "toHashCode",
    "add",
    "ui",
    "core",
    "queue",
    "Manager",
    "scheduleFlush",
    "isScheduled",
    "flush",
    "__getSortedQueue",
    "i",
    "length",
    "hasValidLayout",
    "isRootWidget",
    "hasUserBounds",
    "hint",
    "getSizeHint",
    "renderLayout",
    "width",
    "height",
    "bounds",
    "getBounds",
    "left",
    "top",
    "getNestingLevel",
    "cache",
    "level",
    "parent",
    "$$parent",
    "leveldown",
    "__getLevelGroupedWidgets",
    "VisibilityQueue",
    "Visibility",
    "levels",
    "hash",
    "isVisible",
    "sortedQueue",
    "push",
    "invalidateLayoutCache",
    "oldSizeHint",
    "newSizeHint",
    "hintChanged",
    "minWidth",
    "maxWidth",
    "minHeight",
    "maxHeight",
    "getLayoutParent",
    "Layout"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/core/queue/Layout.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * The layout queue manages all widgets, which need a recalculation of their\n * layout. The {@link #flush} method computes the layout of all queued widgets\n * and their dependent widgets.\n */\nqx.Class.define(\"qx.ui.core.queue.Layout\", {\n  statics: {\n    /** @type {Map} This contains all the queued widgets for the next flush. */\n    __queue: {},\n\n    /** Nesting level cache **/\n    __nesting: {},\n\n    /**\n     * Clears the widget from the internal queue. Normally only used\n     * during interims disposes of one or a few widgets.\n     *\n     * @param widget {qx.ui.core.Widget} The widget to clear\n     */\n    remove(widget) {\n      delete this.__queue[widget.toHashCode()];\n    },\n\n    /**\n     * Mark a widget's layout as invalid and add its layout root to\n     * the queue.\n     *\n     * Should only be used by {@link qx.ui.core.Widget}.\n     *\n     * @param widget {qx.ui.core.Widget} Widget to add.\n     */\n    add(widget) {\n      this.__queue[widget.toHashCode()] = widget;\n      qx.ui.core.queue.Manager.scheduleFlush(\"layout\");\n    },\n\n    /**\n     * Check whether the queue has scheduled changes for a widget.\n     * Note that the layout parent can have changes scheduled that\n     * affect the children widgets.\n     *\n     * @param widget {qx.ui.core.Widget} Widget to check.\n     * @return {Boolean} Whether the widget given has layout changes queued.\n     */\n    isScheduled(widget) {\n      return !!this.__queue[widget.toHashCode()];\n    },\n\n    /**\n     * Update the layout of all widgets, which layout is marked as invalid.\n     *\n     * This is used exclusively by the {@link qx.ui.core.queue.Manager}.\n     *\n     */\n    flush() {\n      // get sorted widgets to (re-)layout\n      var queue = this.__getSortedQueue();\n\n      // iterate in reversed order to process widgets with the smallest nesting\n      // level first because these may affect the inner lying children\n      for (var i = queue.length - 1; i >= 0; i--) {\n        var widget = queue[i];\n\n        // continue if a relayout of one of the root's parents has made the\n        // layout valid\n        if (widget.hasValidLayout()) {\n          continue;\n        }\n\n        // overflow areas or qx.ui.root.*\n        if (widget.isRootWidget() && !widget.hasUserBounds()) {\n          // This is a real root widget. Set its size to its preferred size.\n          var hint = widget.getSizeHint();\n          widget.renderLayout(0, 0, hint.width, hint.height);\n        } else {\n          // This is an inner item of layout changes. Do a relayout of its\n          // children without changing its position and size.\n          var bounds = widget.getBounds();\n          if (bounds) {\n            widget.renderLayout(\n              bounds.left,\n              bounds.top,\n              bounds.width,\n              bounds.height\n            );\n          }\n        }\n      }\n    },\n\n    /**\n     * Get the widget's nesting level. Top level widgets have a nesting level\n     * of <code>0</code>.\n     *\n     * @param widget {qx.ui.core.Widget} The widget to query.\n     * @return {Integer} The nesting level\n     */\n    getNestingLevel(widget) {\n      var cache = this.__nesting;\n      var level = 0;\n      var parent = widget;\n\n      // Detecting level\n      while (true) {\n        if (cache[parent.toHashCode()] != null) {\n          level += cache[parent.toHashCode()];\n          break;\n        }\n\n        if (!parent.$$parent) {\n          break;\n        }\n\n        parent = parent.$$parent;\n        level += 1;\n      }\n\n      // Update the processed hierarchy (runs from inner to outer)\n      var leveldown = level;\n      while (widget && widget !== parent) {\n        cache[widget.toHashCode()] = leveldown--;\n        widget = widget.$$parent;\n      }\n\n      return level;\n    },\n\n    /**\n     * Group widget by their nesting level.\n     *\n     * @return {Map[]} A sparse array. Each entry of the array contains a widget\n     *     map with all widgets of the same level as the array index.\n     */\n    __getLevelGroupedWidgets() {\n      var VisibilityQueue = qx.ui.core.queue.Visibility;\n\n      // clear cache\n      this.__nesting = {};\n\n      // sparse level array\n      var levels = [];\n      var queue = this.__queue;\n      var widget, level;\n\n      for (var hash in queue) {\n        widget = queue[hash];\n\n        if (VisibilityQueue.isVisible(widget)) {\n          level = this.getNestingLevel(widget);\n\n          // create hierarchy\n          if (!levels[level]) {\n            levels[level] = {};\n          }\n\n          // store widget in level map\n          levels[level][hash] = widget;\n\n          // remove widget from layout queue\n          delete queue[hash];\n        }\n      }\n\n      return levels;\n    },\n\n    /**\n     * Compute all layout roots of the given widgets. Layout roots are either\n     * root widgets or widgets, which preferred size has not changed by the\n     * layout changes of its children.\n     *\n     * This function returns the roots ordered by their nesting factors. The\n     * layout with the largest nesting level comes first.\n     *\n     * @return {qx.ui.core.Widget[]} Ordered list or layout roots.\n     */\n    __getSortedQueue() {\n      var sortedQueue = [];\n      var levels = this.__getLevelGroupedWidgets();\n\n      for (var level = levels.length - 1; level >= 0; level--) {\n        // Ignore empty levels (levels is an sparse array)\n        if (!levels[level]) {\n          continue;\n        }\n\n        for (var hash in levels[level]) {\n          var widget = levels[level][hash];\n\n          // This is a real layout root. Add it directly to the list\n          if (level == 0 || widget.isRootWidget() || widget.hasUserBounds()) {\n            sortedQueue.push(widget);\n            widget.invalidateLayoutCache();\n            continue;\n          }\n\n          // compare old size hint to new size hint\n          var oldSizeHint = widget.getSizeHint(false);\n\n          if (oldSizeHint) {\n            widget.invalidateLayoutCache();\n            var newSizeHint = widget.getSizeHint();\n\n            var hintChanged =\n              !widget.getBounds() ||\n              oldSizeHint.minWidth !== newSizeHint.minWidth ||\n              oldSizeHint.width !== newSizeHint.width ||\n              oldSizeHint.maxWidth !== newSizeHint.maxWidth ||\n              oldSizeHint.minHeight !== newSizeHint.minHeight ||\n              oldSizeHint.height !== newSizeHint.height ||\n              oldSizeHint.maxHeight !== newSizeHint.maxHeight;\n          } else {\n            hintChanged = true;\n          }\n\n          if (hintChanged) {\n            // Since the level is > 0, the widget must\n            // have a parent != null.\n            var parent = widget.getLayoutParent();\n            if (!levels[level - 1]) {\n              levels[level - 1] = {};\n            }\n\n            levels[level - 1][parent.toHashCode()] = parent;\n          } else {\n            // this is an internal layout root since its own preferred size\n            // has not changed.\n            sortedQueue.push(widget);\n          }\n        }\n      }\n\n      return sortedQueue;\n    }\n  }\n});\n"
  ],
  "mappings": "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"
}