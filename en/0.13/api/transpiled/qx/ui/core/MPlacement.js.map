{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Mixin",
    "define",
    "statics",
    "__visible",
    "__direction",
    "setVisibleElement",
    "elem",
    "getVisibleElement",
    "setMoveDirection",
    "direction",
    "Error",
    "getMoveDirection",
    "properties",
    "position",
    "check",
    "init",
    "themeable",
    "placeMethod",
    "domMove",
    "placementModeX",
    "placementModeY",
    "offsetLeft",
    "offsetTop",
    "offsetRight",
    "offsetBottom",
    "offset",
    "group",
    "mode",
    "members",
    "__ptwLiveUpdater",
    "__ptwLiveDisappearListener",
    "__ptwLiveUpdateDisappearListener",
    "getLayoutLocation",
    "widget",
    "insets",
    "bounds",
    "left",
    "top",
    "getBounds",
    "size",
    "getLayoutParent",
    "isRootWidget",
    "getInsets",
    "rootCoords",
    "getContentLocation",
    "right",
    "width",
    "bottom",
    "height",
    "moveTo",
    "visible",
    "ui",
    "core",
    "MPlacement",
    "elemLocation",
    "Math",
    "max",
    "getDomMove",
    "setDomPosition",
    "setLayoutProperties",
    "placeToWidget",
    "target",
    "liveupdate",
    "__cleanupFromLastPlaceToWidgetLiveUpdate",
    "lang",
    "Function",
    "bind",
    "event",
    "Idle",
    "getInstance",
    "addListener",
    "coords",
    "_place",
    "removeListener",
    "placeToPointer",
    "round",
    "getDocumentLeft",
    "getDocumentTop",
    "placeToElement",
    "location",
    "bom",
    "element",
    "Location",
    "get",
    "offsetWidth",
    "offsetHeight",
    "placeToPoint",
    "point",
    "_getPlacementOffsets",
    "getOffsetLeft",
    "getOffsetTop",
    "getOffsetRight",
    "getOffsetBottom",
    "__getPlacementSize",
    "callback",
    "_computePlacementSize",
    "isVisible",
    "addListenerOnce",
    "call",
    "result",
    "util",
    "placement",
    "Placement",
    "compute",
    "getPosition",
    "getPlacementModeX",
    "getPlacementModeY",
    "removeState",
    "addState",
    "destruct"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/core/MPlacement.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Martin Wittemann (martinwittemann)\n     * Christian Hagendorn (chris_schmidt)\n\n************************************************************************ */\n\n/**\n * Methods to place popup like widgets to other widgets, points,\n * pointer event coordinates, etc.\n */\nqx.Mixin.define(\"qx.ui.core.MPlacement\", {\n  statics: {\n    __visible: null,\n    __direction: \"left\",\n\n    /**\n     * Set the always visible element. If an element is set, the\n     * {@link #moveTo} method takes care of every move and tries not to cover\n     * the given element with a movable widget like a popup or context menu.\n     *\n     * @param elem {qx.ui.core.Widget} The widget which should always be visible.\n     */\n    setVisibleElement(elem) {\n      this.__visible = elem;\n    },\n\n    /**\n     * Returns the given always visible element. See {@link #setVisibleElement}\n     * for more details.\n     *\n     * @return {qx.ui.core.Widget|null} The given widget.\n     */\n    getVisibleElement() {\n      return this.__visible;\n    },\n\n    /**\n     * Set the move direction for an element which hides always visible element.\n     * The value has only an effect when the {@link #setVisibleElement} is set.\n     *\n     * @param direction {String} The direction <code>left</code> or <code>top</code>.\n     */\n    setMoveDirection(direction) {\n      if (direction === \"top\" || direction === \"left\") {\n        this.__direction = direction;\n      } else {\n        throw new Error(\n          \"Invalid value for the parameter 'direction' \" +\n            \"[qx.ui.core.MPlacement.setMoveDirection()], the value was '\" +\n            direction +\n            \"' \" +\n            \"but 'top' or 'left' are allowed.\"\n        );\n      }\n    },\n\n    /**\n     * Returns the move direction for an element which hides always visible element.\n     * See {@link #setMoveDirection} for more details.\n     *\n     * @return {String} The move direction.\n     */\n    getMoveDirection() {\n      return this.__direction;\n    }\n  },\n\n  properties: {\n    /**\n     * Position of the aligned object in relation to the opener.\n     *\n     * Please note than changes to this property are only applied\n     * when re-aligning the widget.\n     *\n     * The first part of the value is the edge to attach to. The second\n     * part the alignment of the orthogonal edge after the widget\n     * has been attached.\n     *\n     * The default value \"bottom-left\" for example means that the\n     * widget should be shown directly under the given target and\n     * then should be aligned to be left edge:\n     *\n     * <pre>\n     * +--------+\n     * | target |\n     * +--------+\n     * +-------------+\n     * |   widget    |\n     * +-------------+\n     * </pre>\n     */\n    position: {\n      check: [\n        \"top-left\",\n        \"top-center\",\n        \"top-right\",\n        \"bottom-left\",\n        \"bottom-center\",\n        \"bottom-right\",\n        \"left-top\",\n        \"left-middle\",\n        \"left-bottom\",\n        \"right-top\",\n        \"right-middle\",\n        \"right-bottom\"\n      ],\n\n      init: \"bottom-left\",\n      themeable: true\n    },\n\n    /**\n     * Whether the widget should be placed relative to an other widget or to\n     * the pointer.\n     */\n    placeMethod: {\n      check: [\"widget\", \"pointer\"],\n      init: \"pointer\",\n      themeable: true\n    },\n\n    /** Whether the widget should moved using DOM methods. */\n    domMove: {\n      check: \"Boolean\",\n      init: false\n    },\n\n    /**\n     * Selects the algorithm to place the widget horizontally. <code>direct</code>\n     * uses {@link qx.util.placement.DirectAxis}, <code>keep-align</code>\n     * uses {@link qx.util.placement.KeepAlignAxis} and <code>best-fit</code>\n     * uses {@link qx.util.placement.BestFitAxis}.\n     */\n    placementModeX: {\n      check: [\"direct\", \"keep-align\", \"best-fit\"],\n      init: \"keep-align\",\n      themeable: true\n    },\n\n    /**\n     * Selects the algorithm to place the widget vertically. <code>direct</code>\n     * uses {@link qx.util.placement.DirectAxis}, <code>keep-align</code>\n     * uses {@link qx.util.placement.KeepAlignAxis} and <code>best-fit</code>\n     * uses {@link qx.util.placement.BestFitAxis}.\n     */\n    placementModeY: {\n      check: [\"direct\", \"keep-align\", \"best-fit\"],\n      init: \"keep-align\",\n      themeable: true\n    },\n\n    /** Left offset of the pointer (in pixel) */\n    offsetLeft: {\n      check: \"Integer\",\n      init: 0,\n      themeable: true\n    },\n\n    /** Top offset of the pointer (in pixel) */\n    offsetTop: {\n      check: \"Integer\",\n      init: 0,\n      themeable: true\n    },\n\n    /** Right offset of the pointer (in pixel) */\n    offsetRight: {\n      check: \"Integer\",\n      init: 0,\n      themeable: true\n    },\n\n    /** Bottom offset of the pointer (in pixel) */\n    offsetBottom: {\n      check: \"Integer\",\n      init: 0,\n      themeable: true\n    },\n\n    /** Offsets in one group */\n    offset: {\n      group: [\"offsetTop\", \"offsetRight\", \"offsetBottom\", \"offsetLeft\"],\n      mode: \"shorthand\",\n      themeable: true\n    }\n  },\n\n  members: {\n    __ptwLiveUpdater: null,\n    __ptwLiveDisappearListener: null,\n    __ptwLiveUpdateDisappearListener: null,\n\n    /**\n     * Returns the location data like {qx.bom.element.Location#get} does,\n     * but does not rely on DOM elements coordinates to be rendered. Instead,\n     * this method works with the available layout data available in the moment\n     * when it is executed.\n     * This works best when called in some type of <code>resize</code> or\n     * <code>move</code> event which are supported by all widgets out of the\n     * box.\n     *\n     * @param widget {qx.ui.core.Widget} Any widget\n     * @return {Map|null} Returns a map with <code>left</code>, <code>top</code>,\n     *   <code>right</code> and <code>bottom</code> which contains the distance\n     *   of the widget relative coords the document.\n     */\n    getLayoutLocation(widget) {\n      // Use post-layout dimensions\n      // which do not rely on the final rendered DOM element\n      var insets, bounds, left, top;\n\n      // Add bounds of the widget itself\n      bounds = widget.getBounds();\n\n      if (!bounds) {\n        return null;\n      }\n\n      left = bounds.left;\n      top = bounds.top;\n\n      // Keep size to protect it for loop\n      var size = bounds;\n\n      // Now loop up with parents until reaching the root\n      widget = widget.getLayoutParent();\n      while (widget && !widget.isRootWidget()) {\n        // Add coordinates\n        bounds = widget.getBounds();\n        left += bounds.left;\n        top += bounds.top;\n\n        // Add insets\n        insets = widget.getInsets();\n        left += insets.left;\n        top += insets.top;\n\n        // Next parent\n        widget = widget.getLayoutParent();\n      }\n\n      // Add the rendered location of the root widget\n      if (widget && widget.isRootWidget()) {\n        var rootCoords = widget.getContentLocation();\n        if (rootCoords) {\n          left += rootCoords.left;\n          top += rootCoords.top;\n        }\n      }\n\n      // Build location data\n      return {\n        left: left,\n        top: top,\n        right: left + size.width,\n        bottom: top + size.height\n      };\n    },\n\n    /**\n     * Sets the position. Uses low-level, high-performance DOM\n     * methods when the property {@link #domMove} is enabled.\n     * Checks if an always visible element is set and moves the widget to not\n     * overlay the always visible widget if possible. The algorithm tries to\n     * move the widget as far left as necessary but not of the screen.\n     * ({@link #setVisibleElement})\n     *\n     * @param left {Integer} The left position\n     * @param top {Integer} The top position\n     */\n    moveTo(left, top) {\n      var visible = qx.ui.core.MPlacement.getVisibleElement();\n\n      // if we have an always visible element\n      if (visible) {\n        var bounds = this.getBounds();\n        var elemLocation = visible.getContentLocation();\n\n        // if we have bounds for both elements\n        if (bounds && elemLocation) {\n          var bottom = top + bounds.height;\n          var right = left + bounds.width;\n\n          // horizontal placement wrong\n          // each number is for the upcomming check (huge element is\n          // the always visible, eleme prefixed)\n          //     | 3 |\n          //   ---------\n          //   | |---| |\n          //   |       |\n          // --|-|   |-|--\n          // 1 | |   | | 2\n          // --|-|   |-|--\n          //   |       |\n          //   | |---| |\n          //   ---------\n          //     | 4 |\n          if (\n            right > elemLocation.left &&\n            left < elemLocation.right &&\n            bottom > elemLocation.top &&\n            top < elemLocation.bottom\n          ) {\n            var direction = qx.ui.core.MPlacement.getMoveDirection();\n\n            if (direction === \"left\") {\n              left = Math.max(elemLocation.left - bounds.width, 0);\n            } else {\n              top = Math.max(elemLocation.top - bounds.height, 0);\n            }\n          }\n        }\n      }\n\n      if (this.getDomMove()) {\n        this.setDomPosition(left, top);\n      } else {\n        this.setLayoutProperties({ left: left, top: top });\n      }\n    },\n\n    /**\n     * Places the widget to another (at least laid out) widget. The DOM\n     * element is not needed, but the bounds are needed to compute the\n     * location of the widget to align to.\n     *\n     * @param target {qx.ui.core.Widget} Target coords align coords\n     * @param liveupdate {Boolean} Flag indicating if the position of the\n     * widget should be checked and corrected automatically.\n     * @return {Boolean} true if the widget was successfully placed\n     */\n    placeToWidget(target, liveupdate) {\n      // Use the idle event to make sure that the widget's position gets\n      // updated automatically (e.g. the widget gets scrolled).\n      if (liveupdate) {\n        this.__cleanupFromLastPlaceToWidgetLiveUpdate();\n\n        // Bind target and livupdate to placeToWidget\n        this.__ptwLiveUpdater = qx.lang.Function.bind(\n          this.placeToWidget,\n          this,\n          target,\n          false\n        );\n\n        qx.event.Idle.getInstance().addListener(\n          \"interval\",\n          this.__ptwLiveUpdater\n        );\n\n        // Remove the listener when the element disappears.\n        this.__ptwLiveUpdateDisappearListener = function () {\n          this.__cleanupFromLastPlaceToWidgetLiveUpdate();\n        };\n\n        this.addListener(\n          \"disappear\",\n          this.__ptwLiveUpdateDisappearListener,\n          this\n        );\n      }\n\n      var coords =\n        target.getContentLocation() || this.getLayoutLocation(target);\n\n      if (coords != null) {\n        this._place(coords);\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    /**\n     * Removes all resources allocated by the last run of placeToWidget with liveupdate=true\n     */\n    __cleanupFromLastPlaceToWidgetLiveUpdate() {\n      if (this.__ptwLiveUpdater) {\n        qx.event.Idle.getInstance().removeListener(\n          \"interval\",\n          this.__ptwLiveUpdater\n        );\n\n        this.__ptwLiveUpdater = null;\n      }\n\n      if (this.__ptwLiveUpdateDisappearListener) {\n        this.removeListener(\n          \"disappear\",\n          this.__ptwLiveUpdateDisappearListener,\n          this\n        );\n\n        this.__ptwLiveUpdateDisappearListener = null;\n      }\n    },\n\n    /**\n     * Places the widget to the pointer position.\n     *\n     * @param event {qx.event.type.Pointer} Pointer event to align to\n     */\n    placeToPointer(event) {\n      var left = Math.round(event.getDocumentLeft());\n      var top = Math.round(event.getDocumentTop());\n\n      var coords = {\n        left: left,\n        top: top,\n        right: left,\n        bottom: top\n      };\n\n      this._place(coords);\n    },\n\n    /**\n     * Places the widget to any (rendered) DOM element.\n     *\n     * @param elem {Element} DOM element to align to\n     * @param liveupdate {Boolean} Flag indicating if the position of the\n     * widget should be checked and corrected automatically.\n     */\n    placeToElement(elem, liveupdate) {\n      var location = qx.bom.element.Location.get(elem);\n      var coords = {\n        left: location.left,\n        top: location.top,\n        right: location.left + elem.offsetWidth,\n        bottom: location.top + elem.offsetHeight\n      };\n\n      // Use the idle event to make sure that the widget's position gets\n      // updated automatically (e.g. the widget gets scrolled).\n      if (liveupdate) {\n        // Bind target and livupdate to placeToWidget\n        this.__ptwLiveUpdater = qx.lang.Function.bind(\n          this.placeToElement,\n          this,\n          elem,\n          false\n        );\n\n        qx.event.Idle.getInstance().addListener(\n          \"interval\",\n          this.__ptwLiveUpdater\n        );\n\n        // Remove the listener when the element disappears.\n        this.addListener(\"disappear\", () => {\n          if (this.__ptwLiveUpdater) {\n            qx.event.Idle.getInstance().removeListener(\n              \"interval\",\n              this.__ptwLiveUpdater\n            );\n\n            this.__ptwLiveUpdater = null;\n          }\n        });\n      }\n\n      this._place(coords);\n    },\n\n    /**\n     * Places the widget in relation to the given point\n     *\n     * @param point {Map} Coordinate of any point with the keys <code>left</code>\n     *   and <code>top</code>.\n     */\n    placeToPoint(point) {\n      var coords = {\n        left: point.left,\n        top: point.top,\n        right: point.left,\n        bottom: point.top\n      };\n\n      this._place(coords);\n    },\n\n    /**\n     * Returns the placement offsets as a map\n     *\n     * @return {Map} The placement offsets\n     */\n    _getPlacementOffsets() {\n      return {\n        left: this.getOffsetLeft(),\n        top: this.getOffsetTop(),\n        right: this.getOffsetRight(),\n        bottom: this.getOffsetBottom()\n      };\n    },\n\n    /**\n     * Get the size of the object to place. The callback will be called with\n     * the size as first argument. This methods works asynchronously.\n     *\n     * The size of the object to place is the size of the widget. If a widget\n     * including this mixin needs a different size it can implement the method\n     * <code>_computePlacementSize</code>, which returns the size.\n     *\n     *  @param callback {Function} This function will be called with the size as\n     *    first argument\n     */\n    __getPlacementSize(callback) {\n      var size = null;\n\n      if (this._computePlacementSize) {\n        var size = this._computePlacementSize();\n      } else if (this.isVisible()) {\n        var size = this.getBounds();\n      }\n\n      if (size == null) {\n        this.addListenerOnce(\"appear\", () => {\n          this.__getPlacementSize(callback);\n        });\n      } else {\n        callback.call(this, size);\n      }\n    },\n\n    /**\n     * Internal method to read specific this properties and\n     * apply the results to the this afterwards.\n     *\n     * @param coords {Map} Location of the object to align the this to. This map\n     *   should have the keys <code>left</code>, <code>top</code>, <code>right</code>\n     *   and <code>bottom</code>.\n     */\n    _place(coords) {\n      this.__getPlacementSize(function (size) {\n        var result = qx.util.placement.Placement.compute(\n          size,\n          this.getLayoutParent().getBounds(),\n          coords,\n          this._getPlacementOffsets(),\n          this.getPosition(),\n          this.getPlacementModeX(),\n          this.getPlacementModeY()\n        );\n\n        // state handling for tooltips e.g.\n        this.removeState(\"placementLeft\");\n        this.removeState(\"placementRight\");\n        this.addState(\n          coords.left < result.left ? \"placementRight\" : \"placementLeft\"\n        );\n\n        this.moveTo(result.left, result.top);\n      });\n    }\n  },\n\n  destruct() {\n    this.__cleanupFromLastPlaceToWidgetLiveUpdate();\n  }\n});\n"
  ],
  "mappings": "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"
}