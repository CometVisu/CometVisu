{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Mixin",
    "define",
    "statics",
    "__visible",
    "__direction",
    "setVisibleElement",
    "elem",
    "getVisibleElement",
    "setMoveDirection",
    "direction",
    "Error",
    "getMoveDirection",
    "properties",
    "position",
    "check",
    "init",
    "themeable",
    "placeMethod",
    "domMove",
    "placementModeX",
    "placementModeY",
    "offsetLeft",
    "offsetTop",
    "offsetRight",
    "offsetBottom",
    "offset",
    "group",
    "mode",
    "members",
    "__ptwLiveUpdater",
    "__ptwLiveDisappearListener",
    "__ptwLiveUpdateDisappearListener",
    "getLayoutLocation",
    "widget",
    "insets",
    "bounds",
    "left",
    "top",
    "getBounds",
    "size",
    "getLayoutParent",
    "isRootWidget",
    "getInsets",
    "rootCoords",
    "getContentLocation",
    "right",
    "width",
    "bottom",
    "height",
    "moveTo",
    "visible",
    "ui",
    "core",
    "MPlacement",
    "elemLocation",
    "Math",
    "max",
    "getDomMove",
    "setDomPosition",
    "setLayoutProperties",
    "placeToWidget",
    "target",
    "liveupdate",
    "__cleanupFromLastPlaceToWidgetLiveUpdate",
    "lang",
    "Function",
    "bind",
    "event",
    "Idle",
    "getInstance",
    "addListener",
    "coords",
    "_place",
    "__P_324_5",
    "removeListener",
    "placeToPointer",
    "round",
    "getDocumentLeft",
    "getDocumentTop",
    "placeToElement",
    "_this",
    "location",
    "bom",
    "element",
    "Location",
    "get",
    "offsetWidth",
    "offsetHeight",
    "placeToPoint",
    "point",
    "_getPlacementOffsets",
    "getOffsetLeft",
    "getOffsetTop",
    "getOffsetRight",
    "getOffsetBottom",
    "__getPlacementSize",
    "__P_324_6",
    "callback",
    "_this2",
    "_computePlacementSize",
    "isVisible",
    "addListenerOnce",
    "call",
    "result",
    "util",
    "placement",
    "Placement",
    "compute",
    "getPosition",
    "getPlacementModeX",
    "getPlacementModeY",
    "removeState",
    "addState",
    "destruct"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/core/MPlacement.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Sebastian Werner (wpbasti)\r\n     * Martin Wittemann (martinwittemann)\r\n     * Christian Hagendorn (chris_schmidt)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * Methods to place popup like widgets to other widgets, points,\r\n * pointer event coordinates, etc.\r\n */\r\nqx.Mixin.define(\"qx.ui.core.MPlacement\", {\r\n  statics: {\r\n    __visible: null,\r\n    __direction: \"left\",\r\n\r\n    /**\r\n     * Set the always visible element. If an element is set, the\r\n     * {@link #moveTo} method takes care of every move and tries not to cover\r\n     * the given element with a movable widget like a popup or context menu.\r\n     *\r\n     * @param elem {qx.ui.core.Widget} The widget which should always be visible.\r\n     */\r\n    setVisibleElement(elem) {\r\n      this.__visible = elem;\r\n    },\r\n\r\n    /**\r\n     * Returns the given always visible element. See {@link #setVisibleElement}\r\n     * for more details.\r\n     *\r\n     * @return {qx.ui.core.Widget|null} The given widget.\r\n     */\r\n    getVisibleElement() {\r\n      return this.__visible;\r\n    },\r\n\r\n    /**\r\n     * Set the move direction for an element which hides always visible element.\r\n     * The value has only an effect when the {@link #setVisibleElement} is set.\r\n     *\r\n     * @param direction {String} The direction <code>left</code> or <code>top</code>.\r\n     */\r\n    setMoveDirection(direction) {\r\n      if (direction === \"top\" || direction === \"left\") {\r\n        this.__direction = direction;\r\n      } else {\r\n        throw new Error(\r\n          \"Invalid value for the parameter 'direction' \" +\r\n            \"[qx.ui.core.MPlacement.setMoveDirection()], the value was '\" +\r\n            direction +\r\n            \"' \" +\r\n            \"but 'top' or 'left' are allowed.\"\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns the move direction for an element which hides always visible element.\r\n     * See {@link #setMoveDirection} for more details.\r\n     *\r\n     * @return {String} The move direction.\r\n     */\r\n    getMoveDirection() {\r\n      return this.__direction;\r\n    }\r\n  },\r\n\r\n  properties: {\r\n    /**\r\n     * Position of the aligned object in relation to the opener.\r\n     *\r\n     * Please note than changes to this property are only applied\r\n     * when re-aligning the widget.\r\n     *\r\n     * The first part of the value is the edge to attach to. The second\r\n     * part the alignment of the orthogonal edge after the widget\r\n     * has been attached.\r\n     *\r\n     * The default value \"bottom-left\" for example means that the\r\n     * widget should be shown directly under the given target and\r\n     * then should be aligned to be left edge:\r\n     *\r\n     * <pre>\r\n     * +--------+\r\n     * | target |\r\n     * +--------+\r\n     * +-------------+\r\n     * |   widget    |\r\n     * +-------------+\r\n     * </pre>\r\n     */\r\n    position: {\r\n      check: [\r\n        \"top-left\",\r\n        \"top-center\",\r\n        \"top-right\",\r\n        \"bottom-left\",\r\n        \"bottom-center\",\r\n        \"bottom-right\",\r\n        \"left-top\",\r\n        \"left-middle\",\r\n        \"left-bottom\",\r\n        \"right-top\",\r\n        \"right-middle\",\r\n        \"right-bottom\"\r\n      ],\r\n\r\n      init: \"bottom-left\",\r\n      themeable: true\r\n    },\r\n\r\n    /**\r\n     * Whether the widget should be placed relative to an other widget or to\r\n     * the pointer.\r\n     */\r\n    placeMethod: {\r\n      check: [\"widget\", \"pointer\"],\r\n      init: \"pointer\",\r\n      themeable: true\r\n    },\r\n\r\n    /** Whether the widget should moved using DOM methods. */\r\n    domMove: {\r\n      check: \"Boolean\",\r\n      init: false\r\n    },\r\n\r\n    /**\r\n     * Selects the algorithm to place the widget horizontally. <code>direct</code>\r\n     * uses {@link qx.util.placement.DirectAxis}, <code>keep-align</code>\r\n     * uses {@link qx.util.placement.KeepAlignAxis} and <code>best-fit</code>\r\n     * uses {@link qx.util.placement.BestFitAxis}.\r\n     */\r\n    placementModeX: {\r\n      check: [\"direct\", \"keep-align\", \"best-fit\"],\r\n      init: \"keep-align\",\r\n      themeable: true\r\n    },\r\n\r\n    /**\r\n     * Selects the algorithm to place the widget vertically. <code>direct</code>\r\n     * uses {@link qx.util.placement.DirectAxis}, <code>keep-align</code>\r\n     * uses {@link qx.util.placement.KeepAlignAxis} and <code>best-fit</code>\r\n     * uses {@link qx.util.placement.BestFitAxis}.\r\n     */\r\n    placementModeY: {\r\n      check: [\"direct\", \"keep-align\", \"best-fit\"],\r\n      init: \"keep-align\",\r\n      themeable: true\r\n    },\r\n\r\n    /** Left offset of the pointer (in pixel) */\r\n    offsetLeft: {\r\n      check: \"Integer\",\r\n      init: 0,\r\n      themeable: true\r\n    },\r\n\r\n    /** Top offset of the pointer (in pixel) */\r\n    offsetTop: {\r\n      check: \"Integer\",\r\n      init: 0,\r\n      themeable: true\r\n    },\r\n\r\n    /** Right offset of the pointer (in pixel) */\r\n    offsetRight: {\r\n      check: \"Integer\",\r\n      init: 0,\r\n      themeable: true\r\n    },\r\n\r\n    /** Bottom offset of the pointer (in pixel) */\r\n    offsetBottom: {\r\n      check: \"Integer\",\r\n      init: 0,\r\n      themeable: true\r\n    },\r\n\r\n    /** Offsets in one group */\r\n    offset: {\r\n      group: [\"offsetTop\", \"offsetRight\", \"offsetBottom\", \"offsetLeft\"],\r\n      mode: \"shorthand\",\r\n      themeable: true\r\n    }\r\n  },\r\n\r\n  members: {\r\n    __ptwLiveUpdater: null,\r\n    __ptwLiveDisappearListener: null,\r\n    __ptwLiveUpdateDisappearListener: null,\r\n\r\n    /**\r\n     * Returns the location data like {qx.bom.element.Location#get} does,\r\n     * but does not rely on DOM elements coordinates to be rendered. Instead,\r\n     * this method works with the available layout data available in the moment\r\n     * when it is executed.\r\n     * This works best when called in some type of <code>resize</code> or\r\n     * <code>move</code> event which are supported by all widgets out of the\r\n     * box.\r\n     *\r\n     * @param widget {qx.ui.core.Widget} Any widget\r\n     * @return {Map|null} Returns a map with <code>left</code>, <code>top</code>,\r\n     *   <code>right</code> and <code>bottom</code> which contains the distance\r\n     *   of the widget relative coords the document.\r\n     */\r\n    getLayoutLocation(widget) {\r\n      // Use post-layout dimensions\r\n      // which do not rely on the final rendered DOM element\r\n      var insets, bounds, left, top;\r\n\r\n      // Add bounds of the widget itself\r\n      bounds = widget.getBounds();\r\n\r\n      if (!bounds) {\r\n        return null;\r\n      }\r\n\r\n      left = bounds.left;\r\n      top = bounds.top;\r\n\r\n      // Keep size to protect it for loop\r\n      var size = bounds;\r\n\r\n      // Now loop up with parents until reaching the root\r\n      widget = widget.getLayoutParent();\r\n      while (widget && !widget.isRootWidget()) {\r\n        // Add coordinates\r\n        bounds = widget.getBounds();\r\n        left += bounds.left;\r\n        top += bounds.top;\r\n\r\n        // Add insets\r\n        insets = widget.getInsets();\r\n        left += insets.left;\r\n        top += insets.top;\r\n\r\n        // Next parent\r\n        widget = widget.getLayoutParent();\r\n      }\r\n\r\n      // Add the rendered location of the root widget\r\n      if (widget && widget.isRootWidget()) {\r\n        var rootCoords = widget.getContentLocation();\r\n        if (rootCoords) {\r\n          left += rootCoords.left;\r\n          top += rootCoords.top;\r\n        }\r\n      }\r\n\r\n      // Build location data\r\n      return {\r\n        left: left,\r\n        top: top,\r\n        right: left + size.width,\r\n        bottom: top + size.height\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Sets the position. Uses low-level, high-performance DOM\r\n     * methods when the property {@link #domMove} is enabled.\r\n     * Checks if an always visible element is set and moves the widget to not\r\n     * overlay the always visible widget if possible. The algorithm tries to\r\n     * move the widget as far left as necessary but not of the screen.\r\n     * ({@link #setVisibleElement})\r\n     *\r\n     * @param left {Integer} The left position\r\n     * @param top {Integer} The top position\r\n     */\r\n    moveTo(left, top) {\r\n      var visible = qx.ui.core.MPlacement.getVisibleElement();\r\n\r\n      // if we have an always visible element\r\n      if (visible) {\r\n        var bounds = this.getBounds();\r\n        var elemLocation = visible.getContentLocation();\r\n\r\n        // if we have bounds for both elements\r\n        if (bounds && elemLocation) {\r\n          var bottom = top + bounds.height;\r\n          var right = left + bounds.width;\r\n\r\n          // horizontal placement wrong\r\n          // each number is for the upcomming check (huge element is\r\n          // the always visible, eleme prefixed)\r\n          //     | 3 |\r\n          //   ---------\r\n          //   | |---| |\r\n          //   |       |\r\n          // --|-|   |-|--\r\n          // 1 | |   | | 2\r\n          // --|-|   |-|--\r\n          //   |       |\r\n          //   | |---| |\r\n          //   ---------\r\n          //     | 4 |\r\n          if (\r\n            right > elemLocation.left &&\r\n            left < elemLocation.right &&\r\n            bottom > elemLocation.top &&\r\n            top < elemLocation.bottom\r\n          ) {\r\n            var direction = qx.ui.core.MPlacement.getMoveDirection();\r\n\r\n            if (direction === \"left\") {\r\n              left = Math.max(elemLocation.left - bounds.width, 0);\r\n            } else {\r\n              top = Math.max(elemLocation.top - bounds.height, 0);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.getDomMove()) {\r\n        this.setDomPosition(left, top);\r\n      } else {\r\n        this.setLayoutProperties({ left: left, top: top });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Places the widget to another (at least laid out) widget. The DOM\r\n     * element is not needed, but the bounds are needed to compute the\r\n     * location of the widget to align to.\r\n     *\r\n     * @param target {qx.ui.core.Widget} Target coords align coords\r\n     * @param liveupdate {Boolean} Flag indicating if the position of the\r\n     * widget should be checked and corrected automatically.\r\n     * @return {Boolean} true if the widget was successfully placed\r\n     */\r\n    placeToWidget(target, liveupdate) {\r\n      // Use the idle event to make sure that the widget's position gets\r\n      // updated automatically (e.g. the widget gets scrolled).\r\n      if (liveupdate) {\r\n        this.__cleanupFromLastPlaceToWidgetLiveUpdate();\r\n\r\n        // Bind target and livupdate to placeToWidget\r\n        this.__ptwLiveUpdater = qx.lang.Function.bind(\r\n          this.placeToWidget,\r\n          this,\r\n          target,\r\n          false\r\n        );\r\n\r\n        qx.event.Idle.getInstance().addListener(\r\n          \"interval\",\r\n          this.__ptwLiveUpdater\r\n        );\r\n\r\n        // Remove the listener when the element disappears.\r\n        this.__ptwLiveUpdateDisappearListener = function () {\r\n          this.__cleanupFromLastPlaceToWidgetLiveUpdate();\r\n        };\r\n\r\n        this.addListener(\r\n          \"disappear\",\r\n          this.__ptwLiveUpdateDisappearListener,\r\n          this\r\n        );\r\n      }\r\n\r\n      var coords =\r\n        target.getContentLocation() || this.getLayoutLocation(target);\r\n\r\n      if (coords != null) {\r\n        this._place(coords);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Removes all resources allocated by the last run of placeToWidget with liveupdate=true\r\n     */\r\n    __cleanupFromLastPlaceToWidgetLiveUpdate() {\r\n      if (this.__ptwLiveUpdater) {\r\n        qx.event.Idle.getInstance().removeListener(\r\n          \"interval\",\r\n          this.__ptwLiveUpdater\r\n        );\r\n\r\n        this.__ptwLiveUpdater = null;\r\n      }\r\n\r\n      if (this.__ptwLiveUpdateDisappearListener) {\r\n        this.removeListener(\r\n          \"disappear\",\r\n          this.__ptwLiveUpdateDisappearListener,\r\n          this\r\n        );\r\n\r\n        this.__ptwLiveUpdateDisappearListener = null;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Places the widget to the pointer position.\r\n     *\r\n     * @param event {qx.event.type.Pointer} Pointer event to align to\r\n     */\r\n    placeToPointer(event) {\r\n      var left = Math.round(event.getDocumentLeft());\r\n      var top = Math.round(event.getDocumentTop());\r\n\r\n      var coords = {\r\n        left: left,\r\n        top: top,\r\n        right: left,\r\n        bottom: top\r\n      };\r\n\r\n      this._place(coords);\r\n    },\r\n\r\n    /**\r\n     * Places the widget to any (rendered) DOM element.\r\n     *\r\n     * @param elem {Element} DOM element to align to\r\n     * @param liveupdate {Boolean} Flag indicating if the position of the\r\n     * widget should be checked and corrected automatically.\r\n     */\r\n    placeToElement(elem, liveupdate) {\r\n      var location = qx.bom.element.Location.get(elem);\r\n      var coords = {\r\n        left: location.left,\r\n        top: location.top,\r\n        right: location.left + elem.offsetWidth,\r\n        bottom: location.top + elem.offsetHeight\r\n      };\r\n\r\n      // Use the idle event to make sure that the widget's position gets\r\n      // updated automatically (e.g. the widget gets scrolled).\r\n      if (liveupdate) {\r\n        // Bind target and livupdate to placeToWidget\r\n        this.__ptwLiveUpdater = qx.lang.Function.bind(\r\n          this.placeToElement,\r\n          this,\r\n          elem,\r\n          false\r\n        );\r\n\r\n        qx.event.Idle.getInstance().addListener(\r\n          \"interval\",\r\n          this.__ptwLiveUpdater\r\n        );\r\n\r\n        // Remove the listener when the element disappears.\r\n        this.addListener(\"disappear\", () => {\r\n          if (this.__ptwLiveUpdater) {\r\n            qx.event.Idle.getInstance().removeListener(\r\n              \"interval\",\r\n              this.__ptwLiveUpdater\r\n            );\r\n\r\n            this.__ptwLiveUpdater = null;\r\n          }\r\n        });\r\n      }\r\n\r\n      this._place(coords);\r\n    },\r\n\r\n    /**\r\n     * Places the widget in relation to the given point\r\n     *\r\n     * @param point {Map} Coordinate of any point with the keys <code>left</code>\r\n     *   and <code>top</code>.\r\n     */\r\n    placeToPoint(point) {\r\n      var coords = {\r\n        left: point.left,\r\n        top: point.top,\r\n        right: point.left,\r\n        bottom: point.top\r\n      };\r\n\r\n      this._place(coords);\r\n    },\r\n\r\n    /**\r\n     * Returns the placement offsets as a map\r\n     *\r\n     * @return {Map} The placement offsets\r\n     */\r\n    _getPlacementOffsets() {\r\n      return {\r\n        left: this.getOffsetLeft(),\r\n        top: this.getOffsetTop(),\r\n        right: this.getOffsetRight(),\r\n        bottom: this.getOffsetBottom()\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Get the size of the object to place. The callback will be called with\r\n     * the size as first argument. This methods works asynchronously.\r\n     *\r\n     * The size of the object to place is the size of the widget. If a widget\r\n     * including this mixin needs a different size it can implement the method\r\n     * <code>_computePlacementSize</code>, which returns the size.\r\n     *\r\n     *  @param callback {Function} This function will be called with the size as\r\n     *    first argument\r\n     */\r\n    __getPlacementSize(callback) {\r\n      var size = null;\r\n\r\n      if (this._computePlacementSize) {\r\n        var size = this._computePlacementSize();\r\n      } else if (this.isVisible()) {\r\n        var size = this.getBounds();\r\n      }\r\n\r\n      if (size == null) {\r\n        this.addListenerOnce(\"appear\", () => {\r\n          this.__getPlacementSize(callback);\r\n        });\r\n      } else {\r\n        callback.call(this, size);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Internal method to read specific this properties and\r\n     * apply the results to the this afterwards.\r\n     *\r\n     * @param coords {Map} Location of the object to align the this to. This map\r\n     *   should have the keys <code>left</code>, <code>top</code>, <code>right</code>\r\n     *   and <code>bottom</code>.\r\n     */\r\n    _place(coords) {\r\n      this.__getPlacementSize(function (size) {\r\n        var result = qx.util.placement.Placement.compute(\r\n          size,\r\n          this.getLayoutParent().getBounds(),\r\n          coords,\r\n          this._getPlacementOffsets(),\r\n          this.getPosition(),\r\n          this.getPlacementModeX(),\r\n          this.getPlacementModeY()\r\n        );\r\n\r\n        // state handling for tooltips e.g.\r\n        this.removeState(\"placementLeft\");\r\n        this.removeState(\"placementRight\");\r\n        this.addState(\r\n          coords.left < result.left ? \"placementRight\" : \"placementLeft\"\r\n        );\r\n\r\n        this.moveTo(result.left, result.top);\r\n      });\r\n    }\r\n  },\r\n\r\n  destruct() {\r\n    this.__cleanupFromLastPlaceToWidgetLiveUpdate();\r\n  }\r\n});\r\n"
  ],
  "mappings": "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"
}