{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "ui",
    "mobile",
    "container",
    "Composite",
    "construct",
    "scrollProperties",
    "constructor",
    "call",
    "_scrollProperties",
    "addListener",
    "_updateWaypoints",
    "_waypointsX",
    "_waypointsY",
    "_currentX",
    "_currentY",
    "events",
    "scrollEnd",
    "pageEnd",
    "waypoint",
    "momentumStart",
    "momentumEnd",
    "properties",
    "defaultCssClass",
    "refine",
    "init",
    "delegate",
    "nullable",
    "members",
    "_activeWaypointX",
    "_activeWaypointY",
    "_calculatedWaypointsX",
    "_calculatedWaypointsY",
    "_setCurrentX",
    "value",
    "old",
    "_fireWaypoint",
    "_setCurrentY",
    "setWaypointsX",
    "waypoints",
    "setWaypointsY",
    "getScrollHeight",
    "_getScrollHeight",
    "getScrollWidth",
    "_getScrollWidth",
    "_calcWaypoints",
    "results",
    "scrollSize",
    "axis",
    "offset",
    "i",
    "length",
    "lang",
    "Type",
    "isString",
    "endsWith",
    "parseInt",
    "push",
    "input",
    "index",
    "element",
    "getContentElement",
    "waypointElements",
    "bom",
    "Selector",
    "query",
    "j",
    "position",
    "Location",
    "getRelative",
    "top",
    "scrollTop",
    "left",
    "scrollLeft",
    "isNumber",
    "sort",
    "a",
    "b",
    "nextWaypoint",
    "direction",
    "activeWaypoint",
    "fireDataEvent",
    "_createContainerElement",
    "Scroll",
    "superclass",
    "prototype",
    "scrollElement",
    "_createScrollElement",
    "_getContentElement",
    "contentElement",
    "scrollContentElement",
    "_getScrollContentElement",
    "refresh",
    "_refresh",
    "scrollTo",
    "x",
    "y",
    "time",
    "_scrollTo",
    "getPosition",
    "_getPosition",
    "isScrollable",
    "_isScrollable",
    "_isScrollableX",
    "_isScrollableY",
    "getLayoutParent",
    "parentWidth",
    "getContainerElement",
    "clientWidth",
    "contentWidth",
    "scrollWidth",
    "Dimension",
    "getWidth",
    "parentHeight",
    "clientHeight",
    "contentHeight",
    "scrollHeight",
    "getHeight",
    "scrollToElement",
    "target",
    "_scrollToElement",
    "location",
    "_getScrollOffset",
    "getDelegate",
    "getScrollOffset",
    "bind",
    "scrollToWidget",
    "widget",
    "defer",
    "statics",
    "core",
    "Environment",
    "get",
    "include",
    "MIScroll",
    "MNativeScroll",
    "destruct",
    "removeListener"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/mobile/container/Scroll.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2004-2011 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Tino Butz (tbtz)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * Container, which allows, depending on the set variant <code>qx.mobile.nativescroll</code>,\r\n * vertical and horizontal scrolling if the contents is larger than the container.\r\n *\r\n * Note that this class can only have one child widget. This container has a\r\n * fixed layout, which cannot be changed.\r\n *\r\n * *Example*\r\n *\r\n * Here is a little example of how to use the widget.\r\n *\r\n * <pre class='javascript'>\r\n *   // create the scroll widget\r\n *   var scroll = new qx.ui.mobile.container.Scroll();\r\n *\r\n *   // add a children\r\n *   scroll.add(new qx.ui.mobile.basic.Label(\"Name: \"));\r\n *\r\n *   this.getRoot().add(scroll);\r\n * </pre>\r\n *\r\n * This example creates a scroll container and adds a label to it.\r\n */\r\nqx.Class.define(\"qx.ui.mobile.container.Scroll\", {\r\n  extend: qx.ui.mobile.container.Composite,\r\n\r\n  /**\r\n   * @param scrollProperties {Object} A map with scroll properties which are passed to the scrolling container (may contain iScroll properties).\r\n   */\r\n  construct(scrollProperties) {\r\n    super();\r\n\r\n    if (scrollProperties) {\r\n      this._scrollProperties = scrollProperties;\r\n    }\r\n\r\n    this.addListener(\"appear\", this._updateWaypoints, this);\r\n\r\n    this._waypointsX = [];\r\n    this._waypointsY = [];\r\n\r\n    this._currentX = 0;\r\n    this._currentY = 0;\r\n  },\r\n\r\n  events: {\r\n    /** Fired when the scroll container reaches its end position (including momentum/inertia). */\r\n    scrollEnd: \"qx.event.type.Event\",\r\n\r\n    /** Fired when the user scrolls to the end of scroll area. */\r\n    pageEnd: \"qx.event.type.Event\",\r\n\r\n    /** Fired when a vertical or horizontal waypoint is triggered. Data:\r\n     * <code> {\"offset\": 0,\r\n     *        \"input\": \"10%\",\r\n     *        \"index\": 0,\r\n     *        \"element\" : 0}</code>\r\n     */\r\n    waypoint: \"qx.event.type.Data\",\r\n\r\n    /**\r\n     * Fired when a momentum starts on an iOS device.\r\n     */\r\n    momentumStart: \"qx.event.type.Event\",\r\n\r\n    /**\r\n     * Fired when a momentum ends on an iOS device.\r\n     */\r\n    momentumEnd: \"qx.event.type.Data\"\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     PROPERTIES\r\n  *****************************************************************************\r\n  */\r\n  properties: {\r\n    // overridden\r\n    defaultCssClass: {\r\n      refine: true,\r\n      init: \"scroll\"\r\n    },\r\n\r\n    /**\r\n     * Delegation object which can have one or more functions defined by the\r\n     * {@link qx.ui.mobile.container.IScrollDelegate} interface.\r\n     *\r\n     * @internal\r\n     */\r\n    delegate: {\r\n      init: null,\r\n      nullable: true\r\n    }\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     MEMBERS\r\n  *****************************************************************************\r\n  */\r\n\r\n  members: {\r\n    _scrollProperties: null,\r\n    _activeWaypointX: null,\r\n    _activeWaypointY: null,\r\n    _waypointsX: null,\r\n    _waypointsY: null,\r\n    _calculatedWaypointsX: null,\r\n    _calculatedWaypointsY: null,\r\n    _currentX: null,\r\n    _currentY: null,\r\n\r\n    /**\r\n     * Sets the current x position.\r\n     * @param value {Number} the current horizontal position.\r\n     */\r\n    _setCurrentX(value) {\r\n      var old = this._currentX;\r\n      this._currentX = value;\r\n      this._fireWaypoint(value, old, \"x\");\r\n    },\r\n\r\n    /**\r\n     * Sets the current y position.\r\n     * @param value {Number} the current vertical position.\r\n     */\r\n    _setCurrentY(value) {\r\n      var old = this._currentY;\r\n      this._currentY = value;\r\n      this._fireWaypoint(value, old, \"y\");\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal trigger points, where a <code>waypoint</code> event will be fired.\r\n     * @param waypoints {Array} description\r\n     */\r\n    setWaypointsX(waypoints) {\r\n      this._waypointsX = waypoints;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical trigger points, where a <code>waypoint</code> event will be fired.\r\n     * @param waypoints {Array} an array with waypoint descriptions. Allowed are percentage description as string, or pixel trigger points defined as numbers. <code>[\"20%\",200]</code>\r\n     */\r\n    setWaypointsY(waypoints) {\r\n      this._waypointsY = waypoints;\r\n    },\r\n\r\n    /**\r\n     * Returns the scroll height.\r\n     * @return {Number} the scroll height.\r\n     */\r\n    getScrollHeight() {\r\n      return this._getScrollHeight();\r\n    },\r\n\r\n    /**\r\n     * Returns the scroll width.\r\n     * @return {Number} the scroll width.\r\n     */\r\n    getScrollWidth() {\r\n      return this._getScrollWidth();\r\n    },\r\n\r\n    /**\r\n     * Re-calculates the internal waypoint offsets.\r\n     */\r\n    _updateWaypoints() {\r\n      this._calculatedWaypointsX = [];\r\n      this._calculatedWaypointsY = [];\r\n      this._calcWaypoints(\r\n        this._waypointsX,\r\n        this._calculatedWaypointsX,\r\n        this.getScrollWidth(),\r\n        \"x\"\r\n      );\r\n\r\n      this._calcWaypoints(\r\n        this._waypointsY,\r\n        this._calculatedWaypointsY,\r\n        this.getScrollHeight()\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Validates and checks the waypoint offsets.\r\n     * @param waypoints {Array} an array with waypoint descriptions.\r\n     * @param results {Array} the array where calculated waypoints will be added.\r\n     * @param scrollSize {Number} the vertical or horizontal scroll size.\r\n     * @param axis {String?} \"x\" or \"y\".\r\n     */\r\n    _calcWaypoints(waypoints, results, scrollSize, axis) {\r\n      axis = axis || \"y\";\r\n\r\n      var offset = 0;\r\n      for (var i = 0; i < waypoints.length; i++) {\r\n        var waypoint = waypoints[i];\r\n        if (qx.lang.Type.isString(waypoint)) {\r\n          if (waypoint.endsWith(\"%\")) {\r\n            offset = parseInt(waypoint, 10) * (scrollSize / 100);\r\n            results.push({\r\n              offset: offset,\r\n              input: waypoint,\r\n              index: i,\r\n              element: null,\r\n              axis: axis\r\n            });\r\n          } else {\r\n            // Dynamically created waypoints, based upon a selector.\r\n            var element = this.getContentElement();\r\n            var waypointElements = qx.bom.Selector.query(waypoint, element);\r\n            for (var j = 0; j < waypointElements.length; j++) {\r\n              var position = qx.bom.element.Location.getRelative(\r\n                waypointElements[j],\r\n                element\r\n              );\r\n\r\n              if (axis === \"y\") {\r\n                offset = position.top + this.getContentElement().scrollTop;\r\n              } else if (axis === \"x\") {\r\n                offset = position.left + this.getContentElement().scrollLeft;\r\n              }\r\n              results.push({\r\n                offset: position.top + this._currentY,\r\n                input: waypoint,\r\n                index: i,\r\n                element: j,\r\n                axis: axis\r\n              });\r\n            }\r\n          }\r\n        } else if (qx.lang.Type.isNumber(waypoint)) {\r\n          results.push({\r\n            offset: waypoint,\r\n            input: waypoint,\r\n            index: i,\r\n            element: null,\r\n            axis: axis\r\n          });\r\n        }\r\n      }\r\n\r\n      results.sort(function (a, b) {\r\n        return a.offset - b.offset;\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Fires a waypoints event when scroll position changes.\r\n     * @param value {Number} old scroll position.\r\n     * @param old {Number} old scroll position.\r\n     * @param axis {String} \"x\" or \"y\".\r\n     */\r\n    _fireWaypoint(value, old, axis) {\r\n      var waypoints = this._calculatedWaypointsY;\r\n      if (axis === \"x\") {\r\n        waypoints = this._calculatedWaypointsX;\r\n      }\r\n\r\n      if (waypoints === null) {\r\n        return;\r\n      }\r\n\r\n      var nextWaypoint = null;\r\n      for (var i = 0; i < waypoints.length; i++) {\r\n        var waypoint = waypoints[i];\r\n        if (waypoint.offset !== null) {\r\n          if (\r\n            (value > -1 && value >= waypoint.offset) ||\r\n            (value < 0 && waypoint.offset < 0 && value <= waypoint.offset)\r\n          ) {\r\n            nextWaypoint = waypoint;\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (nextWaypoint === null) {\r\n        if (axis === \"x\") {\r\n          this._activeWaypointX = null;\r\n        } else {\r\n          this._activeWaypointY = null;\r\n        }\r\n        return;\r\n      }\r\n\r\n      var direction = null;\r\n      if (old <= value) {\r\n        direction = \"down\";\r\n        if (axis == \"x\") {\r\n          direction = \"left\";\r\n        }\r\n      } else {\r\n        direction = \"up\";\r\n        if (axis == \"x\") {\r\n          direction = \"right\";\r\n        }\r\n      }\r\n\r\n      var activeWaypoint = this._activeWaypointY;\r\n      if (axis === \"x\") {\r\n        activeWaypoint = this._activeWaypointX;\r\n      }\r\n\r\n      if (\r\n        activeWaypoint === null ||\r\n        activeWaypoint.index !== nextWaypoint.index ||\r\n        activeWaypoint.element !== nextWaypoint.element\r\n      ) {\r\n        activeWaypoint = nextWaypoint;\r\n        this._activeWaypointY = activeWaypoint;\r\n        if (axis === \"x\") {\r\n          this._activeWaypointX = activeWaypoint;\r\n        }\r\n        this.fireDataEvent(\"waypoint\", {\r\n          axis: axis,\r\n          index: nextWaypoint.index,\r\n          element: nextWaypoint.element,\r\n          direction: direction\r\n        });\r\n      }\r\n    },\r\n\r\n    // overridden\r\n    _createContainerElement() {\r\n      var element = super._createContainerElement();\r\n      var scrollElement = this._createScrollElement();\r\n      if (scrollElement) {\r\n        return scrollElement;\r\n      }\r\n\r\n      return element;\r\n    },\r\n\r\n    // overridden\r\n    _getContentElement() {\r\n      var contentElement = super._getContentElement();\r\n\r\n      var scrollContentElement = this._getScrollContentElement();\r\n\r\n      return scrollContentElement || contentElement;\r\n    },\r\n\r\n    /**\r\n     * Calls the refresh function the used scrolling method. Needed to recalculate the\r\n     * scrolling container.\r\n     */\r\n    refresh() {\r\n      this._refresh();\r\n      this._updateWaypoints();\r\n    },\r\n\r\n    /**\r\n     * Scrolls the wrapper contents to the x/y coordinates in a given time.\r\n     *\r\n     * @param x {Integer} X coordinate to scroll to.\r\n     * @param y {Integer} Y coordinate to scroll to.\r\n     * @param time {Integer} Time slice in which scrolling should\r\n     *              be done.\r\n     */\r\n    scrollTo(x, y, time) {\r\n      this._scrollTo(x, y, time);\r\n    },\r\n\r\n    /**\r\n     * Returns the current scroll position\r\n     * @return {Array} an array with <code>[scrollLeft,scrollTop]</code>.\r\n     */\r\n    getPosition() {\r\n      return this._getPosition();\r\n    },\r\n\r\n    /**\r\n     * Detects whether this scroll container is scrollable or not.\r\n     * @return {Boolean} <code>true</code> or <code>false</code>\r\n     */\r\n    isScrollable() {\r\n      return this._isScrollable();\r\n    },\r\n\r\n    /**\r\n     * Detects whether this scroll container is scrollable or not.\r\n     * @return {Boolean} <code>true</code> or <code>false</code>\r\n     */\r\n    _isScrollable() {\r\n      return this._isScrollableX() || this._isScrollableY();\r\n    },\r\n\r\n    /**\r\n     * Detects whether this scroll container is scrollable on x axis or not.\r\n     * @return {Boolean} <code>true</code> or <code>false</code>\r\n     */\r\n    _isScrollableX() {\r\n      if (this.getLayoutParent() === null) {\r\n        return false;\r\n      }\r\n\r\n      var parentWidth = this.getContainerElement().clientWidth;\r\n      var contentWidth = this.getContentElement().scrollWidth;\r\n\r\n      var scrollContentElement = this._getScrollContentElement();\r\n      if (scrollContentElement) {\r\n        contentWidth = qx.bom.element.Dimension.getWidth(scrollContentElement);\r\n      }\r\n\r\n      return parentWidth < contentWidth;\r\n    },\r\n\r\n    /**\r\n     * Detects whether this scroll container is scrollable on y axis or not.\r\n     * @return {Boolean} <code>true</code> or <code>false</code>\r\n     */\r\n    _isScrollableY() {\r\n      if (this.getLayoutParent() === null) {\r\n        return false;\r\n      }\r\n\r\n      var parentHeight = this.getContainerElement().clientHeight;\r\n      var contentHeight = this.getContentElement().scrollHeight;\r\n\r\n      var scrollContentElement = this._getScrollContentElement();\r\n      if (scrollContentElement) {\r\n        contentHeight =\r\n          qx.bom.element.Dimension.getHeight(scrollContentElement);\r\n      }\r\n\r\n      return parentHeight < contentHeight;\r\n    },\r\n\r\n    /**\r\n     * Scrolls the wrapper contents to the widgets coordinates in a given\r\n     * period.\r\n     *\r\n     * @param target {Element} the element to which the scroll container should scroll to.\r\n     * @param time {Integer?0} Time slice in which scrolling should\r\n     *              be done (in seconds).\r\n     *\r\n     */\r\n    scrollToElement(target, time) {\r\n      this._scrollToElement(target, time);\r\n    },\r\n\r\n    /**\r\n     * Scrolls the wrapper contents to the widgets coordinates in a given\r\n     * period.\r\n     *\r\n     * @param element {String} the element to which the scroll container should scroll to.\r\n     * @param time {Integer?0} Time slice in which scrolling should be done (in seconds).\r\n     *\r\n     */\r\n    _scrollToElement(element, time) {\r\n      if (this._getContentElement() && this._isScrollable()) {\r\n        if (typeof time === \"undefined\") {\r\n          time = 0;\r\n        }\r\n\r\n        var location = qx.bom.element.Location.getRelative(\r\n          this._getContentElement(),\r\n          element,\r\n          \"scroll\",\r\n          \"scroll\"\r\n        );\r\n\r\n        var offset = this._getScrollOffset();\r\n\r\n        this._scrollTo(\r\n          -location.left - offset[0],\r\n          -location.top - offset[1],\r\n          time\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     *\r\n     * Determines the scroll offset for the <code>_scrollToElement</code> method.\r\n     * If a delegate is available, the method calls\r\n     * <code>qx.ui.mobile.container.IScrollDelegate.getScrollOffset()</code> for offset calculation.\r\n     *\r\n     * @return {Array} an array with x,y offset.\r\n     */\r\n    _getScrollOffset() {\r\n      var delegate = this.getDelegate();\r\n      if (delegate != null && delegate.getScrollOffset) {\r\n        return delegate.getScrollOffset.bind(this)();\r\n      } else {\r\n        return [0, 0];\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Scrolls the wrapper contents to the widgets coordinates in a given\r\n     * period.\r\n     *\r\n     * @param widget {qx.ui.mobile.core.Widget} the widget, the scroll container should scroll to.\r\n     * @param time {Integer} Time slice in which scrolling should\r\n     *              be done.\r\n     */\r\n    scrollToWidget(widget, time) {\r\n      if (widget) {\r\n        this._scrollToElement(widget.getContentElement(), time);\r\n      }\r\n    }\r\n  },\r\n\r\n  defer(statics) {\r\n    if (qx.core.Environment.get(\"qx.mobile.nativescroll\") == false) {\r\n      qx.Class.include(statics, qx.ui.mobile.container.MIScroll);\r\n    } else {\r\n      qx.Class.include(statics, qx.ui.mobile.container.MNativeScroll);\r\n    }\r\n  },\r\n\r\n  destruct() {\r\n    this.removeListener(\"appear\", this._updateWaypoints, this);\r\n    this._waypointsX = this._waypointsY = null;\r\n  }\r\n});\r\n"
  ],
  "mappings": "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"
}