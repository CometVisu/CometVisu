{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "ui",
    "mobile",
    "container",
    "Composite",
    "construct",
    "scrollProperties",
    "constructor",
    "call",
    "_scrollProperties",
    "addListener",
    "_updateWaypoints",
    "_waypointsX",
    "_waypointsY",
    "_currentX",
    "_currentY",
    "events",
    "scrollEnd",
    "pageEnd",
    "waypoint",
    "momentumStart",
    "momentumEnd",
    "properties",
    "defaultCssClass",
    "refine",
    "init",
    "delegate",
    "nullable",
    "members",
    "_activeWaypointX",
    "_activeWaypointY",
    "_calculatedWaypointsX",
    "_calculatedWaypointsY",
    "_setCurrentX",
    "value",
    "old",
    "_fireWaypoint",
    "_setCurrentY",
    "setWaypointsX",
    "waypoints",
    "setWaypointsY",
    "getScrollHeight",
    "_getScrollHeight",
    "getScrollWidth",
    "_getScrollWidth",
    "_calcWaypoints",
    "results",
    "scrollSize",
    "axis",
    "offset",
    "i",
    "length",
    "lang",
    "Type",
    "isString",
    "endsWith",
    "parseInt",
    "push",
    "input",
    "index",
    "element",
    "getContentElement",
    "waypointElements",
    "bom",
    "Selector",
    "query",
    "j",
    "position",
    "Location",
    "getRelative",
    "top",
    "scrollTop",
    "left",
    "scrollLeft",
    "isNumber",
    "sort",
    "a",
    "b",
    "nextWaypoint",
    "direction",
    "activeWaypoint",
    "fireDataEvent",
    "_createContainerElement",
    "Scroll",
    "superclass",
    "prototype",
    "scrollElement",
    "_createScrollElement",
    "_getContentElement",
    "contentElement",
    "scrollContentElement",
    "_getScrollContentElement",
    "refresh",
    "_refresh",
    "scrollTo",
    "x",
    "y",
    "time",
    "_scrollTo",
    "getPosition",
    "_getPosition",
    "isScrollable",
    "_isScrollable",
    "_isScrollableX",
    "_isScrollableY",
    "getLayoutParent",
    "parentWidth",
    "getContainerElement",
    "clientWidth",
    "contentWidth",
    "scrollWidth",
    "Dimension",
    "getWidth",
    "parentHeight",
    "clientHeight",
    "contentHeight",
    "scrollHeight",
    "getHeight",
    "scrollToElement",
    "target",
    "_scrollToElement",
    "location",
    "_getScrollOffset",
    "getDelegate",
    "getScrollOffset",
    "bind",
    "scrollToWidget",
    "widget",
    "defer",
    "statics",
    "core",
    "Environment",
    "get",
    "include",
    "MIScroll",
    "MNativeScroll",
    "destruct",
    "removeListener"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/mobile/container/Scroll.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2011 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Tino Butz (tbtz)\n\n************************************************************************ */\n\n/**\n * Container, which allows, depending on the set variant <code>qx.mobile.nativescroll</code>,\n * vertical and horizontal scrolling if the contents is larger than the container.\n *\n * Note that this class can only have one child widget. This container has a\n * fixed layout, which cannot be changed.\n *\n * *Example*\n *\n * Here is a little example of how to use the widget.\n *\n * <pre class='javascript'>\n *   // create the scroll widget\n *   var scroll = new qx.ui.mobile.container.Scroll();\n *\n *   // add a children\n *   scroll.add(new qx.ui.mobile.basic.Label(\"Name: \"));\n *\n *   this.getRoot().add(scroll);\n * </pre>\n *\n * This example creates a scroll container and adds a label to it.\n */\nqx.Class.define(\"qx.ui.mobile.container.Scroll\", {\n  extend: qx.ui.mobile.container.Composite,\n\n  /**\n   * @param scrollProperties {Object} A map with scroll properties which are passed to the scrolling container (may contain iScroll properties).\n   */\n  construct(scrollProperties) {\n    super();\n\n    if (scrollProperties) {\n      this._scrollProperties = scrollProperties;\n    }\n\n    this.addListener(\"appear\", this._updateWaypoints, this);\n\n    this._waypointsX = [];\n    this._waypointsY = [];\n\n    this._currentX = 0;\n    this._currentY = 0;\n  },\n\n  events: {\n    /** Fired when the scroll container reaches its end position (including momentum/inertia). */\n    scrollEnd: \"qx.event.type.Event\",\n\n    /** Fired when the user scrolls to the end of scroll area. */\n    pageEnd: \"qx.event.type.Event\",\n\n    /** Fired when a vertical or horizontal waypoint is triggered. Data:\n     * <code> {\"offset\": 0,\n     *        \"input\": \"10%\",\n     *        \"index\": 0,\n     *        \"element\" : 0}</code>\n     */\n    waypoint: \"qx.event.type.Data\",\n\n    /**\n     * Fired when a momentum starts on an iOS device.\n     */\n    momentumStart: \"qx.event.type.Event\",\n\n    /**\n     * Fired when a momentum ends on an iOS device.\n     */\n    momentumEnd: \"qx.event.type.Data\"\n  },\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n  properties: {\n    // overridden\n    defaultCssClass: {\n      refine: true,\n      init: \"scroll\"\n    },\n\n    /**\n     * Delegation object which can have one or more functions defined by the\n     * {@link qx.ui.mobile.container.IScrollDelegate} interface.\n     *\n     * @internal\n     */\n    delegate: {\n      init: null,\n      nullable: true\n    }\n  },\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members: {\n    _scrollProperties: null,\n    _activeWaypointX: null,\n    _activeWaypointY: null,\n    _waypointsX: null,\n    _waypointsY: null,\n    _calculatedWaypointsX: null,\n    _calculatedWaypointsY: null,\n    _currentX: null,\n    _currentY: null,\n\n    /**\n     * Sets the current x position.\n     * @param value {Number} the current horizontal position.\n     */\n    _setCurrentX(value) {\n      var old = this._currentX;\n      this._currentX = value;\n      this._fireWaypoint(value, old, \"x\");\n    },\n\n    /**\n     * Sets the current y position.\n     * @param value {Number} the current vertical position.\n     */\n    _setCurrentY(value) {\n      var old = this._currentY;\n      this._currentY = value;\n      this._fireWaypoint(value, old, \"y\");\n    },\n\n    /**\n     * Sets the horizontal trigger points, where a <code>waypoint</code> event will be fired.\n     * @param waypoints {Array} description\n     */\n    setWaypointsX(waypoints) {\n      this._waypointsX = waypoints;\n    },\n\n    /**\n     * Sets the vertical trigger points, where a <code>waypoint</code> event will be fired.\n     * @param waypoints {Array} an array with waypoint descriptions. Allowed are percentage description as string, or pixel trigger points defined as numbers. <code>[\"20%\",200]</code>\n     */\n    setWaypointsY(waypoints) {\n      this._waypointsY = waypoints;\n    },\n\n    /**\n     * Returns the scroll height.\n     * @return {Number} the scroll height.\n     */\n    getScrollHeight() {\n      return this._getScrollHeight();\n    },\n\n    /**\n     * Returns the scroll width.\n     * @return {Number} the scroll width.\n     */\n    getScrollWidth() {\n      return this._getScrollWidth();\n    },\n\n    /**\n     * Re-calculates the internal waypoint offsets.\n     */\n    _updateWaypoints() {\n      this._calculatedWaypointsX = [];\n      this._calculatedWaypointsY = [];\n      this._calcWaypoints(\n        this._waypointsX,\n        this._calculatedWaypointsX,\n        this.getScrollWidth(),\n        \"x\"\n      );\n\n      this._calcWaypoints(\n        this._waypointsY,\n        this._calculatedWaypointsY,\n        this.getScrollHeight()\n      );\n    },\n\n    /**\n     * Validates and checks the waypoint offsets.\n     * @param waypoints {Array} an array with waypoint descriptions.\n     * @param results {Array} the array where calculated waypoints will be added.\n     * @param scrollSize {Number} the vertical or horizontal scroll size.\n     * @param axis {String?} \"x\" or \"y\".\n     */\n    _calcWaypoints(waypoints, results, scrollSize, axis) {\n      axis = axis || \"y\";\n\n      var offset = 0;\n      for (var i = 0; i < waypoints.length; i++) {\n        var waypoint = waypoints[i];\n        if (qx.lang.Type.isString(waypoint)) {\n          if (waypoint.endsWith(\"%\")) {\n            offset = parseInt(waypoint, 10) * (scrollSize / 100);\n            results.push({\n              offset: offset,\n              input: waypoint,\n              index: i,\n              element: null,\n              axis: axis\n            });\n          } else {\n            // Dynamically created waypoints, based upon a selector.\n            var element = this.getContentElement();\n            var waypointElements = qx.bom.Selector.query(waypoint, element);\n            for (var j = 0; j < waypointElements.length; j++) {\n              var position = qx.bom.element.Location.getRelative(\n                waypointElements[j],\n                element\n              );\n\n              if (axis === \"y\") {\n                offset = position.top + this.getContentElement().scrollTop;\n              } else if (axis === \"x\") {\n                offset = position.left + this.getContentElement().scrollLeft;\n              }\n              results.push({\n                offset: position.top + this._currentY,\n                input: waypoint,\n                index: i,\n                element: j,\n                axis: axis\n              });\n            }\n          }\n        } else if (qx.lang.Type.isNumber(waypoint)) {\n          results.push({\n            offset: waypoint,\n            input: waypoint,\n            index: i,\n            element: null,\n            axis: axis\n          });\n        }\n      }\n\n      results.sort(function (a, b) {\n        return a.offset - b.offset;\n      });\n    },\n\n    /**\n     * Fires a waypoints event when scroll position changes.\n     * @param value {Number} old scroll position.\n     * @param old {Number} old scroll position.\n     * @param axis {String} \"x\" or \"y\".\n     */\n    _fireWaypoint(value, old, axis) {\n      var waypoints = this._calculatedWaypointsY;\n      if (axis === \"x\") {\n        waypoints = this._calculatedWaypointsX;\n      }\n\n      if (waypoints === null) {\n        return;\n      }\n\n      var nextWaypoint = null;\n      for (var i = 0; i < waypoints.length; i++) {\n        var waypoint = waypoints[i];\n        if (waypoint.offset !== null) {\n          if (\n            (value > -1 && value >= waypoint.offset) ||\n            (value < 0 && waypoint.offset < 0 && value <= waypoint.offset)\n          ) {\n            nextWaypoint = waypoint;\n          } else {\n            break;\n          }\n        }\n      }\n\n      if (nextWaypoint === null) {\n        if (axis === \"x\") {\n          this._activeWaypointX = null;\n        } else {\n          this._activeWaypointY = null;\n        }\n        return;\n      }\n\n      var direction = null;\n      if (old <= value) {\n        direction = \"down\";\n        if (axis == \"x\") {\n          direction = \"left\";\n        }\n      } else {\n        direction = \"up\";\n        if (axis == \"x\") {\n          direction = \"right\";\n        }\n      }\n\n      var activeWaypoint = this._activeWaypointY;\n      if (axis === \"x\") {\n        activeWaypoint = this._activeWaypointX;\n      }\n\n      if (\n        activeWaypoint === null ||\n        activeWaypoint.index !== nextWaypoint.index ||\n        activeWaypoint.element !== nextWaypoint.element\n      ) {\n        activeWaypoint = nextWaypoint;\n        this._activeWaypointY = activeWaypoint;\n        if (axis === \"x\") {\n          this._activeWaypointX = activeWaypoint;\n        }\n        this.fireDataEvent(\"waypoint\", {\n          axis: axis,\n          index: nextWaypoint.index,\n          element: nextWaypoint.element,\n          direction: direction\n        });\n      }\n    },\n\n    // overridden\n    _createContainerElement() {\n      var element = super._createContainerElement();\n      var scrollElement = this._createScrollElement();\n      if (scrollElement) {\n        return scrollElement;\n      }\n\n      return element;\n    },\n\n    // overridden\n    _getContentElement() {\n      var contentElement = super._getContentElement();\n\n      var scrollContentElement = this._getScrollContentElement();\n\n      return scrollContentElement || contentElement;\n    },\n\n    /**\n     * Calls the refresh function the used scrolling method. Needed to recalculate the\n     * scrolling container.\n     */\n    refresh() {\n      this._refresh();\n      this._updateWaypoints();\n    },\n\n    /**\n     * Scrolls the wrapper contents to the x/y coordinates in a given time.\n     *\n     * @param x {Integer} X coordinate to scroll to.\n     * @param y {Integer} Y coordinate to scroll to.\n     * @param time {Integer} Time slice in which scrolling should\n     *              be done.\n     */\n    scrollTo(x, y, time) {\n      this._scrollTo(x, y, time);\n    },\n\n    /**\n     * Returns the current scroll position\n     * @return {Array} an array with <code>[scrollLeft,scrollTop]</code>.\n     */\n    getPosition() {\n      return this._getPosition();\n    },\n\n    /**\n     * Detects whether this scroll container is scrollable or not.\n     * @return {Boolean} <code>true</code> or <code>false</code>\n     */\n    isScrollable() {\n      return this._isScrollable();\n    },\n\n    /**\n     * Detects whether this scroll container is scrollable or not.\n     * @return {Boolean} <code>true</code> or <code>false</code>\n     */\n    _isScrollable() {\n      return this._isScrollableX() || this._isScrollableY();\n    },\n\n    /**\n     * Detects whether this scroll container is scrollable on x axis or not.\n     * @return {Boolean} <code>true</code> or <code>false</code>\n     */\n    _isScrollableX() {\n      if (this.getLayoutParent() === null) {\n        return false;\n      }\n\n      var parentWidth = this.getContainerElement().clientWidth;\n      var contentWidth = this.getContentElement().scrollWidth;\n\n      var scrollContentElement = this._getScrollContentElement();\n      if (scrollContentElement) {\n        contentWidth = qx.bom.element.Dimension.getWidth(scrollContentElement);\n      }\n\n      return parentWidth < contentWidth;\n    },\n\n    /**\n     * Detects whether this scroll container is scrollable on y axis or not.\n     * @return {Boolean} <code>true</code> or <code>false</code>\n     */\n    _isScrollableY() {\n      if (this.getLayoutParent() === null) {\n        return false;\n      }\n\n      var parentHeight = this.getContainerElement().clientHeight;\n      var contentHeight = this.getContentElement().scrollHeight;\n\n      var scrollContentElement = this._getScrollContentElement();\n      if (scrollContentElement) {\n        contentHeight =\n          qx.bom.element.Dimension.getHeight(scrollContentElement);\n      }\n\n      return parentHeight < contentHeight;\n    },\n\n    /**\n     * Scrolls the wrapper contents to the widgets coordinates in a given\n     * period.\n     *\n     * @param target {Element} the element to which the scroll container should scroll to.\n     * @param time {Integer?0} Time slice in which scrolling should\n     *              be done (in seconds).\n     *\n     */\n    scrollToElement(target, time) {\n      this._scrollToElement(target, time);\n    },\n\n    /**\n     * Scrolls the wrapper contents to the widgets coordinates in a given\n     * period.\n     *\n     * @param element {String} the element to which the scroll container should scroll to.\n     * @param time {Integer?0} Time slice in which scrolling should be done (in seconds).\n     *\n     */\n    _scrollToElement(element, time) {\n      if (this._getContentElement() && this._isScrollable()) {\n        if (typeof time === \"undefined\") {\n          time = 0;\n        }\n\n        var location = qx.bom.element.Location.getRelative(\n          this._getContentElement(),\n          element,\n          \"scroll\",\n          \"scroll\"\n        );\n\n        var offset = this._getScrollOffset();\n\n        this._scrollTo(\n          -location.left - offset[0],\n          -location.top - offset[1],\n          time\n        );\n      }\n    },\n\n    /**\n     *\n     * Determines the scroll offset for the <code>_scrollToElement</code> method.\n     * If a delegate is available, the method calls\n     * <code>qx.ui.mobile.container.IScrollDelegate.getScrollOffset()</code> for offset calculation.\n     *\n     * @return {Array} an array with x,y offset.\n     */\n    _getScrollOffset() {\n      var delegate = this.getDelegate();\n      if (delegate != null && delegate.getScrollOffset) {\n        return delegate.getScrollOffset.bind(this)();\n      } else {\n        return [0, 0];\n      }\n    },\n\n    /**\n     * Scrolls the wrapper contents to the widgets coordinates in a given\n     * period.\n     *\n     * @param widget {qx.ui.mobile.core.Widget} the widget, the scroll container should scroll to.\n     * @param time {Integer} Time slice in which scrolling should\n     *              be done.\n     */\n    scrollToWidget(widget, time) {\n      if (widget) {\n        this._scrollToElement(widget.getContentElement(), time);\n      }\n    }\n  },\n\n  defer(statics) {\n    if (qx.core.Environment.get(\"qx.mobile.nativescroll\") == false) {\n      qx.Class.include(statics, qx.ui.mobile.container.MIScroll);\n    } else {\n      qx.Class.include(statics, qx.ui.mobile.container.MNativeScroll);\n    }\n  },\n\n  destruct() {\n    this.removeListener(\"appear\", this._updateWaypoints, this);\n    this._waypointsX = this._waypointsY = null;\n  }\n});\n"
  ],
  "mappings": "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"
}