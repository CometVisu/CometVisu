{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "ui",
    "mobile",
    "container",
    "Composite",
    "construct",
    "scrollProperties",
    "_scrollProperties",
    "addListener",
    "_updateWaypoints",
    "_waypointsX",
    "_waypointsY",
    "_currentX",
    "_currentY",
    "events",
    "scrollEnd",
    "pageEnd",
    "waypoint",
    "momentumStart",
    "momentumEnd",
    "properties",
    "defaultCssClass",
    "refine",
    "init",
    "delegate",
    "nullable",
    "members",
    "_activeWaypointX",
    "_activeWaypointY",
    "_calculatedWaypointsX",
    "_calculatedWaypointsY",
    "_setCurrentX",
    "value",
    "old",
    "_fireWaypoint",
    "_setCurrentY",
    "setWaypointsX",
    "waypoints",
    "setWaypointsY",
    "getScrollHeight",
    "_getScrollHeight",
    "getScrollWidth",
    "_getScrollWidth",
    "_calcWaypoints",
    "results",
    "scrollSize",
    "axis",
    "offset",
    "i",
    "length",
    "lang",
    "Type",
    "isString",
    "endsWith",
    "parseInt",
    "push",
    "input",
    "index",
    "element",
    "getContentElement",
    "waypointElements",
    "bom",
    "Selector",
    "query",
    "j",
    "position",
    "Location",
    "getRelative",
    "top",
    "scrollTop",
    "left",
    "scrollLeft",
    "isNumber",
    "sort",
    "a",
    "b",
    "nextWaypoint",
    "direction",
    "activeWaypoint",
    "fireDataEvent",
    "_createContainerElement",
    "scrollElement",
    "_createScrollElement",
    "_getContentElement",
    "contentElement",
    "scrollContentElement",
    "_getScrollContentElement",
    "refresh",
    "_refresh",
    "scrollTo",
    "x",
    "y",
    "time",
    "_scrollTo",
    "getPosition",
    "_getPosition",
    "isScrollable",
    "_isScrollable",
    "_isScrollableX",
    "_isScrollableY",
    "getLayoutParent",
    "parentWidth",
    "getContainerElement",
    "clientWidth",
    "contentWidth",
    "scrollWidth",
    "Dimension",
    "getWidth",
    "parentHeight",
    "clientHeight",
    "contentHeight",
    "scrollHeight",
    "getHeight",
    "scrollToElement",
    "target",
    "_scrollToElement",
    "location",
    "_getScrollOffset",
    "getDelegate",
    "getScrollOffset",
    "bind",
    "scrollToWidget",
    "widget",
    "defer",
    "statics",
    "core",
    "Environment",
    "get",
    "include",
    "MIScroll",
    "MNativeScroll",
    "destruct",
    "removeListener",
    "Scroll"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/mobile/container/Scroll.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2011 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Tino Butz (tbtz)\n\n************************************************************************ */\n\n/**\n * Container, which allows, depending on the set variant <code>qx.mobile.nativescroll</code>,\n * vertical and horizontal scrolling if the contents is larger than the container.\n *\n * Note that this class can only have one child widget. This container has a\n * fixed layout, which cannot be changed.\n *\n * *Example*\n *\n * Here is a little example of how to use the widget.\n *\n * <pre class='javascript'>\n *   // create the scroll widget\n *   var scroll = new qx.ui.mobile.container.Scroll();\n *\n *   // add a children\n *   scroll.add(new qx.ui.mobile.basic.Label(\"Name: \"));\n *\n *   this.getRoot().add(scroll);\n * </pre>\n *\n * This example creates a scroll container and adds a label to it.\n */\nqx.Class.define(\"qx.ui.mobile.container.Scroll\", {\n  extend: qx.ui.mobile.container.Composite,\n\n  /**\n   * @param scrollProperties {Object} A map with scroll properties which are passed to the scrolling container (may contain iScroll properties).\n   */\n  construct(scrollProperties) {\n    super();\n\n    if (scrollProperties) {\n      this._scrollProperties = scrollProperties;\n    }\n\n    this.addListener(\"appear\", this._updateWaypoints, this);\n\n    this._waypointsX = [];\n    this._waypointsY = [];\n\n    this._currentX = 0;\n    this._currentY = 0;\n  },\n\n  events: {\n    /** Fired when the scroll container reaches its end position (including momentum/inertia). */\n    scrollEnd: \"qx.event.type.Event\",\n\n    /** Fired when the user scrolls to the end of scroll area. */\n    pageEnd: \"qx.event.type.Event\",\n\n    /** Fired when a vertical or horizontal waypoint is triggered. Data:\n     * <code> {\"offset\": 0,\n     *        \"input\": \"10%\",\n     *        \"index\": 0,\n     *        \"element\" : 0}</code>\n     */\n    waypoint: \"qx.event.type.Data\",\n\n    /**\n     * Fired when a momentum starts on an iOS device.\n     */\n    momentumStart: \"qx.event.type.Event\",\n\n    /**\n     * Fired when a momentum ends on an iOS device.\n     */\n    momentumEnd: \"qx.event.type.Data\"\n  },\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n  properties: {\n    // overridden\n    defaultCssClass: {\n      refine: true,\n      init: \"scroll\"\n    },\n\n    /**\n     * Delegation object which can have one or more functions defined by the\n     * {@link qx.ui.mobile.container.IScrollDelegate} interface.\n     *\n     * @internal\n     */\n    delegate: {\n      init: null,\n      nullable: true\n    }\n  },\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members: {\n    _scrollProperties: null,\n    _activeWaypointX: null,\n    _activeWaypointY: null,\n    _waypointsX: null,\n    _waypointsY: null,\n    _calculatedWaypointsX: null,\n    _calculatedWaypointsY: null,\n    _currentX: null,\n    _currentY: null,\n\n    /**\n     * Sets the current x position.\n     * @param value {Number} the current horizontal position.\n     */\n    _setCurrentX(value) {\n      var old = this._currentX;\n      this._currentX = value;\n      this._fireWaypoint(value, old, \"x\");\n    },\n\n    /**\n     * Sets the current y position.\n     * @param value {Number} the current vertical position.\n     */\n    _setCurrentY(value) {\n      var old = this._currentY;\n      this._currentY = value;\n      this._fireWaypoint(value, old, \"y\");\n    },\n\n    /**\n     * Sets the horizontal trigger points, where a <code>waypoint</code> event will be fired.\n     * @param waypoints {Array} description\n     */\n    setWaypointsX(waypoints) {\n      this._waypointsX = waypoints;\n    },\n\n    /**\n     * Sets the vertical trigger points, where a <code>waypoint</code> event will be fired.\n     * @param waypoints {Array} an array with waypoint descriptions. Allowed are percentage description as string, or pixel trigger points defined as numbers. <code>[\"20%\",200]</code>\n     */\n    setWaypointsY(waypoints) {\n      this._waypointsY = waypoints;\n    },\n\n    /**\n     * Returns the scroll height.\n     * @return {Number} the scroll height.\n     */\n    getScrollHeight() {\n      return this._getScrollHeight();\n    },\n\n    /**\n     * Returns the scroll width.\n     * @return {Number} the scroll width.\n     */\n    getScrollWidth() {\n      return this._getScrollWidth();\n    },\n\n    /**\n     * Re-calculates the internal waypoint offsets.\n     */\n    _updateWaypoints() {\n      this._calculatedWaypointsX = [];\n      this._calculatedWaypointsY = [];\n      this._calcWaypoints(\n        this._waypointsX,\n        this._calculatedWaypointsX,\n        this.getScrollWidth(),\n        \"x\"\n      );\n\n      this._calcWaypoints(\n        this._waypointsY,\n        this._calculatedWaypointsY,\n        this.getScrollHeight()\n      );\n    },\n\n    /**\n     * Validates and checks the waypoint offsets.\n     * @param waypoints {Array} an array with waypoint descriptions.\n     * @param results {Array} the array where calculated waypoints will be added.\n     * @param scrollSize {Number} the vertical or horizontal scroll size.\n     * @param axis {String?} \"x\" or \"y\".\n     */\n    _calcWaypoints(waypoints, results, scrollSize, axis) {\n      axis = axis || \"y\";\n\n      var offset = 0;\n      for (var i = 0; i < waypoints.length; i++) {\n        var waypoint = waypoints[i];\n        if (qx.lang.Type.isString(waypoint)) {\n          if (waypoint.endsWith(\"%\")) {\n            offset = parseInt(waypoint, 10) * (scrollSize / 100);\n            results.push({\n              offset: offset,\n              input: waypoint,\n              index: i,\n              element: null,\n              axis: axis\n            });\n          } else {\n            // Dynamically created waypoints, based upon a selector.\n            var element = this.getContentElement();\n            var waypointElements = qx.bom.Selector.query(waypoint, element);\n            for (var j = 0; j < waypointElements.length; j++) {\n              var position = qx.bom.element.Location.getRelative(\n                waypointElements[j],\n                element\n              );\n\n              if (axis === \"y\") {\n                offset = position.top + this.getContentElement().scrollTop;\n              } else if (axis === \"x\") {\n                offset = position.left + this.getContentElement().scrollLeft;\n              }\n              results.push({\n                offset: position.top + this._currentY,\n                input: waypoint,\n                index: i,\n                element: j,\n                axis: axis\n              });\n            }\n          }\n        } else if (qx.lang.Type.isNumber(waypoint)) {\n          results.push({\n            offset: waypoint,\n            input: waypoint,\n            index: i,\n            element: null,\n            axis: axis\n          });\n        }\n      }\n\n      results.sort(function (a, b) {\n        return a.offset - b.offset;\n      });\n    },\n\n    /**\n     * Fires a waypoints event when scroll position changes.\n     * @param value {Number} old scroll position.\n     * @param old {Number} old scroll position.\n     * @param axis {String} \"x\" or \"y\".\n     */\n    _fireWaypoint(value, old, axis) {\n      var waypoints = this._calculatedWaypointsY;\n      if (axis === \"x\") {\n        waypoints = this._calculatedWaypointsX;\n      }\n\n      if (waypoints === null) {\n        return;\n      }\n\n      var nextWaypoint = null;\n      for (var i = 0; i < waypoints.length; i++) {\n        var waypoint = waypoints[i];\n        if (waypoint.offset !== null) {\n          if (\n            (value > -1 && value >= waypoint.offset) ||\n            (value < 0 && waypoint.offset < 0 && value <= waypoint.offset)\n          ) {\n            nextWaypoint = waypoint;\n          } else {\n            break;\n          }\n        }\n      }\n\n      if (nextWaypoint === null) {\n        if (axis === \"x\") {\n          this._activeWaypointX = null;\n        } else {\n          this._activeWaypointY = null;\n        }\n        return;\n      }\n\n      var direction = null;\n      if (old <= value) {\n        direction = \"down\";\n        if (axis == \"x\") {\n          direction = \"left\";\n        }\n      } else {\n        direction = \"up\";\n        if (axis == \"x\") {\n          direction = \"right\";\n        }\n      }\n\n      var activeWaypoint = this._activeWaypointY;\n      if (axis === \"x\") {\n        activeWaypoint = this._activeWaypointX;\n      }\n\n      if (\n        activeWaypoint === null ||\n        activeWaypoint.index !== nextWaypoint.index ||\n        activeWaypoint.element !== nextWaypoint.element\n      ) {\n        activeWaypoint = nextWaypoint;\n        this._activeWaypointY = activeWaypoint;\n        if (axis === \"x\") {\n          this._activeWaypointX = activeWaypoint;\n        }\n        this.fireDataEvent(\"waypoint\", {\n          axis: axis,\n          index: nextWaypoint.index,\n          element: nextWaypoint.element,\n          direction: direction\n        });\n      }\n    },\n\n    // overridden\n    _createContainerElement() {\n      var element = super._createContainerElement();\n      var scrollElement = this._createScrollElement();\n      if (scrollElement) {\n        return scrollElement;\n      }\n\n      return element;\n    },\n\n    // overridden\n    _getContentElement() {\n      var contentElement = super._getContentElement();\n\n      var scrollContentElement = this._getScrollContentElement();\n\n      return scrollContentElement || contentElement;\n    },\n\n    /**\n     * Calls the refresh function the used scrolling method. Needed to recalculate the\n     * scrolling container.\n     */\n    refresh() {\n      this._refresh();\n      this._updateWaypoints();\n    },\n\n    /**\n     * Scrolls the wrapper contents to the x/y coordinates in a given time.\n     *\n     * @param x {Integer} X coordinate to scroll to.\n     * @param y {Integer} Y coordinate to scroll to.\n     * @param time {Integer} Time slice in which scrolling should\n     *              be done.\n     */\n    scrollTo(x, y, time) {\n      this._scrollTo(x, y, time);\n    },\n\n    /**\n     * Returns the current scroll position\n     * @return {Array} an array with <code>[scrollLeft,scrollTop]</code>.\n     */\n    getPosition() {\n      return this._getPosition();\n    },\n\n    /**\n     * Detects whether this scroll container is scrollable or not.\n     * @return {Boolean} <code>true</code> or <code>false</code>\n     */\n    isScrollable() {\n      return this._isScrollable();\n    },\n\n    /**\n     * Detects whether this scroll container is scrollable or not.\n     * @return {Boolean} <code>true</code> or <code>false</code>\n     */\n    _isScrollable() {\n      return this._isScrollableX() || this._isScrollableY();\n    },\n\n    /**\n     * Detects whether this scroll container is scrollable on x axis or not.\n     * @return {Boolean} <code>true</code> or <code>false</code>\n     */\n    _isScrollableX() {\n      if (this.getLayoutParent() === null) {\n        return false;\n      }\n\n      var parentWidth = this.getContainerElement().clientWidth;\n      var contentWidth = this.getContentElement().scrollWidth;\n\n      var scrollContentElement = this._getScrollContentElement();\n      if (scrollContentElement) {\n        contentWidth = qx.bom.element.Dimension.getWidth(scrollContentElement);\n      }\n\n      return parentWidth < contentWidth;\n    },\n\n    /**\n     * Detects whether this scroll container is scrollable on y axis or not.\n     * @return {Boolean} <code>true</code> or <code>false</code>\n     */\n    _isScrollableY() {\n      if (this.getLayoutParent() === null) {\n        return false;\n      }\n\n      var parentHeight = this.getContainerElement().clientHeight;\n      var contentHeight = this.getContentElement().scrollHeight;\n\n      var scrollContentElement = this._getScrollContentElement();\n      if (scrollContentElement) {\n        contentHeight =\n          qx.bom.element.Dimension.getHeight(scrollContentElement);\n      }\n\n      return parentHeight < contentHeight;\n    },\n\n    /**\n     * Scrolls the wrapper contents to the widgets coordinates in a given\n     * period.\n     *\n     * @param target {Element} the element to which the scroll container should scroll to.\n     * @param time {Integer?0} Time slice in which scrolling should\n     *              be done (in seconds).\n     *\n     */\n    scrollToElement(target, time) {\n      this._scrollToElement(target, time);\n    },\n\n    /**\n     * Scrolls the wrapper contents to the widgets coordinates in a given\n     * period.\n     *\n     * @param element {String} the element to which the scroll container should scroll to.\n     * @param time {Integer?0} Time slice in which scrolling should be done (in seconds).\n     *\n     */\n    _scrollToElement(element, time) {\n      if (this._getContentElement() && this._isScrollable()) {\n        if (typeof time === \"undefined\") {\n          time = 0;\n        }\n\n        var location = qx.bom.element.Location.getRelative(\n          this._getContentElement(),\n          element,\n          \"scroll\",\n          \"scroll\"\n        );\n\n        var offset = this._getScrollOffset();\n\n        this._scrollTo(\n          -location.left - offset[0],\n          -location.top - offset[1],\n          time\n        );\n      }\n    },\n\n    /**\n     *\n     * Determines the scroll offset for the <code>_scrollToElement</code> method.\n     * If a delegate is available, the method calls\n     * <code>qx.ui.mobile.container.IScrollDelegate.getScrollOffset()</code> for offset calculation.\n     *\n     * @return {Array} an array with x,y offset.\n     */\n    _getScrollOffset() {\n      var delegate = this.getDelegate();\n      if (delegate != null && delegate.getScrollOffset) {\n        return delegate.getScrollOffset.bind(this)();\n      } else {\n        return [0, 0];\n      }\n    },\n\n    /**\n     * Scrolls the wrapper contents to the widgets coordinates in a given\n     * period.\n     *\n     * @param widget {qx.ui.mobile.core.Widget} the widget, the scroll container should scroll to.\n     * @param time {Integer} Time slice in which scrolling should\n     *              be done.\n     */\n    scrollToWidget(widget, time) {\n      if (widget) {\n        this._scrollToElement(widget.getContentElement(), time);\n      }\n    }\n  },\n\n  defer(statics) {\n    if (qx.core.Environment.get(\"qx.mobile.nativescroll\") == false) {\n      qx.Class.include(statics, qx.ui.mobile.container.MIScroll);\n    } else {\n      qx.Class.include(statics, qx.ui.mobile.container.MNativeScroll);\n    }\n  },\n\n  destruct() {\n    this.removeListener(\"appear\", this._updateWaypoints, this);\n    this._waypointsX = this._waypointsY = null;\n  }\n});\n"
  ],
  "mappings": "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"
}