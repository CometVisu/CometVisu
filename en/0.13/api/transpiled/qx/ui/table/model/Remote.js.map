{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "type",
    "extend",
    "ui",
    "table",
    "model",
    "Abstract",
    "construct",
    "_sortColumnIndex",
    "_sortAscending",
    "_rowCount",
    "_lruCounter",
    "_firstLoadingBlock",
    "_firstRowToLoad",
    "_lastRowToLoad",
    "_ignoreCurrentRequest",
    "_rowBlockCache",
    "_rowBlockCount",
    "_sortableColArr",
    "_editableColArr",
    "properties",
    "blockSize",
    "check",
    "init",
    "maxCachedBlockCount",
    "clearCacheOnRemove",
    "blockConcurrentLoadRowCount",
    "members",
    "_loadRowCountRequestRunning",
    "_clearCache",
    "_getIgnoreCurrentRequest",
    "getRowCount",
    "getBlockConcurrentLoadRowCount",
    "_loadRowCount",
    "Error",
    "_onRowCountLoaded",
    "rowCount",
    "Number",
    "data",
    "firstRow",
    "lastRow",
    "firstColumn",
    "lastColumn",
    "getColumnCount",
    "fireDataEvent",
    "reloadData",
    "cancelingSucceed",
    "_cancelCurrentRequest",
    "clearCache",
    "getCacheContent",
    "sortColumnIndex",
    "sortAscending",
    "lruCounter",
    "rowBlockCache",
    "rowBlockCount",
    "restoreCacheContent",
    "cacheContent",
    "iterateCachedRows",
    "iterator",
    "object",
    "getBlockSize",
    "blockCount",
    "Math",
    "ceil",
    "block",
    "blockData",
    "rowOffset",
    "rowDataArr",
    "relRow",
    "length",
    "rowData",
    "newRowData",
    "call",
    "prefetchRows",
    "firstRowIndex",
    "lastRowIndex",
    "totalBlockCount",
    "firstBlock",
    "parseInt",
    "lastBlock",
    "firstBlockToLoad",
    "lastBlockToLoad",
    "isDirty",
    "_loadRowData",
    "_onRowDataLoaded",
    "_setRowBlockData",
    "i",
    "blockRowData",
    "mailCount",
    "min",
    "row",
    "push",
    "getMaxCachedBlockCount",
    "lruBlock",
    "minLru",
    "currBlock",
    "currLru",
    "lru",
    "removeRow",
    "rowIndex",
    "_checkEditing",
    "getClearCacheOnRemove",
    "startBlock",
    "removeIndex",
    "splice",
    "nextBlockData",
    "hasListener",
    "getRowData",
    "getValue",
    "columnIndex",
    "columnId",
    "getColumnId",
    "setValue",
    "value",
    "setEditable",
    "editable",
    "col",
    "fireEvent",
    "setColumnEditable",
    "isColumnEditable",
    "setColumnSortable",
    "sortable",
    "isColumnSortable",
    "sortByColumn",
    "ascending",
    "getSortColumnIndex",
    "isSortAscending",
    "setSortColumnIndexWithoutSortingData",
    "setSortAscendingWithoutSortingData",
    "destruct",
    "Remote"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/table/model/Remote.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2006 STZ-IDA, Germany, http://www.stz-ida.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Til Schneider (til132)\n\n************************************************************************ */\n\n/**\n * A table model that loads its data from a backend.\n * <p>\n * Only a subset of the available rows, those which are within or near the\n * currently visible area, are loaded. If a quick scroll operation occurs,\n * rows will soon be displayed using asynchronous loading in the background.\n * All loaded data is managed through a cache which automatically removes\n * the oldest used rows when it gets full.\n * <p>\n * This class is abstract: The actual loading of row data must be done by\n * subclasses.\n */\nqx.Class.define(\"qx.ui.table.model.Remote\", {\n  type: \"abstract\",\n  extend: qx.ui.table.model.Abstract,\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  construct() {\n    super();\n\n    this._sortColumnIndex = -1;\n    this._sortAscending = true;\n    this._rowCount = -1;\n\n    this._lruCounter = 0;\n\n    // Holds the index of the first block that is currently loading.\n    // Is -1 if there is currently no request on its way.\n    this._firstLoadingBlock = -1;\n\n    // Holds the index of the first row that should be loaded when the response of\n    // the current request arrives. Is -1 we need no following request.\n    this._firstRowToLoad = -1;\n\n    // Counterpart to _firstRowToLoad\n    this._lastRowToLoad = -1;\n\n    // Holds whether the current request will bring obsolete data. When true the\n    // response of the current request will be ignored.\n    this._ignoreCurrentRequest = false;\n\n    this._rowBlockCache = {};\n    this._rowBlockCount = 0;\n\n    this._sortableColArr = null;\n    this._editableColArr = null;\n  },\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties: {\n    /** The number of rows that are stored in one cache block. */\n    blockSize: {\n      check: \"Integer\",\n      init: 50\n    },\n\n    /** The maximum number of row blocks kept in the cache. */\n    maxCachedBlockCount: {\n      check: \"Integer\",\n      init: 15\n    },\n\n    /**\n     * Whether to clear the cache when some rows are removed.\n     * If true the rows are removed locally in the cache.\n     */\n    clearCacheOnRemove: {\n      check: \"Boolean\",\n      init: false\n    },\n\n    /**\n     * Whether to block remote requests for the row count while a request for\n     * the row count is pending. Row counts are requested at various times and\n     * from various parts of the code, resulting in numerous requests to the\n     * user-provided _loadRowCount() method, often while other requests are\n     * already pending. The default behavior now ignores requests to load a\n     * new row count if such a request is already pending. It is therefore now\n     * conceivable that the row count changes between an initial request for\n     * the row count and a later (ignored) request. Since the chance of this\n     * is low, the desirability of reducing the server requests outweighs the\n     * slight possibility of an altered count (which will, by the way, be\n     * detected soon thereafter upon the next request for the row count). If\n     * the old behavior is desired, set this property to false.\n     */\n    blockConcurrentLoadRowCount: {\n      check: \"Boolean\",\n      init: true\n    }\n  },\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members: {\n    _rowCount: null,\n    _ignoreCurrentRequest: null,\n\n    _lruCounter: null,\n    _firstLoadingBlock: null,\n    _firstRowToLoad: null,\n    _lastRowToLoad: null,\n    _rowBlockCache: null,\n    _rowBlockCount: null,\n\n    _sortColumnIndex: null,\n    _sortAscending: null,\n\n    _editableColArr: null,\n    _sortableColArr: null,\n\n    _loadRowCountRequestRunning: false,\n\n    _clearCache: false,\n\n    /**\n     * Returns whether the current request is ignored by the model.\n     *\n     * @return {Boolean} true when the current request is ignored by the model.\n     */\n    _getIgnoreCurrentRequest() {\n      return this._ignoreCurrentRequest;\n    },\n\n    // overridden\n    getRowCount() {\n      if (this._rowCount == -1) {\n        if (\n          !this._loadRowCountRequestRunning ||\n          !this.getBlockConcurrentLoadRowCount()\n        ) {\n          this._loadRowCountRequestRunning = true;\n          this._loadRowCount();\n        }\n\n        // NOTE: _loadRowCount may set this._rowCount\n        return this._rowCount == -1 ? 0 : this._rowCount;\n      } else {\n        return this._rowCount;\n      }\n    },\n\n    /**\n     * Implementing classes have to call {@link #_onRowCountLoaded} when the\n     * server response arrived. That method has to be called! Even when there\n     * was an error.\n     *\n     * @abstract\n     * @throws {Error} the abstract function warning.\n     */\n    _loadRowCount() {\n      throw new Error(\"_loadRowCount is abstract\");\n    },\n\n    /**\n     * Sets the row count.\n     *\n     * Has to be called by {@link #_loadRowCount}.\n     *\n     * @param rowCount {Integer} the number of rows in this model or null if loading.\n     */\n    _onRowCountLoaded(rowCount) {\n      if (this.getBlockConcurrentLoadRowCount()) {\n        // There's no longer a loadRowCount() in progress\n        this._loadRowCountRequestRunning = false;\n      }\n\n      // this.debug(\"row count loaded: \" + rowCount);\n      if (rowCount == null || rowCount < 0) {\n        rowCount = 0;\n      }\n\n      this._rowCount = Number(rowCount);\n\n      // Inform the listeners\n      var data = {\n        firstRow: 0,\n        lastRow: rowCount - 1,\n        firstColumn: 0,\n        lastColumn: this.getColumnCount() - 1\n      };\n\n      this.fireDataEvent(\"dataChanged\", data);\n    },\n\n    /**\n     * Reloads the model and clears the local cache.\n     *\n     */\n    reloadData() {\n      // If there is currently a request on its way, then this request will bring\n      // obsolete data -> Ignore it\n      if (this._firstLoadingBlock != -1) {\n        var cancelingSucceed = this._cancelCurrentRequest();\n        if (cancelingSucceed) {\n          // The request was canceled -> We're not loading any blocks any more\n          this._firstLoadingBlock = -1;\n          this._ignoreCurrentRequest = false;\n        } else {\n          // The request was not canceled -> Ignore it\n          this._ignoreCurrentRequest = true;\n        }\n      }\n\n      // Force clearing row cache, because of reloading data.\n      this._clearCache = true;\n\n      // Forget a possibly outstanding request\n      // (_loadRowCount will tell the listeners anyway, that the whole table\n      // changed)\n      //\n      // NOTE: This will inform the listeners as soon as the new row count is\n      // known\n      this._firstRowToLoad = -1;\n      this._lastRowToLoad = -1;\n      this._loadRowCountRequestRunning = true;\n      this._loadRowCount();\n    },\n\n    /**\n     * Clears the cache.\n     *\n     */\n    clearCache() {\n      this._rowBlockCache = {};\n      this._rowBlockCount = 0;\n    },\n\n    /**\n     * Returns the current state of the cache.\n     * <p>\n     * Do not change anything in the returned data. This breaks the model state.\n     * Use this method only together with {@link #restoreCacheContent} for backing\n     * up state for a later restore.\n     *\n     * @return {Map} the current cache state.\n     */\n    getCacheContent() {\n      return {\n        sortColumnIndex: this._sortColumnIndex,\n        sortAscending: this._sortAscending,\n        rowCount: this._rowCount,\n        lruCounter: this._lruCounter,\n        rowBlockCache: this._rowBlockCache,\n        rowBlockCount: this._rowBlockCount\n      };\n    },\n\n    /**\n     * Restores a cache state created by {@link #getCacheContent}.\n     *\n     * @param cacheContent {Map} An old cache state.\n     */\n    restoreCacheContent(cacheContent) {\n      // If there is currently a request on its way, then this request will bring\n      // obsolete data -> Ignore it\n      if (this._firstLoadingBlock != -1) {\n        // Try to cancel the current request\n        var cancelingSucceed = this._cancelCurrentRequest();\n\n        if (cancelingSucceed) {\n          // The request was canceled -> We're not loading any blocks any more\n          this._firstLoadingBlock = -1;\n          this._ignoreCurrentRequest = false;\n        } else {\n          // The request was not canceled -> Ignore it\n          this._ignoreCurrentRequest = true;\n        }\n      }\n\n      // Restore the cache content\n      this._sortColumnIndex = cacheContent.sortColumnIndex;\n      this._sortAscending = cacheContent.sortAscending;\n      this._rowCount = cacheContent.rowCount;\n      this._lruCounter = cacheContent.lruCounter;\n      this._rowBlockCache = cacheContent.rowBlockCache;\n      this._rowBlockCount = cacheContent.rowBlockCount;\n\n      // Inform the listeners\n      var data = {\n        firstRow: 0,\n        lastRow: this._rowCount - 1,\n        firstColumn: 0,\n        lastColumn: this.getColumnCount() - 1\n      };\n\n      this.fireDataEvent(\"dataChanged\", data);\n    },\n\n    /**\n     * Cancels the current request if possible.\n     *\n     * Should be overridden by subclasses if they are able to cancel requests. This\n     * allows sending a new request directly after a call of {@link #reloadData}.\n     *\n     * @return {Boolean} whether the request was canceled.\n     */\n    _cancelCurrentRequest() {\n      return false;\n    },\n\n    /**\n     * Iterates through all cached rows.\n     *\n     * The iterator will be called for each cached row with two parameters: The row\n     * index of the current row (Integer) and the row data of that row (var[]). If\n     * the iterator returns something this will be used as new row data.\n     *\n     * The iterator is called in the same order as the rows are in the model\n     * (the row index is always ascending).\n     *\n     * @param iterator {Function} The iterator function to call.\n     * @param object {Object} context of the iterator\n     */\n    iterateCachedRows(iterator, object) {\n      var blockSize = this.getBlockSize();\n      var blockCount = Math.ceil(this.getRowCount() / blockSize);\n\n      // Remove the row and move the rows of all following blocks\n      for (var block = 0; block <= blockCount; block++) {\n        var blockData = this._rowBlockCache[block];\n\n        if (blockData != null) {\n          var rowOffset = block * blockSize;\n          var rowDataArr = blockData.rowDataArr;\n\n          for (var relRow = 0; relRow < rowDataArr.length; relRow++) {\n            // Call the iterator for this row\n            var rowData = rowDataArr[relRow];\n            var newRowData = iterator.call(object, rowOffset + relRow, rowData);\n\n            if (newRowData != null) {\n              rowDataArr[relRow] = newRowData;\n            }\n          }\n        }\n      }\n    },\n\n    // overridden\n    prefetchRows(firstRowIndex, lastRowIndex) {\n      // this.debug(\"Prefetch wanted: \" + firstRowIndex + \"..\" + lastRowIndex);\n      if (this._firstLoadingBlock == -1) {\n        var blockSize = this.getBlockSize();\n        var totalBlockCount = Math.ceil(this._rowCount / blockSize);\n\n        // There is currently no request running -> Start a new one\n        // NOTE: We load one more block above and below to have a smooth\n        //       scrolling into the next block without blank cells\n        var firstBlock = parseInt(firstRowIndex / blockSize, 10) - 1;\n\n        if (firstBlock < 0) {\n          firstBlock = 0;\n        }\n\n        var lastBlock = parseInt(lastRowIndex / blockSize, 10) + 1;\n\n        if (lastBlock >= totalBlockCount) {\n          lastBlock = totalBlockCount - 1;\n        }\n\n        // Check which blocks we have to load\n        var firstBlockToLoad = -1;\n        var lastBlockToLoad = -1;\n\n        for (var block = firstBlock; block <= lastBlock; block++) {\n          if (\n            (this._clearCache && !this._loadRowCountRequestRunning) ||\n            this._rowBlockCache[block] == null ||\n            this._rowBlockCache[block].isDirty\n          ) {\n            // We don't have this block\n            if (firstBlockToLoad == -1) {\n              firstBlockToLoad = block;\n            }\n\n            lastBlockToLoad = block;\n          }\n        }\n\n        // Load the blocks\n        if (firstBlockToLoad != -1) {\n          this._firstRowToLoad = -1;\n          this._lastRowToLoad = -1;\n\n          this._firstLoadingBlock = firstBlockToLoad;\n\n          // this.debug(\"Starting server request. rows: \" + firstRowIndex + \"..\" + lastRowIndex + \", blocks: \" + firstBlockToLoad + \"..\" + lastBlockToLoad);\n          this._loadRowData(\n            firstBlockToLoad * blockSize,\n            (lastBlockToLoad + 1) * blockSize - 1\n          );\n        }\n      } else {\n        // There is already a request running -> Remember this request\n        // so it can be executed after the current one is finished.\n        this._firstRowToLoad = firstRowIndex;\n        this._lastRowToLoad = lastRowIndex;\n      }\n    },\n\n    /**\n     * Loads some row data from the server.\n     *\n     * Implementing classes have to call {@link #_onRowDataLoaded} when the server\n     * response arrived. That method has to be called! Even when there was an error.\n     *\n     * @abstract\n     * @param firstRow {Integer} The index of the first row to load.\n     * @param lastRow {Integer} The index of the last row to load.\n     * @throws {Error} the abstract function warning.\n     */\n    _loadRowData(firstRow, lastRow) {\n      throw new Error(\"_loadRowData is abstract\");\n    },\n\n    /**\n     * Sets row data.\n     *\n     * Has to be called by {@link #_loadRowData}.\n     *\n     * @param rowDataArr {Map[]} the loaded row data or null if there was an error.\n     */\n    _onRowDataLoaded(rowDataArr) {\n      // Clear cache if function was called because of a reload.\n      if (this._clearCache) {\n        this.clearCache();\n        this._clearCache = false;\n      }\n\n      if (rowDataArr != null && !this._ignoreCurrentRequest) {\n        var blockSize = this.getBlockSize();\n        var blockCount = Math.ceil(rowDataArr.length / blockSize);\n\n        if (blockCount == 1) {\n          // We got one block -> Use the rowData directly\n          this._setRowBlockData(this._firstLoadingBlock, rowDataArr);\n        } else {\n          // We got more than one block -> We've to split the rowData\n          for (var i = 0; i < blockCount; i++) {\n            var rowOffset = i * blockSize;\n            var blockRowData = [];\n            var mailCount = Math.min(blockSize, rowDataArr.length - rowOffset);\n\n            for (var row = 0; row < mailCount; row++) {\n              blockRowData.push(rowDataArr[rowOffset + row]);\n            }\n\n            this._setRowBlockData(this._firstLoadingBlock + i, blockRowData);\n          }\n        }\n\n        // this.debug(\"Got server answer. blocks: \" + this._firstLoadingBlock + \"..\" + (this._firstLoadingBlock + blockCount - 1) + \". mail count: \" + rowDataArr.length + \" block count:\" + blockCount);\n        // Inform the listeners\n        var data = {\n          firstRow: this._firstLoadingBlock * blockSize,\n          lastRow: (this._firstLoadingBlock + blockCount + 1) * blockSize - 1,\n          firstColumn: 0,\n          lastColumn: this.getColumnCount() - 1\n        };\n\n        this.fireDataEvent(\"dataChanged\", data);\n      }\n\n      // We're not loading any blocks any more\n      this._firstLoadingBlock = -1;\n      this._ignoreCurrentRequest = false;\n\n      // Check whether we have to start a new request\n      if (this._firstRowToLoad != -1) {\n        this.prefetchRows(this._firstRowToLoad, this._lastRowToLoad);\n      }\n    },\n\n    /**\n     * Sets the data of one block.\n     *\n     * @param block {Integer} the index of the block.\n     * @param rowDataArr {var[][]} the data to set.\n     */\n    _setRowBlockData(block, rowDataArr) {\n      if (this._rowBlockCache[block] == null) {\n        // This is a new block -> Check whether we have to remove another block first\n        this._rowBlockCount++;\n\n        while (this._rowBlockCount > this.getMaxCachedBlockCount()) {\n          // Find the last recently used block\n          // NOTE: We never remove block 0 and 1\n          var lruBlock;\n          var minLru = this._lruCounter;\n\n          for (var currBlock in this._rowBlockCache) {\n            var currLru = this._rowBlockCache[currBlock].lru;\n\n            if (currLru < minLru && currBlock > 1) {\n              minLru = currLru;\n              lruBlock = currBlock;\n            }\n          }\n\n          // Remove that block\n          // this.debug(\"Removing block: \" + lruBlock + \". current LRU: \" + this._lruCounter);\n          delete this._rowBlockCache[lruBlock];\n          this._rowBlockCount--;\n        }\n      }\n\n      this._rowBlockCache[block] = {\n        lru: ++this._lruCounter,\n        rowDataArr: rowDataArr\n      };\n    },\n\n    /**\n     * Removes a row from the model.\n     *\n     * @param rowIndex {Integer} the index of the row to remove.\n     */\n    removeRow(rowIndex) {\n      this._checkEditing();\n      if (this.getClearCacheOnRemove()) {\n        this.clearCache();\n\n        // Inform the listeners\n        var data = {\n          firstRow: 0,\n          lastRow: this.getRowCount() - 1,\n          firstColumn: 0,\n          lastColumn: this.getColumnCount() - 1\n        };\n\n        this.fireDataEvent(\"dataChanged\", data);\n      } else {\n        var blockSize = this.getBlockSize();\n        var blockCount = Math.ceil(this.getRowCount() / blockSize);\n        var startBlock = parseInt(rowIndex / blockSize, 10);\n\n        // Remove the row and move the rows of all following blocks\n        for (var block = startBlock; block <= blockCount; block++) {\n          var blockData = this._rowBlockCache[block];\n\n          if (blockData != null) {\n            // Remove the row in the start block\n            // NOTE: In the other blocks the first row is removed\n            //       (This is the row that was)\n            var removeIndex = 0;\n\n            if (block == startBlock) {\n              removeIndex = rowIndex - block * blockSize;\n            }\n\n            blockData.rowDataArr.splice(removeIndex, 1);\n\n            if (block == blockCount - 1) {\n              // This is the last block\n              if (blockData.rowDataArr.length == 0) {\n                // It is empty now -> Remove it\n                delete this._rowBlockCache[block];\n              }\n            } else {\n              // Try to copy the first row of the next block to the end of this block\n              // so this block can stays clean\n              var nextBlockData = this._rowBlockCache[block + 1];\n\n              if (nextBlockData != null) {\n                blockData.rowDataArr.push(nextBlockData.rowDataArr[0]);\n              } else {\n                // There is no row to move -> Mark this block as dirty\n                blockData.isDirty = true;\n              }\n            }\n          }\n        }\n\n        if (this._rowCount != -1) {\n          this._rowCount--;\n        }\n\n        // Inform the listeners\n        if (this.hasListener(\"dataChanged\")) {\n          var data = {\n            firstRow: rowIndex,\n            lastRow: this.getRowCount() - 1,\n            firstColumn: 0,\n            lastColumn: this.getColumnCount() - 1\n          };\n\n          this.fireDataEvent(\"dataChanged\", data);\n        }\n      }\n    },\n\n    /**\n     *\n     * See overridden method for details.\n     *\n     * @param rowIndex {Integer} the model index of the row.\n     * @return {Object} Map containing a value for each column.\n     */\n    getRowData(rowIndex) {\n      var blockSize = this.getBlockSize();\n      var block = parseInt(rowIndex / blockSize, 10);\n      var blockData = this._rowBlockCache[block];\n\n      if (blockData == null) {\n        // This block is not (yet) loaded\n        return null;\n      } else {\n        var rowData = blockData.rowDataArr[rowIndex - block * blockSize];\n\n        // Update the last recently used counter\n        if (blockData.lru != this._lruCounter) {\n          blockData.lru = ++this._lruCounter;\n        }\n\n        return rowData;\n      }\n    },\n\n    // overridden\n    getValue(columnIndex, rowIndex) {\n      var rowData = this.getRowData(rowIndex);\n\n      if (rowData == null) {\n        return null;\n      } else {\n        var columnId = this.getColumnId(columnIndex);\n        return rowData[columnId];\n      }\n    },\n\n    // overridden\n    setValue(columnIndex, rowIndex, value) {\n      var rowData = this.getRowData(rowIndex);\n\n      if (rowData == null) {\n        // row has not yet been loaded or does not exist\n        return;\n      } else {\n        var columnId = this.getColumnId(columnIndex);\n        rowData[columnId] = value;\n\n        // Inform the listeners\n        if (this.hasListener(\"dataChanged\")) {\n          var data = {\n            firstRow: rowIndex,\n            lastRow: rowIndex,\n            firstColumn: columnIndex,\n            lastColumn: columnIndex\n          };\n\n          this.fireDataEvent(\"dataChanged\", data);\n        }\n      }\n    },\n\n    /**\n     * Sets all columns editable or not editable.\n     *\n     * @param editable {Boolean} whether all columns are editable.\n     */\n    setEditable(editable) {\n      this._editableColArr = [];\n\n      for (var col = 0; col < this.getColumnCount(); col++) {\n        this._editableColArr[col] = editable;\n      }\n\n      this.fireEvent(\"metaDataChanged\");\n    },\n\n    /**\n     * Sets whether a column is editable.\n     *\n     * @param columnIndex {Integer} the column of which to set the editable state.\n     * @param editable {Boolean} whether the column should be editable.\n     */\n    setColumnEditable(columnIndex, editable) {\n      if (editable != this.isColumnEditable(columnIndex)) {\n        if (this._editableColArr == null) {\n          this._editableColArr = [];\n        }\n\n        this._editableColArr[columnIndex] = editable;\n\n        this.fireEvent(\"metaDataChanged\");\n      }\n    },\n\n    // overridden\n    isColumnEditable(columnIndex) {\n      return this._editableColArr\n        ? this._editableColArr[columnIndex] == true\n        : false;\n    },\n\n    /**\n     * Sets whether a column is sortable.\n     *\n     * @param columnIndex {Integer} the column of which to set the sortable state.\n     * @param sortable {Boolean} whether the column should be sortable.\n     */\n    setColumnSortable(columnIndex, sortable) {\n      if (sortable != this.isColumnSortable(columnIndex)) {\n        if (this._sortableColArr == null) {\n          this._sortableColArr = [];\n        }\n\n        this._sortableColArr[columnIndex] = sortable;\n\n        this.fireEvent(\"metaDataChanged\");\n      }\n    },\n\n    // overridden\n    isColumnSortable(columnIndex) {\n      return this._sortableColArr\n        ? this._sortableColArr[columnIndex] !== false\n        : true;\n    },\n\n    // overridden\n    sortByColumn(columnIndex, ascending) {\n      if (\n        this._sortColumnIndex != columnIndex ||\n        this._sortAscending != ascending\n      ) {\n        this._sortColumnIndex = columnIndex;\n        this._sortAscending = ascending;\n\n        this.clearCache();\n\n        // Inform the listeners\n        this.fireEvent(\"metaDataChanged\");\n      }\n    },\n\n    // overridden\n    getSortColumnIndex() {\n      return this._sortColumnIndex;\n    },\n\n    // overridden\n    isSortAscending() {\n      return this._sortAscending;\n    },\n\n    /**\n     * Sets the sorted column without sorting the data.\n     * Use this method, if you want to mark the column as the sorted column,\n     * (e.g. for appearance reason), but the sorting of the data will be done\n     * in another step.\n     *\n     * @param sortColumnIndex {Integer} the column, which shall be marked as the sorted column.\n     */\n    setSortColumnIndexWithoutSortingData(sortColumnIndex) {\n      this._sortColumnIndex = sortColumnIndex;\n    },\n\n    /**\n     * Sets the direction of the sorting without sorting the data.\n     * Use this method, if you want to set the direction of sorting, (e.g\n     * for appearance reason), but the sorting of the data will be done in\n     * another step.\n     *\n     * @param sortAscending {Boolean} whether the sorting direction is ascending\n     *        (true) or not (false).\n     */\n    setSortAscendingWithoutSortingData(sortAscending) {\n      this._sortAscending = sortAscending;\n    }\n  },\n\n  destruct() {\n    this._sortableColArr = this._editableColArr = this._rowBlockCache = null;\n  }\n});\n"
  ],
  "mappings": "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"
}