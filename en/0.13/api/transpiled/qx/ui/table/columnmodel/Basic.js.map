{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "constructor",
    "call",
    "__overallColumnArr",
    "__visibleColumnArr",
    "events",
    "widthChanged",
    "visibilityChangedPre",
    "visibilityChanged",
    "orderChanged",
    "headerCellRendererChanged",
    "statics",
    "DEFAULT_WIDTH",
    "DEFAULT_HEADER_RENDERER",
    "ui",
    "table",
    "headerrenderer",
    "Default",
    "DEFAULT_DATA_RENDERER",
    "cellrenderer",
    "DEFAULT_EDITOR_FACTORY",
    "celleditor",
    "TextField",
    "members",
    "__internalChange",
    "__colToXPosMap",
    "__columnDataArr",
    "__headerRenderer",
    "__dataRenderer",
    "__editorFactory",
    "init",
    "colCount",
    "width",
    "columnmodel",
    "Basic",
    "headerRenderer",
    "dataRenderer",
    "editorFactory",
    "initiallyHiddenColumns",
    "getInitiallyHiddenColumns",
    "col",
    "hidden",
    "length",
    "setColumnVisible",
    "data",
    "visible",
    "isColumnVisible",
    "fireDataEvent",
    "getVisibleColumns",
    "setColumnWidth",
    "isPointerAction",
    "oldWidth",
    "newWidth",
    "getColumnWidth",
    "setHeaderCellRenderer",
    "renderer",
    "oldRenderer",
    "dispose",
    "setHeaderCellRenderers",
    "renderers",
    "cols",
    "keys",
    "getHeaderCellRenderer",
    "setDataCellRenderer",
    "getDataCellRenderer",
    "setCellEditorFactory",
    "factory",
    "oldFactory",
    "getCellEditorFactory",
    "_getColToXPosMap",
    "overX",
    "visX",
    "getVisibleColumnCount",
    "getVisibleColumnAtX",
    "visXPos",
    "getVisibleX",
    "getOverallColumnCount",
    "getOverallColumnAtX",
    "overXPos",
    "getOverallX",
    "colToXPosMap",
    "Error",
    "nextVisX",
    "x",
    "currCol",
    "currVisX",
    "splice",
    "moveColumn",
    "fromOverXPos",
    "toOverXPos",
    "setColumnsOrder",
    "newPositions",
    "isVisible",
    "Array",
    "colIdx",
    "lang",
    "clone",
    "destruct",
    "i",
    "_disposeObjects"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/table/columnmodel/Basic.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2006 STZ-IDA, Germany, http://www.stz-ida.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Til Schneider (til132)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * A model that contains all meta data about columns, such as width, renderer,\r\n * visibility and order.\r\n *\r\n * @see qx.ui.table.ITableModel\r\n */\r\nqx.Class.define(\"qx.ui.table.columnmodel.Basic\", {\r\n  extend: qx.core.Object,\r\n\r\n  construct() {\r\n    super();\r\n\r\n    this.__overallColumnArr = [];\r\n    this.__visibleColumnArr = [];\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     EVENTS\r\n  *****************************************************************************\r\n  */\r\n\r\n  events: {\r\n    /**\r\n     * Fired when the width of a column has changed. The data property of the event is\r\n     * a map having the following attributes:\r\n     * <ul>\r\n     *   <li>col: The model index of the column the width of which has changed.</li>\r\n     *   <li>newWidth: The new width of the column in pixels.</li>\r\n     *   <li>oldWidth: The old width of the column in pixels.</li>\r\n     * </ul>\r\n     */\r\n    widthChanged: \"qx.event.type.Data\",\r\n\r\n    /**\r\n     * Fired when the visibility of a column has changed. This event is equal to\r\n     * \"visibilityChanged\", but is fired right before.\r\n     */\r\n    visibilityChangedPre: \"qx.event.type.Data\",\r\n\r\n    /**\r\n     * Fired when the visibility of a column has changed. The data property of the\r\n     * event is a map having the following attributes:\r\n     * <ul>\r\n     *   <li>col: The model index of the column the visibility of which has changed.</li>\r\n     *   <li>visible: Whether the column is now visible.</li>\r\n     * </ul>\r\n     */\r\n    visibilityChanged: \"qx.event.type.Data\",\r\n\r\n    /**\r\n     * Fired when the column order has changed. The data property of the\r\n     * event is a map having the following attributes:\r\n     * <ul>\r\n     *   <li>col: The model index of the column that was moved.</li>\r\n     *   <li>fromOverXPos: The old overall x position of the column.</li>\r\n     *   <li>toOverXPos: The new overall x position of the column.</li>\r\n     * </ul>\r\n     */\r\n    orderChanged: \"qx.event.type.Data\",\r\n\r\n    /**\r\n     * Fired when the cell renderer of a column has changed.\r\n     * The data property of the event is a map having the following attributes:\r\n     * <ul>\r\n     *   <li>col: The model index of the column that was moved.</li>\r\n     * </ul>\r\n     */\r\n    headerCellRendererChanged: \"qx.event.type.Data\"\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     STATICS\r\n  *****************************************************************************\r\n  */\r\n\r\n  statics: {\r\n    /** @type {Integer} the default width of a column in pixels. */\r\n    DEFAULT_WIDTH: 100,\r\n\r\n    /** @type {qx.ui.table.headerrenderer.Default} the default header cell renderer. */\r\n    DEFAULT_HEADER_RENDERER: qx.ui.table.headerrenderer.Default,\r\n\r\n    /** @type {qx.ui.table.cellrenderer.Default} the default data cell renderer. */\r\n    DEFAULT_DATA_RENDERER: qx.ui.table.cellrenderer.Default,\r\n\r\n    /** @type {qx.ui.table.celleditor.TextField} the default editor factory. */\r\n    DEFAULT_EDITOR_FACTORY: qx.ui.table.celleditor.TextField\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     MEMBERS\r\n  *****************************************************************************\r\n  */\r\n\r\n  members: {\r\n    __internalChange: null,\r\n    __colToXPosMap: null,\r\n    __visibleColumnArr: null,\r\n    __overallColumnArr: null,\r\n    __columnDataArr: null,\r\n\r\n    __headerRenderer: null,\r\n    __dataRenderer: null,\r\n    __editorFactory: null,\r\n\r\n    /**\r\n     * Initializes the column model.\r\n     *\r\n     * @param colCount {Integer}\r\n     *   The number of columns the model should have.\r\n     *\r\n     * @param table {qx.ui.table.Table}\r\n     *   The table to which this column model is attached.\r\n     */\r\n    init(colCount, table) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(colCount, \"Invalid argument 'colCount'.\");\r\n      }\r\n\r\n      this.__columnDataArr = [];\r\n\r\n      var width = qx.ui.table.columnmodel.Basic.DEFAULT_WIDTH;\r\n      var headerRenderer =\r\n        this.__headerRenderer ||\r\n        (this.__headerRenderer =\r\n          new qx.ui.table.columnmodel.Basic.DEFAULT_HEADER_RENDERER());\r\n      var dataRenderer =\r\n        this.__dataRenderer ||\r\n        (this.__dataRenderer =\r\n          new qx.ui.table.columnmodel.Basic.DEFAULT_DATA_RENDERER());\r\n      var editorFactory =\r\n        this.__editorFactory ||\r\n        (this.__editorFactory =\r\n          new qx.ui.table.columnmodel.Basic.DEFAULT_EDITOR_FACTORY());\r\n      this.__overallColumnArr = [];\r\n      this.__visibleColumnArr = [];\r\n\r\n      // Get the initially hidden column array, if one was provided. Older\r\n      // subclasses may not provide the 'table' argument, so we treat them\r\n      // traditionally with no initially hidden columns.\r\n      var initiallyHiddenColumns;\r\n\r\n      // Was a table provided to us?\r\n      if (table) {\r\n        // Yup. Get its list of initially hidden columns, if the user provided\r\n        // such a list.\r\n        initiallyHiddenColumns = table.getInitiallyHiddenColumns();\r\n      }\r\n\r\n      // If no table was specified, or if the user didn't provide a list of\r\n      // initially hidden columns, use an empty list.\r\n      initiallyHiddenColumns = initiallyHiddenColumns || [];\r\n\r\n      for (var col = 0; col < colCount; col++) {\r\n        this.__columnDataArr[col] = {\r\n          width: width,\r\n          headerRenderer: headerRenderer,\r\n          dataRenderer: dataRenderer,\r\n          editorFactory: editorFactory\r\n        };\r\n\r\n        this.__overallColumnArr[col] = col;\r\n        this.__visibleColumnArr[col] = col;\r\n      }\r\n\r\n      this.__colToXPosMap = null;\r\n\r\n      // If any columns are initially hidden, hide them now. Make it an\r\n      // internal change so that events are not generated.\r\n      this.__internalChange = true;\r\n      for (var hidden = 0; hidden < initiallyHiddenColumns.length; hidden++) {\r\n        this.setColumnVisible(initiallyHiddenColumns[hidden], false);\r\n      }\r\n      this.__internalChange = false;\r\n\r\n      for (col = 0; col < colCount; col++) {\r\n        var data = {\r\n          col: col,\r\n          visible: this.isColumnVisible(col)\r\n        };\r\n\r\n        this.fireDataEvent(\"visibilityChangedPre\", data);\r\n        this.fireDataEvent(\"visibilityChanged\", data);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Return the array of visible columns\r\n     *\r\n     * @return {Array} List of all visible columns\r\n     */\r\n    getVisibleColumns() {\r\n      return this.__visibleColumnArr != null ? this.__visibleColumnArr : [];\r\n    },\r\n\r\n    /**\r\n     * Sets the width of a column.\r\n     *\r\n     * @param col {Integer}\r\n     *   The model index of the column.\r\n     *\r\n     * @param width {Integer}\r\n     *   The new width the column should get in pixels.\r\n     *\r\n     * @param isPointerAction {Boolean}\r\n     *   <i>true</i> if the column width is being changed as a result of a\r\n     *   pointer drag in the header; false or undefined otherwise.\r\n     *\r\n     */\r\n    setColumnWidth(col, width, isPointerAction) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(col, \"Invalid argument 'col'.\");\r\n        this.assertInteger(width, \"Invalid argument 'width'.\");\r\n        this.assertNotUndefined(\r\n          this.__columnDataArr[col],\r\n          \"Column not found in table model\"\r\n        );\r\n      }\r\n\r\n      var oldWidth = this.__columnDataArr[col].width;\r\n\r\n      if (oldWidth != width) {\r\n        this.__columnDataArr[col].width = width;\r\n\r\n        var data = {\r\n          col: col,\r\n          newWidth: width,\r\n          oldWidth: oldWidth,\r\n          isPointerAction: isPointerAction || false\r\n        };\r\n\r\n        this.fireDataEvent(\"widthChanged\", data);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns the width of a column.\r\n     *\r\n     * @param col {Integer} the model index of the column.\r\n     * @return {Integer} the width of the column in pixels.\r\n     */\r\n    getColumnWidth(col) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(col, \"Invalid argument 'col'.\");\r\n        this.assertNotUndefined(\r\n          this.__columnDataArr[col],\r\n          \"Column not found in table model\"\r\n        );\r\n      }\r\n\r\n      return this.__columnDataArr[col].width;\r\n    },\r\n\r\n    /**\r\n     * Sets the header renderer of a column. Use setHeaderCellRenderers\r\n     * instead of this method if you want to set the header renderer of many\r\n     * columns.\r\n     *\r\n     * @param col {Integer} the model index of the column.\r\n     * @param renderer {qx.ui.table.IHeaderRenderer} the new header renderer the column\r\n     *      should get.\r\n     */\r\n    setHeaderCellRenderer(col, renderer) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(col, \"Invalid argument 'col'.\");\r\n        this.assertInterface(\r\n          renderer,\r\n          qx.ui.table.IHeaderRenderer,\r\n          \"Invalid argument 'renderer'.\"\r\n        );\r\n\r\n        this.assertNotUndefined(\r\n          this.__columnDataArr[col],\r\n          \"Column not found in table model\"\r\n        );\r\n      }\r\n\r\n      var oldRenderer = this.__columnDataArr[col].headerRenderer;\r\n      if (oldRenderer !== this.__headerRenderer) {\r\n        oldRenderer.dispose();\r\n      }\r\n\r\n      this.__columnDataArr[col].headerRenderer = renderer;\r\n      if (!this.__internalChange) {\r\n        this.fireDataEvent(\"headerCellRendererChanged\", { col: col });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets the header renderer of one or more columns. Use this method, in\r\n     * favor of setHeaderCellRenderer, if you want to set the header renderer\r\n     * of many columns. This method fires the \"headerCellRendererChanged\"\r\n     * event only once, after setting all renderers, whereas\r\n     * setHeaderCellRenderer fires it for each changed renderer which can be\r\n     * slow with many columns.\r\n     *\r\n     * @param renderers {Map}\r\n     *   Map, where the keys are column numbers and values are the renderers,\r\n     *   implementing qx.ui.table.IHeaderRenderer, of the the new header\r\n     *   renderers for that column\r\n     */\r\n    setHeaderCellRenderers(renderers) {\r\n      var col;\r\n\r\n      // Prevent firing \"headerCellRendererChanged\" for each column. Instead,\r\n      // we'll fire it once at the end.\r\n      this.__internalChange = true;\r\n\r\n      // For each listed column...\r\n      for (col in renderers) {\r\n        // ... set that column's renderer\r\n        this.setHeaderCellRenderer(+col, renderers[col]);\r\n      }\r\n\r\n      // Turn off the internal-change flag so operation returns to normal\r\n      this.__internalChange = false;\r\n\r\n      // Now we can fire the event once. The data indicates which columns\r\n      // changed. Internally to qooxdoo, nothing cares about the event data.\r\n      this.fireDataEvent(\"headerCellRendererChanged\", {\r\n        cols: Object.keys(renderers)\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Returns the header renderer of a column.\r\n     *\r\n     * @param col {Integer} the model index of the column.\r\n     * @return {qx.ui.table.IHeaderRenderer} the header renderer of the column.\r\n     */\r\n    getHeaderCellRenderer(col) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(col, \"Invalid argument 'col'.\");\r\n        this.assertNotUndefined(\r\n          this.__columnDataArr[col],\r\n          \"Column not found in table model\"\r\n        );\r\n      }\r\n\r\n      return this.__columnDataArr[col].headerRenderer;\r\n    },\r\n\r\n    /**\r\n     * Sets the data renderer of a column.\r\n     *\r\n     * @param col {Integer} the model index of the column.\r\n     * @param renderer {qx.ui.table.ICellRenderer} the new data renderer\r\n     *   the column should get.\r\n     * @return {qx.ui.table.ICellRenderer?null} If an old renderer was set and\r\n     *   it was not the default renderer, the old renderer is returned for\r\n     *   pooling or disposing.\r\n     */\r\n    setDataCellRenderer(col, renderer) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(col, \"Invalid argument 'col'.\");\r\n        this.assertInterface(\r\n          renderer,\r\n          qx.ui.table.ICellRenderer,\r\n          \"Invalid argument 'renderer'.\"\r\n        );\r\n\r\n        this.assertNotUndefined(\r\n          this.__columnDataArr[col],\r\n          \"Column not found in table model\"\r\n        );\r\n      }\r\n\r\n      var oldRenderer = this.__columnDataArr[col].dataRenderer;\r\n      this.__columnDataArr[col].dataRenderer = renderer;\r\n\r\n      if (oldRenderer !== this.__dataRenderer) {\r\n        return oldRenderer;\r\n      }\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * Returns the data renderer of a column.\r\n     *\r\n     * @param col {Integer} the model index of the column.\r\n     * @return {qx.ui.table.ICellRenderer} the data renderer of the column.\r\n     */\r\n    getDataCellRenderer(col) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(col, \"Invalid argument 'col'.\");\r\n        this.assertNotUndefined(\r\n          this.__columnDataArr[col],\r\n          \"Column not found in table model\"\r\n        );\r\n      }\r\n\r\n      return this.__columnDataArr[col].dataRenderer;\r\n    },\r\n\r\n    /**\r\n     * Sets the cell editor factory of a column.\r\n     *\r\n     * @param col {Integer} the model index of the column.\r\n     * @param factory {qx.ui.table.ICellEditorFactory} the new cell editor factory the column should get.\r\n     */\r\n    setCellEditorFactory(col, factory) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(col, \"Invalid argument 'col'.\");\r\n        this.assertInterface(\r\n          factory,\r\n          qx.ui.table.ICellEditorFactory,\r\n          \"Invalid argument 'factory'.\"\r\n        );\r\n\r\n        this.assertNotUndefined(\r\n          this.__columnDataArr[col],\r\n          \"Column not found in table model\"\r\n        );\r\n      }\r\n\r\n      var oldFactory = this.__columnDataArr[col].editorFactory;\r\n      if (oldFactory === factory) {\r\n        return;\r\n      }\r\n      if (oldFactory !== this.__editorFactory) {\r\n        oldFactory.dispose();\r\n      }\r\n\r\n      this.__columnDataArr[col].editorFactory = factory;\r\n    },\r\n\r\n    /**\r\n     * Returns the cell editor factory of a column.\r\n     *\r\n     * @param col {Integer} the model index of the column.\r\n     * @return {qx.ui.table.ICellEditorFactory} the cell editor factory of the column.\r\n     */\r\n    getCellEditorFactory(col) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(col, \"Invalid argument 'col'.\");\r\n        this.assertNotUndefined(\r\n          this.__columnDataArr[col],\r\n          \"Column not found in table model\"\r\n        );\r\n      }\r\n\r\n      return this.__columnDataArr[col].editorFactory;\r\n    },\r\n\r\n    /**\r\n     * Returns the map that translates model indexes to x positions.\r\n     *\r\n     * The returned map contains for a model index (int) a map having two\r\n     * properties: overX (the overall x position of the column, int) and\r\n     * visX (the visible x position of the column, int). visX is missing for\r\n     * hidden columns.\r\n     *\r\n     * @return {Map} the \"column to x position\" map.\r\n     */\r\n    _getColToXPosMap() {\r\n      if (this.__colToXPosMap == null) {\r\n        this.__colToXPosMap = {};\r\n\r\n        for (var overX = 0; overX < this.__overallColumnArr.length; overX++) {\r\n          var col = this.__overallColumnArr[overX];\r\n          this.__colToXPosMap[col] = { overX: overX };\r\n        }\r\n\r\n        for (var visX = 0; visX < this.__visibleColumnArr.length; visX++) {\r\n          var col = this.__visibleColumnArr[visX];\r\n          this.__colToXPosMap[col].visX = visX;\r\n        }\r\n      }\r\n\r\n      return this.__colToXPosMap;\r\n    },\r\n\r\n    /**\r\n     * Returns the number of visible columns.\r\n     *\r\n     * @return {Integer} the number of visible columns.\r\n     */\r\n    getVisibleColumnCount() {\r\n      return this.__visibleColumnArr != null\r\n        ? this.__visibleColumnArr.length\r\n        : 0;\r\n    },\r\n\r\n    /**\r\n     * Returns the model index of a column at a certain visible x position.\r\n     *\r\n     * @param visXPos {Integer} the visible x position of the column.\r\n     * @return {Integer} the model index of the column.\r\n     */\r\n    getVisibleColumnAtX(visXPos) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(visXPos, \"Invalid argument 'visXPos'.\");\r\n      }\r\n\r\n      return this.__visibleColumnArr[visXPos];\r\n    },\r\n\r\n    /**\r\n     * Returns the visible x position of a column.\r\n     *\r\n     * @param col {Integer} the model index of the column.\r\n     * @return {Integer} the visible x position of the column.\r\n     */\r\n    getVisibleX(col) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(col, \"Invalid argument 'col'.\");\r\n      }\r\n\r\n      return this._getColToXPosMap()[col].visX;\r\n    },\r\n\r\n    /**\r\n     * Returns the overall number of columns (including hidden columns).\r\n     *\r\n     * @return {Integer} the overall number of columns.\r\n     */\r\n    getOverallColumnCount() {\r\n      return this.__overallColumnArr.length;\r\n    },\r\n\r\n    /**\r\n     * Returns the model index of a column at a certain overall x position.\r\n     *\r\n     * @param overXPos {Integer} the overall x position of the column.\r\n     * @return {Integer} the model index of the column.\r\n     */\r\n    getOverallColumnAtX(overXPos) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(overXPos, \"Invalid argument 'overXPos'.\");\r\n      }\r\n\r\n      return this.__overallColumnArr[overXPos];\r\n    },\r\n\r\n    /**\r\n     * Returns the overall x position of a column.\r\n     *\r\n     * @param col {Integer} the model index of the column.\r\n     * @return {Integer} the overall x position of the column.\r\n     */\r\n    getOverallX(col) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(col, \"Invalid argument 'col'.\");\r\n      }\r\n\r\n      return this._getColToXPosMap()[col].overX;\r\n    },\r\n\r\n    /**\r\n     * Returns whether a certain column is visible.\r\n     *\r\n     * @param col {Integer} the model index of the column.\r\n     * @return {Boolean} whether the column is visible.\r\n     */\r\n    isColumnVisible(col) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(col, \"Invalid argument 'col'.\");\r\n      }\r\n\r\n      return this._getColToXPosMap()[col].visX != null;\r\n    },\r\n\r\n    /**\r\n     * Sets whether a certain column is visible.\r\n     *\r\n     * @param col {Integer} the model index of the column.\r\n     * @param visible {Boolean} whether the column should be visible.\r\n     */\r\n    setColumnVisible(col, visible) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(col, \"Invalid argument 'col'.\");\r\n        this.assertBoolean(visible, \"Invalid argument 'visible'.\");\r\n      }\r\n\r\n      if (visible != this.isColumnVisible(col)) {\r\n        if (visible) {\r\n          var colToXPosMap = this._getColToXPosMap();\r\n\r\n          var overX = colToXPosMap[col].overX;\r\n\r\n          if (overX == null) {\r\n            throw new Error(\r\n              \"Showing column failed: \" +\r\n                col +\r\n                \". The column is not added to this TablePaneModel.\"\r\n            );\r\n          }\r\n\r\n          // get the visX of the next visible column after the column to show\r\n          var nextVisX;\r\n\r\n          for (var x = overX + 1; x < this.__overallColumnArr.length; x++) {\r\n            var currCol = this.__overallColumnArr[x];\r\n            var currVisX = colToXPosMap[currCol].visX;\r\n\r\n            if (currVisX != null) {\r\n              nextVisX = currVisX;\r\n              break;\r\n            }\r\n          }\r\n\r\n          // If there comes no visible column any more, then show the column\r\n          // at the end\r\n          if (nextVisX == null) {\r\n            nextVisX = this.__visibleColumnArr.length;\r\n          }\r\n\r\n          // Add the column to the visible columns\r\n          this.__visibleColumnArr.splice(nextVisX, 0, col);\r\n        } else {\r\n          var visX = this.getVisibleX(col);\r\n          this.__visibleColumnArr.splice(visX, 1);\r\n        }\r\n\r\n        // Invalidate the __colToXPosMap\r\n        this.__colToXPosMap = null;\r\n\r\n        // Inform the listeners\r\n        if (!this.__internalChange) {\r\n          var data = {\r\n            col: col,\r\n            visible: visible\r\n          };\r\n\r\n          this.fireDataEvent(\"visibilityChangedPre\", data);\r\n          this.fireDataEvent(\"visibilityChanged\", data);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Moves a column.\r\n     *\r\n     * @param fromOverXPos {Integer} the overall x position of the column to move.\r\n     * @param toOverXPos {Integer} the overall x position of where the column should be\r\n     *      moved to.\r\n     */\r\n    moveColumn(fromOverXPos, toOverXPos) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertInteger(fromOverXPos, \"Invalid argument 'fromOverXPos'.\");\r\n        this.assertInteger(toOverXPos, \"Invalid argument 'toOverXPos'.\");\r\n      }\r\n\r\n      this.__internalChange = true;\r\n\r\n      var col = this.__overallColumnArr[fromOverXPos];\r\n      var visible = this.isColumnVisible(col);\r\n\r\n      if (visible) {\r\n        this.setColumnVisible(col, false);\r\n      }\r\n\r\n      this.__overallColumnArr.splice(fromOverXPos, 1);\r\n      this.__overallColumnArr.splice(toOverXPos, 0, col);\r\n\r\n      // Invalidate the __colToXPosMap\r\n      this.__colToXPosMap = null;\r\n\r\n      if (visible) {\r\n        this.setColumnVisible(col, true);\r\n      }\r\n      this.__internalChange = false;\r\n\r\n      // Inform the listeners\r\n      var data = {\r\n        col: col,\r\n        fromOverXPos: fromOverXPos,\r\n        toOverXPos: toOverXPos\r\n      };\r\n\r\n      this.fireDataEvent(\"orderChanged\", data);\r\n    },\r\n\r\n    /**\r\n     * Reorders all columns to new overall positions. Will fire one \"orderChanged\" event\r\n     * without data afterwards\r\n     *\r\n     * @param newPositions {Integer[]} Array mapping the index of a column in table model to its wanted overall\r\n     *                            position on screen (both zero based). If the table models holds\r\n     *                            col0, col1, col2 and col3 and you give [1,3,2,0], the new column order\r\n     *                            will be col1, col3, col2, col0\r\n     */\r\n    setColumnsOrder(newPositions) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        this.assertArray(newPositions, \"Invalid argument 'newPositions'.\");\r\n      }\r\n\r\n      if (newPositions.length == this.__overallColumnArr.length) {\r\n        this.__internalChange = true;\r\n\r\n        // Go through each column an switch visible ones to invisible. Reason is unknown,\r\n        // this just mimicks the behaviour of moveColumn. Possibly useful because setting\r\n        // a column visible later updates a map with its screen coords.\r\n        var isVisible = new Array(newPositions.length);\r\n        for (\r\n          var colIdx = 0;\r\n          colIdx < this.__overallColumnArr.length;\r\n          colIdx++\r\n        ) {\r\n          var visible = this.isColumnVisible(colIdx);\r\n          isVisible[colIdx] = visible; //Remember, as this relies on this.__colToXPosMap which is cleared below\r\n          if (visible) {\r\n            this.setColumnVisible(colIdx, false);\r\n          }\r\n        }\r\n\r\n        // Store new position values\r\n        this.__overallColumnArr = qx.lang.Array.clone(newPositions);\r\n\r\n        // Invalidate the __colToXPosMap\r\n        this.__colToXPosMap = null;\r\n\r\n        // Go through each column an switch invisible ones back to visible\r\n        for (\r\n          var colIdx = 0;\r\n          colIdx < this.__overallColumnArr.length;\r\n          colIdx++\r\n        ) {\r\n          if (isVisible[colIdx]) {\r\n            this.setColumnVisible(colIdx, true);\r\n          }\r\n        }\r\n        this.__internalChange = false;\r\n\r\n        // Inform the listeners. Do not add data as all known listeners in qooxdoo\r\n        // only take this event to mean \"total repaint necesscary\". Fabian will look\r\n        // after deprecating the data part of the orderChanged - event\r\n        this.fireDataEvent(\"orderChanged\");\r\n      } else {\r\n        throw new Error(\r\n          \"setColumnsOrder: Invalid number of column positions given, expected \" +\r\n            this.__overallColumnArr.length +\r\n            \", got \" +\r\n            newPositions.length\r\n        );\r\n      }\r\n    }\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     DESTRUCTOR\r\n  *****************************************************************************\r\n  */\r\n\r\n  destruct() {\r\n    for (var i = 0; i < this.__columnDataArr.length; i++) {\r\n      this.__columnDataArr[i].headerRenderer.dispose();\r\n      this.__columnDataArr[i].dataRenderer.dispose();\r\n      this.__columnDataArr[i].editorFactory.dispose();\r\n    }\r\n\r\n    this.__overallColumnArr =\r\n      this.__visibleColumnArr =\r\n      this.__columnDataArr =\r\n      this.__colToXPosMap =\r\n        null;\r\n\r\n    this._disposeObjects(\r\n      \"__headerRenderer\",\r\n      \"__dataRenderer\",\r\n      \"__editorFactory\"\r\n    );\r\n  }\r\n});\r\n"
  ],
  "mappings": "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"
}