{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/compiler/node_modules/@qooxdoo/framework/source/class/qx/ui/table/selection/Model.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "__selectedRangeArr",
    "__anchorSelectionIndex",
    "__leadSelectionIndex",
    "hasBatchModeRefCount",
    "__hadChangeEventInBatchMode",
    "events",
    "statics",
    "NO_SELECTION",
    "SINGLE_SELECTION",
    "SINGLE_INTERVAL_SELECTION",
    "MULTIPLE_INTERVAL_SELECTION",
    "MULTIPLE_INTERVAL_SELECTION_TOGGLE",
    "properties",
    "selectionMode",
    "init",
    "check",
    "apply",
    "members",
    "_applySelectionMode",
    "resetSelection",
    "setBatchMode",
    "batchMode",
    "Error",
    "_fireChangeSelection",
    "hasBatchMode",
    "getAnchorSelectionIndex",
    "_setAnchorSelectionIndex",
    "index",
    "getLeadSelectionIndex",
    "_setLeadSelectionIndex",
    "_getSelectedRangeArr",
    "isSelectionEmpty",
    "_resetSelection",
    "length",
    "getSelectedCount",
    "selectedCount",
    "i",
    "range",
    "maxIndex",
    "minIndex",
    "isSelectedIndex",
    "getSelectedRanges",
    "retVal",
    "push",
    "iterateSelection",
    "iterator",
    "object",
    "j",
    "call",
    "setSelectionInterval",
    "fromIndex",
    "toIndex",
    "me",
    "getSelectionMode",
    "_addSelectionInterval",
    "removeSelectionInterval",
    "e",
    "addSelectionInterval",
    "SelectionModel",
    "ui",
    "table",
    "selection",
    "Model",
    "rowsRemoved",
    "Math",
    "min",
    "max",
    "removeCount",
    "newRanges",
    "extraRange",
    "minIsIn",
    "maxIsIn",
    "newRangeIndex",
    "splice",
    "lastRange",
    "_dumpRanges",
    "text",
    "debug",
    "fireEvent",
    "destruct"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2006 STZ-IDA, Germany, http://www.stz-ida.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Til Schneider (til132)\n     * David Perez Carmona (david-perez)\n\n************************************************************************ */\n\n/**\n * A selection model.\n */\nqx.Class.define(\"qx.ui.table.selection.Model\",\n{\n  extend : qx.core.Object,\n\n\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  construct : function()\n  {\n    this.base(arguments);\n\n    this.__selectedRangeArr = [];\n    this.__anchorSelectionIndex = -1;\n    this.__leadSelectionIndex = -1;\n    this.hasBatchModeRefCount = 0;\n    this.__hadChangeEventInBatchMode = false;\n  },\n\n\n\n  /*\n  *****************************************************************************\n     EVENTS\n  *****************************************************************************\n  */\n\n  events: {\n    /** Fired when the selection has changed. */\n    \"changeSelection\" : \"qx.event.type.Event\"\n  },\n\n\n\n  /*\n  *****************************************************************************\n     STATICS\n  *****************************************************************************\n  */\n\n  statics :\n  {\n\n    /** @type {int} The selection mode \"none\". Nothing can ever be selected. */\n    NO_SELECTION                : 1,\n\n    /** @type {int} The selection mode \"single\". This mode only allows one selected item. */\n    SINGLE_SELECTION            : 2,\n\n\n    /**\n     * @type {int} The selection mode \"single interval\". This mode only allows one\n     * continuous interval of selected items.\n     */\n    SINGLE_INTERVAL_SELECTION   : 3,\n\n\n    /**\n     * @type {int} The selection mode \"multiple interval\". This mode only allows any\n     * selection.\n     */\n    MULTIPLE_INTERVAL_SELECTION : 4,\n\n\n    /**\n     * @type {int} The selection mode \"multiple interval\". This mode only allows any\n     * selection. The difference with the previous one, is that multiple\n     * selection is eased. A tap on an item, toggles its selection state.\n     * On the other hand, MULTIPLE_INTERVAL_SELECTION does this behavior only\n     * when Ctrl-tapping an item.\n     */\n    MULTIPLE_INTERVAL_SELECTION_TOGGLE : 5\n  },\n\n\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties :\n  {\n    /**\n     * Set the selection mode. Valid values are {@link #NO_SELECTION},\n     * {@link #SINGLE_SELECTION}, {@link #SINGLE_INTERVAL_SELECTION},\n     * {@link #MULTIPLE_INTERVAL_SELECTION} and\n     * {@link #MULTIPLE_INTERVAL_SELECTION_TOGGLE}.\n     */\n    selectionMode :\n    {\n      init : 2, //SINGLE_SELECTION,\n      check : [1,2,3,4,5],\n      //[ NO_SELECTION, SINGLE_SELECTION, SINGLE_INTERVAL_SELECTION, MULTIPLE_INTERVAL_SELECTION, MULTIPLE_INTERVAL_SELECTION_TOGGLE ],\n      apply : \"_applySelectionMode\"\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n    __hadChangeEventInBatchMode : null,\n    __anchorSelectionIndex : null,\n    __leadSelectionIndex : null,\n    __selectedRangeArr : null,\n\n\n    // selectionMode property modifier\n    _applySelectionMode : function(selectionMode) {\n      this.resetSelection();\n    },\n\n\n    /**\n     *\n     * Activates / Deactivates batch mode. In batch mode, no change events will be thrown but\n     * will be collected instead. When batch mode is turned off again and any events have\n     * been collected, one event is thrown to inform the listeners.\n     *\n     * This method supports nested calling, i. e. batch mode can be turned more than once.\n     * In this case, batch mode will not end until it has been turned off once for each\n     * turning on.\n     *\n     * @param batchMode {Boolean} true to activate batch mode, false to deactivate\n     * @return {Boolean} true if batch mode is active, false otherwise\n     * @throws {Error} if batch mode is turned off once more than it has been turned on\n     */\n    setBatchMode : function(batchMode)\n    {\n      if (batchMode) {\n        this.hasBatchModeRefCount += 1;\n      }\n      else\n      {\n        if (this.hasBatchModeRefCount == 0) {\n          throw new Error(\"Try to turn off batch mode althoug it was not turned on.\");\n        }\n\n        this.hasBatchModeRefCount -= 1;\n\n        if (this.__hadChangeEventInBatchMode)\n        {\n          this.__hadChangeEventInBatchMode = false;\n          this._fireChangeSelection();\n        }\n      }\n\n      return this.hasBatchMode();\n    },\n\n\n    /**\n     *\n     * Returns whether batch mode is active. See setter for a description of batch mode.\n     *\n     * @return {Boolean} true if batch mode is active, false otherwise\n     */\n    hasBatchMode : function() {\n      return this.hasBatchModeRefCount > 0;\n    },\n\n\n    /**\n     * Returns the first argument of the last call to {@link #setSelectionInterval()},\n     * {@link #addSelectionInterval()} or {@link #removeSelectionInterval()}.\n     *\n     * @return {Integer} the anchor selection index.\n     */\n    getAnchorSelectionIndex : function() {\n      return this.__anchorSelectionIndex;\n    },\n\n\n    /**\n     * Sets the anchor selection index. Only use this function, if you want manipulate\n     * the selection manually.\n     *\n     * @param index {Integer} the index to set.\n     */\n    _setAnchorSelectionIndex : function(index) {\n      this.__anchorSelectionIndex = index;\n    },\n\n\n    /**\n     * Returns the second argument of the last call to {@link #setSelectionInterval()},\n     * {@link #addSelectionInterval()} or {@link #removeSelectionInterval()}.\n     *\n     * @return {Integer} the lead selection index.\n     */\n    getLeadSelectionIndex : function() {\n      return this.__leadSelectionIndex;\n    },\n\n\n    /**\n     * Sets the lead selection index. Only use this function, if you want manipulate\n     * the selection manually.\n     *\n     * @param index {Integer} the index to set.\n     */\n    _setLeadSelectionIndex : function(index) {\n      this.__leadSelectionIndex = index;\n    },\n\n\n    /**\n     * Returns an array that holds all the selected ranges of the table. Each\n     * entry is a map holding information about the \"minIndex\" and \"maxIndex\" of the\n     * selection range.\n     *\n     * @return {Map[]} array with all the selected ranges.\n     */\n    _getSelectedRangeArr : function() {\n      return this.__selectedRangeArr;\n    },\n\n\n    /**\n     * Resets (clears) the selection.\n     */\n    resetSelection : function()\n    {\n      if (!this.isSelectionEmpty())\n      {\n        this._resetSelection();\n        this._fireChangeSelection();\n      }\n    },\n\n\n    /**\n     * Returns whether the selection is empty.\n     *\n     * @return {Boolean} whether the selection is empty.\n     */\n    isSelectionEmpty : function() {\n      return this.__selectedRangeArr.length == 0;\n    },\n\n\n    /**\n     * Returns the number of selected items.\n     *\n     * @return {Integer} the number of selected items.\n     */\n    getSelectedCount : function()\n    {\n      var selectedCount = 0;\n\n      for (var i=0; i<this.__selectedRangeArr.length; i++)\n      {\n        var range = this.__selectedRangeArr[i];\n        selectedCount += range.maxIndex - range.minIndex + 1;\n      }\n\n      return selectedCount;\n    },\n\n\n    /**\n     * Returns whether an index is selected.\n     *\n     * @param index {Integer} the index to check.\n     * @return {Boolean} whether the index is selected.\n     */\n    isSelectedIndex : function(index)\n    {\n      for (var i=0; i<this.__selectedRangeArr.length; i++)\n      {\n        var range = this.__selectedRangeArr[i];\n\n        if (index >= range.minIndex && index <= range.maxIndex) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n\n    /**\n     * Returns the selected ranges as an array. Each array element has a\n     * <code>minIndex</code> and a <code>maxIndex</code> property.\n     *\n     * @return {Map[]} the selected ranges.\n     */\n    getSelectedRanges : function()\n    {\n      // clone the selection array and the individual elements - this prevents the\n      // caller from messing with the internal model\n      var retVal = [];\n\n      for (var i=0; i<this.__selectedRangeArr.length; i++)\n      {\n        retVal.push(\n        {\n          minIndex : this.__selectedRangeArr[i].minIndex,\n          maxIndex : this.__selectedRangeArr[i].maxIndex\n        });\n      }\n\n      return retVal;\n    },\n\n\n    /**\n     * Calls an iterator function for each selected index.\n     *\n     * Usage Example:\n     * <pre class='javascript'>\n     * var selectedRowData = [];\n     * mySelectionModel.iterateSelection(function(index) {\n     *   selectedRowData.push(myTableModel.getRowData(index));\n     * });\n     * </pre>\n     *\n     * @param iterator {Function} the function to call for each selected index.\n     *          Gets the current index as parameter.\n     * @param object {var ? null} the object to use when calling the handler.\n     *          (this object will be available via \"this\" in the iterator)\n     */\n    iterateSelection : function(iterator, object)\n    {\n      for (var i=0; i<this.__selectedRangeArr.length; i++)\n      {\n        for (var j=this.__selectedRangeArr[i].minIndex; j<=this.__selectedRangeArr[i].maxIndex; j++) {\n          iterator.call(object, j);\n        }\n      }\n    },\n\n\n    /**\n     * Sets the selected interval. This will clear the former selection.\n     *\n     * @param fromIndex {Integer} the first index of the selection (including).\n     * @param toIndex {Integer} the last index of the selection (including).\n     */\n    setSelectionInterval : function(fromIndex, toIndex)\n    {\n      var me = this.self(arguments);\n\n      switch(this.getSelectionMode())\n      {\n        case me.NO_SELECTION:\n          return;\n\n        case me.SINGLE_SELECTION:\n          // Ensure there is actually a change of selection\n          if (this.isSelectedIndex(toIndex)) {\n            return;\n          }\n\n          fromIndex = toIndex;\n          break;\n\n        case me.MULTIPLE_INTERVAL_SELECTION_TOGGLE:\n          this.setBatchMode(true);\n          try\n          {\n            for (var i = fromIndex; i <= toIndex; i++)\n            {\n              if (!this.isSelectedIndex(i))\n              {\n                this._addSelectionInterval(i, i);\n              }\n              else\n              {\n                this.removeSelectionInterval(i, i);\n              }\n            }\n          }\n          catch (e) {\n            throw e;\n          }\n          finally {\n            this.setBatchMode(false);\n          }\n          this._fireChangeSelection();\n          return;\n      }\n\n      this._resetSelection();\n      this._addSelectionInterval(fromIndex, toIndex);\n\n      this._fireChangeSelection();\n    },\n\n\n    /**\n     * Adds a selection interval to the current selection.\n     *\n     * @param fromIndex {Integer} the first index of the selection (including).\n     * @param toIndex {Integer} the last index of the selection (including).\n     */\n    addSelectionInterval : function(fromIndex, toIndex)\n    {\n      var SelectionModel = qx.ui.table.selection.Model;\n\n      switch(this.getSelectionMode())\n      {\n        case SelectionModel.NO_SELECTION:\n          return;\n\n        case SelectionModel.MULTIPLE_INTERVAL_SELECTION:\n        case SelectionModel.MULTIPLE_INTERVAL_SELECTION_TOGGLE:\n          this._addSelectionInterval(fromIndex, toIndex);\n          this._fireChangeSelection();\n          break;\n\n        default:\n          this.setSelectionInterval(fromIndex, toIndex);\n          break;\n      }\n    },\n\n\n    /**\n     * Removes an interval from the current selection.\n     *\n     * @param fromIndex {Integer} the first index of the interval (including).\n     * @param toIndex {Integer} the last index of the interval (including).\n     * @param rowsRemoved {Boolean?} rows were removed that caused this selection to change.\n     *   If rows were removed, move the selections over so the same rows are selected as before.\n     */\n    removeSelectionInterval : function(fromIndex, toIndex, rowsRemoved)\n    {\n      this.__anchorSelectionIndex = fromIndex;\n      this.__leadSelectionIndex = toIndex;\n\n      var minIndex = Math.min(fromIndex, toIndex);\n      var maxIndex = Math.max(fromIndex, toIndex);\n      var removeCount = maxIndex + 1 - minIndex;\n\n      // Crop the affected ranges\n      var newRanges = [];\n      var extraRange = null;\n      for (var i=0; i<this.__selectedRangeArr.length; i++)\n      {\n        var range = this.__selectedRangeArr[i];\n\n        if (range.minIndex > maxIndex)\n        {\n          if (rowsRemoved) {\n            // Move whole selection up.\n            range.minIndex -= removeCount;\n            range.maxIndex -= removeCount;\n          }\n        }\n        else if (range.maxIndex >= minIndex)\n        {\n          // This range is affected\n          var minIsIn = (range.minIndex >= minIndex);\n          var maxIsIn = (range.maxIndex >= minIndex) && (range.maxIndex <= maxIndex);\n\n          if (minIsIn && maxIsIn)\n          {\n            // This range is removed completely\n            range = null;\n          }\n          else if (minIsIn)\n          {\n            if (rowsRemoved) {\n              range.minIndex = minIndex;\n              range.maxIndex -= removeCount;\n            } else {\n              // The range is cropped from the left\n              range.minIndex = maxIndex + 1;\n            }\n          }\n          else if (maxIsIn)\n          {\n            // The range is cropped from the right\n            range.maxIndex = minIndex - 1;\n          }\n          else\n          {\n            if (rowsRemoved) {\n              range.maxIndex -= removeCount;\n            } else {\n              // The range is split\n              extraRange = {\n                minIndex: maxIndex + 1,\n                maxIndex: range.maxIndex\n              };\n\n              range.maxIndex = minIndex - 1;\n            }\n          }\n        }\n\n        if (range) {\n          newRanges.push(range);\n          range = null;\n        }\n        if (extraRange) {\n          newRanges.push(extraRange);\n          extraRange = null;\n        }\n      }\n\n      this.__selectedRangeArr = newRanges;\n\n      this._fireChangeSelection();\n    },\n\n\n    /**\n     * Resets (clears) the selection, but doesn't inform the listeners.\n     */\n    _resetSelection : function()\n    {\n      this.__selectedRangeArr = [];\n      this.__anchorSelectionIndex = -1;\n      this.__leadSelectionIndex = -1;\n    },\n\n\n    /**\n     * Adds a selection interval to the current selection, but doesn't inform\n     * the listeners.\n     *\n     * @param fromIndex {Integer} the first index of the selection (including).\n     * @param toIndex {Integer} the last index of the selection (including).\n     */\n    _addSelectionInterval : function(fromIndex, toIndex)\n    {\n      this.__anchorSelectionIndex = fromIndex;\n      this.__leadSelectionIndex = toIndex;\n\n      var minIndex = Math.min(fromIndex, toIndex);\n      var maxIndex = Math.max(fromIndex, toIndex);\n\n      // Find the index where the new range should be inserted\n      var newRangeIndex = 0;\n\n      for (;newRangeIndex<this.__selectedRangeArr.length; newRangeIndex++)\n      {\n        var range = this.__selectedRangeArr[newRangeIndex];\n\n        if (range.minIndex > minIndex) {\n          break;\n        }\n      }\n\n      // Add the new range\n      this.__selectedRangeArr.splice(newRangeIndex, 0,\n      {\n        minIndex : minIndex,\n        maxIndex : maxIndex\n      });\n\n      // Merge overlapping ranges\n      var lastRange = this.__selectedRangeArr[0];\n\n      for (var i=1; i<this.__selectedRangeArr.length; i++)\n      {\n        var range = this.__selectedRangeArr[i];\n\n        if (lastRange.maxIndex + 1 >= range.minIndex)\n        {\n          // The ranges are overlapping -> merge them\n          lastRange.maxIndex = Math.max(lastRange.maxIndex, range.maxIndex);\n\n          // Remove the current range\n          this.__selectedRangeArr.splice(i, 1);\n\n          // Check this index another time\n          i--;\n        }\n        else\n        {\n          lastRange = range;\n        }\n      }\n    },\n\n    // this._dumpRanges();\n    /**\n     * Logs the current ranges for debug purposes.\n     *\n     */\n    _dumpRanges : function()\n    {\n      var text = \"Ranges:\";\n\n      for (var i=0; i<this.__selectedRangeArr.length; i++)\n      {\n        var range = this.__selectedRangeArr[i];\n        text += \" [\" + range.minIndex + \"..\" + range.maxIndex + \"]\";\n      }\n\n      this.debug(text);\n    },\n\n\n    /**\n     * Fires the \"changeSelection\" event to all registered listeners. If the selection model\n     * currently is in batch mode, only one event will be thrown when batch mode is ended.\n     *\n     */\n    _fireChangeSelection : function()\n    {\n      if (this.hasBatchMode())\n      {\n        // In batch mode, remember event but do not throw (yet)\n        this.__hadChangeEventInBatchMode = true;\n      }\n      else\n      {\n        // If not in batch mode, throw event\n        this.fireEvent(\"changeSelection\");\n      }\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     DESTRUCTOR\n  *****************************************************************************\n  */\n\n  destruct : function() {\n    this.__selectedRangeArr = null;\n  }\n});\n"
  ]
}