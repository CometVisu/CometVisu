{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "constructor",
    "call",
    "__selectedRangeArr",
    "__anchorSelectionIndex",
    "__leadSelectionIndex",
    "hasBatchModeRefCount",
    "__hadChangeEventInBatchMode",
    "events",
    "changeSelection",
    "statics",
    "NO_SELECTION",
    "SINGLE_SELECTION",
    "SINGLE_INTERVAL_SELECTION",
    "MULTIPLE_INTERVAL_SELECTION",
    "MULTIPLE_INTERVAL_SELECTION_TOGGLE",
    "properties",
    "selectionMode",
    "init",
    "check",
    "apply",
    "members",
    "_applySelectionMode",
    "resetSelection",
    "setBatchMode",
    "batchMode",
    "Error",
    "_fireChangeSelection",
    "hasBatchMode",
    "getAnchorSelectionIndex",
    "_setAnchorSelectionIndex",
    "index",
    "getLeadSelectionIndex",
    "_setLeadSelectionIndex",
    "_getSelectedRangeArr",
    "isSelectionEmpty",
    "_resetSelection",
    "length",
    "getSelectedCount",
    "selectedCount",
    "i",
    "range",
    "maxIndex",
    "minIndex",
    "isSelectedIndex",
    "getSelectedRanges",
    "retVal",
    "push",
    "iterateSelection",
    "iterator",
    "object",
    "j",
    "setSelectionInterval",
    "fromIndex",
    "toIndex",
    "me",
    "ui",
    "table",
    "selection",
    "Model",
    "getSelectionMode",
    "_addSelectionInterval",
    "removeSelectionInterval",
    "e",
    "addSelectionInterval",
    "SelectionModel",
    "rowsRemoved",
    "Math",
    "min",
    "max",
    "removeCount",
    "newRanges",
    "extraRange",
    "minIsIn",
    "maxIsIn",
    "newRangeIndex",
    "splice",
    "lastRange",
    "_dumpRanges",
    "text",
    "debug",
    "fireEvent",
    "destruct"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/table/selection/Model.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2006 STZ-IDA, Germany, http://www.stz-ida.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Til Schneider (til132)\r\n     * David Perez Carmona (david-perez)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * A selection model.\r\n */\r\nqx.Class.define(\"qx.ui.table.selection.Model\", {\r\n  extend: qx.core.Object,\r\n\r\n  /*\r\n  *****************************************************************************\r\n     CONSTRUCTOR\r\n  *****************************************************************************\r\n  */\r\n\r\n  construct() {\r\n    super();\r\n\r\n    this.__selectedRangeArr = [];\r\n    this.__anchorSelectionIndex = -1;\r\n    this.__leadSelectionIndex = -1;\r\n    this.hasBatchModeRefCount = 0;\r\n    this.__hadChangeEventInBatchMode = false;\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     EVENTS\r\n  *****************************************************************************\r\n  */\r\n\r\n  events: {\r\n    /** Fired when the selection has changed. */\r\n    changeSelection: \"qx.event.type.Event\"\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     STATICS\r\n  *****************************************************************************\r\n  */\r\n\r\n  statics: {\r\n    /** @type {int} The selection mode \"none\". Nothing can ever be selected. */\r\n    NO_SELECTION: 1,\r\n\r\n    /** @type {int} The selection mode \"single\". This mode only allows one selected item. */\r\n    SINGLE_SELECTION: 2,\r\n\r\n    /**\r\n     * @type {int} The selection mode \"single interval\". This mode only allows one\r\n     * continuous interval of selected items.\r\n     */\r\n    SINGLE_INTERVAL_SELECTION: 3,\r\n\r\n    /**\r\n     * @type {int} The selection mode \"multiple interval\". This mode only allows any\r\n     * selection.\r\n     */\r\n    MULTIPLE_INTERVAL_SELECTION: 4,\r\n\r\n    /**\r\n     * @type {int} The selection mode \"multiple interval\". This mode only allows any\r\n     * selection. The difference with the previous one, is that multiple\r\n     * selection is eased. A tap on an item, toggles its selection state.\r\n     * On the other hand, MULTIPLE_INTERVAL_SELECTION does this behavior only\r\n     * when Ctrl-tapping an item.\r\n     */\r\n    MULTIPLE_INTERVAL_SELECTION_TOGGLE: 5\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     PROPERTIES\r\n  *****************************************************************************\r\n  */\r\n\r\n  properties: {\r\n    /**\r\n     * Set the selection mode. Valid values are {@link #NO_SELECTION},\r\n     * {@link #SINGLE_SELECTION}, {@link #SINGLE_INTERVAL_SELECTION},\r\n     * {@link #MULTIPLE_INTERVAL_SELECTION} and\r\n     * {@link #MULTIPLE_INTERVAL_SELECTION_TOGGLE}.\r\n     */\r\n    selectionMode: {\r\n      init: 2, //SINGLE_SELECTION,\r\n      check: [1, 2, 3, 4, 5],\r\n      //[ NO_SELECTION, SINGLE_SELECTION, SINGLE_INTERVAL_SELECTION, MULTIPLE_INTERVAL_SELECTION, MULTIPLE_INTERVAL_SELECTION_TOGGLE ],\r\n      apply: \"_applySelectionMode\"\r\n    }\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     MEMBERS\r\n  *****************************************************************************\r\n  */\r\n\r\n  members: {\r\n    __hadChangeEventInBatchMode: null,\r\n    __anchorSelectionIndex: null,\r\n    __leadSelectionIndex: null,\r\n    __selectedRangeArr: null,\r\n\r\n    // selectionMode property modifier\r\n    _applySelectionMode(selectionMode) {\r\n      this.resetSelection();\r\n    },\r\n\r\n    /**\r\n     *\r\n     * Activates / Deactivates batch mode. In batch mode, no change events will be thrown but\r\n     * will be collected instead. When batch mode is turned off again and any events have\r\n     * been collected, one event is thrown to inform the listeners.\r\n     *\r\n     * This method supports nested calling, i. e. batch mode can be turned more than once.\r\n     * In this case, batch mode will not end until it has been turned off once for each\r\n     * turning on.\r\n     *\r\n     * @param batchMode {Boolean} true to activate batch mode, false to deactivate\r\n     * @return {Boolean} true if batch mode is active, false otherwise\r\n     * @throws {Error} if batch mode is turned off once more than it has been turned on\r\n     */\r\n    setBatchMode(batchMode) {\r\n      if (batchMode) {\r\n        this.hasBatchModeRefCount += 1;\r\n      } else {\r\n        if (this.hasBatchModeRefCount == 0) {\r\n          throw new Error(\r\n            \"Try to turn off batch mode althoug it was not turned on.\"\r\n          );\r\n        }\r\n\r\n        this.hasBatchModeRefCount -= 1;\r\n\r\n        if (this.__hadChangeEventInBatchMode) {\r\n          this.__hadChangeEventInBatchMode = false;\r\n          this._fireChangeSelection();\r\n        }\r\n      }\r\n\r\n      return this.hasBatchMode();\r\n    },\r\n\r\n    /**\r\n     *\r\n     * Returns whether batch mode is active. See setter for a description of batch mode.\r\n     *\r\n     * @return {Boolean} true if batch mode is active, false otherwise\r\n     */\r\n    hasBatchMode() {\r\n      return this.hasBatchModeRefCount > 0;\r\n    },\r\n\r\n    /**\r\n     * Returns the first argument of the last call to {@link #setSelectionInterval()},\r\n     * {@link #addSelectionInterval()} or {@link #removeSelectionInterval()}.\r\n     *\r\n     * @return {Integer} the anchor selection index.\r\n     */\r\n    getAnchorSelectionIndex() {\r\n      return this.__anchorSelectionIndex;\r\n    },\r\n\r\n    /**\r\n     * Sets the anchor selection index. Only use this function, if you want manipulate\r\n     * the selection manually.\r\n     *\r\n     * @param index {Integer} the index to set.\r\n     */\r\n    _setAnchorSelectionIndex(index) {\r\n      this.__anchorSelectionIndex = index;\r\n    },\r\n\r\n    /**\r\n     * Returns the second argument of the last call to {@link #setSelectionInterval()},\r\n     * {@link #addSelectionInterval()} or {@link #removeSelectionInterval()}.\r\n     *\r\n     * @return {Integer} the lead selection index.\r\n     */\r\n    getLeadSelectionIndex() {\r\n      return this.__leadSelectionIndex;\r\n    },\r\n\r\n    /**\r\n     * Sets the lead selection index. Only use this function, if you want manipulate\r\n     * the selection manually.\r\n     *\r\n     * @param index {Integer} the index to set.\r\n     */\r\n    _setLeadSelectionIndex(index) {\r\n      this.__leadSelectionIndex = index;\r\n    },\r\n\r\n    /**\r\n     * Returns an array that holds all the selected ranges of the table. Each\r\n     * entry is a map holding information about the \"minIndex\" and \"maxIndex\" of the\r\n     * selection range.\r\n     *\r\n     * @return {Map[]} array with all the selected ranges.\r\n     */\r\n    _getSelectedRangeArr() {\r\n      return this.__selectedRangeArr;\r\n    },\r\n\r\n    /**\r\n     * Resets (clears) the selection.\r\n     */\r\n    resetSelection() {\r\n      if (!this.isSelectionEmpty()) {\r\n        this._resetSelection();\r\n        this._fireChangeSelection();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns whether the selection is empty.\r\n     *\r\n     * @return {Boolean} whether the selection is empty.\r\n     */\r\n    isSelectionEmpty() {\r\n      return this.__selectedRangeArr.length == 0;\r\n    },\r\n\r\n    /**\r\n     * Returns the number of selected items.\r\n     *\r\n     * @return {Integer} the number of selected items.\r\n     */\r\n    getSelectedCount() {\r\n      var selectedCount = 0;\r\n\r\n      for (var i = 0; i < this.__selectedRangeArr.length; i++) {\r\n        var range = this.__selectedRangeArr[i];\r\n        selectedCount += range.maxIndex - range.minIndex + 1;\r\n      }\r\n\r\n      return selectedCount;\r\n    },\r\n\r\n    /**\r\n     * Returns whether an index is selected.\r\n     *\r\n     * @param index {Integer} the index to check.\r\n     * @return {Boolean} whether the index is selected.\r\n     */\r\n    isSelectedIndex(index) {\r\n      for (var i = 0; i < this.__selectedRangeArr.length; i++) {\r\n        var range = this.__selectedRangeArr[i];\r\n\r\n        if (index >= range.minIndex && index <= range.maxIndex) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Returns the selected ranges as an array. Each array element has a\r\n     * <code>minIndex</code> and a <code>maxIndex</code> property.\r\n     *\r\n     * @return {Map[]} the selected ranges.\r\n     */\r\n    getSelectedRanges() {\r\n      // clone the selection array and the individual elements - this prevents the\r\n      // caller from messing with the internal model\r\n      var retVal = [];\r\n\r\n      for (var i = 0; i < this.__selectedRangeArr.length; i++) {\r\n        retVal.push({\r\n          minIndex: this.__selectedRangeArr[i].minIndex,\r\n          maxIndex: this.__selectedRangeArr[i].maxIndex\r\n        });\r\n      }\r\n\r\n      return retVal;\r\n    },\r\n\r\n    /**\r\n     * Calls an iterator function for each selected index.\r\n     *\r\n     * Usage Example:\r\n     * <pre class='javascript'>\r\n     * var selectedRowData = [];\r\n     * mySelectionModel.iterateSelection(function(index) {\r\n     *   selectedRowData.push(myTableModel.getRowData(index));\r\n     * });\r\n     * </pre>\r\n     *\r\n     * @param iterator {Function} the function to call for each selected index.\r\n     *          Gets the current index as parameter.\r\n     * @param object {var ? null} the object to use when calling the handler.\r\n     *          (this object will be available via \"this\" in the iterator)\r\n     */\r\n    iterateSelection(iterator, object) {\r\n      for (var i = 0; i < this.__selectedRangeArr.length; i++) {\r\n        for (\r\n          var j = this.__selectedRangeArr[i].minIndex;\r\n          j <= this.__selectedRangeArr[i].maxIndex;\r\n          j++\r\n        ) {\r\n          iterator.call(object, j);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets the selected interval. This will clear the former selection.\r\n     *\r\n     * @param fromIndex {Integer} the first index of the selection (including).\r\n     * @param toIndex {Integer} the last index of the selection (including).\r\n     */\r\n    setSelectionInterval(fromIndex, toIndex) {\r\n      var me = this.self(arguments);\r\n\r\n      switch (this.getSelectionMode()) {\r\n        case me.NO_SELECTION:\r\n          return;\r\n\r\n        case me.SINGLE_SELECTION:\r\n          // Ensure there is actually a change of selection\r\n          if (this.isSelectedIndex(toIndex)) {\r\n            return;\r\n          }\r\n\r\n          fromIndex = toIndex;\r\n          break;\r\n\r\n        case me.MULTIPLE_INTERVAL_SELECTION_TOGGLE:\r\n          this.setBatchMode(true);\r\n          try {\r\n            for (var i = fromIndex; i <= toIndex; i++) {\r\n              if (!this.isSelectedIndex(i)) {\r\n                this._addSelectionInterval(i, i);\r\n              } else {\r\n                this.removeSelectionInterval(i, i);\r\n              }\r\n            }\r\n          } catch (e) {\r\n            throw e;\r\n          } finally {\r\n            this.setBatchMode(false);\r\n          }\r\n          this._fireChangeSelection();\r\n          return;\r\n      }\r\n\r\n      this._resetSelection();\r\n      this._addSelectionInterval(fromIndex, toIndex);\r\n\r\n      this._fireChangeSelection();\r\n    },\r\n\r\n    /**\r\n     * Adds a selection interval to the current selection.\r\n     *\r\n     * @param fromIndex {Integer} the first index of the selection (including).\r\n     * @param toIndex {Integer} the last index of the selection (including).\r\n     */\r\n    addSelectionInterval(fromIndex, toIndex) {\r\n      var SelectionModel = qx.ui.table.selection.Model;\r\n\r\n      switch (this.getSelectionMode()) {\r\n        case SelectionModel.NO_SELECTION:\r\n          return;\r\n\r\n        case SelectionModel.MULTIPLE_INTERVAL_SELECTION:\r\n        case SelectionModel.MULTIPLE_INTERVAL_SELECTION_TOGGLE:\r\n          this._addSelectionInterval(fromIndex, toIndex);\r\n          this._fireChangeSelection();\r\n          break;\r\n\r\n        default:\r\n          this.setSelectionInterval(fromIndex, toIndex);\r\n          break;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Removes an interval from the current selection.\r\n     *\r\n     * @param fromIndex {Integer} the first index of the interval (including).\r\n     * @param toIndex {Integer} the last index of the interval (including).\r\n     * @param rowsRemoved {Boolean?} rows were removed that caused this selection to change.\r\n     *   If rows were removed, move the selections over so the same rows are selected as before.\r\n     */\r\n    removeSelectionInterval(fromIndex, toIndex, rowsRemoved) {\r\n      this.__anchorSelectionIndex = fromIndex;\r\n      this.__leadSelectionIndex = toIndex;\r\n\r\n      var minIndex = Math.min(fromIndex, toIndex);\r\n      var maxIndex = Math.max(fromIndex, toIndex);\r\n      var removeCount = maxIndex + 1 - minIndex;\r\n\r\n      // Crop the affected ranges\r\n      var newRanges = [];\r\n      var extraRange = null;\r\n      for (var i = 0; i < this.__selectedRangeArr.length; i++) {\r\n        var range = this.__selectedRangeArr[i];\r\n\r\n        if (range.minIndex > maxIndex) {\r\n          if (rowsRemoved) {\r\n            // Move whole selection up.\r\n            range.minIndex -= removeCount;\r\n            range.maxIndex -= removeCount;\r\n          }\r\n        } else if (range.maxIndex >= minIndex) {\r\n          // This range is affected\r\n          var minIsIn = range.minIndex >= minIndex;\r\n          var maxIsIn =\r\n            range.maxIndex >= minIndex && range.maxIndex <= maxIndex;\r\n\r\n          if (minIsIn && maxIsIn) {\r\n            // This range is removed completely\r\n            range = null;\r\n          } else if (minIsIn) {\r\n            if (rowsRemoved) {\r\n              range.minIndex = minIndex;\r\n              range.maxIndex -= removeCount;\r\n            } else {\r\n              // The range is cropped from the left\r\n              range.minIndex = maxIndex + 1;\r\n            }\r\n          } else if (maxIsIn) {\r\n            // The range is cropped from the right\r\n            range.maxIndex = minIndex - 1;\r\n          } else {\r\n            if (rowsRemoved) {\r\n              range.maxIndex -= removeCount;\r\n            } else {\r\n              // The range is split\r\n              extraRange = {\r\n                minIndex: maxIndex + 1,\r\n                maxIndex: range.maxIndex\r\n              };\r\n\r\n              range.maxIndex = minIndex - 1;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (range) {\r\n          newRanges.push(range);\r\n          range = null;\r\n        }\r\n        if (extraRange) {\r\n          newRanges.push(extraRange);\r\n          extraRange = null;\r\n        }\r\n      }\r\n\r\n      this.__selectedRangeArr = newRanges;\r\n\r\n      this._fireChangeSelection();\r\n    },\r\n\r\n    /**\r\n     * Resets (clears) the selection, but doesn't inform the listeners.\r\n     */\r\n    _resetSelection() {\r\n      this.__selectedRangeArr = [];\r\n      this.__anchorSelectionIndex = -1;\r\n      this.__leadSelectionIndex = -1;\r\n    },\r\n\r\n    /**\r\n     * Adds a selection interval to the current selection, but doesn't inform\r\n     * the listeners.\r\n     *\r\n     * @param fromIndex {Integer} the first index of the selection (including).\r\n     * @param toIndex {Integer} the last index of the selection (including).\r\n     */\r\n    _addSelectionInterval(fromIndex, toIndex) {\r\n      this.__anchorSelectionIndex = fromIndex;\r\n      this.__leadSelectionIndex = toIndex;\r\n\r\n      var minIndex = Math.min(fromIndex, toIndex);\r\n      var maxIndex = Math.max(fromIndex, toIndex);\r\n\r\n      // Find the index where the new range should be inserted\r\n      var newRangeIndex = 0;\r\n\r\n      for (; newRangeIndex < this.__selectedRangeArr.length; newRangeIndex++) {\r\n        var range = this.__selectedRangeArr[newRangeIndex];\r\n\r\n        if (range.minIndex > minIndex) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Add the new range\r\n      this.__selectedRangeArr.splice(newRangeIndex, 0, {\r\n        minIndex: minIndex,\r\n        maxIndex: maxIndex\r\n      });\r\n\r\n      // Merge overlapping ranges\r\n      var lastRange = this.__selectedRangeArr[0];\r\n\r\n      for (var i = 1; i < this.__selectedRangeArr.length; i++) {\r\n        var range = this.__selectedRangeArr[i];\r\n\r\n        if (lastRange.maxIndex + 1 >= range.minIndex) {\r\n          // The ranges are overlapping -> merge them\r\n          lastRange.maxIndex = Math.max(lastRange.maxIndex, range.maxIndex);\r\n\r\n          // Remove the current range\r\n          this.__selectedRangeArr.splice(i, 1);\r\n\r\n          // Check this index another time\r\n          i--;\r\n        } else {\r\n          lastRange = range;\r\n        }\r\n      }\r\n    },\r\n\r\n    // this._dumpRanges();\r\n    /**\r\n     * Logs the current ranges for debug purposes.\r\n     *\r\n     */\r\n    _dumpRanges() {\r\n      var text = \"Ranges:\";\r\n\r\n      for (var i = 0; i < this.__selectedRangeArr.length; i++) {\r\n        var range = this.__selectedRangeArr[i];\r\n        text += \" [\" + range.minIndex + \"..\" + range.maxIndex + \"]\";\r\n      }\r\n\r\n      this.debug(text);\r\n    },\r\n\r\n    /**\r\n     * Fires the \"changeSelection\" event to all registered listeners. If the selection model\r\n     * currently is in batch mode, only one event will be thrown when batch mode is ended.\r\n     *\r\n     */\r\n    _fireChangeSelection() {\r\n      if (this.hasBatchMode()) {\r\n        // In batch mode, remember event but do not throw (yet)\r\n        this.__hadChangeEventInBatchMode = true;\r\n      } else {\r\n        // If not in batch mode, throw event\r\n        this.fireEvent(\"changeSelection\");\r\n      }\r\n    }\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     DESTRUCTOR\r\n  *****************************************************************************\r\n  */\r\n\r\n  destruct() {\r\n    this.__selectedRangeArr = null;\r\n  }\r\n});\r\n"
  ],
  "mappings": "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"
}