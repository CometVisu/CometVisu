{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "statics",
    "PERCENT_VALUE",
    "computeFlexOffsets",
    "flexibles",
    "avail",
    "used",
    "child",
    "key",
    "flexSum",
    "flexStep",
    "grow",
    "remaining",
    "Math",
    "abs",
    "roundingOffset",
    "currentOffset",
    "result",
    "potential",
    "max",
    "value",
    "min",
    "flex",
    "offset",
    "Infinity",
    "ceil",
    "computeHorizontalAlignOffset",
    "align",
    "width",
    "availWidth",
    "marginLeft",
    "marginRight",
    "round",
    "computeVerticalAlignOffset",
    "height",
    "availHeight",
    "marginTop",
    "marginBottom",
    "collapseMargins",
    "varargs",
    "i",
    "l",
    "arguments",
    "length",
    "computeHorizontalGaps",
    "children",
    "spacing",
    "collapse",
    "gaps",
    "getMarginLeft",
    "getMarginRight",
    "computeVerticalGaps",
    "getMarginTop",
    "getMarginBottom",
    "computeHorizontalSeparatorGaps",
    "separator",
    "instance",
    "theme",
    "manager",
    "Decoration",
    "getInstance",
    "resolve",
    "insets",
    "getInsets",
    "left",
    "right",
    "computeVerticalSeparatorGaps",
    "top",
    "bottom",
    "arrangeIdeals",
    "beginMin",
    "beginIdeal",
    "beginMax",
    "endMin",
    "endIdeal",
    "endMax",
    "begin",
    "end",
    "ui",
    "layout",
    "Util"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/layout/Util.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Sebastian Werner (wpbasti)\r\n     * Fabian Jakobs (fjakobs)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * Common set of utility methods used by the standard qooxdoo layouts.\r\n *\r\n * @internal\r\n */\r\nqx.Class.define(\"qx.ui.layout.Util\", {\r\n  statics: {\r\n    /** @type {RegExp} Regular expression to match percent values */\r\n    PERCENT_VALUE: /[0-9]+(?:\\.[0-9]+)?%/,\r\n\r\n    /**\r\n     * Computes the flex offsets needed to reduce the space\r\n     * difference as much as possible by respecting the\r\n     * potential of the given elements (being in the range of\r\n     * their min/max values)\r\n     *\r\n     * @param flexibles {Map} Each entry must have these keys:\r\n     *   <code>id</code>, <code>potential</code> and <code>flex</code>.\r\n     *   The ID is used in the result map as the key for the user to work\r\n     *   with later (e.g. upgrade sizes etc. to respect the given offset)\r\n     *   The potential is an integer value which is the difference of the\r\n     *   currently interesting direction (e.g. shrinking=width-minWidth, growing=\r\n     *   maxWidth-width). The flex key holds the flex value of the item.\r\n     * @param avail {Integer} Full available space to allocate (ignoring used one)\r\n     * @param used {Integer} Size of already allocated space\r\n     * @return {Map} A map which contains the calculated offsets under the key\r\n     *   which is identical to the ID given in the incoming map.\r\n     */\r\n    computeFlexOffsets(flexibles, avail, used) {\r\n      var child, key, flexSum, flexStep;\r\n      var grow = avail > used;\r\n      var remaining = Math.abs(avail - used);\r\n      var roundingOffset, currentOffset;\r\n\r\n      // Preprocess data\r\n      var result = {};\r\n      for (key in flexibles) {\r\n        child = flexibles[key];\r\n        result[key] = {\r\n          potential: grow ? child.max - child.value : child.value - child.min,\r\n          flex: grow ? child.flex : 1 / child.flex,\r\n          offset: 0\r\n        };\r\n      }\r\n\r\n      // Continue as long as we need to do anything\r\n      while (remaining != 0) {\r\n        // Find minimum potential for next correction\r\n        flexStep = Infinity;\r\n        flexSum = 0;\r\n        for (key in result) {\r\n          child = result[key];\r\n\r\n          if (child.potential > 0) {\r\n            flexSum += child.flex;\r\n            flexStep = Math.min(flexStep, child.potential / child.flex);\r\n          }\r\n        }\r\n\r\n        // No potential found, quit here\r\n        if (flexSum == 0) {\r\n          break;\r\n        }\r\n\r\n        // Respect maximum potential given through remaining space\r\n        // The parent should always win in such conflicts.\r\n        flexStep = Math.min(remaining, flexStep * flexSum) / flexSum;\r\n\r\n        // Start with correction\r\n        roundingOffset = 0;\r\n        for (key in result) {\r\n          child = result[key];\r\n\r\n          if (child.potential > 0) {\r\n            // Compute offset for this step\r\n            currentOffset = Math.min(\r\n              remaining,\r\n              child.potential,\r\n              Math.ceil(flexStep * child.flex)\r\n            );\r\n\r\n            // Fix rounding issues\r\n            roundingOffset += currentOffset - flexStep * child.flex;\r\n            if (roundingOffset >= 1) {\r\n              roundingOffset -= 1;\r\n              currentOffset -= 1;\r\n            }\r\n\r\n            // Update child status\r\n            child.potential -= currentOffset;\r\n\r\n            if (grow) {\r\n              child.offset += currentOffset;\r\n            } else {\r\n              child.offset -= currentOffset;\r\n            }\r\n\r\n            // Update parent status\r\n            remaining -= currentOffset;\r\n          }\r\n        }\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Computes the offset which needs to be added to the top position\r\n     * to result in the stated vertical alignment. Also respects\r\n     * existing margins (without collapsing).\r\n     *\r\n     * @param align {String} One of <code>top</code>, <code>center</code> or <code>bottom</code>.\r\n     * @param width {Integer} The visible width of the widget\r\n     * @param availWidth {Integer} The available inner width of the parent\r\n     * @param marginLeft {Integer?0} Optional left margin of the widget\r\n     * @param marginRight {Integer?0} Optional right margin of the widget\r\n     * @return {Integer} Computed top coordinate\r\n     */\r\n    computeHorizontalAlignOffset(\r\n      align,\r\n      width,\r\n      availWidth,\r\n      marginLeft,\r\n      marginRight\r\n    ) {\r\n      if (marginLeft == null) {\r\n        marginLeft = 0;\r\n      }\r\n\r\n      if (marginRight == null) {\r\n        marginRight = 0;\r\n      }\r\n\r\n      var value = 0;\r\n      switch (align) {\r\n        case \"left\":\r\n          value = marginLeft;\r\n          break;\r\n\r\n        case \"right\":\r\n          // Align right changes priority to right edge:\r\n          // To align to the right is more important here than to left.\r\n          value = availWidth - width - marginRight;\r\n          break;\r\n\r\n        case \"center\":\r\n          // Ideal center position\r\n          value = Math.round((availWidth - width) / 2);\r\n\r\n          // Try to make this possible (with left-right priority)\r\n          if (value < marginLeft) {\r\n            value = marginLeft;\r\n          } else if (value < marginRight) {\r\n            value = Math.max(marginLeft, availWidth - width - marginRight);\r\n          }\r\n\r\n          break;\r\n      }\r\n\r\n      return value;\r\n    },\r\n\r\n    /**\r\n     * Computes the offset which needs to be added to the top position\r\n     * to result in the stated vertical alignment. Also respects\r\n     * existing margins (without collapsing).\r\n     *\r\n     * @param align {String} One of <code>top</code>, <code>middle</code> or <code>bottom</code>.\r\n     * @param height {Integer} The visible height of the widget\r\n     * @param availHeight {Integer} The available inner height of the parent\r\n     * @param marginTop {Integer?0} Optional top margin of the widget\r\n     * @param marginBottom {Integer?0} Optional bottom margin of the widget\r\n     * @return {Integer} Computed top coordinate\r\n     */\r\n    computeVerticalAlignOffset(\r\n      align,\r\n      height,\r\n      availHeight,\r\n      marginTop,\r\n      marginBottom\r\n    ) {\r\n      if (marginTop == null) {\r\n        marginTop = 0;\r\n      }\r\n\r\n      if (marginBottom == null) {\r\n        marginBottom = 0;\r\n      }\r\n\r\n      var value = 0;\r\n      switch (align) {\r\n        case \"top\":\r\n          value = marginTop;\r\n          break;\r\n\r\n        case \"bottom\":\r\n          // Align bottom changes priority to bottom edge:\r\n          // To align to the bottom is more important here than to top.\r\n          value = availHeight - height - marginBottom;\r\n          break;\r\n\r\n        case \"middle\":\r\n          // Ideal middle position\r\n          value = Math.round((availHeight - height) / 2);\r\n\r\n          // Try to make this possible (with top-down priority)\r\n          if (value < marginTop) {\r\n            value = marginTop;\r\n          } else if (value < marginBottom) {\r\n            value = Math.max(marginTop, availHeight - height - marginBottom);\r\n          }\r\n\r\n          break;\r\n      }\r\n\r\n      return value;\r\n    },\r\n\r\n    /**\r\n     * Collapses two margins.\r\n     *\r\n     * Supports positive and negative margins.\r\n     * Collapsing find the largest positive and the largest\r\n     * negative value. Afterwards the result is computed through the\r\n     * subtraction of the negative from the positive value.\r\n     *\r\n     * @param varargs {arguments} Any number of configured margins\r\n     * @return {Integer} The collapsed margin\r\n     */\r\n    collapseMargins(varargs) {\r\n      var max = 0,\r\n        min = 0;\r\n      for (var i = 0, l = arguments.length; i < l; i++) {\r\n        var value = arguments[i];\r\n\r\n        if (value < 0) {\r\n          min = Math.min(min, value);\r\n        } else if (value > 0) {\r\n          max = Math.max(max, value);\r\n        }\r\n      }\r\n\r\n      return max + min;\r\n    },\r\n\r\n    /**\r\n     * Computes the sum of all horizontal gaps. Normally the\r\n     * result is used to compute the available width in a widget.\r\n     *\r\n     * The method optionally respects margin collapsing as well. In\r\n     * this mode the spacing is collapsed together with the margins.\r\n     *\r\n     * @param children {Array} List of children\r\n     * @param spacing {Integer?0} Spacing between every child\r\n     * @param collapse {Boolean?false} Optional margin collapsing mode\r\n     * @return {Integer} Sum of all gaps in the final layout.\r\n     */\r\n    computeHorizontalGaps(children, spacing, collapse) {\r\n      if (spacing == null) {\r\n        spacing = 0;\r\n      }\r\n\r\n      var gaps = 0;\r\n\r\n      if (collapse) {\r\n        // Add first child\r\n        gaps += children[0].getMarginLeft();\r\n\r\n        for (var i = 1, l = children.length; i < l; i += 1) {\r\n          gaps += this.collapseMargins(\r\n            spacing,\r\n            children[i - 1].getMarginRight(),\r\n            children[i].getMarginLeft()\r\n          );\r\n        }\r\n\r\n        // Add last child\r\n        gaps += children[l - 1].getMarginRight();\r\n      } else {\r\n        // Simple adding of all margins\r\n        for (var i = 1, l = children.length; i < l; i += 1) {\r\n          gaps += children[i].getMarginLeft() + children[i].getMarginRight();\r\n        }\r\n\r\n        // Add spacing\r\n        gaps += spacing * (l - 1);\r\n      }\r\n\r\n      return gaps;\r\n    },\r\n\r\n    /**\r\n     * Computes the sum of all vertical gaps. Normally the\r\n     * result is used to compute the available height in a widget.\r\n     *\r\n     * The method optionally respects margin collapsing as well. In\r\n     * this mode the spacing is collapsed together with the margins.\r\n     *\r\n     * @param children {Array} List of children\r\n     * @param spacing {Integer?0} Spacing between every child\r\n     * @param collapse {Boolean?false} Optional margin collapsing mode\r\n     * @return {Integer} Sum of all gaps in the final layout.\r\n     */\r\n    computeVerticalGaps(children, spacing, collapse) {\r\n      if (spacing == null) {\r\n        spacing = 0;\r\n      }\r\n\r\n      var gaps = 0;\r\n\r\n      if (collapse) {\r\n        // Add first child\r\n        gaps += children[0].getMarginTop();\r\n\r\n        for (var i = 1, l = children.length; i < l; i += 1) {\r\n          gaps += this.collapseMargins(\r\n            spacing,\r\n            children[i - 1].getMarginBottom(),\r\n            children[i].getMarginTop()\r\n          );\r\n        }\r\n\r\n        // Add last child\r\n        gaps += children[l - 1].getMarginBottom();\r\n      } else {\r\n        // Simple adding of all margins\r\n        for (var i = 1, l = children.length; i < l; i += 1) {\r\n          gaps += children[i].getMarginTop() + children[i].getMarginBottom();\r\n        }\r\n\r\n        // Add spacing\r\n        gaps += spacing * (l - 1);\r\n      }\r\n\r\n      return gaps;\r\n    },\r\n\r\n    /**\r\n     * Computes the gaps together with the configuration of separators.\r\n     *\r\n     * @param children {qx.ui.core.LayoutItem[]} List of children\r\n     * @param spacing {Integer} Configured spacing\r\n     * @param separator {String|qx.ui.decoration.IDecorator} Separator to render\r\n     * @return {Integer} Sum of gaps\r\n     */\r\n    computeHorizontalSeparatorGaps(children, spacing, separator) {\r\n      var instance =\r\n        qx.theme.manager.Decoration.getInstance().resolve(separator);\r\n      var insets = instance.getInsets();\r\n      var width = insets.left + insets.right;\r\n\r\n      var gaps = 0;\r\n      for (var i = 0, l = children.length; i < l; i++) {\r\n        var child = children[i];\r\n        gaps += child.getMarginLeft() + child.getMarginRight();\r\n      }\r\n\r\n      gaps += (spacing + width + spacing) * (l - 1);\r\n\r\n      return gaps;\r\n    },\r\n\r\n    /**\r\n     * Computes the gaps together with the configuration of separators.\r\n     *\r\n     * @param children {qx.ui.core.LayoutItem[]} List of children\r\n     * @param spacing {Integer} Configured spacing\r\n     * @param separator {String|qx.ui.decoration.IDecorator} Separator to render\r\n     * @return {Integer} Sum of gaps\r\n     */\r\n    computeVerticalSeparatorGaps(children, spacing, separator) {\r\n      var instance =\r\n        qx.theme.manager.Decoration.getInstance().resolve(separator);\r\n      var insets = instance.getInsets();\r\n      var height = insets.top + insets.bottom;\r\n\r\n      var gaps = 0;\r\n      for (var i = 0, l = children.length; i < l; i++) {\r\n        var child = children[i];\r\n        gaps += child.getMarginTop() + child.getMarginBottom();\r\n      }\r\n\r\n      gaps += (spacing + height + spacing) * (l - 1);\r\n\r\n      return gaps;\r\n    },\r\n\r\n    /**\r\n     * Arranges two sizes in one box to best respect their individual limitations.\r\n     *\r\n     * Mainly used by split layouts (Split Panes) where the layout is mainly defined\r\n     * by the outer dimensions.\r\n     *\r\n     * @param beginMin {Integer} Minimum size of first widget (from size hint)\r\n     * @param beginIdeal {Integer} Ideal size of first widget (maybe after dragging the splitter)\r\n     * @param beginMax {Integer} Maximum size of first widget (from size hint)\r\n     * @param endMin {Integer} Minimum size of second widget (from size hint)\r\n     * @param endIdeal {Integer} Ideal size of second widget (maybe after dragging the splitter)\r\n     * @param endMax {Integer} Maximum size of second widget (from size hint)\r\n     * @return {Map} Map with the keys <code>begin</code and <code>end</code> with the\r\n     *   arranged dimensions.\r\n     */\r\n    arrangeIdeals(beginMin, beginIdeal, beginMax, endMin, endIdeal, endMax) {\r\n      if (beginIdeal < beginMin || endIdeal < endMin) {\r\n        if (beginIdeal < beginMin && endIdeal < endMin) {\r\n          // Just increase both, can not rearrange them otherwise\r\n          // Result into overflowing of the overlapping content\r\n          // Should normally not happen through auto sizing!\r\n          beginIdeal = beginMin;\r\n          endIdeal = endMin;\r\n        } else if (beginIdeal < beginMin) {\r\n          // Reduce end, increase begin to min\r\n          endIdeal -= beginMin - beginIdeal;\r\n          beginIdeal = beginMin;\r\n\r\n          // Re-check to keep min size of end\r\n          if (endIdeal < endMin) {\r\n            endIdeal = endMin;\r\n          }\r\n        } else if (endIdeal < endMin) {\r\n          // Reduce begin, increase end to min\r\n          beginIdeal -= endMin - endIdeal;\r\n          endIdeal = endMin;\r\n\r\n          // Re-check to keep min size of begin\r\n          if (beginIdeal < beginMin) {\r\n            beginIdeal = beginMin;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (beginIdeal > beginMax || endIdeal > endMax) {\r\n        if (beginIdeal > beginMax && endIdeal > endMax) {\r\n          // Just reduce both, can not rearrange them otherwise\r\n          // Leaves a blank area in the pane!\r\n          beginIdeal = beginMax;\r\n          endIdeal = endMax;\r\n        } else if (beginIdeal > beginMax) {\r\n          // Increase end, reduce begin to max\r\n          endIdeal += beginIdeal - beginMax;\r\n          beginIdeal = beginMax;\r\n\r\n          // Re-check to keep max size of end\r\n          if (endIdeal > endMax) {\r\n            endIdeal = endMax;\r\n          }\r\n        } else if (endIdeal > endMax) {\r\n          // Increase begin, reduce end to max\r\n          beginIdeal += endIdeal - endMax;\r\n          endIdeal = endMax;\r\n\r\n          // Re-check to keep max size of begin\r\n          if (beginIdeal > beginMax) {\r\n            beginIdeal = beginMax;\r\n          }\r\n        }\r\n      }\r\n\r\n      return {\r\n        begin: beginIdeal,\r\n        end: endIdeal\r\n      };\r\n    }\r\n  }\r\n});\r\n"
  ],
  "mappings": "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"
}