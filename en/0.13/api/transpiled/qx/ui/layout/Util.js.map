{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "statics",
    "PERCENT_VALUE",
    "computeFlexOffsets",
    "flexibles",
    "avail",
    "used",
    "child",
    "key",
    "flexSum",
    "flexStep",
    "grow",
    "remaining",
    "Math",
    "abs",
    "roundingOffset",
    "currentOffset",
    "result",
    "potential",
    "max",
    "value",
    "min",
    "flex",
    "offset",
    "Infinity",
    "ceil",
    "computeHorizontalAlignOffset",
    "align",
    "width",
    "availWidth",
    "marginLeft",
    "marginRight",
    "round",
    "computeVerticalAlignOffset",
    "height",
    "availHeight",
    "marginTop",
    "marginBottom",
    "collapseMargins",
    "varargs",
    "i",
    "l",
    "arguments",
    "length",
    "computeHorizontalGaps",
    "children",
    "spacing",
    "collapse",
    "gaps",
    "getMarginLeft",
    "getMarginRight",
    "computeVerticalGaps",
    "getMarginTop",
    "getMarginBottom",
    "computeHorizontalSeparatorGaps",
    "separator",
    "instance",
    "theme",
    "manager",
    "Decoration",
    "getInstance",
    "resolve",
    "insets",
    "getInsets",
    "left",
    "right",
    "computeVerticalSeparatorGaps",
    "top",
    "bottom",
    "arrangeIdeals",
    "beginMin",
    "beginIdeal",
    "beginMax",
    "endMin",
    "endIdeal",
    "endMax",
    "begin",
    "end",
    "ui",
    "layout",
    "Util"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/layout/Util.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * Common set of utility methods used by the standard qooxdoo layouts.\n *\n * @internal\n */\nqx.Class.define(\"qx.ui.layout.Util\", {\n  statics: {\n    /** @type {RegExp} Regular expression to match percent values */\n    PERCENT_VALUE: /[0-9]+(?:\\.[0-9]+)?%/,\n\n    /**\n     * Computes the flex offsets needed to reduce the space\n     * difference as much as possible by respecting the\n     * potential of the given elements (being in the range of\n     * their min/max values)\n     *\n     * @param flexibles {Map} Each entry must have these keys:\n     *   <code>id</code>, <code>potential</code> and <code>flex</code>.\n     *   The ID is used in the result map as the key for the user to work\n     *   with later (e.g. upgrade sizes etc. to respect the given offset)\n     *   The potential is an integer value which is the difference of the\n     *   currently interesting direction (e.g. shrinking=width-minWidth, growing=\n     *   maxWidth-width). The flex key holds the flex value of the item.\n     * @param avail {Integer} Full available space to allocate (ignoring used one)\n     * @param used {Integer} Size of already allocated space\n     * @return {Map} A map which contains the calculated offsets under the key\n     *   which is identical to the ID given in the incoming map.\n     */\n    computeFlexOffsets(flexibles, avail, used) {\n      var child, key, flexSum, flexStep;\n      var grow = avail > used;\n      var remaining = Math.abs(avail - used);\n      var roundingOffset, currentOffset;\n\n      // Preprocess data\n      var result = {};\n      for (key in flexibles) {\n        child = flexibles[key];\n        result[key] = {\n          potential: grow ? child.max - child.value : child.value - child.min,\n          flex: grow ? child.flex : 1 / child.flex,\n          offset: 0\n        };\n      }\n\n      // Continue as long as we need to do anything\n      while (remaining != 0) {\n        // Find minimum potential for next correction\n        flexStep = Infinity;\n        flexSum = 0;\n        for (key in result) {\n          child = result[key];\n\n          if (child.potential > 0) {\n            flexSum += child.flex;\n            flexStep = Math.min(flexStep, child.potential / child.flex);\n          }\n        }\n\n        // No potential found, quit here\n        if (flexSum == 0) {\n          break;\n        }\n\n        // Respect maximum potential given through remaining space\n        // The parent should always win in such conflicts.\n        flexStep = Math.min(remaining, flexStep * flexSum) / flexSum;\n\n        // Start with correction\n        roundingOffset = 0;\n        for (key in result) {\n          child = result[key];\n\n          if (child.potential > 0) {\n            // Compute offset for this step\n            currentOffset = Math.min(\n              remaining,\n              child.potential,\n              Math.ceil(flexStep * child.flex)\n            );\n\n            // Fix rounding issues\n            roundingOffset += currentOffset - flexStep * child.flex;\n            if (roundingOffset >= 1) {\n              roundingOffset -= 1;\n              currentOffset -= 1;\n            }\n\n            // Update child status\n            child.potential -= currentOffset;\n\n            if (grow) {\n              child.offset += currentOffset;\n            } else {\n              child.offset -= currentOffset;\n            }\n\n            // Update parent status\n            remaining -= currentOffset;\n          }\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * Computes the offset which needs to be added to the top position\n     * to result in the stated vertical alignment. Also respects\n     * existing margins (without collapsing).\n     *\n     * @param align {String} One of <code>top</code>, <code>center</code> or <code>bottom</code>.\n     * @param width {Integer} The visible width of the widget\n     * @param availWidth {Integer} The available inner width of the parent\n     * @param marginLeft {Integer?0} Optional left margin of the widget\n     * @param marginRight {Integer?0} Optional right margin of the widget\n     * @return {Integer} Computed top coordinate\n     */\n    computeHorizontalAlignOffset(\n      align,\n      width,\n      availWidth,\n      marginLeft,\n      marginRight\n    ) {\n      if (marginLeft == null) {\n        marginLeft = 0;\n      }\n\n      if (marginRight == null) {\n        marginRight = 0;\n      }\n\n      var value = 0;\n      switch (align) {\n        case \"left\":\n          value = marginLeft;\n          break;\n\n        case \"right\":\n          // Align right changes priority to right edge:\n          // To align to the right is more important here than to left.\n          value = availWidth - width - marginRight;\n          break;\n\n        case \"center\":\n          // Ideal center position\n          value = Math.round((availWidth - width) / 2);\n\n          // Try to make this possible (with left-right priority)\n          if (value < marginLeft) {\n            value = marginLeft;\n          } else if (value < marginRight) {\n            value = Math.max(marginLeft, availWidth - width - marginRight);\n          }\n\n          break;\n      }\n\n      return value;\n    },\n\n    /**\n     * Computes the offset which needs to be added to the top position\n     * to result in the stated vertical alignment. Also respects\n     * existing margins (without collapsing).\n     *\n     * @param align {String} One of <code>top</code>, <code>middle</code> or <code>bottom</code>.\n     * @param height {Integer} The visible height of the widget\n     * @param availHeight {Integer} The available inner height of the parent\n     * @param marginTop {Integer?0} Optional top margin of the widget\n     * @param marginBottom {Integer?0} Optional bottom margin of the widget\n     * @return {Integer} Computed top coordinate\n     */\n    computeVerticalAlignOffset(\n      align,\n      height,\n      availHeight,\n      marginTop,\n      marginBottom\n    ) {\n      if (marginTop == null) {\n        marginTop = 0;\n      }\n\n      if (marginBottom == null) {\n        marginBottom = 0;\n      }\n\n      var value = 0;\n      switch (align) {\n        case \"top\":\n          value = marginTop;\n          break;\n\n        case \"bottom\":\n          // Align bottom changes priority to bottom edge:\n          // To align to the bottom is more important here than to top.\n          value = availHeight - height - marginBottom;\n          break;\n\n        case \"middle\":\n          // Ideal middle position\n          value = Math.round((availHeight - height) / 2);\n\n          // Try to make this possible (with top-down priority)\n          if (value < marginTop) {\n            value = marginTop;\n          } else if (value < marginBottom) {\n            value = Math.max(marginTop, availHeight - height - marginBottom);\n          }\n\n          break;\n      }\n\n      return value;\n    },\n\n    /**\n     * Collapses two margins.\n     *\n     * Supports positive and negative margins.\n     * Collapsing find the largest positive and the largest\n     * negative value. Afterwards the result is computed through the\n     * subtraction of the negative from the positive value.\n     *\n     * @param varargs {arguments} Any number of configured margins\n     * @return {Integer} The collapsed margin\n     */\n    collapseMargins(varargs) {\n      var max = 0,\n        min = 0;\n      for (var i = 0, l = arguments.length; i < l; i++) {\n        var value = arguments[i];\n\n        if (value < 0) {\n          min = Math.min(min, value);\n        } else if (value > 0) {\n          max = Math.max(max, value);\n        }\n      }\n\n      return max + min;\n    },\n\n    /**\n     * Computes the sum of all horizontal gaps. Normally the\n     * result is used to compute the available width in a widget.\n     *\n     * The method optionally respects margin collapsing as well. In\n     * this mode the spacing is collapsed together with the margins.\n     *\n     * @param children {Array} List of children\n     * @param spacing {Integer?0} Spacing between every child\n     * @param collapse {Boolean?false} Optional margin collapsing mode\n     * @return {Integer} Sum of all gaps in the final layout.\n     */\n    computeHorizontalGaps(children, spacing, collapse) {\n      if (spacing == null) {\n        spacing = 0;\n      }\n\n      var gaps = 0;\n\n      if (collapse) {\n        // Add first child\n        gaps += children[0].getMarginLeft();\n\n        for (var i = 1, l = children.length; i < l; i += 1) {\n          gaps += this.collapseMargins(\n            spacing,\n            children[i - 1].getMarginRight(),\n            children[i].getMarginLeft()\n          );\n        }\n\n        // Add last child\n        gaps += children[l - 1].getMarginRight();\n      } else {\n        // Simple adding of all margins\n        for (var i = 1, l = children.length; i < l; i += 1) {\n          gaps += children[i].getMarginLeft() + children[i].getMarginRight();\n        }\n\n        // Add spacing\n        gaps += spacing * (l - 1);\n      }\n\n      return gaps;\n    },\n\n    /**\n     * Computes the sum of all vertical gaps. Normally the\n     * result is used to compute the available height in a widget.\n     *\n     * The method optionally respects margin collapsing as well. In\n     * this mode the spacing is collapsed together with the margins.\n     *\n     * @param children {Array} List of children\n     * @param spacing {Integer?0} Spacing between every child\n     * @param collapse {Boolean?false} Optional margin collapsing mode\n     * @return {Integer} Sum of all gaps in the final layout.\n     */\n    computeVerticalGaps(children, spacing, collapse) {\n      if (spacing == null) {\n        spacing = 0;\n      }\n\n      var gaps = 0;\n\n      if (collapse) {\n        // Add first child\n        gaps += children[0].getMarginTop();\n\n        for (var i = 1, l = children.length; i < l; i += 1) {\n          gaps += this.collapseMargins(\n            spacing,\n            children[i - 1].getMarginBottom(),\n            children[i].getMarginTop()\n          );\n        }\n\n        // Add last child\n        gaps += children[l - 1].getMarginBottom();\n      } else {\n        // Simple adding of all margins\n        for (var i = 1, l = children.length; i < l; i += 1) {\n          gaps += children[i].getMarginTop() + children[i].getMarginBottom();\n        }\n\n        // Add spacing\n        gaps += spacing * (l - 1);\n      }\n\n      return gaps;\n    },\n\n    /**\n     * Computes the gaps together with the configuration of separators.\n     *\n     * @param children {qx.ui.core.LayoutItem[]} List of children\n     * @param spacing {Integer} Configured spacing\n     * @param separator {String|qx.ui.decoration.IDecorator} Separator to render\n     * @return {Integer} Sum of gaps\n     */\n    computeHorizontalSeparatorGaps(children, spacing, separator) {\n      var instance =\n        qx.theme.manager.Decoration.getInstance().resolve(separator);\n      var insets = instance.getInsets();\n      var width = insets.left + insets.right;\n\n      var gaps = 0;\n      for (var i = 0, l = children.length; i < l; i++) {\n        var child = children[i];\n        gaps += child.getMarginLeft() + child.getMarginRight();\n      }\n\n      gaps += (spacing + width + spacing) * (l - 1);\n\n      return gaps;\n    },\n\n    /**\n     * Computes the gaps together with the configuration of separators.\n     *\n     * @param children {qx.ui.core.LayoutItem[]} List of children\n     * @param spacing {Integer} Configured spacing\n     * @param separator {String|qx.ui.decoration.IDecorator} Separator to render\n     * @return {Integer} Sum of gaps\n     */\n    computeVerticalSeparatorGaps(children, spacing, separator) {\n      var instance =\n        qx.theme.manager.Decoration.getInstance().resolve(separator);\n      var insets = instance.getInsets();\n      var height = insets.top + insets.bottom;\n\n      var gaps = 0;\n      for (var i = 0, l = children.length; i < l; i++) {\n        var child = children[i];\n        gaps += child.getMarginTop() + child.getMarginBottom();\n      }\n\n      gaps += (spacing + height + spacing) * (l - 1);\n\n      return gaps;\n    },\n\n    /**\n     * Arranges two sizes in one box to best respect their individual limitations.\n     *\n     * Mainly used by split layouts (Split Panes) where the layout is mainly defined\n     * by the outer dimensions.\n     *\n     * @param beginMin {Integer} Minimum size of first widget (from size hint)\n     * @param beginIdeal {Integer} Ideal size of first widget (maybe after dragging the splitter)\n     * @param beginMax {Integer} Maximum size of first widget (from size hint)\n     * @param endMin {Integer} Minimum size of second widget (from size hint)\n     * @param endIdeal {Integer} Ideal size of second widget (maybe after dragging the splitter)\n     * @param endMax {Integer} Maximum size of second widget (from size hint)\n     * @return {Map} Map with the keys <code>begin</code and <code>end</code> with the\n     *   arranged dimensions.\n     */\n    arrangeIdeals(beginMin, beginIdeal, beginMax, endMin, endIdeal, endMax) {\n      if (beginIdeal < beginMin || endIdeal < endMin) {\n        if (beginIdeal < beginMin && endIdeal < endMin) {\n          // Just increase both, can not rearrange them otherwise\n          // Result into overflowing of the overlapping content\n          // Should normally not happen through auto sizing!\n          beginIdeal = beginMin;\n          endIdeal = endMin;\n        } else if (beginIdeal < beginMin) {\n          // Reduce end, increase begin to min\n          endIdeal -= beginMin - beginIdeal;\n          beginIdeal = beginMin;\n\n          // Re-check to keep min size of end\n          if (endIdeal < endMin) {\n            endIdeal = endMin;\n          }\n        } else if (endIdeal < endMin) {\n          // Reduce begin, increase end to min\n          beginIdeal -= endMin - endIdeal;\n          endIdeal = endMin;\n\n          // Re-check to keep min size of begin\n          if (beginIdeal < beginMin) {\n            beginIdeal = beginMin;\n          }\n        }\n      }\n\n      if (beginIdeal > beginMax || endIdeal > endMax) {\n        if (beginIdeal > beginMax && endIdeal > endMax) {\n          // Just reduce both, can not rearrange them otherwise\n          // Leaves a blank area in the pane!\n          beginIdeal = beginMax;\n          endIdeal = endMax;\n        } else if (beginIdeal > beginMax) {\n          // Increase end, reduce begin to max\n          endIdeal += beginIdeal - beginMax;\n          beginIdeal = beginMax;\n\n          // Re-check to keep max size of end\n          if (endIdeal > endMax) {\n            endIdeal = endMax;\n          }\n        } else if (endIdeal > endMax) {\n          // Increase begin, reduce end to max\n          beginIdeal += endIdeal - endMax;\n          endIdeal = endMax;\n\n          // Re-check to keep max size of begin\n          if (beginIdeal > beginMax) {\n            beginIdeal = beginMax;\n          }\n        }\n      }\n\n      return {\n        begin: beginIdeal,\n        end: endIdeal\n      };\n    }\n  }\n});\n"
  ],
  "mappings": "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"
}