{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "rowConfig",
    "columnConfig",
    "_cells",
    "_invalidateSortCache",
    "_invalidatePositionCache",
    "addListener",
    "_onRowConfigChange",
    "_onColumnConfigChange",
    "_rowConfig",
    "_columnConfig",
    "members",
    "addCell",
    "id",
    "row",
    "column",
    "rowSpan",
    "columnSpan",
    "firstRow",
    "lastRow",
    "firstColumn",
    "lastColumn",
    "removeCell",
    "_sorted",
    "_getSortedCells",
    "key",
    "sorted",
    "values",
    "sort",
    "a",
    "b",
    "_findCellsInRange",
    "min",
    "max",
    "cells",
    "length",
    "start",
    "end",
    "pivot",
    "cell",
    "result",
    "findCellsInWindow",
    "rowCount",
    "columnCount",
    "verticalInWindow",
    "lang",
    "mergeWith",
    "horizontalInWindow",
    "__intersectionAsArray",
    "setA",
    "setB",
    "intersection",
    "push",
    "e",
    "_rowPos",
    "_columnPos",
    "_getRowPosition",
    "pos",
    "undefined",
    "getItemPosition",
    "_getColumnPosition",
    "_getSingleCellBounds",
    "firstVisibleRow",
    "firstVisibleColumn",
    "bounds",
    "left",
    "top",
    "width",
    "height",
    "getItemSize",
    "getCellBounds",
    "i",
    "l",
    "computeCellSpanMap",
    "map",
    "rowStartIndex",
    "Math",
    "rowEndIndex",
    "rowIndex",
    "columnStartIndex",
    "columnEndIndex",
    "columnIndex",
    "destruct",
    "removeListener",
    "ui",
    "virtual",
    "layer",
    "CellSpanManager"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/virtual/layer/CellSpanManager.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * The CellSpanManager manages cells, which span several rows or columns.\n *\n * It provides functionality to compute, which spanning cells are visible\n * in a given view port and how they have to be placed.\n */\nqx.Class.define(\"qx.ui.virtual.layer.CellSpanManager\", {\n  extend: qx.core.Object,\n\n  /**\n   * @param rowConfig {qx.ui.virtual.core.Axis} The row configuration of the pane\n   *    in which the cells will be rendered\n   * @param columnConfig {qx.ui.virtual.core.Axis} The column configuration of the pane\n   *    in which the cells will be rendered\n   */\n  construct(rowConfig, columnConfig) {\n    super();\n\n    if (qx.core.Environment.get(\"qx.debug\")) {\n      this.assertInstance(rowConfig, qx.ui.virtual.core.Axis);\n      this.assertInstance(columnConfig, qx.ui.virtual.core.Axis);\n    }\n\n    this._cells = {};\n    this._invalidateSortCache();\n    this._invalidatePositionCache();\n\n    rowConfig.addListener(\"change\", this._onRowConfigChange, this);\n    columnConfig.addListener(\"change\", this._onColumnConfigChange, this);\n\n    this._rowConfig = rowConfig;\n    this._columnConfig = columnConfig;\n  },\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members: {\n    /**\n     * Add a spanning cell to the manager.\n     *\n     * @param id {String} Unique id for the cell definition. This id is required\n     *    for removing the cell from the manager\n     * @param row {PositiveInteger} The cell's row\n     * @param column {PositiveInteger} The cell's column\n     * @param rowSpan {PositiveInteger} The number of rows the cells spans\n     * @param columnSpan {PositiveInteger} The number of columns the cells spans\n     */\n    addCell(id, row, column, rowSpan, columnSpan) {\n      this._cells[id] = {\n        firstRow: row,\n        lastRow: row + rowSpan - 1,\n        firstColumn: column,\n        lastColumn: column + columnSpan - 1,\n        id: id\n      };\n\n      this._invalidateSortCache();\n    },\n\n    /**\n     * Remove a cell from the manager\n     *\n     * @param id {String} The id of the cell to remove\n     */\n    removeCell(id) {\n      delete this._cells[id];\n      this._invalidateSortCache();\n    },\n\n    /**\n     * Invalidate the sort cache\n     */\n    _invalidateSortCache() {\n      this._sorted = {};\n    },\n\n    /**\n     * Get the cell array sorted by the given key (ascending)\n     *\n     * @param key {String} The sort key. One of <code>firstRow</code>,\n     *     <code>lastRow</code>, <code>firstColumn</code> or <code>lastColumn</code>\n     * @return {Map[]} sorted array of cell descriptions\n     */\n    _getSortedCells(key) {\n      if (this._sorted[key]) {\n        return this._sorted[key];\n      }\n      var sorted = (this._sorted[key] = Object.values(this._cells));\n      sorted.sort(function (a, b) {\n        return a[key] < b[key] ? -1 : 1;\n      });\n      return sorted;\n    },\n\n    /**\n     * Finds all cells with a sort key within the given range.\n     *\n     * Complexity: O(log n)\n     *\n     * @param key {String} The key to search for\n     * @param min {Integer} minimum value\n     * @param max {Integer} maximum value (inclusive)\n     * @return {Map} Map, which will contain the search results\n     */\n    _findCellsInRange(key, min, max) {\n      var cells = this._getSortedCells(key);\n      if (cells.length == 0) {\n        return {};\n      }\n\n      var start = 0;\n      var end = cells.length - 1;\n\n      // find first cell, which is >= \"min\"\n      while (true) {\n        var pivot = start + ((end - start) >> 1);\n\n        var cell = cells[pivot];\n        if (cell[key] >= min && (pivot == 0 || cells[pivot - 1][key] < min)) {\n          // the start cell was found\n          break;\n        }\n\n        if (cell[key] >= min) {\n          end = pivot - 1;\n        } else {\n          start = pivot + 1;\n        }\n        if (start > end) {\n          // nothing found\n          return {};\n        }\n      }\n\n      var result = {};\n      var cell = cells[pivot];\n      while (cell && cell[key] >= min && cell[key] <= max) {\n        result[cell.id] = cell;\n        cell = cells[pivot++];\n      }\n      return result;\n    },\n\n    /**\n     * Find all cells, which are visible in the given grid window.\n     *\n     * @param firstRow {PositiveInteger} first visible row\n     * @param firstColumn {PositiveInteger} first visible column\n     * @param rowCount {PositiveInteger} number of rows in the window\n     * @param columnCount {PositiveInteger} number of columns in the window\n     * @return {Map[]} The array of found cell descriptions. A cell description\n     *    contains the keys <code>firstRow</code>, <code>lastRow</code>,\n     *    <code>firstColumn</code> or <code>lastColumn</code>\n     */\n    findCellsInWindow(firstRow, firstColumn, rowCount, columnCount) {\n      var verticalInWindow = {};\n\n      if (rowCount > 0) {\n        var lastRow = firstRow + rowCount - 1;\n        qx.lang.Object.mergeWith(\n          verticalInWindow,\n          this._findCellsInRange(\"firstRow\", firstRow, lastRow)\n        );\n\n        qx.lang.Object.mergeWith(\n          verticalInWindow,\n          this._findCellsInRange(\"lastRow\", firstRow, lastRow)\n        );\n      }\n\n      var horizontalInWindow = {};\n\n      if (columnCount > 0) {\n        var lastColumn = firstColumn + columnCount - 1;\n        qx.lang.Object.mergeWith(\n          horizontalInWindow,\n          this._findCellsInRange(\"firstColumn\", firstColumn, lastColumn)\n        );\n\n        qx.lang.Object.mergeWith(\n          horizontalInWindow,\n          this._findCellsInRange(\"lastColumn\", firstColumn, lastColumn)\n        );\n      }\n\n      return this.__intersectionAsArray(horizontalInWindow, verticalInWindow);\n    },\n\n    /**\n     * Return the intersection of two maps as an array. The objects intersect if\n     * they have the same keys.\n     *\n     * @param setA {Object} The first map\n     * @param setB {Object} The second map\n     * @return {String[]} An array keys found in both maps\n     */\n    __intersectionAsArray(setA, setB) {\n      var intersection = [];\n      for (var key in setA) {\n        if (setB[key]) {\n          intersection.push(setB[key]);\n        }\n      }\n      return intersection;\n    },\n\n    /**\n     * Event handler for row configuration changes\n     *\n     * @param e {qx.event.type.Event} the event object\n     */\n    _onRowConfigChange(e) {\n      this._rowPos = [];\n    },\n\n    /**\n     * Event handler for column configuration changes\n     *\n     * @param e {qx.event.type.Event} the event object\n     */\n    _onColumnConfigChange(e) {\n      this._columnPos = [];\n    },\n\n    /**\n     * Invalidates the row/column position cache\n     */\n    _invalidatePositionCache() {\n      this._rowPos = [];\n      this._columnPos = [];\n    },\n\n    /**\n     * Get the pixel start position of the given row\n     *\n     * @param row {Integer} The row index\n     * @return {Integer} The pixel start position of the given row\n     */\n    _getRowPosition(row) {\n      var pos = this._rowPos[row];\n      if (pos !== undefined) {\n        return pos;\n      }\n\n      pos = this._rowPos[row] = this._rowConfig.getItemPosition(row);\n      return pos;\n    },\n\n    /**\n     * Get the pixel start position of the given column\n     *\n     * @param column {Integer} The column index\n     * @return {Integer} The pixel start position of the given column\n     */\n    _getColumnPosition(column) {\n      var pos = this._columnPos[column];\n      if (pos !== undefined) {\n        return pos;\n      }\n\n      pos = this._columnPos[column] =\n        this._columnConfig.getItemPosition(column);\n      return pos;\n    },\n\n    /**\n     * Get the bounds of a single cell\n     *\n     * @param cell {Map} the cell description as returned by\n     *    {@link #findCellsInWindow} to get the bounds for\n     * @param firstVisibleRow {Map} The pane's first visible row\n     * @param firstVisibleColumn {Map} The pane's first visible column\n     * @return {Map} Boundaries map with the keys <code>left</code>,\n     * <code>top</code>, <code>width</code> and <code>height</code>\n     */\n    _getSingleCellBounds(cell, firstVisibleRow, firstVisibleColumn) {\n      var bounds = {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      };\n\n      bounds.height =\n        this._getRowPosition(cell.lastRow) +\n        this._rowConfig.getItemSize(cell.lastRow) -\n        this._getRowPosition(cell.firstRow);\n\n      bounds.top =\n        this._getRowPosition(cell.firstRow) -\n        this._getRowPosition(firstVisibleRow);\n\n      bounds.width =\n        this._getColumnPosition(cell.lastColumn) +\n        this._columnConfig.getItemSize(cell.lastColumn) -\n        this._getColumnPosition(cell.firstColumn);\n\n      bounds.left =\n        this._getColumnPosition(cell.firstColumn) -\n        this._getColumnPosition(firstVisibleColumn);\n\n      return bounds;\n    },\n\n    /**\n     * Get the bounds of a list of cells as returned by {@link #findCellsInWindow}\n     *\n     * @param cells {Map[]} Array of cell descriptions\n     * @param firstVisibleRow {Map} The pane's first visible row\n     * @param firstVisibleColumn {Map} The pane's first visible column\n     * @return {Map[]} Array, which contains a bounds map for each cell.\n     */\n    getCellBounds(cells, firstVisibleRow, firstVisibleColumn) {\n      var bounds = [];\n      for (var i = 0, l = cells.length; i < l; i++) {\n        bounds.push(\n          this._getSingleCellBounds(\n            cells[i],\n            firstVisibleRow,\n            firstVisibleColumn\n          )\n        );\n      }\n      return bounds;\n    },\n\n    /**\n     * Compute a bitmap, which marks for each visible cell, whether the cell\n     * is covered by a spanning cell.\n     *\n     * @param cells {Map[]} Array of cell descriptions as returned by\n     *     {@link #findCellsInWindow}.\n     * @param firstRow {PositiveInteger} first visible row\n     * @param firstColumn {PositiveInteger} first visible column\n     * @param rowCount {PositiveInteger} number of rows in the window\n     * @param columnCount {PositiveInteger} number of columns in the window\n     * @return {Map[][]} Two dimensional array, which contains a <code>1</code>\n     *    for each visible cell, which is covered by a spanned cell.\n     */\n    computeCellSpanMap(cells, firstRow, firstColumn, rowCount, columnCount) {\n      var map = [];\n\n      if (rowCount <= 0) {\n        return map;\n      }\n      var lastRow = firstRow + rowCount - 1;\n\n      for (var i = firstRow; i <= lastRow; i++) {\n        map[i] = [];\n      }\n\n      if (columnCount <= 0) {\n        return map;\n      }\n      var lastColumn = firstColumn + columnCount - 1;\n\n      for (var i = 0, l = cells.length; i < l; i++) {\n        var cell = cells[i];\n\n        var rowStartIndex = Math.max(firstRow, cell.firstRow);\n        var rowEndIndex = Math.min(lastRow, cell.lastRow);\n        var row;\n\n        for (\n          var rowIndex = rowStartIndex;\n          rowIndex <= rowEndIndex;\n          rowIndex++\n        ) {\n          row = map[rowIndex];\n\n          var columnStartIndex = Math.max(firstColumn, cell.firstColumn);\n          var columnEndIndex = Math.min(lastColumn, cell.lastColumn);\n          for (\n            var columnIndex = columnStartIndex;\n            columnIndex <= columnEndIndex;\n            columnIndex++\n          ) {\n            row[columnIndex] = 1;\n          }\n        }\n      }\n\n      return map;\n    }\n  },\n\n  destruct() {\n    this._rowConfig.removeListener(\"change\", this._onRowConfigChange, this);\n    this._columnConfig.removeListener(\n      \"change\",\n      this._onColumnConfigChange,\n      this\n    );\n\n    this._cells =\n      this._sorted =\n      this._rowPos =\n      this._columnPos =\n      this._rowConfig =\n      this._columnConfig =\n        null;\n  }\n});\n"
  ],
  "mappings": "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"
}