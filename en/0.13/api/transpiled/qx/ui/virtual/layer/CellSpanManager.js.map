{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "rowConfig",
    "columnConfig",
    "_cells",
    "_invalidateSortCache",
    "_invalidatePositionCache",
    "addListener",
    "_onRowConfigChange",
    "_onColumnConfigChange",
    "_rowConfig",
    "_columnConfig",
    "members",
    "addCell",
    "id",
    "row",
    "column",
    "rowSpan",
    "columnSpan",
    "firstRow",
    "lastRow",
    "firstColumn",
    "lastColumn",
    "removeCell",
    "_sorted",
    "_getSortedCells",
    "key",
    "sorted",
    "values",
    "sort",
    "a",
    "b",
    "_findCellsInRange",
    "min",
    "max",
    "cells",
    "length",
    "start",
    "end",
    "pivot",
    "cell",
    "result",
    "findCellsInWindow",
    "rowCount",
    "columnCount",
    "verticalInWindow",
    "lang",
    "mergeWith",
    "horizontalInWindow",
    "__intersectionAsArray",
    "setA",
    "setB",
    "intersection",
    "push",
    "e",
    "_rowPos",
    "_columnPos",
    "_getRowPosition",
    "pos",
    "undefined",
    "getItemPosition",
    "_getColumnPosition",
    "_getSingleCellBounds",
    "firstVisibleRow",
    "firstVisibleColumn",
    "bounds",
    "left",
    "top",
    "width",
    "height",
    "getItemSize",
    "getCellBounds",
    "i",
    "l",
    "computeCellSpanMap",
    "map",
    "rowStartIndex",
    "Math",
    "rowEndIndex",
    "rowIndex",
    "columnStartIndex",
    "columnEndIndex",
    "columnIndex",
    "destruct",
    "removeListener",
    "ui",
    "virtual",
    "layer",
    "CellSpanManager"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/virtual/layer/CellSpanManager.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * The CellSpanManager manages cells, which span several rows or columns.\n *\n * It provides functionality to compute, which spanning cells are visible\n * in a given view port and how they have to be placed.\n */\nqx.Class.define(\"qx.ui.virtual.layer.CellSpanManager\", {\n  extend: qx.core.Object,\n\n  /**\n   * @param rowConfig {qx.ui.virtual.core.Axis} The row configuration of the pane\n   *    in which the cells will be rendered\n   * @param columnConfig {qx.ui.virtual.core.Axis} The column configuration of the pane\n   *    in which the cells will be rendered\n   */\n  construct(rowConfig, columnConfig) {\n    super();\n\n    if (qx.core.Environment.get(\"qx.debug\")) {\n      this.assertInstance(rowConfig, qx.ui.virtual.core.Axis);\n      this.assertInstance(columnConfig, qx.ui.virtual.core.Axis);\n    }\n\n    this._cells = {};\n    this._invalidateSortCache();\n    this._invalidatePositionCache();\n\n    rowConfig.addListener(\"change\", this._onRowConfigChange, this);\n    columnConfig.addListener(\"change\", this._onColumnConfigChange, this);\n\n    this._rowConfig = rowConfig;\n    this._columnConfig = columnConfig;\n  },\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members: {\n    /**\n     * Add a spanning cell to the manager.\n     *\n     * @param id {String} Unique id for the cell definition. This id is required\n     *    for removing the cell from the manager\n     * @param row {PositiveInteger} The cell's row\n     * @param column {PositiveInteger} The cell's column\n     * @param rowSpan {PositiveInteger} The number of rows the cells spans\n     * @param columnSpan {PositiveInteger} The number of columns the cells spans\n     */\n    addCell(id, row, column, rowSpan, columnSpan) {\n      this._cells[id] = {\n        firstRow: row,\n        lastRow: row + rowSpan - 1,\n        firstColumn: column,\n        lastColumn: column + columnSpan - 1,\n        id: id\n      };\n\n      this._invalidateSortCache();\n    },\n\n    /**\n     * Remove a cell from the manager\n     *\n     * @param id {String} The id of the cell to remove\n     */\n    removeCell(id) {\n      delete this._cells[id];\n      this._invalidateSortCache();\n    },\n\n    /**\n     * Invalidate the sort cache\n     */\n    _invalidateSortCache() {\n      this._sorted = {};\n    },\n\n    /**\n     * Get the cell array sorted by the given key (ascending)\n     *\n     * @param key {String} The sort key. One of <code>firstRow</code>,\n     *     <code>lastRow</code>, <code>firstColumn</code> or <code>lastColumn</code>\n     * @return {Map[]} sorted array of cell descriptions\n     */\n    _getSortedCells(key) {\n      if (this._sorted[key]) {\n        return this._sorted[key];\n      }\n      var sorted = (this._sorted[key] = Object.values(this._cells));\n      sorted.sort(function (a, b) {\n        return a[key] < b[key] ? -1 : 1;\n      });\n      return sorted;\n    },\n\n    /**\n     * Finds all cells with a sort key within the given range.\n     *\n     * Complexity: O(log n)\n     *\n     * @param key {String} The key to search for\n     * @param min {Integer} minimum value\n     * @param max {Integer} maximum value (inclusive)\n     * @return {Map} Map, which will contain the search results\n     */\n    _findCellsInRange(key, min, max) {\n      var cells = this._getSortedCells(key);\n      if (cells.length == 0) {\n        return {};\n      }\n\n      var start = 0;\n      var end = cells.length - 1;\n\n      // find first cell, which is >= \"min\"\n      while (true) {\n        var pivot = start + ((end - start) >> 1);\n\n        var cell = cells[pivot];\n        if (cell[key] >= min && (pivot == 0 || cells[pivot - 1][key] < min)) {\n          // the start cell was found\n          break;\n        }\n\n        if (cell[key] >= min) {\n          end = pivot - 1;\n        } else {\n          start = pivot + 1;\n        }\n        if (start > end) {\n          // nothing found\n          return {};\n        }\n      }\n\n      var result = {};\n      var cell = cells[pivot];\n      while (cell && cell[key] >= min && cell[key] <= max) {\n        result[cell.id] = cell;\n        cell = cells[pivot++];\n      }\n      return result;\n    },\n\n    /**\n     * Find all cells, which are visible in the given grid window.\n     *\n     * @param firstRow {PositiveInteger} first visible row\n     * @param firstColumn {PositiveInteger} first visible column\n     * @param rowCount {PositiveInteger} number of rows in the window\n     * @param columnCount {PositiveInteger} number of columns in the window\n     * @return {Map[]} The array of found cell descriptions. A cell description\n     *    contains the keys <code>firstRow</code>, <code>lastRow</code>,\n     *    <code>firstColumn</code> or <code>lastColumn</code>\n     */\n    findCellsInWindow(firstRow, firstColumn, rowCount, columnCount) {\n      var verticalInWindow = {};\n\n      if (rowCount > 0) {\n        var lastRow = firstRow + rowCount - 1;\n        qx.lang.Object.mergeWith(\n          verticalInWindow,\n          this._findCellsInRange(\"firstRow\", firstRow, lastRow)\n        );\n\n        qx.lang.Object.mergeWith(\n          verticalInWindow,\n          this._findCellsInRange(\"lastRow\", firstRow, lastRow)\n        );\n      }\n\n      var horizontalInWindow = {};\n\n      if (columnCount > 0) {\n        var lastColumn = firstColumn + columnCount - 1;\n        qx.lang.Object.mergeWith(\n          horizontalInWindow,\n          this._findCellsInRange(\"firstColumn\", firstColumn, lastColumn)\n        );\n\n        qx.lang.Object.mergeWith(\n          horizontalInWindow,\n          this._findCellsInRange(\"lastColumn\", firstColumn, lastColumn)\n        );\n      }\n\n      return this.__intersectionAsArray(horizontalInWindow, verticalInWindow);\n    },\n\n    /**\n     * Return the intersection of two maps as an array. The objects intersect if\n     * they have the same keys.\n     *\n     * @param setA {Object} The first map\n     * @param setB {Object} The second map\n     * @return {String[]} An array keys found in both maps\n     */\n    __intersectionAsArray(setA, setB) {\n      var intersection = [];\n      for (var key in setA) {\n        if (setB[key]) {\n          intersection.push(setB[key]);\n        }\n      }\n      return intersection;\n    },\n\n    /**\n     * Event handler for row configuration changes\n     *\n     * @param e {qx.event.type.Event} the event object\n     */\n    _onRowConfigChange(e) {\n      this._rowPos = [];\n    },\n\n    /**\n     * Event handler for column configuration changes\n     *\n     * @param e {qx.event.type.Event} the event object\n     */\n    _onColumnConfigChange(e) {\n      this._columnPos = [];\n    },\n\n    /**\n     * Invalidates the row/column position cache\n     */\n    _invalidatePositionCache() {\n      this._rowPos = [];\n      this._columnPos = [];\n    },\n\n    /**\n     * Get the pixel start position of the given row\n     *\n     * @param row {Integer} The row index\n     * @return {Integer} The pixel start position of the given row\n     */\n    _getRowPosition(row) {\n      var pos = this._rowPos[row];\n      if (pos !== undefined) {\n        return pos;\n      }\n\n      pos = this._rowPos[row] = this._rowConfig.getItemPosition(row);\n      return pos;\n    },\n\n    /**\n     * Get the pixel start position of the given column\n     *\n     * @param column {Integer} The column index\n     * @return {Integer} The pixel start position of the given column\n     */\n    _getColumnPosition(column) {\n      var pos = this._columnPos[column];\n      if (pos !== undefined) {\n        return pos;\n      }\n\n      pos = this._columnPos[column] =\n        this._columnConfig.getItemPosition(column);\n      return pos;\n    },\n\n    /**\n     * Get the bounds of a single cell\n     *\n     * @param cell {Map} the cell description as returned by\n     *    {@link #findCellsInWindow} to get the bounds for\n     * @param firstVisibleRow {Map} The pane's first visible row\n     * @param firstVisibleColumn {Map} The pane's first visible column\n     * @return {Map} Boundaries map with the keys <code>left</code>,\n     * <code>top</code>, <code>width</code> and <code>height</code>\n     */\n    _getSingleCellBounds(cell, firstVisibleRow, firstVisibleColumn) {\n      var bounds = {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      };\n\n      bounds.height =\n        this._getRowPosition(cell.lastRow) +\n        this._rowConfig.getItemSize(cell.lastRow) -\n        this._getRowPosition(cell.firstRow);\n\n      bounds.top =\n        this._getRowPosition(cell.firstRow) -\n        this._getRowPosition(firstVisibleRow);\n\n      bounds.width =\n        this._getColumnPosition(cell.lastColumn) +\n        this._columnConfig.getItemSize(cell.lastColumn) -\n        this._getColumnPosition(cell.firstColumn);\n\n      bounds.left =\n        this._getColumnPosition(cell.firstColumn) -\n        this._getColumnPosition(firstVisibleColumn);\n\n      return bounds;\n    },\n\n    /**\n     * Get the bounds of a list of cells as returned by {@link #findCellsInWindow}\n     *\n     * @param cells {Map[]} Array of cell descriptions\n     * @param firstVisibleRow {Map} The pane's first visible row\n     * @param firstVisibleColumn {Map} The pane's first visible column\n     * @return {Map[]} Array, which contains a bounds map for each cell.\n     */\n    getCellBounds(cells, firstVisibleRow, firstVisibleColumn) {\n      var bounds = [];\n      for (var i = 0, l = cells.length; i < l; i++) {\n        bounds.push(\n          this._getSingleCellBounds(\n            cells[i],\n            firstVisibleRow,\n            firstVisibleColumn\n          )\n        );\n      }\n      return bounds;\n    },\n\n    /**\n     * Compute a bitmap, which marks for each visible cell, whether the cell\n     * is covered by a spanning cell.\n     *\n     * @param cells {Map[]} Array of cell descriptions as returned by\n     *     {@link #findCellsInWindow}.\n     * @param firstRow {PositiveInteger} first visible row\n     * @param firstColumn {PositiveInteger} first visible column\n     * @param rowCount {PositiveInteger} number of rows in the window\n     * @param columnCount {PositiveInteger} number of columns in the window\n     * @return {Map[][]} Two dimensional array, which contains a <code>1</code>\n     *    for each visible cell, which is covered by a spanned cell.\n     */\n    computeCellSpanMap(cells, firstRow, firstColumn, rowCount, columnCount) {\n      var map = [];\n\n      if (rowCount <= 0) {\n        return map;\n      }\n      var lastRow = firstRow + rowCount - 1;\n\n      for (var i = firstRow; i <= lastRow; i++) {\n        map[i] = [];\n      }\n\n      if (columnCount <= 0) {\n        return map;\n      }\n      var lastColumn = firstColumn + columnCount - 1;\n\n      for (var i = 0, l = cells.length; i < l; i++) {\n        var cell = cells[i];\n\n        var rowStartIndex = Math.max(firstRow, cell.firstRow);\n        var rowEndIndex = Math.min(lastRow, cell.lastRow);\n        var row;\n\n        for (\n          var rowIndex = rowStartIndex;\n          rowIndex <= rowEndIndex;\n          rowIndex++\n        ) {\n          row = map[rowIndex];\n\n          var columnStartIndex = Math.max(firstColumn, cell.firstColumn);\n          var columnEndIndex = Math.min(lastColumn, cell.lastColumn);\n          for (\n            var columnIndex = columnStartIndex;\n            columnIndex <= columnEndIndex;\n            columnIndex++\n          ) {\n            row[columnIndex] = 1;\n          }\n        }\n      }\n\n      return map;\n    }\n  },\n\n  destruct() {\n    this._rowConfig.removeListener(\"change\", this._onRowConfigChange, this);\n    this._columnConfig.removeListener(\n      \"change\",\n      this._onColumnConfigChange,\n      this\n    );\n\n    this._cells =\n      this._sorted =\n      this._rowPos =\n      this._columnPos =\n      this._rowConfig =\n      this._columnConfig =\n        null;\n  }\n});\n"
  ],
  "mappings": ";;;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC;;EAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;AACA;AACA;AACA;EACAH,EAAE,CAACI,KAAH,CAASC,MAAT,CAAgB,qCAAhB,EAAuD;IACrDC,MAAM,EAAEN,EAAE,CAACO,IAAH,CAAQC,MADqC;;IAGrD;AACF;AACA;AACA;AACA;AACA;IACEC,SATqD,qBAS3CC,SAT2C,EAShCC,YATgC,EASlB;MACjC;MAOA,KAAKC,MAAL,GAAc,EAAd;;MACA,KAAKC,oBAAL;;MACA,KAAKC,wBAAL;;MAEAJ,SAAS,CAACK,WAAV,CAAsB,QAAtB,EAAgC,KAAKC,kBAArC,EAAyD,IAAzD;MACAL,YAAY,CAACI,WAAb,CAAyB,QAAzB,EAAmC,KAAKE,qBAAxC,EAA+D,IAA/D;MAEA,KAAKC,UAAL,GAAkBR,SAAlB;MACA,KAAKS,aAAL,GAAqBR,YAArB;IACD,CA1BoD;;IA4BrD;AACF;AACA;AACA;AACA;IAEES,OAAO,EAAE;MACP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,OAXO,mBAWCC,EAXD,EAWKC,GAXL,EAWUC,MAXV,EAWkBC,OAXlB,EAW2BC,UAX3B,EAWuC;QAC5C,KAAKd,MAAL,CAAYU,EAAZ,IAAkB;UAChBK,QAAQ,EAAEJ,GADM;UAEhBK,OAAO,EAAEL,GAAG,GAAGE,OAAN,GAAgB,CAFT;UAGhBI,WAAW,EAAEL,MAHG;UAIhBM,UAAU,EAAEN,MAAM,GAAGE,UAAT,GAAsB,CAJlB;UAKhBJ,EAAE,EAAEA;QALY,CAAlB;;QAQA,KAAKT,oBAAL;MACD,CArBM;;MAuBP;AACJ;AACA;AACA;AACA;MACIkB,UA5BO,sBA4BIT,EA5BJ,EA4BQ;QACb,OAAO,KAAKV,MAAL,CAAYU,EAAZ,CAAP;;QACA,KAAKT,oBAAL;MACD,CA/BM;;MAiCP;AACJ;AACA;MACIA,oBApCO,kCAoCgB;QACrB,KAAKmB,OAAL,GAAe,EAAf;MACD,CAtCM;;MAwCP;AACJ;AACA;AACA;AACA;AACA;AACA;MACIC,eA/CO,2BA+CSC,GA/CT,EA+Cc;QACnB,IAAI,KAAKF,OAAL,CAAaE,GAAb,CAAJ,EAAuB;UACrB,OAAO,KAAKF,OAAL,CAAaE,GAAb,CAAP;QACD;;QACD,IAAIC,MAAM,GAAI,KAAKH,OAAL,CAAaE,GAAb,IAAoB1B,MAAM,CAAC4B,MAAP,CAAc,KAAKxB,MAAnB,CAAlC;QACAuB,MAAM,CAACE,IAAP,CAAY,UAAUC,CAAV,EAAaC,CAAb,EAAgB;UAC1B,OAAOD,CAAC,CAACJ,GAAD,CAAD,GAASK,CAAC,CAACL,GAAD,CAAV,GAAkB,CAAC,CAAnB,GAAuB,CAA9B;QACD,CAFD;QAGA,OAAOC,MAAP;MACD,CAxDM;;MA0DP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIK,iBApEO,6BAoEWN,GApEX,EAoEgBO,GApEhB,EAoEqBC,GApErB,EAoE0B;QAC/B,IAAIC,KAAK,GAAG,KAAKV,eAAL,CAAqBC,GAArB,CAAZ;;QACA,IAAIS,KAAK,CAACC,MAAN,IAAgB,CAApB,EAAuB;UACrB,OAAO,EAAP;QACD;;QAED,IAAIC,KAAK,GAAG,CAAZ;QACA,IAAIC,GAAG,GAAGH,KAAK,CAACC,MAAN,GAAe,CAAzB,CAP+B,CAS/B;;QACA,OAAO,IAAP,EAAa;UACX,IAAIG,KAAK,GAAGF,KAAK,IAAKC,GAAG,GAAGD,KAAP,IAAiB,CAArB,CAAjB;UAEA,IAAIG,IAAI,GAAGL,KAAK,CAACI,KAAD,CAAhB;;UACA,IAAIC,IAAI,CAACd,GAAD,CAAJ,IAAaO,GAAb,KAAqBM,KAAK,IAAI,CAAT,IAAcJ,KAAK,CAACI,KAAK,GAAG,CAAT,CAAL,CAAiBb,GAAjB,IAAwBO,GAA3D,CAAJ,EAAqE;YACnE;YACA;UACD;;UAED,IAAIO,IAAI,CAACd,GAAD,CAAJ,IAAaO,GAAjB,EAAsB;YACpBK,GAAG,GAAGC,KAAK,GAAG,CAAd;UACD,CAFD,MAEO;YACLF,KAAK,GAAGE,KAAK,GAAG,CAAhB;UACD;;UACD,IAAIF,KAAK,GAAGC,GAAZ,EAAiB;YACf;YACA,OAAO,EAAP;UACD;QACF;;QAED,IAAIG,MAAM,GAAG,EAAb;QACA,IAAID,IAAI,GAAGL,KAAK,CAACI,KAAD,CAAhB;;QACA,OAAOC,IAAI,IAAIA,IAAI,CAACd,GAAD,CAAJ,IAAaO,GAArB,IAA4BO,IAAI,CAACd,GAAD,CAAJ,IAAaQ,GAAhD,EAAqD;UACnDO,MAAM,CAACD,IAAI,CAAC1B,EAAN,CAAN,GAAkB0B,IAAlB;UACAA,IAAI,GAAGL,KAAK,CAACI,KAAK,EAAN,CAAZ;QACD;;QACD,OAAOE,MAAP;MACD,CAzGM;;MA2GP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,iBAtHO,6BAsHWvB,QAtHX,EAsHqBE,WAtHrB,EAsHkCsB,QAtHlC,EAsH4CC,WAtH5C,EAsHyD;QAC9D,IAAIC,gBAAgB,GAAG,EAAvB;;QAEA,IAAIF,QAAQ,GAAG,CAAf,EAAkB;UAChB,IAAIvB,OAAO,GAAGD,QAAQ,GAAGwB,QAAX,GAAsB,CAApC;UACAnD,EAAE,CAACsD,IAAH,CAAQ9C,MAAR,CAAe+C,SAAf,CACEF,gBADF,EAEE,KAAKb,iBAAL,CAAuB,UAAvB,EAAmCb,QAAnC,EAA6CC,OAA7C,CAFF;UAKA5B,EAAE,CAACsD,IAAH,CAAQ9C,MAAR,CAAe+C,SAAf,CACEF,gBADF,EAEE,KAAKb,iBAAL,CAAuB,SAAvB,EAAkCb,QAAlC,EAA4CC,OAA5C,CAFF;QAID;;QAED,IAAI4B,kBAAkB,GAAG,EAAzB;;QAEA,IAAIJ,WAAW,GAAG,CAAlB,EAAqB;UACnB,IAAItB,UAAU,GAAGD,WAAW,GAAGuB,WAAd,GAA4B,CAA7C;UACApD,EAAE,CAACsD,IAAH,CAAQ9C,MAAR,CAAe+C,SAAf,CACEC,kBADF,EAEE,KAAKhB,iBAAL,CAAuB,aAAvB,EAAsCX,WAAtC,EAAmDC,UAAnD,CAFF;UAKA9B,EAAE,CAACsD,IAAH,CAAQ9C,MAAR,CAAe+C,SAAf,CACEC,kBADF,EAEE,KAAKhB,iBAAL,CAAuB,YAAvB,EAAqCX,WAArC,EAAkDC,UAAlD,CAFF;QAID;;QAED,OAAO,KAAK2B,SAAL,CAA2BD,kBAA3B,EAA+CH,gBAA/C,CAAP;MACD,CAtJM;;MAwJP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;MACII,SAhKO,qBAgKeC,IAhKf,EAgKqBC,IAhKrB,EAgK2B;QAChC,IAAIC,YAAY,GAAG,EAAnB;;QACA,KAAK,IAAI1B,GAAT,IAAgBwB,IAAhB,EAAsB;UACpB,IAAIC,IAAI,CAACzB,GAAD,CAAR,EAAe;YACb0B,YAAY,CAACC,IAAb,CAAkBF,IAAI,CAACzB,GAAD,CAAtB;UACD;QACF;;QACD,OAAO0B,YAAP;MACD,CAxKM;;MA0KP;AACJ;AACA;AACA;AACA;MACI5C,kBA/KO,8BA+KY8C,CA/KZ,EA+Ke;QACpB,KAAKC,OAAL,GAAe,EAAf;MACD,CAjLM;;MAmLP;AACJ;AACA;AACA;AACA;MACI9C,qBAxLO,iCAwLe6C,CAxLf,EAwLkB;QACvB,KAAKE,UAAL,GAAkB,EAAlB;MACD,CA1LM;;MA4LP;AACJ;AACA;MACIlD,wBA/LO,sCA+LoB;QACzB,KAAKiD,OAAL,GAAe,EAAf;QACA,KAAKC,UAAL,GAAkB,EAAlB;MACD,CAlMM;;MAoMP;AACJ;AACA;AACA;AACA;AACA;MACIC,eA1MO,2BA0MS1C,GA1MT,EA0Mc;QACnB,IAAI2C,GAAG,GAAG,KAAKH,OAAL,CAAaxC,GAAb,CAAV;;QACA,IAAI2C,GAAG,KAAKC,SAAZ,EAAuB;UACrB,OAAOD,GAAP;QACD;;QAEDA,GAAG,GAAG,KAAKH,OAAL,CAAaxC,GAAb,IAAoB,KAAKL,UAAL,CAAgBkD,eAAhB,CAAgC7C,GAAhC,CAA1B;QACA,OAAO2C,GAAP;MACD,CAlNM;;MAoNP;AACJ;AACA;AACA;AACA;AACA;MACIG,kBA1NO,8BA0NY7C,MA1NZ,EA0NoB;QACzB,IAAI0C,GAAG,GAAG,KAAKF,UAAL,CAAgBxC,MAAhB,CAAV;;QACA,IAAI0C,GAAG,KAAKC,SAAZ,EAAuB;UACrB,OAAOD,GAAP;QACD;;QAEDA,GAAG,GAAG,KAAKF,UAAL,CAAgBxC,MAAhB,IACJ,KAAKL,aAAL,CAAmBiD,eAAnB,CAAmC5C,MAAnC,CADF;QAEA,OAAO0C,GAAP;MACD,CAnOM;;MAqOP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACII,oBA/OO,gCA+OctB,IA/Od,EA+OoBuB,eA/OpB,EA+OqCC,kBA/OrC,EA+OyD;QAC9D,IAAIC,MAAM,GAAG;UACXC,IAAI,EAAE,CADK;UAEXC,GAAG,EAAE,CAFM;UAGXC,KAAK,EAAE,CAHI;UAIXC,MAAM,EAAE;QAJG,CAAb;QAOAJ,MAAM,CAACI,MAAP,GACE,KAAKZ,eAAL,CAAqBjB,IAAI,CAACpB,OAA1B,IACA,KAAKV,UAAL,CAAgB4D,WAAhB,CAA4B9B,IAAI,CAACpB,OAAjC,CADA,GAEA,KAAKqC,eAAL,CAAqBjB,IAAI,CAACrB,QAA1B,CAHF;QAKA8C,MAAM,CAACE,GAAP,GACE,KAAKV,eAAL,CAAqBjB,IAAI,CAACrB,QAA1B,IACA,KAAKsC,eAAL,CAAqBM,eAArB,CAFF;QAIAE,MAAM,CAACG,KAAP,GACE,KAAKP,kBAAL,CAAwBrB,IAAI,CAAClB,UAA7B,IACA,KAAKX,aAAL,CAAmB2D,WAAnB,CAA+B9B,IAAI,CAAClB,UAApC,CADA,GAEA,KAAKuC,kBAAL,CAAwBrB,IAAI,CAACnB,WAA7B,CAHF;QAKA4C,MAAM,CAACC,IAAP,GACE,KAAKL,kBAAL,CAAwBrB,IAAI,CAACnB,WAA7B,IACA,KAAKwC,kBAAL,CAAwBG,kBAAxB,CAFF;QAIA,OAAOC,MAAP;MACD,CA1QM;;MA4QP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;MACIM,aApRO,yBAoROpC,KApRP,EAoRc4B,eApRd,EAoR+BC,kBApR/B,EAoRmD;QACxD,IAAIC,MAAM,GAAG,EAAb;;QACA,KAAK,IAAIO,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGtC,KAAK,CAACC,MAA1B,EAAkCoC,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;UAC5CP,MAAM,CAACZ,IAAP,CACE,KAAKS,oBAAL,CACE3B,KAAK,CAACqC,CAAD,CADP,EAEET,eAFF,EAGEC,kBAHF,CADF;QAOD;;QACD,OAAOC,MAAP;MACD,CAhSM;;MAkSP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIS,kBA/SO,8BA+SYvC,KA/SZ,EA+SmBhB,QA/SnB,EA+S6BE,WA/S7B,EA+S0CsB,QA/S1C,EA+SoDC,WA/SpD,EA+SiE;QACtE,IAAI+B,GAAG,GAAG,EAAV;;QAEA,IAAIhC,QAAQ,IAAI,CAAhB,EAAmB;UACjB,OAAOgC,GAAP;QACD;;QACD,IAAIvD,OAAO,GAAGD,QAAQ,GAAGwB,QAAX,GAAsB,CAApC;;QAEA,KAAK,IAAI6B,CAAC,GAAGrD,QAAb,EAAuBqD,CAAC,IAAIpD,OAA5B,EAAqCoD,CAAC,EAAtC,EAA0C;UACxCG,GAAG,CAACH,CAAD,CAAH,GAAS,EAAT;QACD;;QAED,IAAI5B,WAAW,IAAI,CAAnB,EAAsB;UACpB,OAAO+B,GAAP;QACD;;QACD,IAAIrD,UAAU,GAAGD,WAAW,GAAGuB,WAAd,GAA4B,CAA7C;;QAEA,KAAK,IAAI4B,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGtC,KAAK,CAACC,MAA1B,EAAkCoC,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;UAC5C,IAAIhC,IAAI,GAAGL,KAAK,CAACqC,CAAD,CAAhB;UAEA,IAAII,aAAa,GAAGC,IAAI,CAAC3C,GAAL,CAASf,QAAT,EAAmBqB,IAAI,CAACrB,QAAxB,CAApB;UACA,IAAI2D,WAAW,GAAGD,IAAI,CAAC5C,GAAL,CAASb,OAAT,EAAkBoB,IAAI,CAACpB,OAAvB,CAAlB;UACA,IAAIL,GAAJ;;UAEA,KACE,IAAIgE,QAAQ,GAAGH,aADjB,EAEEG,QAAQ,IAAID,WAFd,EAGEC,QAAQ,EAHV,EAIE;YACAhE,GAAG,GAAG4D,GAAG,CAACI,QAAD,CAAT;YAEA,IAAIC,gBAAgB,GAAGH,IAAI,CAAC3C,GAAL,CAASb,WAAT,EAAsBmB,IAAI,CAACnB,WAA3B,CAAvB;YACA,IAAI4D,cAAc,GAAGJ,IAAI,CAAC5C,GAAL,CAASX,UAAT,EAAqBkB,IAAI,CAAClB,UAA1B,CAArB;;YACA,KACE,IAAI4D,WAAW,GAAGF,gBADpB,EAEEE,WAAW,IAAID,cAFjB,EAGEC,WAAW,EAHb,EAIE;cACAnE,GAAG,CAACmE,WAAD,CAAH,GAAmB,CAAnB;YACD;UACF;QACF;;QAED,OAAOP,GAAP;MACD;IA3VM,CAlC4C;IAgYrDQ,QAhYqD,sBAgY1C;MACT,KAAKzE,UAAL,CAAgB0E,cAAhB,CAA+B,QAA/B,EAAyC,KAAK5E,kBAA9C,EAAkE,IAAlE;;MACA,KAAKG,aAAL,CAAmByE,cAAnB,CACE,QADF,EAEE,KAAK3E,qBAFP,EAGE,IAHF;;MAMA,KAAKL,MAAL,GACE,KAAKoB,OAAL,GACA,KAAK+B,OAAL,GACA,KAAKC,UAAL,GACA,KAAK9C,UAAL,GACA,KAAKC,aAAL,GACE,IANJ;IAOD;EA/YoD,CAAvD;EAxBAnB,EAAE,CAAC6F,EAAH,CAAMC,OAAN,CAAcC,KAAd,CAAoBC,eAApB,CAAoC7F,aAApC,GAAoDA,aAApD"
}