{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "rowConfig",
    "columnConfig",
    "constructor",
    "call",
    "_cells",
    "_invalidateSortCache",
    "_invalidatePositionCache",
    "addListener",
    "_onRowConfigChange",
    "_onColumnConfigChange",
    "_rowConfig",
    "_columnConfig",
    "members",
    "addCell",
    "id",
    "row",
    "column",
    "rowSpan",
    "columnSpan",
    "firstRow",
    "lastRow",
    "firstColumn",
    "lastColumn",
    "removeCell",
    "_sorted",
    "_getSortedCells",
    "key",
    "sorted",
    "values",
    "sort",
    "a",
    "b",
    "_findCellsInRange",
    "min",
    "max",
    "cells",
    "length",
    "start",
    "end",
    "pivot",
    "cell",
    "result",
    "findCellsInWindow",
    "rowCount",
    "columnCount",
    "verticalInWindow",
    "lang",
    "mergeWith",
    "horizontalInWindow",
    "__intersectionAsArray",
    "__P_481_0",
    "setA",
    "setB",
    "intersection",
    "push",
    "e",
    "_rowPos",
    "_columnPos",
    "_getRowPosition",
    "pos",
    "undefined",
    "getItemPosition",
    "_getColumnPosition",
    "_getSingleCellBounds",
    "firstVisibleRow",
    "firstVisibleColumn",
    "bounds",
    "left",
    "top",
    "width",
    "height",
    "getItemSize",
    "getCellBounds",
    "i",
    "l",
    "computeCellSpanMap",
    "map",
    "rowStartIndex",
    "Math",
    "rowEndIndex",
    "rowIndex",
    "columnStartIndex",
    "columnEndIndex",
    "columnIndex",
    "destruct",
    "removeListener",
    "ui",
    "virtual",
    "layer",
    "CellSpanManager"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/virtual/layer/CellSpanManager.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Fabian Jakobs (fjakobs)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * The CellSpanManager manages cells, which span several rows or columns.\r\n *\r\n * It provides functionality to compute, which spanning cells are visible\r\n * in a given view port and how they have to be placed.\r\n */\r\nqx.Class.define(\"qx.ui.virtual.layer.CellSpanManager\", {\r\n  extend: qx.core.Object,\r\n\r\n  /**\r\n   * @param rowConfig {qx.ui.virtual.core.Axis} The row configuration of the pane\r\n   *    in which the cells will be rendered\r\n   * @param columnConfig {qx.ui.virtual.core.Axis} The column configuration of the pane\r\n   *    in which the cells will be rendered\r\n   */\r\n  construct(rowConfig, columnConfig) {\r\n    super();\r\n\r\n    if (qx.core.Environment.get(\"qx.debug\")) {\r\n      this.assertInstance(rowConfig, qx.ui.virtual.core.Axis);\r\n      this.assertInstance(columnConfig, qx.ui.virtual.core.Axis);\r\n    }\r\n\r\n    this._cells = {};\r\n    this._invalidateSortCache();\r\n    this._invalidatePositionCache();\r\n\r\n    rowConfig.addListener(\"change\", this._onRowConfigChange, this);\r\n    columnConfig.addListener(\"change\", this._onColumnConfigChange, this);\r\n\r\n    this._rowConfig = rowConfig;\r\n    this._columnConfig = columnConfig;\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     MEMBERS\r\n  *****************************************************************************\r\n  */\r\n\r\n  members: {\r\n    /**\r\n     * Add a spanning cell to the manager.\r\n     *\r\n     * @param id {String} Unique id for the cell definition. This id is required\r\n     *    for removing the cell from the manager\r\n     * @param row {PositiveInteger} The cell's row\r\n     * @param column {PositiveInteger} The cell's column\r\n     * @param rowSpan {PositiveInteger} The number of rows the cells spans\r\n     * @param columnSpan {PositiveInteger} The number of columns the cells spans\r\n     */\r\n    addCell(id, row, column, rowSpan, columnSpan) {\r\n      this._cells[id] = {\r\n        firstRow: row,\r\n        lastRow: row + rowSpan - 1,\r\n        firstColumn: column,\r\n        lastColumn: column + columnSpan - 1,\r\n        id: id\r\n      };\r\n\r\n      this._invalidateSortCache();\r\n    },\r\n\r\n    /**\r\n     * Remove a cell from the manager\r\n     *\r\n     * @param id {String} The id of the cell to remove\r\n     */\r\n    removeCell(id) {\r\n      delete this._cells[id];\r\n      this._invalidateSortCache();\r\n    },\r\n\r\n    /**\r\n     * Invalidate the sort cache\r\n     */\r\n    _invalidateSortCache() {\r\n      this._sorted = {};\r\n    },\r\n\r\n    /**\r\n     * Get the cell array sorted by the given key (ascending)\r\n     *\r\n     * @param key {String} The sort key. One of <code>firstRow</code>,\r\n     *     <code>lastRow</code>, <code>firstColumn</code> or <code>lastColumn</code>\r\n     * @return {Map[]} sorted array of cell descriptions\r\n     */\r\n    _getSortedCells(key) {\r\n      if (this._sorted[key]) {\r\n        return this._sorted[key];\r\n      }\r\n      var sorted = (this._sorted[key] = Object.values(this._cells));\r\n      sorted.sort(function (a, b) {\r\n        return a[key] < b[key] ? -1 : 1;\r\n      });\r\n      return sorted;\r\n    },\r\n\r\n    /**\r\n     * Finds all cells with a sort key within the given range.\r\n     *\r\n     * Complexity: O(log n)\r\n     *\r\n     * @param key {String} The key to search for\r\n     * @param min {Integer} minimum value\r\n     * @param max {Integer} maximum value (inclusive)\r\n     * @return {Map} Map, which will contain the search results\r\n     */\r\n    _findCellsInRange(key, min, max) {\r\n      var cells = this._getSortedCells(key);\r\n      if (cells.length == 0) {\r\n        return {};\r\n      }\r\n\r\n      var start = 0;\r\n      var end = cells.length - 1;\r\n\r\n      // find first cell, which is >= \"min\"\r\n      while (true) {\r\n        var pivot = start + ((end - start) >> 1);\r\n\r\n        var cell = cells[pivot];\r\n        if (cell[key] >= min && (pivot == 0 || cells[pivot - 1][key] < min)) {\r\n          // the start cell was found\r\n          break;\r\n        }\r\n\r\n        if (cell[key] >= min) {\r\n          end = pivot - 1;\r\n        } else {\r\n          start = pivot + 1;\r\n        }\r\n        if (start > end) {\r\n          // nothing found\r\n          return {};\r\n        }\r\n      }\r\n\r\n      var result = {};\r\n      var cell = cells[pivot];\r\n      while (cell && cell[key] >= min && cell[key] <= max) {\r\n        result[cell.id] = cell;\r\n        cell = cells[pivot++];\r\n      }\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Find all cells, which are visible in the given grid window.\r\n     *\r\n     * @param firstRow {PositiveInteger} first visible row\r\n     * @param firstColumn {PositiveInteger} first visible column\r\n     * @param rowCount {PositiveInteger} number of rows in the window\r\n     * @param columnCount {PositiveInteger} number of columns in the window\r\n     * @return {Map[]} The array of found cell descriptions. A cell description\r\n     *    contains the keys <code>firstRow</code>, <code>lastRow</code>,\r\n     *    <code>firstColumn</code> or <code>lastColumn</code>\r\n     */\r\n    findCellsInWindow(firstRow, firstColumn, rowCount, columnCount) {\r\n      var verticalInWindow = {};\r\n\r\n      if (rowCount > 0) {\r\n        var lastRow = firstRow + rowCount - 1;\r\n        qx.lang.Object.mergeWith(\r\n          verticalInWindow,\r\n          this._findCellsInRange(\"firstRow\", firstRow, lastRow)\r\n        );\r\n\r\n        qx.lang.Object.mergeWith(\r\n          verticalInWindow,\r\n          this._findCellsInRange(\"lastRow\", firstRow, lastRow)\r\n        );\r\n      }\r\n\r\n      var horizontalInWindow = {};\r\n\r\n      if (columnCount > 0) {\r\n        var lastColumn = firstColumn + columnCount - 1;\r\n        qx.lang.Object.mergeWith(\r\n          horizontalInWindow,\r\n          this._findCellsInRange(\"firstColumn\", firstColumn, lastColumn)\r\n        );\r\n\r\n        qx.lang.Object.mergeWith(\r\n          horizontalInWindow,\r\n          this._findCellsInRange(\"lastColumn\", firstColumn, lastColumn)\r\n        );\r\n      }\r\n\r\n      return this.__intersectionAsArray(horizontalInWindow, verticalInWindow);\r\n    },\r\n\r\n    /**\r\n     * Return the intersection of two maps as an array. The objects intersect if\r\n     * they have the same keys.\r\n     *\r\n     * @param setA {Object} The first map\r\n     * @param setB {Object} The second map\r\n     * @return {String[]} An array keys found in both maps\r\n     */\r\n    __intersectionAsArray(setA, setB) {\r\n      var intersection = [];\r\n      for (var key in setA) {\r\n        if (setB[key]) {\r\n          intersection.push(setB[key]);\r\n        }\r\n      }\r\n      return intersection;\r\n    },\r\n\r\n    /**\r\n     * Event handler for row configuration changes\r\n     *\r\n     * @param e {qx.event.type.Event} the event object\r\n     */\r\n    _onRowConfigChange(e) {\r\n      this._rowPos = [];\r\n    },\r\n\r\n    /**\r\n     * Event handler for column configuration changes\r\n     *\r\n     * @param e {qx.event.type.Event} the event object\r\n     */\r\n    _onColumnConfigChange(e) {\r\n      this._columnPos = [];\r\n    },\r\n\r\n    /**\r\n     * Invalidates the row/column position cache\r\n     */\r\n    _invalidatePositionCache() {\r\n      this._rowPos = [];\r\n      this._columnPos = [];\r\n    },\r\n\r\n    /**\r\n     * Get the pixel start position of the given row\r\n     *\r\n     * @param row {Integer} The row index\r\n     * @return {Integer} The pixel start position of the given row\r\n     */\r\n    _getRowPosition(row) {\r\n      var pos = this._rowPos[row];\r\n      if (pos !== undefined) {\r\n        return pos;\r\n      }\r\n\r\n      pos = this._rowPos[row] = this._rowConfig.getItemPosition(row);\r\n      return pos;\r\n    },\r\n\r\n    /**\r\n     * Get the pixel start position of the given column\r\n     *\r\n     * @param column {Integer} The column index\r\n     * @return {Integer} The pixel start position of the given column\r\n     */\r\n    _getColumnPosition(column) {\r\n      var pos = this._columnPos[column];\r\n      if (pos !== undefined) {\r\n        return pos;\r\n      }\r\n\r\n      pos = this._columnPos[column] =\r\n        this._columnConfig.getItemPosition(column);\r\n      return pos;\r\n    },\r\n\r\n    /**\r\n     * Get the bounds of a single cell\r\n     *\r\n     * @param cell {Map} the cell description as returned by\r\n     *    {@link #findCellsInWindow} to get the bounds for\r\n     * @param firstVisibleRow {Map} The pane's first visible row\r\n     * @param firstVisibleColumn {Map} The pane's first visible column\r\n     * @return {Map} Boundaries map with the keys <code>left</code>,\r\n     * <code>top</code>, <code>width</code> and <code>height</code>\r\n     */\r\n    _getSingleCellBounds(cell, firstVisibleRow, firstVisibleColumn) {\r\n      var bounds = {\r\n        left: 0,\r\n        top: 0,\r\n        width: 0,\r\n        height: 0\r\n      };\r\n\r\n      bounds.height =\r\n        this._getRowPosition(cell.lastRow) +\r\n        this._rowConfig.getItemSize(cell.lastRow) -\r\n        this._getRowPosition(cell.firstRow);\r\n\r\n      bounds.top =\r\n        this._getRowPosition(cell.firstRow) -\r\n        this._getRowPosition(firstVisibleRow);\r\n\r\n      bounds.width =\r\n        this._getColumnPosition(cell.lastColumn) +\r\n        this._columnConfig.getItemSize(cell.lastColumn) -\r\n        this._getColumnPosition(cell.firstColumn);\r\n\r\n      bounds.left =\r\n        this._getColumnPosition(cell.firstColumn) -\r\n        this._getColumnPosition(firstVisibleColumn);\r\n\r\n      return bounds;\r\n    },\r\n\r\n    /**\r\n     * Get the bounds of a list of cells as returned by {@link #findCellsInWindow}\r\n     *\r\n     * @param cells {Map[]} Array of cell descriptions\r\n     * @param firstVisibleRow {Map} The pane's first visible row\r\n     * @param firstVisibleColumn {Map} The pane's first visible column\r\n     * @return {Map[]} Array, which contains a bounds map for each cell.\r\n     */\r\n    getCellBounds(cells, firstVisibleRow, firstVisibleColumn) {\r\n      var bounds = [];\r\n      for (var i = 0, l = cells.length; i < l; i++) {\r\n        bounds.push(\r\n          this._getSingleCellBounds(\r\n            cells[i],\r\n            firstVisibleRow,\r\n            firstVisibleColumn\r\n          )\r\n        );\r\n      }\r\n      return bounds;\r\n    },\r\n\r\n    /**\r\n     * Compute a bitmap, which marks for each visible cell, whether the cell\r\n     * is covered by a spanning cell.\r\n     *\r\n     * @param cells {Map[]} Array of cell descriptions as returned by\r\n     *     {@link #findCellsInWindow}.\r\n     * @param firstRow {PositiveInteger} first visible row\r\n     * @param firstColumn {PositiveInteger} first visible column\r\n     * @param rowCount {PositiveInteger} number of rows in the window\r\n     * @param columnCount {PositiveInteger} number of columns in the window\r\n     * @return {Map[][]} Two dimensional array, which contains a <code>1</code>\r\n     *    for each visible cell, which is covered by a spanned cell.\r\n     */\r\n    computeCellSpanMap(cells, firstRow, firstColumn, rowCount, columnCount) {\r\n      var map = [];\r\n\r\n      if (rowCount <= 0) {\r\n        return map;\r\n      }\r\n      var lastRow = firstRow + rowCount - 1;\r\n\r\n      for (var i = firstRow; i <= lastRow; i++) {\r\n        map[i] = [];\r\n      }\r\n\r\n      if (columnCount <= 0) {\r\n        return map;\r\n      }\r\n      var lastColumn = firstColumn + columnCount - 1;\r\n\r\n      for (var i = 0, l = cells.length; i < l; i++) {\r\n        var cell = cells[i];\r\n\r\n        var rowStartIndex = Math.max(firstRow, cell.firstRow);\r\n        var rowEndIndex = Math.min(lastRow, cell.lastRow);\r\n        var row;\r\n\r\n        for (\r\n          var rowIndex = rowStartIndex;\r\n          rowIndex <= rowEndIndex;\r\n          rowIndex++\r\n        ) {\r\n          row = map[rowIndex];\r\n\r\n          var columnStartIndex = Math.max(firstColumn, cell.firstColumn);\r\n          var columnEndIndex = Math.min(lastColumn, cell.lastColumn);\r\n          for (\r\n            var columnIndex = columnStartIndex;\r\n            columnIndex <= columnEndIndex;\r\n            columnIndex++\r\n          ) {\r\n            row[columnIndex] = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      return map;\r\n    }\r\n  },\r\n\r\n  destruct() {\r\n    this._rowConfig.removeListener(\"change\", this._onRowConfigChange, this);\r\n    this._columnConfig.removeListener(\r\n      \"change\",\r\n      this._onColumnConfigChange,\r\n      this\r\n    );\r\n\r\n    this._cells =\r\n      this._sorted =\r\n      this._rowPos =\r\n      this._columnPos =\r\n      this._rowConfig =\r\n      this._columnConfig =\r\n        null;\r\n  }\r\n});\r\n"
  ],
  "mappings": "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"
}