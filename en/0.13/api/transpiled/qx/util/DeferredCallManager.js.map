{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "type",
    "implement",
    "IDisposable",
    "construct",
    "__calls",
    "__timeoutWrapper",
    "lang",
    "Function",
    "bind",
    "__timeout",
    "__hasCalls",
    "members",
    "__timeoutId",
    "__currentQueue",
    "schedule",
    "deferredCall",
    "window",
    "setTimeout",
    "callKey",
    "toHashCode",
    "refreshTimeout",
    "cancel",
    "isEmpty",
    "clearTimeout",
    "event",
    "GlobalError",
    "observeMethod",
    "clone",
    "key",
    "call",
    "destruct",
    "util",
    "DeferredCallManager"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/util/DeferredCallManager.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * This class manages the timer used for deferred calls. All\n * {@link qx.util.DeferredCall} instances use the single timer from this class.\n *\n * NOTE: Instances of this class must be disposed of after use\n *\n */\nqx.Class.define(\"qx.util.DeferredCallManager\", {\n  extend: qx.core.Object,\n  type: \"singleton\",\n  implement: [qx.core.IDisposable],\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  construct() {\n    this.__calls = {};\n    this.__timeoutWrapper = qx.lang.Function.bind(this.__timeout, this);\n    this.__hasCalls = false;\n  },\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members: {\n    __timeoutId: null,\n    __currentQueue: null,\n    __calls: null,\n    __hasCalls: null,\n    __timeoutWrapper: null,\n\n    /**\n     * Schedule a deferred call\n     *\n     * @param deferredCall {qx.util.DeferredCall} The call to schedule\n     */\n    schedule(deferredCall) {\n      if (this.__timeoutId == null) {\n        this.__timeoutId = window.setTimeout(this.__timeoutWrapper, 0);\n      }\n\n      var callKey = deferredCall.toHashCode();\n\n      // the flush is currently running and the call is already\n      // scheduled\n      if (this.__currentQueue && this.__currentQueue[callKey]) {\n        return;\n      }\n\n      this.__calls[callKey] = deferredCall;\n      this.__hasCalls = true;\n    },\n\n    /**\n     * Refresh the timeout if the current one is not active anymore.\n     * This is a very special case which can happen in unit tests using\n     * fakeTimers, which overrides the window.setTimeout function (amongst others)\n     * after restoring the sinon sandbox the timeout must be refreshed otherwise\n     * DeferredCalls would never fire.\n     */\n    refreshTimeout() {\n      if (this.__timeoutId !== null) {\n        this.__timeoutId = window.setTimeout(this.__timeoutWrapper, 0);\n      }\n    },\n\n    /**\n     * Cancel a scheduled deferred call\n     *\n     * @param deferredCall {qx.util.DeferredCall} The call to schedule\n     */\n    cancel(deferredCall) {\n      var callKey = deferredCall.toHashCode();\n\n      // the flush is currently running and the call is already\n      // scheduled -> remove it from the current queue\n      if (this.__currentQueue && this.__currentQueue[callKey]) {\n        this.__currentQueue[callKey] = null;\n        return;\n      }\n\n      delete this.__calls[callKey];\n\n      // stop timer if no other calls are waiting\n      if (qx.lang.Object.isEmpty(this.__calls) && this.__timeoutId != null) {\n        window.clearTimeout(this.__timeoutId);\n        this.__timeoutId = null;\n      }\n    },\n\n    /**\n     * Helper function for the timer.\n     *\n     * @signature function()\n     */\n    __timeout: qx.event.GlobalError.observeMethod(function () {\n      this.__timeoutId = null;\n\n      // the queue may change while doing the flush so we work on a copy of\n      // the queue and loop while the queue has any entries.\n      while (this.__hasCalls) {\n        this.__currentQueue = qx.lang.Object.clone(this.__calls);\n        this.__calls = {};\n        this.__hasCalls = false;\n\n        for (var key in this.__currentQueue) {\n          var call = this.__currentQueue[key];\n          if (call) {\n            this.__currentQueue[key] = null;\n            call.call();\n          }\n        }\n      }\n\n      this.__currentQueue = null;\n    })\n  },\n\n  /*\n  *****************************************************************************\n     DESTRUCTOR\n  *****************************************************************************\n  */\n\n  destruct() {\n    if (this.__timeoutId != null) {\n      window.clearTimeout(this.__timeoutId);\n    }\n    this.__timeoutWrapper = this.__calls = null;\n  }\n});\n"
  ],
  "mappings": "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"
}