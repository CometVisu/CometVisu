{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "extend",
    "Object",
    "construct",
    "maxEntries",
    "setMaxEntries",
    "members",
    "__nextIndexToStoreTo",
    "__entriesStored",
    "__isMarkActive",
    "__entriesStoredSinceMark",
    "__entries",
    "__maxEntries",
    "clear",
    "getMaxEntries",
    "addEntry",
    "entry",
    "__addToIndex",
    "max",
    "getNumEntriesStored",
    "mark",
    "clearMark",
    "getAllEntries",
    "getEntries",
    "count",
    "startingFromMark",
    "indexOfYoungestElementInHistory",
    "startIndex",
    "result",
    "slice",
    "concat",
    "Array",
    "__P_510_6",
    "idx",
    "addMe",
    "util",
    "RingBuffer"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/util/RingBuffer.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2006 STZ-IDA, Germany, http://www.stz-ida.de\n     2009 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Carsten Lergenmueller (carstenl)\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * An memory container which stores arbitrary data up to a maximum number of\n * entries. When new entries come in an the maximum is reached, the oldest\n * entries are deleted.\n *\n * A mark feature also exists which can be used to remember a point in time.\n * When retrieving entries, it is possible to get only those entries\n * after the marked time. This is useful if data from the buffer is extracted\n * and processed. Whenever this happens, a mark() call can be used so that the\n * next extraction will only get new data.\n */\nqx.Bootstrap.define(\"qx.util.RingBuffer\", {\n  extend: Object,\n\n  /**\n   * Constructor.\n   *\n   * @param maxEntries {Integer ? 50} Maximum number of entries in the buffer\n   */\n  construct(maxEntries) {\n    this.setMaxEntries(maxEntries || 50);\n  },\n\n  members: {\n    //Next slot in ringbuffer to use\n    __nextIndexToStoreTo: 0,\n\n    //Number of elements in ring buffer\n    __entriesStored: 0,\n\n    //Was a mark set?\n    __isMarkActive: false,\n\n    //How many elements were stored since setting of mark?\n    __entriesStoredSinceMark: 0,\n\n    //ring buffer\n    __entries: null,\n\n    //Maximum number of messages to store. Could be converted to a qx property.\n    __maxEntries: null,\n\n    /**\n     * Set the maximum number of messages to hold. If null the number of\n     * messages is not limited.\n     *\n     * Warning: Changing this property will clear the events logged so far.\n     *\n     * @param maxEntries {Integer} the maximum number of messages to hold\n     */\n    setMaxEntries(maxEntries) {\n      this.__maxEntries = maxEntries;\n      this.clear();\n    },\n\n    /**\n     * Get the maximum number of entries to hold\n     *\n     * @return {Integer}\n     */\n    getMaxEntries() {\n      return this.__maxEntries;\n    },\n\n    /**\n     * Adds a single entry\n     *\n     * @param entry {var} The data to store\n     */\n    addEntry(entry) {\n      this.__entries[this.__nextIndexToStoreTo] = entry;\n\n      this.__nextIndexToStoreTo = this.__addToIndex(\n        this.__nextIndexToStoreTo,\n        1\n      );\n\n      //Count # of stored entries\n      var max = this.getMaxEntries();\n      if (this.__entriesStored < max) {\n        this.__entriesStored++;\n      }\n\n      //Count # of stored elements since last mark call\n      if (this.__isMarkActive && this.__entriesStoredSinceMark < max) {\n        this.__entriesStoredSinceMark++;\n      }\n    },\n\n    /**\n     * Returns the number of entries stored\n     * @return {Integer}\n     */\n    getNumEntriesStored() {\n      return this.__entriesStored;\n    },\n\n    /**\n     * Remembers the current position in the ring buffer\n     *\n     */\n    mark() {\n      this.__isMarkActive = true;\n      this.__entriesStoredSinceMark = 0;\n    },\n\n    /**\n     * Removes the current mark position\n     */\n    clearMark() {\n      this.__isMarkActive = false;\n    },\n\n    /**\n     * Returns all stored entries. Mark is ignored.\n     *\n     * @return {Array} array of stored entries\n     */\n    getAllEntries() {\n      return this.getEntries(this.getMaxEntries(), false);\n    },\n\n    /**\n     * Returns entries which have been added previously.\n     *\n     * @param count {Integer} The number of entries to retrieve. If there are\n     *    more entries than the given count, the oldest ones will not be returned.\n     *\n     * @param startingFromMark {Boolean ? false} If true, only entries since\n     *   the last call to mark() will be returned\n     * @return {Array} array of stored entries\n     */\n    getEntries(count, startingFromMark) {\n      //Trim count so it does not exceed ringbuffer size\n      if (count > this.__entriesStored) {\n        count = this.__entriesStored;\n      }\n\n      // Trim count so it does not exceed last call to mark (if mark was called\n      // and startingFromMark was true)\n      if (\n        startingFromMark &&\n        this.__isMarkActive &&\n        count > this.__entriesStoredSinceMark\n      ) {\n        count = this.__entriesStoredSinceMark;\n      }\n\n      if (count > 0) {\n        var indexOfYoungestElementInHistory = this.__addToIndex(\n          this.__nextIndexToStoreTo,\n          -1\n        );\n\n        var startIndex = this.__addToIndex(\n          indexOfYoungestElementInHistory,\n          -count + 1\n        );\n\n        var result;\n\n        if (startIndex <= indexOfYoungestElementInHistory) {\n          //Requested segment not wrapping around ringbuffer boundary, get in one run\n          result = this.__entries.slice(\n            startIndex,\n            indexOfYoungestElementInHistory + 1\n          );\n        } else {\n          //Requested segment wrapping around ringbuffer boundary, get two parts & concat\n          result = this.__entries\n            .slice(startIndex, this.__entriesStored)\n            .concat(\n              this.__entries.slice(0, indexOfYoungestElementInHistory + 1)\n            );\n        }\n      } else {\n        result = [];\n      }\n\n      return result;\n    },\n\n    /**\n     * Clears all entries\n     */\n    clear() {\n      this.__entries = new Array(this.getMaxEntries());\n      this.__entriesStored = 0;\n      this.__entriesStoredSinceMark = 0;\n      this.__nextIndexToStoreTo = 0;\n    },\n\n    /**\n     * Adds a number to an ringbuffer index. Does a modulus calculation,\n     * i. e. if the index leaves the ringbuffer space it will wrap around to\n     * the other end of the ringbuffer.\n     *\n     * @param idx {Number} The current index.\n     * @param addMe {Number} The number to add.\n     * @return {Number} The new index\n     */\n    __addToIndex(idx, addMe) {\n      var max = this.getMaxEntries();\n      var result = (idx + addMe) % max;\n\n      //If negative, wrap up into the ringbuffer space\n      if (result < 0) {\n        result += max;\n      }\n      return result;\n    }\n  }\n});\n"
  ],
  "mappings": "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"
}