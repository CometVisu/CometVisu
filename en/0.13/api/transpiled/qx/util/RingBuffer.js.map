{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "extend",
    "Object",
    "construct",
    "maxEntries",
    "setMaxEntries",
    "members",
    "__nextIndexToStoreTo",
    "__entriesStored",
    "__isMarkActive",
    "__entriesStoredSinceMark",
    "__entries",
    "__maxEntries",
    "clear",
    "getMaxEntries",
    "addEntry",
    "entry",
    "__addToIndex",
    "max",
    "getNumEntriesStored",
    "mark",
    "clearMark",
    "getAllEntries",
    "getEntries",
    "count",
    "startingFromMark",
    "indexOfYoungestElementInHistory",
    "startIndex",
    "result",
    "slice",
    "concat",
    "Array",
    "__P_510_6",
    "idx",
    "addMe",
    "util",
    "RingBuffer"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/util/RingBuffer.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2006 STZ-IDA, Germany, http://www.stz-ida.de\r\n     2009 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Carsten Lergenmueller (carstenl)\r\n     * Fabian Jakobs (fjakobs)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * An memory container which stores arbitrary data up to a maximum number of\r\n * entries. When new entries come in an the maximum is reached, the oldest\r\n * entries are deleted.\r\n *\r\n * A mark feature also exists which can be used to remember a point in time.\r\n * When retrieving entries, it is possible to get only those entries\r\n * after the marked time. This is useful if data from the buffer is extracted\r\n * and processed. Whenever this happens, a mark() call can be used so that the\r\n * next extraction will only get new data.\r\n */\r\nqx.Bootstrap.define(\"qx.util.RingBuffer\", {\r\n  extend: Object,\r\n\r\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param maxEntries {Integer ? 50} Maximum number of entries in the buffer\r\n   */\r\n  construct(maxEntries) {\r\n    this.setMaxEntries(maxEntries || 50);\r\n  },\r\n\r\n  members: {\r\n    //Next slot in ringbuffer to use\r\n    __nextIndexToStoreTo: 0,\r\n\r\n    //Number of elements in ring buffer\r\n    __entriesStored: 0,\r\n\r\n    //Was a mark set?\r\n    __isMarkActive: false,\r\n\r\n    //How many elements were stored since setting of mark?\r\n    __entriesStoredSinceMark: 0,\r\n\r\n    //ring buffer\r\n    __entries: null,\r\n\r\n    //Maximum number of messages to store. Could be converted to a qx property.\r\n    __maxEntries: null,\r\n\r\n    /**\r\n     * Set the maximum number of messages to hold. If null the number of\r\n     * messages is not limited.\r\n     *\r\n     * Warning: Changing this property will clear the events logged so far.\r\n     *\r\n     * @param maxEntries {Integer} the maximum number of messages to hold\r\n     */\r\n    setMaxEntries(maxEntries) {\r\n      this.__maxEntries = maxEntries;\r\n      this.clear();\r\n    },\r\n\r\n    /**\r\n     * Get the maximum number of entries to hold\r\n     *\r\n     * @return {Integer}\r\n     */\r\n    getMaxEntries() {\r\n      return this.__maxEntries;\r\n    },\r\n\r\n    /**\r\n     * Adds a single entry\r\n     *\r\n     * @param entry {var} The data to store\r\n     */\r\n    addEntry(entry) {\r\n      this.__entries[this.__nextIndexToStoreTo] = entry;\r\n\r\n      this.__nextIndexToStoreTo = this.__addToIndex(\r\n        this.__nextIndexToStoreTo,\r\n        1\r\n      );\r\n\r\n      //Count # of stored entries\r\n      var max = this.getMaxEntries();\r\n      if (this.__entriesStored < max) {\r\n        this.__entriesStored++;\r\n      }\r\n\r\n      //Count # of stored elements since last mark call\r\n      if (this.__isMarkActive && this.__entriesStoredSinceMark < max) {\r\n        this.__entriesStoredSinceMark++;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns the number of entries stored\r\n     * @return {Integer}\r\n     */\r\n    getNumEntriesStored() {\r\n      return this.__entriesStored;\r\n    },\r\n\r\n    /**\r\n     * Remembers the current position in the ring buffer\r\n     *\r\n     */\r\n    mark() {\r\n      this.__isMarkActive = true;\r\n      this.__entriesStoredSinceMark = 0;\r\n    },\r\n\r\n    /**\r\n     * Removes the current mark position\r\n     */\r\n    clearMark() {\r\n      this.__isMarkActive = false;\r\n    },\r\n\r\n    /**\r\n     * Returns all stored entries. Mark is ignored.\r\n     *\r\n     * @return {Array} array of stored entries\r\n     */\r\n    getAllEntries() {\r\n      return this.getEntries(this.getMaxEntries(), false);\r\n    },\r\n\r\n    /**\r\n     * Returns entries which have been added previously.\r\n     *\r\n     * @param count {Integer} The number of entries to retrieve. If there are\r\n     *    more entries than the given count, the oldest ones will not be returned.\r\n     *\r\n     * @param startingFromMark {Boolean ? false} If true, only entries since\r\n     *   the last call to mark() will be returned\r\n     * @return {Array} array of stored entries\r\n     */\r\n    getEntries(count, startingFromMark) {\r\n      //Trim count so it does not exceed ringbuffer size\r\n      if (count > this.__entriesStored) {\r\n        count = this.__entriesStored;\r\n      }\r\n\r\n      // Trim count so it does not exceed last call to mark (if mark was called\r\n      // and startingFromMark was true)\r\n      if (\r\n        startingFromMark &&\r\n        this.__isMarkActive &&\r\n        count > this.__entriesStoredSinceMark\r\n      ) {\r\n        count = this.__entriesStoredSinceMark;\r\n      }\r\n\r\n      if (count > 0) {\r\n        var indexOfYoungestElementInHistory = this.__addToIndex(\r\n          this.__nextIndexToStoreTo,\r\n          -1\r\n        );\r\n\r\n        var startIndex = this.__addToIndex(\r\n          indexOfYoungestElementInHistory,\r\n          -count + 1\r\n        );\r\n\r\n        var result;\r\n\r\n        if (startIndex <= indexOfYoungestElementInHistory) {\r\n          //Requested segment not wrapping around ringbuffer boundary, get in one run\r\n          result = this.__entries.slice(\r\n            startIndex,\r\n            indexOfYoungestElementInHistory + 1\r\n          );\r\n        } else {\r\n          //Requested segment wrapping around ringbuffer boundary, get two parts & concat\r\n          result = this.__entries\r\n            .slice(startIndex, this.__entriesStored)\r\n            .concat(\r\n              this.__entries.slice(0, indexOfYoungestElementInHistory + 1)\r\n            );\r\n        }\r\n      } else {\r\n        result = [];\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Clears all entries\r\n     */\r\n    clear() {\r\n      this.__entries = new Array(this.getMaxEntries());\r\n      this.__entriesStored = 0;\r\n      this.__entriesStoredSinceMark = 0;\r\n      this.__nextIndexToStoreTo = 0;\r\n    },\r\n\r\n    /**\r\n     * Adds a number to an ringbuffer index. Does a modulus calculation,\r\n     * i. e. if the index leaves the ringbuffer space it will wrap around to\r\n     * the other end of the ringbuffer.\r\n     *\r\n     * @param idx {Number} The current index.\r\n     * @param addMe {Number} The number to add.\r\n     * @return {Number} The new index\r\n     */\r\n    __addToIndex(idx, addMe) {\r\n      var max = this.getMaxEntries();\r\n      var result = (idx + addMe) % max;\r\n\r\n      //If negative, wrap up into the ringbuffer space\r\n      if (result < 0) {\r\n        result += max;\r\n      }\r\n      return result;\r\n    }\r\n  }\r\n});\r\n"
  ],
  "mappings": ";;;;;;;;;EAAAA,EAAE,CAACC,SAAS,CAACC,oBAAoB,CAACC,aAAa,CAAC;EAAhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAH,EAAE,CAACC,SAAS,CAACG,MAAM,CAAC,oBAAoB,EAAE;IACxCC,MAAM,EAAEC,MAAM;IAEd;AACF;AACA;AACA;AACA;IACEC,SAAS,WAAAA,UAACC,UAAU,EAAE;MACpB,IAAI,CAACC,aAAa,CAACD,UAAU,IAAI,EAAE,CAAC;IACtC,CAAC;IAEDE,OAAO,EAAE;MACP;MACAC,SAAoB,EAAE,CAAC;MAEvB;MACAC,SAAe,EAAE,CAAC;MAElB;MACAC,SAAc,EAAE,KAAK;MAErB;MACAC,SAAwB,EAAE,CAAC;MAE3B;MACAC,SAAS,EAAE,IAAI;MAEf;MACAC,SAAY,EAAE,IAAI;MAElB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;MACIP,aAAa,WAAAA,cAACD,UAAU,EAAE;QACxB,IAAI,CAACQ,SAAY,GAAGR,UAAU;QAC9B,IAAI,CAACS,KAAK,CAAC,CAAC;MACd,CAAC;MAED;AACJ;AACA;AACA;AACA;MACIC,aAAa,WAAAA,cAAA,EAAG;QACd,OAAO,IAAI,CAACF,SAAY;MAC1B,CAAC;MAED;AACJ;AACA;AACA;AACA;MACIG,QAAQ,WAAAA,SAACC,KAAK,EAAE;QACd,IAAI,CAACL,SAAS,CAAC,IAAI,CAACJ,SAAoB,CAAC,GAAGS,KAAK;QAEjD,IAAI,CAACT,SAAoB,GAAG,IAAI,CAACU,SAAY,CAC3C,IAAI,CAACV,SAAoB,EACzB,CACF,CAAC;;QAED;QACA,IAAIW,GAAG,GAAG,IAAI,CAACJ,aAAa,CAAC,CAAC;QAC9B,IAAI,IAAI,CAACN,SAAe,GAAGU,GAAG,EAAE;UAC9B,IAAI,CAACV,SAAe,EAAE;QACxB;;QAEA;QACA,IAAI,IAAI,CAACC,SAAc,IAAI,IAAI,CAACC,SAAwB,GAAGQ,GAAG,EAAE;UAC9D,IAAI,CAACR,SAAwB,EAAE;QACjC;MACF,CAAC;MAED;AACJ;AACA;AACA;MACIS,mBAAmB,WAAAA,oBAAA,EAAG;QACpB,OAAO,IAAI,CAACX,SAAe;MAC7B,CAAC;MAED;AACJ;AACA;AACA;MACIY,IAAI,WAAAA,KAAA,EAAG;QACL,IAAI,CAACX,SAAc,GAAG,IAAI;QAC1B,IAAI,CAACC,SAAwB,GAAG,CAAC;MACnC,CAAC;MAED;AACJ;AACA;MACIW,SAAS,WAAAA,UAAA,EAAG;QACV,IAAI,CAACZ,SAAc,GAAG,KAAK;MAC7B,CAAC;MAED;AACJ;AACA;AACA;AACA;MACIa,aAAa,WAAAA,cAAA,EAAG;QACd,OAAO,IAAI,CAACC,UAAU,CAAC,IAAI,CAACT,aAAa,CAAC,CAAC,EAAE,KAAK,CAAC;MACrD,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIS,UAAU,WAAAA,WAACC,KAAK,EAAEC,gBAAgB,EAAE;QAClC;QACA,IAAID,KAAK,GAAG,IAAI,CAAChB,SAAe,EAAE;UAChCgB,KAAK,GAAG,IAAI,CAAChB,SAAe;QAC9B;;QAEA;QACA;QACA,IACEiB,gBAAgB,IAChB,IAAI,CAAChB,SAAc,IACnBe,KAAK,GAAG,IAAI,CAACd,SAAwB,EACrC;UACAc,KAAK,GAAG,IAAI,CAACd,SAAwB;QACvC;QAEA,IAAIc,KAAK,GAAG,CAAC,EAAE;UACb,IAAIE,+BAA+B,GAAG,IAAI,CAACT,SAAY,CACrD,IAAI,CAACV,SAAoB,EACzB,CAAC,CACH,CAAC;UAED,IAAIoB,UAAU,GAAG,IAAI,CAACV,SAAY,CAChCS,+BAA+B,EAC/B,CAACF,KAAK,GAAG,CACX,CAAC;UAED,IAAII,MAAM;UAEV,IAAID,UAAU,IAAID,+BAA+B,EAAE;YACjD;YACAE,MAAM,GAAG,IAAI,CAACjB,SAAS,CAACkB,KAAK,CAC3BF,UAAU,EACVD,+BAA+B,GAAG,CACpC,CAAC;UACH,CAAC,MAAM;YACL;YACAE,MAAM,GAAG,IAAI,CAACjB,SAAS,CACpBkB,KAAK,CAACF,UAAU,EAAE,IAAI,CAACnB,SAAe,CAAC,CACvCsB,MAAM,CACL,IAAI,CAACnB,SAAS,CAACkB,KAAK,CAAC,CAAC,EAAEH,+BAA+B,GAAG,CAAC,CAC7D,CAAC;UACL;QACF,CAAC,MAAM;UACLE,MAAM,GAAG,EAAE;QACb;QAEA,OAAOA,MAAM;MACf,CAAC;MAED;AACJ;AACA;MACIf,KAAK,WAAAA,MAAA,EAAG;QACN,IAAI,CAACF,SAAS,GAAG,IAAIoB,KAAK,CAAC,IAAI,CAACjB,aAAa,CAAC,CAAC,CAAC;QAChD,IAAI,CAACN,SAAe,GAAG,CAAC;QACxB,IAAI,CAACE,SAAwB,GAAG,CAAC;QACjC,IAAI,CAACH,SAAoB,GAAG,CAAC;MAC/B,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIU,SAAY,WAAAe,UAACC,GAAG,EAAEC,KAAK,EAAE;QACvB,IAAIhB,GAAG,GAAG,IAAI,CAACJ,aAAa,CAAC,CAAC;QAC9B,IAAIc,MAAM,GAAG,CAACK,GAAG,GAAGC,KAAK,IAAIhB,GAAG;;QAEhC;QACA,IAAIU,MAAM,GAAG,CAAC,EAAE;UACdA,MAAM,IAAIV,GAAG;QACf;QACA,OAAOU,MAAM;MACf;IACF;EACF,CAAC,CAAC;EAxOFhC,EAAE,CAACuC,IAAI,CAACC,UAAU,CAACrC,aAAa,GAAGA,aAAa;AAAC"
}