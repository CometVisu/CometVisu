{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "type",
    "statics",
    "__timerQueue",
    "__timerData",
    "__timerId",
    "members",
    "__timerListenerActive",
    "start",
    "callback",
    "recurTime",
    "context",
    "userData",
    "initialTime",
    "expireAt",
    "Date",
    "getTime",
    "util",
    "TimerManager",
    "__insertNewTimer",
    "stop",
    "timerId",
    "timerQueue",
    "length",
    "i",
    "splice",
    "event",
    "Idle",
    "getInstance",
    "removeListener",
    "__processQueue",
    "__P_520_4",
    "timerData",
    "push",
    "addListener",
    "__P_520_5",
    "timeNow",
    "expiredTimerId",
    "shift",
    "expiredTimerData",
    "call",
    "now"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/util/TimerManager.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2008 Derrell Lipman\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Derrell Lipman (derrell)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * Timer manipulation for handling multiple timed callbacks with the use of\r\n * only a single native timer object.\r\n *\r\n * Use of these timers is via the methods start() and stop().  Examples:\r\n * <pre class='javascript'>\r\n * var timer = qx.util.TimerManager.getInstance();\r\n *\r\n * // Start a 5-second recurrent timer.\r\n * // Note that the first expiration is after 3 seconds\r\n * // (last parameter is 3000) but each subsequent expiration is\r\n * // at 5 second intervals.\r\n * timer.start(function(userData, timerId)\r\n *             {\r\n *               this.debug(\"Recurrent 5-second timer: \" + timerId);\r\n *             },\r\n *             5000,\r\n *             this,\r\n *             null,\r\n *             3000);\r\n *\r\n * // Start a 1-second one-shot timer\r\n * timer.start(function(userData, timerId)\r\n *             {\r\n *               this.debug(\"One-shot 1-second timer: \" + timerId);\r\n *             },\r\n *             0,\r\n *             this,\r\n *             null,\r\n *             1000);\r\n *\r\n * // Start a 2-second recurrent timer that stops itself after\r\n * // three iterations\r\n * timer.start(function(userData, timerId)\r\n *             {\r\n *               this.debug(\"Recurrent 2-second timer with limit 3:\" +\r\n *                          timerId);\r\n *               if (++userData.count == 3)\r\n *               {\r\n *                 this.debug(\"Stopping recurrent 2-second timer\");\r\n *                 timer.stop(timerId);\r\n *               }\r\n *             },\r\n *             2000,\r\n *             this,\r\n *             { count : 0 });\r\n *\r\n * // Start an immediate one-shot timer\r\n * timer.start(function(userData, timerId)\r\n *             {\r\n *               this.debug(\"Immediate one-shot timer: \" + timerId);\r\n *             });\r\n * </pre>\r\n */\r\nqx.Class.define(\"qx.util.TimerManager\", {\r\n  extend: qx.core.Object,\r\n  type: \"singleton\",\r\n\r\n  statics: {\r\n    /** Time-ordered queue of timers */\r\n    __timerQueue: [],\r\n\r\n    /** Saved data for each timer */\r\n    __timerData: {},\r\n\r\n    /** Next timer id value is determined by incrementing this */\r\n    __timerId: 0\r\n  },\r\n\r\n  members: {\r\n    /** Whether we're currently listening on the interval timer event */\r\n    __timerListenerActive: false,\r\n\r\n    /**\r\n     * Start a new timer\r\n     *\r\n     * @param callback {Function}\r\n     *   Function to be called upon expiration of the timer.  The function is\r\n     *   passed these parameters:\r\n     *   <dl>\r\n     *     <dt>userData</dt>\r\n     *       <dd>The user data provided to the start() method</dd>\r\n     *     <dt>timerId</dt>\r\n     *       <dd>The timer id, as was returned by the start() method</dd>\r\n     *   </dl>\r\n     *\r\n     * @param recurTime {Integer|null}\r\n     *   If null, the timer will not recur.  Once the callback function\r\n     *   returns the first time, the timer will be removed from the timer\r\n     *   queue.  If non-null, upon return from the callback function, the\r\n     *   timer will be reset to this number of milliseconds.\r\n     *\r\n     * @param context {qx.core.Object|null}\r\n     *   Context (this) the callback function is called with.  If not\r\n     *   provided, this Timer singleton object is used.\r\n     *\r\n     * @param userData {var}\r\n     *   Data which is passed to the callback function upon timer expiry\r\n     *\r\n     * @param initialTime {Integer|null}\r\n     *   Milliseconds before the callback function is called the very first\r\n     *   time.  If not specified and recurTime is specified, then recurTime\r\n     *   will be used as initialTime; otherwise initialTime will default\r\n     *   to zero.\r\n     *\r\n     * @return {Integer}\r\n     *   The timer id of this unique timer.  It may be provided to the stop()\r\n     *   method to cancel a timer before expiration.\r\n     */\r\n    start(callback, recurTime, context, userData, initialTime) {\r\n      // Get the expiration time for this timer\r\n      if (typeof initialTime != \"number\") {\r\n        initialTime = recurTime || 0;\r\n      }\r\n\r\n      var expireAt = new Date().getTime() + initialTime;\r\n\r\n      // Save the callback, user data, and requested recurrency time as well\r\n      // as the current expiry time\r\n      this.self(arguments).__timerData[++this.self(arguments).__timerId] = {\r\n        callback: callback,\r\n        userData: userData || null,\r\n        expireAt: expireAt,\r\n        recurTime: recurTime,\r\n        context: context || this\r\n      };\r\n\r\n      // Insert this new timer on the time-ordered timer queue\r\n      this.__insertNewTimer(expireAt, this.self(arguments).__timerId);\r\n\r\n      // Give 'em the timer id\r\n      return this.self(arguments).__timerId;\r\n    },\r\n\r\n    /**\r\n     * Stop a running timer\r\n     *\r\n     * @param timerId {Integer}\r\n     *   A timer id previously returned by start()\r\n     */\r\n    stop(timerId) {\r\n      // Find this timer id in the time-ordered list\r\n      var timerQueue = this.self(arguments).__timerQueue;\r\n      var length = timerQueue.length;\r\n      for (var i = 0; i < length; i++) {\r\n        // Is this the one we're looking for?\r\n        if (timerQueue[i] == timerId) {\r\n          // Yup.  Remove it.\r\n          timerQueue.splice(i, 1);\r\n\r\n          // We found it so no need to continue looping through the queue\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Ensure it's gone from the timer data map as well\r\n      delete this.self(arguments).__timerData[timerId];\r\n\r\n      // If there are no more timers pending...\r\n      if (timerQueue.length == 0 && this.__timerListenerActive) {\r\n        // ... then stop listening for the periodic timer\r\n        qx.event.Idle.getInstance().removeListener(\r\n          \"interval\",\r\n          this.__processQueue,\r\n          this\r\n        );\r\n\r\n        this.__timerListenerActive = false;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Insert a timer on the time-ordered list of active timers.\r\n     *\r\n     * @param expireAt {Integer}\r\n     *   Milliseconds from now when this timer should expire\r\n     *\r\n     * @param timerId {Integer}\r\n     *   Id of the timer to be time-ordered\r\n     *\r\n     */\r\n    __insertNewTimer(expireAt, timerId) {\r\n      // The timer queue is time-ordered so that processing timers need not\r\n      // search the queue; rather, it can simply look at the first element\r\n      // and if not yet ready to fire, be done.  Search the queue for the\r\n      // appropriate place to insert this timer.\r\n      var timerQueue = this.self(arguments).__timerQueue;\r\n      var timerData = this.self(arguments).__timerData;\r\n      var length = timerQueue.length;\r\n      for (var i = 0; i < length; i++) {\r\n        // Have we reached a later time?\r\n        if (timerData[timerQueue[i]].expireAt > expireAt) {\r\n          // Yup.  Insert our new timer id before this element.\r\n          timerQueue.splice(i, 0, timerId);\r\n\r\n          // No need to loop through the queue further\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Did we find someplace in the middle of the queue for it?\r\n      if (timerQueue.length == length) {\r\n        // Nope.  Insert it at the end.\r\n        timerQueue.push(timerId);\r\n      }\r\n\r\n      // If this is the first element on the queue...\r\n      if (!this.__timerListenerActive) {\r\n        // ... then start listening for the periodic timer.\r\n        qx.event.Idle.getInstance().addListener(\r\n          \"interval\",\r\n          this.__processQueue,\r\n          this\r\n        );\r\n\r\n        this.__timerListenerActive = true;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Process the queue of timers.  Call the registered callback function for\r\n     * any timer which has expired.  If the timer is marked as recurrent, the\r\n     * timer is restarted with the recurrent timeout following completion of\r\n     * the callback function.\r\n     *\r\n     */\r\n    __processQueue() {\r\n      // Get the current time\r\n      var timeNow = new Date().getTime();\r\n\r\n      // While there are timer elements that need processing...\r\n      var timerQueue = this.self(arguments).__timerQueue;\r\n      var timerData = this.self(arguments).__timerData;\r\n\r\n      // Is it time to process the first timer element yet?\r\n      while (\r\n        timerQueue.length > 0 &&\r\n        timerData[timerQueue[0]].expireAt <= timeNow\r\n      ) {\r\n        // Yup.  Do it.  First, remove element from the queue.\r\n        var expiredTimerId = timerQueue.shift();\r\n\r\n        // Call the handler function for this timer\r\n        var expiredTimerData = timerData[expiredTimerId];\r\n        expiredTimerData.callback.call(\r\n          expiredTimerData.context,\r\n          expiredTimerData.userData,\r\n          expiredTimerId\r\n        );\r\n\r\n        // If this is a recurrent timer which wasn't stopped by the callback...\r\n        if (expiredTimerData.recurTime && timerData[expiredTimerId]) {\r\n          // ... then restart it.\r\n          var now = new Date().getTime();\r\n          expiredTimerData.expireAt = now + expiredTimerData.recurTime;\r\n\r\n          // Insert this timer back on the time-ordered timer queue\r\n          this.__insertNewTimer(expiredTimerData.expireAt, expiredTimerId);\r\n        } else {\r\n          // If it's not a recurrent timer, we can purge its data too.\r\n          delete timerData[expiredTimerId];\r\n        }\r\n      }\r\n\r\n      // If there are no more timers pending...\r\n      if (timerQueue.length == 0 && this.__timerListenerActive) {\r\n        // ... then stop listening for the periodic timer\r\n        qx.event.Idle.getInstance().removeListener(\r\n          \"interval\",\r\n          this.__processQueue,\r\n          this\r\n        );\r\n\r\n        this.__timerListenerActive = false;\r\n      }\r\n    }\r\n  }\r\n});\r\n"
  ],
  "mappings": ";;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAS,CAACC,oBAAoB,CAACC,aAAa,CAAC;EAAhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAH,EAAE,CAACI,KAAK,CAACC,MAAM,CAAC,sBAAsB,EAAE;IACtCC,MAAM,EAAEN,EAAE,CAACO,IAAI,CAACC,MAAM;IACtBC,IAAI,EAAE,WAAW;IAEjBC,OAAO,EAAE;MACP;MACAC,SAAY,EAAE,EAAE;MAEhB;MACAC,SAAW,EAAE,CAAC,CAAC;MAEf;MACAC,SAAS,EAAE;IACb,CAAC;IAEDC,OAAO,EAAE;MACP;MACAC,SAAqB,EAAE,KAAK;MAE5B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,KAAK,WAAAA,MAACC,QAAQ,EAAEC,SAAS,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,WAAW,EAAE;QACzD;QACA,IAAI,OAAOA,WAAW,IAAI,QAAQ,EAAE;UAClCA,WAAW,GAAGH,SAAS,IAAI,CAAC;QAC9B;QAEA,IAAII,QAAQ,GAAG,IAAIC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,GAAGH,WAAW;;QAEjD;QACA;QACArB,EAAA,CAAAyB,IAAA,CAAAC,YAAA,CAAqBd,SAAW,CAAC,EAAEZ,EAAA,CAAAyB,IAAA,CAAAC,YAAA,CA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"
}