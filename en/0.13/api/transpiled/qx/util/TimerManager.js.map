{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "type",
    "statics",
    "__timerQueue",
    "__timerData",
    "__timerId",
    "members",
    "__timerListenerActive",
    "start",
    "callback",
    "recurTime",
    "context",
    "userData",
    "initialTime",
    "expireAt",
    "Date",
    "getTime",
    "__insertNewTimer",
    "stop",
    "timerId",
    "timerQueue",
    "length",
    "i",
    "splice",
    "event",
    "Idle",
    "getInstance",
    "removeListener",
    "__processQueue",
    "timerData",
    "push",
    "addListener",
    "timeNow",
    "expiredTimerId",
    "shift",
    "expiredTimerData",
    "call",
    "now",
    "util",
    "TimerManager"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/util/TimerManager.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2008 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * Timer manipulation for handling multiple timed callbacks with the use of\n * only a single native timer object.\n *\n * Use of these timers is via the methods start() and stop().  Examples:\n * <pre class='javascript'>\n * var timer = qx.util.TimerManager.getInstance();\n *\n * // Start a 5-second recurrent timer.\n * // Note that the first expiration is after 3 seconds\n * // (last parameter is 3000) but each subsequent expiration is\n * // at 5 second intervals.\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"Recurrent 5-second timer: \" + timerId);\n *             },\n *             5000,\n *             this,\n *             null,\n *             3000);\n *\n * // Start a 1-second one-shot timer\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"One-shot 1-second timer: \" + timerId);\n *             },\n *             0,\n *             this,\n *             null,\n *             1000);\n *\n * // Start a 2-second recurrent timer that stops itself after\n * // three iterations\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"Recurrent 2-second timer with limit 3:\" +\n *                          timerId);\n *               if (++userData.count == 3)\n *               {\n *                 this.debug(\"Stopping recurrent 2-second timer\");\n *                 timer.stop(timerId);\n *               }\n *             },\n *             2000,\n *             this,\n *             { count : 0 });\n *\n * // Start an immediate one-shot timer\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"Immediate one-shot timer: \" + timerId);\n *             });\n * </pre>\n */\nqx.Class.define(\"qx.util.TimerManager\", {\n  extend: qx.core.Object,\n  type: \"singleton\",\n\n  statics: {\n    /** Time-ordered queue of timers */\n    __timerQueue: [],\n\n    /** Saved data for each timer */\n    __timerData: {},\n\n    /** Next timer id value is determined by incrementing this */\n    __timerId: 0\n  },\n\n  members: {\n    /** Whether we're currently listening on the interval timer event */\n    __timerListenerActive: false,\n\n    /**\n     * Start a new timer\n     *\n     * @param callback {Function}\n     *   Function to be called upon expiration of the timer.  The function is\n     *   passed these parameters:\n     *   <dl>\n     *     <dt>userData</dt>\n     *       <dd>The user data provided to the start() method</dd>\n     *     <dt>timerId</dt>\n     *       <dd>The timer id, as was returned by the start() method</dd>\n     *   </dl>\n     *\n     * @param recurTime {Integer|null}\n     *   If null, the timer will not recur.  Once the callback function\n     *   returns the first time, the timer will be removed from the timer\n     *   queue.  If non-null, upon return from the callback function, the\n     *   timer will be reset to this number of milliseconds.\n     *\n     * @param context {qx.core.Object|null}\n     *   Context (this) the callback function is called with.  If not\n     *   provided, this Timer singleton object is used.\n     *\n     * @param userData {var}\n     *   Data which is passed to the callback function upon timer expiry\n     *\n     * @param initialTime {Integer|null}\n     *   Milliseconds before the callback function is called the very first\n     *   time.  If not specified and recurTime is specified, then recurTime\n     *   will be used as initialTime; otherwise initialTime will default\n     *   to zero.\n     *\n     * @return {Integer}\n     *   The timer id of this unique timer.  It may be provided to the stop()\n     *   method to cancel a timer before expiration.\n     */\n    start(callback, recurTime, context, userData, initialTime) {\n      // Get the expiration time for this timer\n      if (typeof initialTime != \"number\") {\n        initialTime = recurTime || 0;\n      }\n\n      var expireAt = new Date().getTime() + initialTime;\n\n      // Save the callback, user data, and requested recurrency time as well\n      // as the current expiry time\n      this.self(arguments).__timerData[++this.self(arguments).__timerId] = {\n        callback: callback,\n        userData: userData || null,\n        expireAt: expireAt,\n        recurTime: recurTime,\n        context: context || this\n      };\n\n      // Insert this new timer on the time-ordered timer queue\n      this.__insertNewTimer(expireAt, this.self(arguments).__timerId);\n\n      // Give 'em the timer id\n      return this.self(arguments).__timerId;\n    },\n\n    /**\n     * Stop a running timer\n     *\n     * @param timerId {Integer}\n     *   A timer id previously returned by start()\n     */\n    stop(timerId) {\n      // Find this timer id in the time-ordered list\n      var timerQueue = this.self(arguments).__timerQueue;\n      var length = timerQueue.length;\n      for (var i = 0; i < length; i++) {\n        // Is this the one we're looking for?\n        if (timerQueue[i] == timerId) {\n          // Yup.  Remove it.\n          timerQueue.splice(i, 1);\n\n          // We found it so no need to continue looping through the queue\n          break;\n        }\n      }\n\n      // Ensure it's gone from the timer data map as well\n      delete this.self(arguments).__timerData[timerId];\n\n      // If there are no more timers pending...\n      if (timerQueue.length == 0 && this.__timerListenerActive) {\n        // ... then stop listening for the periodic timer\n        qx.event.Idle.getInstance().removeListener(\n          \"interval\",\n          this.__processQueue,\n          this\n        );\n\n        this.__timerListenerActive = false;\n      }\n    },\n\n    /**\n     * Insert a timer on the time-ordered list of active timers.\n     *\n     * @param expireAt {Integer}\n     *   Milliseconds from now when this timer should expire\n     *\n     * @param timerId {Integer}\n     *   Id of the timer to be time-ordered\n     *\n     */\n    __insertNewTimer(expireAt, timerId) {\n      // The timer queue is time-ordered so that processing timers need not\n      // search the queue; rather, it can simply look at the first element\n      // and if not yet ready to fire, be done.  Search the queue for the\n      // appropriate place to insert this timer.\n      var timerQueue = this.self(arguments).__timerQueue;\n      var timerData = this.self(arguments).__timerData;\n      var length = timerQueue.length;\n      for (var i = 0; i < length; i++) {\n        // Have we reached a later time?\n        if (timerData[timerQueue[i]].expireAt > expireAt) {\n          // Yup.  Insert our new timer id before this element.\n          timerQueue.splice(i, 0, timerId);\n\n          // No need to loop through the queue further\n          break;\n        }\n      }\n\n      // Did we find someplace in the middle of the queue for it?\n      if (timerQueue.length == length) {\n        // Nope.  Insert it at the end.\n        timerQueue.push(timerId);\n      }\n\n      // If this is the first element on the queue...\n      if (!this.__timerListenerActive) {\n        // ... then start listening for the periodic timer.\n        qx.event.Idle.getInstance().addListener(\n          \"interval\",\n          this.__processQueue,\n          this\n        );\n\n        this.__timerListenerActive = true;\n      }\n    },\n\n    /**\n     * Process the queue of timers.  Call the registered callback function for\n     * any timer which has expired.  If the timer is marked as recurrent, the\n     * timer is restarted with the recurrent timeout following completion of\n     * the callback function.\n     *\n     */\n    __processQueue() {\n      // Get the current time\n      var timeNow = new Date().getTime();\n\n      // While there are timer elements that need processing...\n      var timerQueue = this.self(arguments).__timerQueue;\n      var timerData = this.self(arguments).__timerData;\n\n      // Is it time to process the first timer element yet?\n      while (\n        timerQueue.length > 0 &&\n        timerData[timerQueue[0]].expireAt <= timeNow\n      ) {\n        // Yup.  Do it.  First, remove element from the queue.\n        var expiredTimerId = timerQueue.shift();\n\n        // Call the handler function for this timer\n        var expiredTimerData = timerData[expiredTimerId];\n        expiredTimerData.callback.call(\n          expiredTimerData.context,\n          expiredTimerData.userData,\n          expiredTimerId\n        );\n\n        // If this is a recurrent timer which wasn't stopped by the callback...\n        if (expiredTimerData.recurTime && timerData[expiredTimerId]) {\n          // ... then restart it.\n          var now = new Date().getTime();\n          expiredTimerData.expireAt = now + expiredTimerData.recurTime;\n\n          // Insert this timer back on the time-ordered timer queue\n          this.__insertNewTimer(expiredTimerData.expireAt, expiredTimerId);\n        } else {\n          // If it's not a recurrent timer, we can purge its data too.\n          delete timerData[expiredTimerId];\n        }\n      }\n\n      // If there are no more timers pending...\n      if (timerQueue.length == 0 && this.__timerListenerActive) {\n        // ... then stop listening for the periodic timer\n        qx.event.Idle.getInstance().removeListener(\n          \"interval\",\n          this.__processQueue,\n          this\n        );\n\n        this.__timerListenerActive = false;\n      }\n    }\n  }\n});\n"
  ],
  "mappings": ";;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAS,CAACC,oBAAoB,CAACC,aAAa,CAAC;EAAhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAH,EAAE,CAACI,KAAK,CAACC,MAAM,CAAC,sBAAsB,EAAE;IACtCC,MAAM,EAAEN,EAAE,CAACO,IAAI,CAACC,MAAM;IACtBC,IAAI,EAAE,WAAW;IAEjBC,OAAO,EAAE;MACP;MACAC,SAAY,EAAE,EAAE;MAEhB;MACAC,SAAW,EAAE,CAAC,CAAC;MAEf;MACAC,SAAS,EAAE;IACb,CAAC;IAEDC,OAAO,EAAE;MACP;MACAC,SAAqB,EAAE,KAAK;MAE5B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,KAAK,iBAACC,QAAQ,EAAEC,SAAS,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,WAAW,EAAE;QACzD;QACA,IAAI,OAAOA,WAAW,IAAI,QAAQ,EAAE;UAClCA,WAAW,GAAGH,SAAS,IAAI,CAAC;QAC9B;QAEA,IAAII,QAAQ,GAAG,IAAIC,IAAI,EAAE,CAACC,OAAO,EAAE,GAAGH,WAAW;;QAEjD;QACA;QACA,qBAAqBT,SAAW,CAAC,EAAE,qBAAqBC,SAAS,CAAC,GAAG;UACnEI,QAAQ,EAAEA,QAAQ;UAClBG,QAAQ,EAAEA,QAAQ,IAAI,I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"
}