{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "type",
    "statics",
    "__timerQueue",
    "__timerData",
    "__timerId",
    "members",
    "__timerListenerActive",
    "start",
    "callback",
    "recurTime",
    "context",
    "userData",
    "initialTime",
    "expireAt",
    "Date",
    "getTime",
    "__insertNewTimer",
    "stop",
    "timerId",
    "timerQueue",
    "length",
    "i",
    "splice",
    "event",
    "Idle",
    "getInstance",
    "removeListener",
    "__processQueue",
    "timerData",
    "push",
    "addListener",
    "timeNow",
    "expiredTimerId",
    "shift",
    "expiredTimerData",
    "call",
    "now",
    "util",
    "TimerManager"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/util/TimerManager.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2008 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * Timer manipulation for handling multiple timed callbacks with the use of\n * only a single native timer object.\n *\n * Use of these timers is via the methods start() and stop().  Examples:\n * <pre class='javascript'>\n * var timer = qx.util.TimerManager.getInstance();\n *\n * // Start a 5-second recurrent timer.\n * // Note that the first expiration is after 3 seconds\n * // (last parameter is 3000) but each subsequent expiration is\n * // at 5 second intervals.\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"Recurrent 5-second timer: \" + timerId);\n *             },\n *             5000,\n *             this,\n *             null,\n *             3000);\n *\n * // Start a 1-second one-shot timer\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"One-shot 1-second timer: \" + timerId);\n *             },\n *             0,\n *             this,\n *             null,\n *             1000);\n *\n * // Start a 2-second recurrent timer that stops itself after\n * // three iterations\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"Recurrent 2-second timer with limit 3:\" +\n *                          timerId);\n *               if (++userData.count == 3)\n *               {\n *                 this.debug(\"Stopping recurrent 2-second timer\");\n *                 timer.stop(timerId);\n *               }\n *             },\n *             2000,\n *             this,\n *             { count : 0 });\n *\n * // Start an immediate one-shot timer\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"Immediate one-shot timer: \" + timerId);\n *             });\n * </pre>\n */\nqx.Class.define(\"qx.util.TimerManager\", {\n  extend: qx.core.Object,\n  type: \"singleton\",\n\n  statics: {\n    /** Time-ordered queue of timers */\n    __timerQueue: [],\n\n    /** Saved data for each timer */\n    __timerData: {},\n\n    /** Next timer id value is determined by incrementing this */\n    __timerId: 0\n  },\n\n  members: {\n    /** Whether we're currently listening on the interval timer event */\n    __timerListenerActive: false,\n\n    /**\n     * Start a new timer\n     *\n     * @param callback {Function}\n     *   Function to be called upon expiration of the timer.  The function is\n     *   passed these parameters:\n     *   <dl>\n     *     <dt>userData</dt>\n     *       <dd>The user data provided to the start() method</dd>\n     *     <dt>timerId</dt>\n     *       <dd>The timer id, as was returned by the start() method</dd>\n     *   </dl>\n     *\n     * @param recurTime {Integer|null}\n     *   If null, the timer will not recur.  Once the callback function\n     *   returns the first time, the timer will be removed from the timer\n     *   queue.  If non-null, upon return from the callback function, the\n     *   timer will be reset to this number of milliseconds.\n     *\n     * @param context {qx.core.Object|null}\n     *   Context (this) the callback function is called with.  If not\n     *   provided, this Timer singleton object is used.\n     *\n     * @param userData {var}\n     *   Data which is passed to the callback function upon timer expiry\n     *\n     * @param initialTime {Integer|null}\n     *   Milliseconds before the callback function is called the very first\n     *   time.  If not specified and recurTime is specified, then recurTime\n     *   will be used as initialTime; otherwise initialTime will default\n     *   to zero.\n     *\n     * @return {Integer}\n     *   The timer id of this unique timer.  It may be provided to the stop()\n     *   method to cancel a timer before expiration.\n     */\n    start(callback, recurTime, context, userData, initialTime) {\n      // Get the expiration time for this timer\n      if (typeof initialTime != \"number\") {\n        initialTime = recurTime || 0;\n      }\n\n      var expireAt = new Date().getTime() + initialTime;\n\n      // Save the callback, user data, and requested recurrency time as well\n      // as the current expiry time\n      this.self(arguments).__timerData[++this.self(arguments).__timerId] = {\n        callback: callback,\n        userData: userData || null,\n        expireAt: expireAt,\n        recurTime: recurTime,\n        context: context || this\n      };\n\n      // Insert this new timer on the time-ordered timer queue\n      this.__insertNewTimer(expireAt, this.self(arguments).__timerId);\n\n      // Give 'em the timer id\n      return this.self(arguments).__timerId;\n    },\n\n    /**\n     * Stop a running timer\n     *\n     * @param timerId {Integer}\n     *   A timer id previously returned by start()\n     */\n    stop(timerId) {\n      // Find this timer id in the time-ordered list\n      var timerQueue = this.self(arguments).__timerQueue;\n      var length = timerQueue.length;\n      for (var i = 0; i < length; i++) {\n        // Is this the one we're looking for?\n        if (timerQueue[i] == timerId) {\n          // Yup.  Remove it.\n          timerQueue.splice(i, 1);\n\n          // We found it so no need to continue looping through the queue\n          break;\n        }\n      }\n\n      // Ensure it's gone from the timer data map as well\n      delete this.self(arguments).__timerData[timerId];\n\n      // If there are no more timers pending...\n      if (timerQueue.length == 0 && this.__timerListenerActive) {\n        // ... then stop listening for the periodic timer\n        qx.event.Idle.getInstance().removeListener(\n          \"interval\",\n          this.__processQueue,\n          this\n        );\n\n        this.__timerListenerActive = false;\n      }\n    },\n\n    /**\n     * Insert a timer on the time-ordered list of active timers.\n     *\n     * @param expireAt {Integer}\n     *   Milliseconds from now when this timer should expire\n     *\n     * @param timerId {Integer}\n     *   Id of the timer to be time-ordered\n     *\n     */\n    __insertNewTimer(expireAt, timerId) {\n      // The timer queue is time-ordered so that processing timers need not\n      // search the queue; rather, it can simply look at the first element\n      // and if not yet ready to fire, be done.  Search the queue for the\n      // appropriate place to insert this timer.\n      var timerQueue = this.self(arguments).__timerQueue;\n      var timerData = this.self(arguments).__timerData;\n      var length = timerQueue.length;\n      for (var i = 0; i < length; i++) {\n        // Have we reached a later time?\n        if (timerData[timerQueue[i]].expireAt > expireAt) {\n          // Yup.  Insert our new timer id before this element.\n          timerQueue.splice(i, 0, timerId);\n\n          // No need to loop through the queue further\n          break;\n        }\n      }\n\n      // Did we find someplace in the middle of the queue for it?\n      if (timerQueue.length == length) {\n        // Nope.  Insert it at the end.\n        timerQueue.push(timerId);\n      }\n\n      // If this is the first element on the queue...\n      if (!this.__timerListenerActive) {\n        // ... then start listening for the periodic timer.\n        qx.event.Idle.getInstance().addListener(\n          \"interval\",\n          this.__processQueue,\n          this\n        );\n\n        this.__timerListenerActive = true;\n      }\n    },\n\n    /**\n     * Process the queue of timers.  Call the registered callback function for\n     * any timer which has expired.  If the timer is marked as recurrent, the\n     * timer is restarted with the recurrent timeout following completion of\n     * the callback function.\n     *\n     */\n    __processQueue() {\n      // Get the current time\n      var timeNow = new Date().getTime();\n\n      // While there are timer elements that need processing...\n      var timerQueue = this.self(arguments).__timerQueue;\n      var timerData = this.self(arguments).__timerData;\n\n      // Is it time to process the first timer element yet?\n      while (\n        timerQueue.length > 0 &&\n        timerData[timerQueue[0]].expireAt <= timeNow\n      ) {\n        // Yup.  Do it.  First, remove element from the queue.\n        var expiredTimerId = timerQueue.shift();\n\n        // Call the handler function for this timer\n        var expiredTimerData = timerData[expiredTimerId];\n        expiredTimerData.callback.call(\n          expiredTimerData.context,\n          expiredTimerData.userData,\n          expiredTimerId\n        );\n\n        // If this is a recurrent timer which wasn't stopped by the callback...\n        if (expiredTimerData.recurTime && timerData[expiredTimerId]) {\n          // ... then restart it.\n          var now = new Date().getTime();\n          expiredTimerData.expireAt = now + expiredTimerData.recurTime;\n\n          // Insert this timer back on the time-ordered timer queue\n          this.__insertNewTimer(expiredTimerData.expireAt, expiredTimerId);\n        } else {\n          // If it's not a recurrent timer, we can purge its data too.\n          delete timerData[expiredTimerId];\n        }\n      }\n\n      // If there are no more timers pending...\n      if (timerQueue.length == 0 && this.__timerListenerActive) {\n        // ... then stop listening for the periodic timer\n        qx.event.Idle.getInstance().removeListener(\n          \"interval\",\n          this.__processQueue,\n          this\n        );\n\n        this.__timerListenerActive = false;\n      }\n    }\n  }\n});\n"
  ],
  "mappings": ";;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC;;EAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAH,EAAE,CAACI,KAAH,CAASC,MAAT,CAAgB,sBAAhB,EAAwC;IACtCC,MAAM,EAAEN,EAAE,CAACO,IAAH,CAAQC,MADsB;IAEtCC,IAAI,EAAE,WAFgC;IAItCC,OAAO,EAAE;MACP;MACAC,SAAY,EAAE,EAFP;;MAIP;MACAC,SAAW,EAAE,EALN;;MAOP;MACAC,SAAS,EAAE;IARJ,CAJ6B;IAetCC,OAAO,EAAE;MACP;MACAC,SAAqB,EAAE,KAFhB;;MAIP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,KAxCO,iBAwCDC,QAxCC,EAwCSC,SAxCT,EAwCoBC,OAxCpB,EAwC6BC,QAxC7B,EAwCuCC,WAxCvC,EAwCoD;QACzD;QACA,IAAI,OAAOA,WAAP,IAAsB,QAA1B,EAAoC;UAClCA,WAAW,GAAGH,SAAS,IAAI,CAA3B;QACD;;QAED,IAAII,QAAQ,GAAG,IAAIC,IAAJ,GAAWC,OAAX,KAAuBH,WAAtC,CANyD,CAQzD;QACA;;QACA,qBAAqBT,SAArB,CAAiC,EAAE,qBAAqBC,SAAxD,IAAqE;UACnEI,QAAQ,EAAEA,QADyD;UAEnEG,QA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"
}