{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "transitionName",
    "transitionInfo",
    "context",
    "setName",
    "window",
    "setUserData",
    "field",
    "setPredicate",
    "__bindIfFunction",
    "setNextState",
    "setAutoActionsBeforeOntransition",
    "setAutoActionsAfterOntransition",
    "setOntransition",
    "debug",
    "properties",
    "name",
    "check",
    "nullable",
    "predicate",
    "init",
    "fsm",
    "event",
    "transform",
    "nextState",
    "util",
    "FiniteStateMachine",
    "StateChange",
    "CURRENT_STATE",
    "autoActionsBeforeOntransition",
    "autoActionsAfterOntransition",
    "ontransition",
    "members",
    "__transformPredicate",
    "value",
    "lang",
    "Function",
    "bind",
    "getUserData",
    "Error",
    "__transformNextState",
    "POP_STATE_STACK",
    "TERMINATE",
    "__transformAutoActionsBeforeOntransition",
    "State",
    "_commonTransformAutoActions",
    "__transformAutoActionsAfterOntransition",
    "__transformOntransition",
    "f",
    "Transition"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/util/fsm/Transition.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2006, 2007, 2011 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * Create a new possible transition from one state to another.\n */\nqx.Class.define(\"qx.util.fsm.Transition\", {\n  extend: qx.core.Object,\n\n  /**\n   * @param transitionName {String}\n   *   The name of this transition, used in debug messages.\n   *\n   * @param transitionInfo {Object}\n   *   <pre>\n   *   An object optionally containing any of the following properties:\n   *\n   *     context -\n   *       A context in which all of the following functions should be run.\n   *\n   *     predicate -\n   *       A function which is called to determine whether this transition is\n   *       acceptable.  An acceptable transition will cause the transition's\n   *       \"ontransition\" function to be run, the current state's \"onexit\"\n   *       function to be run, and the new state's \"onentry\" function to be\n   *       run.\n   *\n   *       The predicate function's signature is function(fsm, event) and it\n   *       is saved in the predicate property of the transition object.  In\n   *       the predicate function:\n   *\n   *         fsm -\n   *           The finite state machine object to which this state is\n   *           attached.\n   *\n   *         event -\n   *           The event that caused a run of the finite state machine\n   *\n   *       The predicate function should return one of the following three\n   *       values:\n   *\n   *         - true means the transition is acceptable\n   *\n   *         - false means the transition is not acceptable, and the next\n   *           transition (if one exists) should be tried to determine if it\n   *           is acceptable\n   *\n   *         - null means that the transition determined that no further\n   *           transitions should be tried.  This might be used when the\n   *           transition ascertained that the event is for a target that is\n   *           not available in the current state, and the event has called\n   *           fsm.queueEvent() to have the event delivered upon state\n   *           transition.\n   *\n   *       It is possible to create a default predicate -- one that will cause\n   *       a transition to be acceptable always -- by either not providing a\n   *       predicate property, or by explicitly either setting the predicate\n   *       property to 'true' or setting it to a function that unconditionally\n   *       returns 'true'.  This default transition should, of course, always\n   *       be the last transition added to a state, since no transition added\n   *       after it will ever be tried.\n   *\n   *     nextState -\n   *       The state to which we transition, if the predicate returns true\n   *       (meaning the transition is acceptable).  The value of nextState may\n   *       be:\n   *\n   *         - a string, the state name of the state to transition to\n   *\n   *         - One of the constants:\n   *           - qx.util.fsm.FiniteStateMachine.StateChange.CURRENT_STATE:\n   *               Remain in whatever is the current state\n   *           - qx.util.fsm.FiniteStateMachine.StateChange.POP_STATE_STACK:\n   *               Transition to the state at the top of the saved-state\n   *               stack, and remove the top element from the saved-state\n   *               stack.  Elements are added to the saved-state stack using\n   *               fsm.pushState().  It is an error if no state exists on the\n   *               saved-state stack.\n   *           - qx.util.fsm.FiniteStateMachine.StateChange.TERMINATE:\n   *               TBD\n   *\n   *     autoActionsBeforeOntransition -\n   *     autoActionsAfterOntransition -\n   *       Automatic actions which take place at the time specified by the\n   *       property name.  In all cases, the action takes place immediately\n   *       before or after the specified function.\n   *\n   *       The property value for each of these properties is an object which\n   *       describes some number of functions to invoke on a set of specified\n   *       objects (typically widgets).\n   *\n   *       See {@link qx.util.fsm.State} for an example of autoActions.\n   *\n   *     ontransition -\n   *       A function which is called if the predicate function for this\n   *       transition returns true.  Its signature is function(fsm, event) and\n   *       it is saved in the ontransition property of the transition object.\n   *       In the ontransition function:\n   *\n   *         fsm -\n   *           The finite state machine object to which this state is\n   *           attached.\n   *\n   *         event -\n   *           The event that caused a run of the finite state machine\n   *\n   *     Additional properties may be provided in transInfo.  They will not be\n   *     used by the finite state machine, but will be available via\n   *     this.getUserData(\"<propertyName>\") during the transition's predicate\n   *     and ontransition functions.\n   *   </pre>\n   */\n  construct(transitionName, transitionInfo) {\n    var context;\n\n    // Call our superclass' constructor\n    super();\n\n    // Save the state name\n    this.setName(transitionName);\n\n    // If a context was specified, retrieve it.\n    context = transitionInfo.context || window;\n\n    // Save it for future use\n    this.setUserData(\"context\", context);\n\n    // Save data from the transitionInfo object\n    for (var field in transitionInfo) {\n      // If we find one of our properties, call its setter.\n      switch (field) {\n        case \"predicate\":\n          this.setPredicate(\n            this.__bindIfFunction(transitionInfo[field], context)\n          );\n\n          break;\n\n        case \"nextState\":\n          this.setNextState(transitionInfo[field]);\n          break;\n\n        case \"autoActionsBeforeOntransition\":\n          this.setAutoActionsBeforeOntransition(\n            this.__bindIfFunction(transitionInfo[field], context)\n          );\n\n          break;\n\n        case \"autoActionsAfterOntransition\":\n          this.setAutoActionsAfterOntransition(\n            this.__bindIfFunction(transitionInfo[field], context)\n          );\n\n          break;\n\n        case \"ontransition\":\n          this.setOntransition(\n            this.__bindIfFunction(transitionInfo[field], context)\n          );\n\n          break;\n\n        case \"context\":\n          // already handled\n          break;\n\n        default:\n          // Anything else is user-provided data for their own use.  Save it.\n          this.setUserData(field, transitionInfo[field]);\n\n          // Log it in case it was a typo and they intended a built-in field\n          this.debug(\n            \"Transition \" +\n              transitionName +\n              \": \" +\n              \"Adding user-provided field to transition: \" +\n              field\n          );\n\n          break;\n      }\n    }\n  },\n\n  properties: {\n    /**\n     * The name of this transition\n     */\n    name: {\n      check: \"String\",\n      nullable: true\n    },\n\n    /**\n     * The predicate function for this transition.  This is documented in the\n     * constructor, and is typically provided through the constructor's\n     * transitionInfo object, but it is also possible (but highly NOT\n     * recommended) to change this dynamically.\n     */\n    predicate: {\n      init(fsm, event) {\n        return true;\n      },\n\n      transform: \"__transformPredicate\"\n    },\n\n    /**\n     * The state to transition to, if the predicate determines that this\n     * transition is acceptable.  This is documented in the constructor, and\n     * is typically provided through the constructor's transitionInfo object,\n     * but it is also possible (but highly NOT recommended) to change this\n     * dynamically.\n     */\n    nextState: {\n      init: qx.util.fsm.FiniteStateMachine.StateChange.CURRENT_STATE,\n      transform: \"__transformNextState\"\n    },\n\n    /**\n     * Automatic actions to take prior to calling the transition's\n     * ontransition function.  This is documented in the constructor, and is\n     * typically provided through the constructor's transitionInfo object, but\n     * it is also possible (but highly NOT recommended) to change this\n     * dynamically.\n     */\n    autoActionsBeforeOntransition: {\n      init(fsm, event) {},\n      transform: \"__transformAutoActionsBeforeOntransition\"\n    },\n\n    /**\n     * Automatic actions to take immediately after calling the transition's\n     * ontransition function.  This is documented in the constructor, and is\n     * typically provided through the constructor's transitionInfo object, but\n     * it is also possible (but highly NOT recommended) to change this\n     * dynamically.\n     */\n    autoActionsAfterOntransition: {\n      init(fsm, event) {},\n      transform: \"__transformAutoActionsAfterOntransition\"\n    },\n\n    /**\n     * The function run when the transition is accepted.  This is documented\n     * in the constructor, and is typically provided through the constructor's\n     * transitionInfo object, but it is also possible (but highly NOT\n     * recommended) to change this dynamically.\n     */\n    ontransition: {\n      init(fsm, event) {},\n      transform: \"__transformOntransition\"\n    }\n  },\n\n  members: {\n    /**\n     * Validate the predicate. Converts all incoming values to functions.\n     *\n     * @param value {var} incoming value\n     * @return {Function} predicate function\n     */\n    __transformPredicate(value) {\n      // Validate the predicate.  Convert all valid types to function.\n      switch (typeof value) {\n        case \"undefined\":\n          // No predicate means predicate passes\n          return function (fsm, event) {\n            return true;\n          };\n\n        case \"boolean\":\n          // Convert boolean predicate to a function which returns that value\n          return function (fsm, event) {\n            return value;\n          };\n\n        case \"function\":\n          // Use user-provided function.\n          return qx.lang.Function.bind(value, this.getUserData(\"context\"));\n\n        default:\n          throw new Error(\"Invalid transition predicate type: \" + typeof value);\n      }\n    },\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {Function} the final value\n     */\n    __transformNextState(value) {\n      // Validate nextState.  It must be a string or a number.\n      switch (typeof value) {\n        case \"string\":\n          return value;\n\n        case \"number\":\n          // Ensure that it's one of the possible state-change constants\n          switch (value) {\n            case qx.util.fsm.FiniteStateMachine.StateChange.CURRENT_STATE:\n            case qx.util.fsm.FiniteStateMachine.StateChange.POP_STATE_STACK:\n            case qx.util.fsm.FiniteStateMachine.StateChange.TERMINATE:\n              return value;\n\n            default:\n              throw new Error(\n                \"Invalid transition nextState value: \" +\n                  value +\n                  \": \" +\n                  \"nextState must be an explicit state name, \" +\n                  \"or one of the Fsm.StateChange constants\"\n              );\n          }\n\n        default:\n          throw new Error(\"Invalid transition nextState type: \" + typeof value);\n      }\n    },\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {Function} the final value\n     */\n    __transformAutoActionsBeforeOntransition(value) {\n      return qx.util.fsm.State._commonTransformAutoActions(\n        \"autoActionsBeforeOntransition\",\n        value,\n        this.getUserData(\"context\")\n      );\n    },\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {Function} the final value\n     */\n    __transformAutoActionsAfterOntransition(value) {\n      return qx.util.fsm.State._commonTransformAutoActions(\n        \"autoActionsAfterOntransition\",\n        value,\n        this.getUserData(\"context\")\n      );\n    },\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {Function} the final value\n     */\n    __transformOntransition(value) {\n      // Validate the ontransition function.  Convert undefined to function.\n      switch (typeof value) {\n        case \"undefined\":\n          // No provided function just means do nothing.  Use a null\n          // function.\n          return function (fsm, event) {};\n\n        case \"function\":\n          // Use user-provided function.\n          return qx.lang.Function.bind(value, this.getUserData(\"context\"));\n\n        default:\n          throw new Error(\"Invalid ontransition type: \" + typeof value);\n      }\n    },\n\n    /**\n     * If given a function, bind it to a specified context.\n     *\n     * @param f {Function|var}\n     *   The (possibly) function to be bound to the specified context.\n     *\n     * @param context {Object}\n     *   The context to bind the function to.\n     *\n     * @return {Function}\n     *   If f was a function, the return value is f wrapped such that it will\n     *   be called in the specified context. Otherwise, f is returned\n     *   unaltered.\n     */\n    __bindIfFunction(f, context) {\n      // Is the first parameter a function?\n      if (typeof f == \"function\") {\n        // Yup. Bind it to the specified context.\n        f = qx.lang.Function.bind(f, context);\n      }\n\n      return f;\n    }\n  }\n});\n"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC;;EAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;EACAH,EAAE,CAACI,KAAH,CAASC,MAAT,CAAgB,wBAAhB,EAA0C;IACxCC,MAAM,EAAEN,EAAE,CAACO,IAAH,CAAQC,MADwB;;IAGxC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEC,SA1GwC,qBA0G9BC,cA1G8B,EA0GdC,cA1Gc,EA0GE;MACxC,IAAIC,OAAJ,CADwC,CAGxC;;MACA,sCAJwC,CAMxC;;MACA,KAAKC,OAAL,CAAaH,cAAb,EAPwC,CASxC;;MACAE,OAAO,GAAGD,cAAc,CAACC,OAAf,IAA0BE,MAApC,CAVwC,CAYxC;;MACA,KAAKC,WAAL,CAAiB,SAAjB,EAA4BH,OAA5B,EAbwC,CAexC;;MACA,KAAK,IAAII,KAAT,IAAkBL,cAAlB,EAAkC;QAChC;QACA,QAAQK,KAAR;UACE,KAAK,WAAL;YACE,KAAKC,YAAL,CACE,KAAKC,SAAL,CAAsBP,cAAc,CAACK,KAAD,CAApC,EAA6CJ,OAA7C,CADF;YAIA;;UAEF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"
}