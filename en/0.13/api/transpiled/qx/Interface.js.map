{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "name",
    "config",
    "extend",
    "getClass",
    "iface",
    "$$extends",
    "properties",
    "$$properties",
    "members",
    "$$members",
    "events",
    "$$events",
    "$$type",
    "toString",
    "genericToString",
    "basename",
    "createNamespace",
    "Interface",
    "$$registry",
    "getByName",
    "isDefined",
    "undefined",
    "getTotalNumber",
    "objectGetLength",
    "flatten",
    "ifaces",
    "list",
    "concat",
    "i",
    "l",
    "length",
    "push",
    "apply",
    "__checkMembers",
    "__P_99_0",
    "object",
    "clazz",
    "wrap",
    "shouldThrow",
    "key",
    "isFunction",
    "isPropertyMethod",
    "__isPropertyMethod",
    "hasMemberFunction",
    "Error",
    "classname",
    "shouldWrapFunction",
    "util",
    "OOUtil",
    "hasInterface",
    "__wrapInterfaceMember",
    "__P_99_1",
    "methodName",
    "match",
    "propertyName",
    "firstLow",
    "getPropertyDefinition",
    "isBoolean",
    "check",
    "__checkProperties",
    "__P_99_3",
    "__checkEvents",
    "__P_99_4",
    "supportsEvent",
    "assertObject",
    "constructor",
    "assert",
    "prototype",
    "objectImplements",
    "classImplements",
    "has",
    "core",
    "Environment",
    "select",
    "_true",
    "origFunction",
    "functionName",
    "preCondition",
    "wrappedFunction",
    "arguments",
    "wrapper",
    "base",
    "_default",
    "__allowedKeys",
    "__validateConfig"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/Interface.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Sebastian Werner (wpbasti)\r\n     * Andreas Ecker (ecker)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * This class is used to define interfaces (similar to Java interfaces).\r\n *\r\n * See the description of the {@link #define} method how an interface is\r\n * defined.\r\n *\r\n * @require(qx.lang.normalize.Array)\r\n */\r\nqx.Bootstrap.define(\"qx.Interface\", {\r\n  statics: {\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n       PUBLIC API\r\n    ---------------------------------------------------------------------------\r\n    */\r\n\r\n    /**\r\n     * Define a new interface. Interface definitions look much like class definitions.\r\n     *\r\n     * The main difference is that the bodies of functions defined in <code>members</code>\r\n     * and <code>statics</code> are called before the original function with the\r\n     * same arguments. This can be used to check the passed arguments. If the\r\n     * checks fail, an exception should be thrown. It is convenient to use the\r\n     * method defined in {@link qx.core.MAssert} to check the arguments.\r\n     *\r\n     * In the <code>build</code> version the checks are omitted.\r\n     *\r\n     * For properties only the names are required so the value of the properties\r\n     * can be empty maps.\r\n     *\r\n     * Example:\r\n     * <pre class='javascript'>\r\n     * qx.Interface.define(\"name\",\r\n     * {\r\n     *   extend: [SuperInterfaces],\r\n     *\r\n     *   statics:\r\n     *   {\r\n     *     PI : 3.14\r\n     *   },\r\n     *\r\n     *   properties: {\"color\": {}, \"name\": {} },\r\n     *\r\n     *   members:\r\n     *   {\r\n     *     meth1: function() {},\r\n     *     meth2: function(a, b) { this.assertArgumentsCount(arguments, 2, 2); },\r\n     *     meth3: function(c) { this.assertInterface(c.constructor, qx.some.Interface); }\r\n     *   },\r\n     *\r\n     *   events :\r\n     *   {\r\n     *     keydown : \"qx.event.type.KeySequence\"\r\n     *   }\r\n     * });\r\n     * </pre>\r\n     *\r\n     * @param name {String} name of the interface\r\n     * @param config {Map ? null} Interface definition structure. The configuration map has the following keys:\r\n     *   <table>\r\n     *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>\r\n     *     <tr><th>extend</th><td>Interface |<br>Interface[]</td><td>Single interface or array of interfaces this interface inherits from.</td></tr>\r\n     *     <tr><th>members</th><td>Map</td><td>Map of members of the interface.</td></tr>\r\n     *     <tr><th>statics</th><td>Map</td><td>\r\n     *         Map of statics of the interface. The statics will not get copied into the target class.\r\n     *         This is the same behaviour as statics in mixins ({@link qx.Mixin#define}).\r\n     *     </td></tr>\r\n     *     <tr><th>properties</th><td>Map</td><td>Map of properties and their definitions.</td></tr>\r\n     *     <tr><th>events</th><td>Map</td><td>Map of event names and the corresponding event class name.</td></tr>\r\n     *   </table>\r\n     *\r\n     * @return {qx.Interface} The configured interface\r\n     */\r\n    define(name, config) {\r\n      if (config) {\r\n        // Normalize include\r\n        if (\r\n          config.extend &&\r\n          !(qx.Bootstrap.getClass(config.extend) === \"Array\")\r\n        ) {\r\n          config.extend = [config.extend];\r\n        }\r\n\r\n        // Validate incoming data\r\n        if (qx.core.Environment.get(\"qx.debug\")) {\r\n          this.__validateConfig(name, config);\r\n        }\r\n\r\n        // Create interface from statics\r\n        var iface = config.statics ? config.statics : {};\r\n\r\n        // Attach configuration\r\n        if (config.extend) {\r\n          iface.$$extends = config.extend;\r\n        }\r\n\r\n        if (config.properties) {\r\n          iface.$$properties = config.properties;\r\n        }\r\n\r\n        if (config.members) {\r\n          iface.$$members = config.members;\r\n        }\r\n\r\n        if (config.events) {\r\n          iface.$$events = config.events;\r\n        }\r\n      } else {\r\n        // Create empty interface\r\n        var iface = {};\r\n      }\r\n\r\n      // Add Basics\r\n      iface.$$type = \"Interface\";\r\n      iface.name = name;\r\n\r\n      // Attach toString\r\n      iface.toString = this.genericToString;\r\n\r\n      // Assign to namespace\r\n      iface.basename = qx.Bootstrap.createNamespace(name, iface);\r\n\r\n      // Add to registry\r\n      qx.Interface.$$registry[name] = iface;\r\n\r\n      // Return final interface\r\n      return iface;\r\n    },\r\n\r\n    /**\r\n     * Returns an interface by name\r\n     *\r\n     * @param name {String} class name to resolve\r\n     * @return {Class} the class\r\n     */\r\n    getByName(name) {\r\n      return this.$$registry[name];\r\n    },\r\n\r\n    /**\r\n     * Determine if interface exists\r\n     *\r\n     * @param name {String} Interface name to check\r\n     * @return {Boolean} true if interface exists\r\n     */\r\n    isDefined(name) {\r\n      return this.getByName(name) !== undefined;\r\n    },\r\n\r\n    /**\r\n     * Determine the number of interfaces which are defined\r\n     *\r\n     * @return {Number} the number of interfaces\r\n     */\r\n    getTotalNumber() {\r\n      return qx.Bootstrap.objectGetLength(this.$$registry);\r\n    },\r\n\r\n    /**\r\n     * Generates a list of all interfaces including their super interfaces\r\n     * (resolved recursively)\r\n     *\r\n     * @param ifaces {Interface[] ? []} List of interfaces to be resolved\r\n     * @return {Array} List of all interfaces\r\n     */\r\n    flatten(ifaces) {\r\n      if (!ifaces) {\r\n        return [];\r\n      }\r\n\r\n      // we need to create a copy and not to modify the existing array\r\n      var list = ifaces.concat();\r\n\r\n      for (var i = 0, l = ifaces.length; i < l; i++) {\r\n        if (ifaces[i].$$extends) {\r\n          list.push.apply(list, this.flatten(ifaces[i].$$extends));\r\n        }\r\n      }\r\n\r\n      return list;\r\n    },\r\n\r\n    /**\r\n     * Assert members\r\n     *\r\n     * @param object {qx.core.Object} The object, which contains the methods\r\n     * @param clazz {Class} class of the object\r\n     * @param iface {Interface} the interface to verify\r\n     * @param wrap {Boolean ? false} wrap functions required by interface to\r\n     *     check parameters etc.\r\n     * @param shouldThrow {Boolean} if <code>false</code>, the method\r\n     *   will return a boolean instead of throwing an exception\r\n     * @return {Boolean} <code>true</code> if all members are supported\r\n     */\r\n    __checkMembers(object, clazz, iface, wrap, shouldThrow) {\r\n      // Validate members\r\n      var members = iface.$$members;\r\n      if (members) {\r\n        for (var key in members) {\r\n          if (qx.Bootstrap.isFunction(members[key])) {\r\n            var isPropertyMethod = this.__isPropertyMethod(clazz, key);\r\n            var hasMemberFunction =\r\n              isPropertyMethod || qx.Bootstrap.isFunction(object[key]);\r\n\r\n            if (!hasMemberFunction) {\r\n              if (shouldThrow) {\r\n                throw new Error(\r\n                  'Implementation of method \"' +\r\n                    key +\r\n                    '\" is missing in class \"' +\r\n                    clazz.classname +\r\n                    '\" required by interface \"' +\r\n                    iface.name +\r\n                    '\"'\r\n                );\r\n              } else {\r\n                return false;\r\n              }\r\n            }\r\n\r\n            // Only wrap members if the interface was not been applied yet. This\r\n            // can easily be checked by the recursive hasInterface method.\r\n            var shouldWrapFunction =\r\n              wrap === true &&\r\n              !isPropertyMethod &&\r\n              !qx.util.OOUtil.hasInterface(clazz, iface);\r\n\r\n            if (shouldWrapFunction) {\r\n              object[key] = this.__wrapInterfaceMember(\r\n                iface,\r\n                object[key],\r\n                key,\r\n                members[key]\r\n              );\r\n            }\r\n          } else {\r\n            // Other members are not checked more detailed because of\r\n            // JavaScript's loose type handling\r\n            if (typeof object[key] === \"undefined\") {\r\n              if (shouldThrow) {\r\n                throw new Error(\r\n                  'Implementation of member \"' +\r\n                    key +\r\n                    '\" is missing in class \"' +\r\n                    clazz.classname +\r\n                    '\" required by interface \"' +\r\n                    iface.name +\r\n                    '\"'\r\n                );\r\n              } else {\r\n                return false;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (!shouldThrow) {\r\n        return true;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Internal helper to detect if the method will be generated by the\r\n     * property system.\r\n     *\r\n     * @param clazz {Class} The current class.\r\n     * @param methodName {String} The name of the method.\r\n     *\r\n     * @return {Boolean} true, if the method will be generated by the property\r\n     *   system.\r\n     */\r\n    __isPropertyMethod(clazz, methodName) {\r\n      var match = methodName.match(/^(is|toggle|get|set|reset)(.*)$/);\r\n\r\n      if (!match) {\r\n        return false;\r\n      }\r\n\r\n      var propertyName = qx.Bootstrap.firstLow(match[2]);\r\n      var isPropertyMethod = qx.util.OOUtil.getPropertyDefinition(\r\n        clazz,\r\n        propertyName\r\n      );\r\n\r\n      if (!isPropertyMethod) {\r\n        return false;\r\n      }\r\n\r\n      var isBoolean = match[0] === \"is\" || match[0] === \"toggle\";\r\n      if (isBoolean) {\r\n        return (\r\n          qx.util.OOUtil.getPropertyDefinition(clazz, propertyName).check ===\r\n          \"Boolean\"\r\n        );\r\n      }\r\n\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Assert properties\r\n     *\r\n     * @param clazz {Class} class to check interface for\r\n     * @param iface {Interface} the interface to verify\r\n     * @param shouldThrow {Boolean} if <code>false</code>, the method\r\n     *   will return a boolean instead of throwing an exception\r\n     * @return {Boolean} <code>true</code> if all properties are supported\r\n     */\r\n    __checkProperties(clazz, iface, shouldThrow) {\r\n      if (iface.$$properties) {\r\n        for (var key in iface.$$properties) {\r\n          if (!qx.util.OOUtil.getPropertyDefinition(clazz, key)) {\r\n            if (shouldThrow) {\r\n              throw new Error(\r\n                'The property \"' +\r\n                  key +\r\n                  '\" is not supported by Class \"' +\r\n                  clazz.classname +\r\n                  '\"!'\r\n              );\r\n            } else {\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (!shouldThrow) {\r\n        return true;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Assert events\r\n     *\r\n     * @param clazz {Class} class to check interface for\r\n     * @param iface {Interface} the interface to verify\r\n     * @param shouldThrow {Boolean} if <code>false</code>, the method\r\n     *   will return a boolean instead of throwing an exception\r\n     * @return {Boolean} <code>true</code> if all events are supported\r\n     */\r\n    __checkEvents(clazz, iface, shouldThrow) {\r\n      if (iface.$$events) {\r\n        for (var key in iface.$$events) {\r\n          if (!qx.util.OOUtil.supportsEvent(clazz, key)) {\r\n            if (shouldThrow) {\r\n              throw new Error(\r\n                'The event \"' +\r\n                  key +\r\n                  '\" is not supported by Class \"' +\r\n                  clazz.classname +\r\n                  '\"!'\r\n              );\r\n            } else {\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (!shouldThrow) {\r\n        return true;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Asserts that the given object implements all the methods defined in the\r\n     * interface. This method throws an exception if the object does not\r\n     * implement the interface.\r\n     *\r\n     *  @param object {qx.core.Object} Object to check interface for\r\n     *  @param iface {Interface} The interface to verify\r\n     */\r\n    assertObject(object, iface) {\r\n      var clazz = object.constructor;\r\n      this.__checkMembers(object, clazz, iface, false, true);\r\n      this.__checkProperties(clazz, iface, true);\r\n      this.__checkEvents(clazz, iface, true);\r\n\r\n      // Validate extends, recursive\r\n      var extend = iface.$$extends;\r\n      if (extend) {\r\n        for (var i = 0, l = extend.length; i < l; i++) {\r\n          this.assertObject(object, extend[i]);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Checks if an interface is implemented by a class\r\n     *\r\n     * @param clazz {Class} class to check interface for\r\n     * @param iface {Interface} the interface to verify\r\n     * @param wrap {Boolean ? false} wrap functions required by interface to\r\n     *     check parameters etc.\r\n     */\r\n    assert(clazz, iface, wrap) {\r\n      this.__checkMembers(clazz.prototype, clazz, iface, wrap, true);\r\n      this.__checkProperties(clazz, iface, true);\r\n      this.__checkEvents(clazz, iface, true);\r\n\r\n      // Validate extends, recursive\r\n      var extend = iface.$$extends;\r\n      if (extend) {\r\n        for (var i = 0, l = extend.length; i < l; i++) {\r\n          this.assert(clazz, extend[i], wrap);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Asserts that the given object implements all the methods defined in the\r\n     * interface.\r\n     *\r\n     *  @param object {qx.core.Object} Object to check interface for\r\n     *  @param iface {Interface} The interface to verify\r\n     * @return {Boolean} <code>true</code> if the objects implements the interface\r\n     */\r\n    objectImplements(object, iface) {\r\n      var clazz = object.constructor;\r\n      if (\r\n        !this.__checkMembers(object, clazz, iface) ||\r\n        !this.__checkProperties(clazz, iface) ||\r\n        !this.__checkEvents(clazz, iface)\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      // Validate extends, recursive\r\n      var extend = iface.$$extends;\r\n      if (extend) {\r\n        for (var i = 0, l = extend.length; i < l; i++) {\r\n          if (!this.objectImplements(object, extend[i])) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Tests whether an interface is implemented by a class, without throwing an\r\n     * exception when it doesn't.\r\n     *\r\n     * @param clazz {Class} class to check interface for\r\n     * @param iface {Interface} the interface to verify\r\n     * @return {Boolean} <code>true</code> if interface is implemented\r\n     */\r\n    classImplements(clazz, iface) {\r\n      if (\r\n        !this.__checkMembers(clazz.prototype, clazz, iface) ||\r\n        !this.__checkProperties(clazz, iface) ||\r\n        !this.__checkEvents(clazz, iface)\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      // Validate extends, recursive\r\n      var extend = iface.$$extends;\r\n      if (extend) {\r\n        for (var i = 0, l = extend.length; i < l; i++) {\r\n          if (!this.has(clazz, extend[i])) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n\r\n      return true;\r\n    },\r\n\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n       PRIVATE/INTERNAL API\r\n    ---------------------------------------------------------------------------\r\n    */\r\n\r\n    /**\r\n     * This method will be attached to all interface to return\r\n     * a nice identifier for them.\r\n     *\r\n     * @internal\r\n     * @return {String} The interface identifier\r\n     */\r\n    genericToString() {\r\n      return \"[Interface \" + this.name + \"]\";\r\n    },\r\n\r\n    /** Registry of all defined interfaces */\r\n    $$registry: {},\r\n\r\n    /**\r\n     * Wrap a method with a precondition check.\r\n     *\r\n     * @signature function(iface, origFunction, functionName, preCondition)\r\n     * @param iface {String} Name of the interface, where the pre condition\r\n     *   was defined. (Used in error messages).\r\n     * @param origFunction {Function} function to wrap.\r\n     * @param functionName {String} name of the function. (Used in error messages).\r\n     * @param preCondition {Function}. This function gets called with the arguments of the\r\n     *   original function. If this function return true the original function is called.\r\n     *   Otherwise an exception is thrown.\r\n     * @return {Function} wrapped function\r\n     */\r\n    __wrapInterfaceMember: qx.core.Environment.select(\"qx.debug\", {\r\n      true(iface, origFunction, functionName, preCondition) {\r\n        function wrappedFunction() {\r\n          // call precondition\r\n          preCondition.apply(this, arguments);\r\n\r\n          // call original function\r\n          return origFunction.apply(this, arguments);\r\n        }\r\n\r\n        origFunction.wrapper = wrappedFunction;\r\n        if (origFunction.base !== undefined) {\r\n          if (wrappedFunction.base !== undefined) {\r\n            throw new Error(\"base is already defined for the wrapped function\");\r\n          }\r\n          wrappedFunction.base = origFunction.base;\r\n        }\r\n        return wrappedFunction;\r\n      },\r\n\r\n      default(iface, origFunction, functionName, preCondition) {}\r\n    }),\r\n\r\n    /** @type {Map} allowed keys in interface definition */\r\n    __allowedKeys: qx.core.Environment.select(\"qx.debug\", {\r\n      true: {\r\n        extend: \"object\", // Interface | Interface[]\r\n        statics: \"object\", // Map\r\n        members: \"object\", // Map\r\n        properties: \"object\", // Map\r\n        events: \"object\" // Map\r\n      },\r\n\r\n      default: null\r\n    }),\r\n\r\n    /**\r\n     * Validates incoming configuration and checks keys and values\r\n     *\r\n     * @signature function(name, config)\r\n     * @param name {String} The name of the class\r\n     * @param config {Map} Configuration map\r\n     */\r\n    __validateConfig: qx.core.Environment.select(\"qx.debug\", {\r\n      true(name, config) {\r\n        if (qx.core.Environment.get(\"qx.debug\")) {\r\n          // Validate keys\r\n          var allowed = this.__allowedKeys;\r\n\r\n          for (var key in config) {\r\n            if (allowed[key] === undefined) {\r\n              throw new Error(\r\n                'The configuration key \"' +\r\n                  key +\r\n                  '\" in class \"' +\r\n                  name +\r\n                  '\" is not allowed!'\r\n              );\r\n            }\r\n\r\n            if (config[key] == null) {\r\n              throw new Error(\r\n                \"Invalid key '\" +\r\n                  key +\r\n                  \"' in interface '\" +\r\n                  name +\r\n                  \"'! The value is undefined/null!\"\r\n              );\r\n            }\r\n\r\n            if (allowed[key] !== null && typeof config[key] !== allowed[key]) {\r\n              throw new Error(\r\n                'Invalid type of key \"' +\r\n                  key +\r\n                  '\" in interface \"' +\r\n                  name +\r\n                  '\"! The type of the key must be \"' +\r\n                  allowed[key] +\r\n                  '\"!'\r\n              );\r\n            }\r\n          }\r\n\r\n          // Validate maps\r\n          var maps = [\"statics\", \"members\", \"properties\", \"events\"];\r\n          for (var i = 0, l = maps.length; i < l; i++) {\r\n            var key = maps[i];\r\n\r\n            if (\r\n              config[key] !== undefined &&\r\n              ([\"Array\", \"RegExp\", \"Date\"].indexOf(\r\n                qx.Bootstrap.getClass(config[key])\r\n              ) != -1 ||\r\n                config[key].classname !== undefined)\r\n            ) {\r\n              throw new Error(\r\n                'Invalid key \"' +\r\n                  key +\r\n                  '\" in interface \"' +\r\n                  name +\r\n                  '\"! The value needs to be a map!'\r\n              );\r\n            }\r\n          }\r\n\r\n          // Validate extends\r\n          if (config.extend) {\r\n            for (var i = 0, a = config.extend, l = a.length; i < l; i++) {\r\n              if (a[i] == null) {\r\n                throw new Error(\r\n                  \"Extends of interfaces must be interfaces. The extend number '\" +\r\n                    i +\r\n                    1 +\r\n                    \"' in interface '\" +\r\n                    name +\r\n                    \"' is undefined/null!\"\r\n                );\r\n              }\r\n\r\n              if (a[i].$$type !== \"Interface\") {\r\n                throw new Error(\r\n                  \"Extends of interfaces must be interfaces. The extend number '\" +\r\n                    i +\r\n                    1 +\r\n                    \"' in interface '\" +\r\n                    name +\r\n                    \"' is not an interface!\"\r\n                );\r\n              }\r\n            }\r\n          }\r\n\r\n          // Validate statics\r\n          if (config.statics) {\r\n            for (var key in config.statics) {\r\n              if (key.toUpperCase() !== key) {\r\n                throw new Error(\r\n                  'Invalid key \"' +\r\n                    key +\r\n                    '\" in interface \"' +\r\n                    name +\r\n                    '\"! Static constants must be all uppercase.'\r\n                );\r\n              }\r\n\r\n              switch (typeof config.statics[key]) {\r\n                case \"boolean\":\r\n                case \"string\":\r\n                case \"number\":\r\n                  break;\r\n\r\n                default:\r\n                  throw new Error(\r\n                    'Invalid key \"' +\r\n                      key +\r\n                      '\" in interface \"' +\r\n                      name +\r\n                      '\"! Static constants must be all of a primitive type.'\r\n                  );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      },\r\n\r\n      default(name, config) {}\r\n    })\r\n  }\r\n});\r\n"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAS,CAACC,oBAAoB,CAACC,aAAa,CAAC;EAAhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAH,EAAE,CAACC,SAAS,CAACG,MAAM,CAAC,cAAc,EAAE;IAClCC,OAAO,EAAE;MACP;AACJ;AACA;AACA;AACA;MAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACID,MAAM,WAAAA,OAACE,IAAI,EAAEC,MAAM,EAAE;QACnB,IAAIA,MAAM,EAAE;UACV;UACA,IACEA,MAAM,CAACC,MAAM,IACb,EAAER,EAAE,CAACC,SAAS,CAACQ,QAAQ,CAACF,MAAM,CAACC,MAAM,CAAC,KAAK,OAAO,CAAC,EACnD;YACAD,MAAM,CAACC,MAAM,GAAG,CAACD,MAAM,CAACC,MAAM,CAAC;UACjC;;UAEA;;UAKA;UACA,IAAIE,KAAK,GAAGH,MAAM,CAACF,OAAO,GAAGE,MAAM,CAACF,OAAO,GAAG,CAAC,CAAC;;UAEhD;UACA,IAAIE,MAAM,CAACC,MAAM,EAAE;YACjBE,KAAK,CAACC,SAAS,GAAGJ,MAAM,CAACC,MAAM;UACjC;UAEA,IAAID,MAAM,CAACK,UAAU,EAAE;YACrBF,KAAK,CAACG,YAAY,GAAGN,MAAM,CAACK,UAAU;UACxC;UAEA,IAAIL,MAAM,CAACO,OAAO,EAAE;YAClBJ,KAAK,CAACK,SAAS,GAAGR,MAAM,CAACO,OAAO;UAClC;UAEA,IAAIP,MAAM,CAACS,MAAM,EAAE;YACjBN,KAAK,CAACO,QAAQ,GAAGV,MAAM,CAACS,MAAM;UAChC;QACF,CAAC,MAAM;UACL;UACA,IAAIN,KAAK,GAAG,CAAC,CAAC;QAChB;;QAEA;QACAA,KAAK,CAACQ,MAAM,GAAG,WAAW;QAC1BR,KAAK,CAACJ,IAAI,GAAGA,IAAI;;QAEjB;QACAI,KAAK,CAACS,QAAQ,GAAG,IAAI,CAACC,eAAe;;QAErC;QACAV,KAAK,CAACW,QAAQ,GAAGrB,EAAE,CAACC,SAAS,CAACqB,eAAe,CAAChB,IAAI,EAAEI,KAAK,CAAC;;QAE1D;QACAV,EAAE,CAACuB,SAAS,CAACC,UAAU,CAAClB,IAAI,CAAC,GAAGI,KAAK;;QAErC;QACA,OAAOA,KAAK;MACd,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;MACIe,SAAS,WAAAA,UAACnB,IAAI,EAAE;QACd,OAAO,IAAI,CAACkB,UAAU,CAAClB,IAAI,CAAC;MAC9B,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;MACIoB,SAAS,WAAAA,UAACpB,IAAI,EAAE;QACd,OAAO,IAAI,CAACmB,SAAS,CAACnB,IAAI,CAAC,KAAKqB,SAAS;MAC3C,CAAC;MAED;AACJ;AACA;AACA;AACA;MACIC,cAAc,WAAAA,eAAA,EAAG;QACf,OAAO5B,EAAE,CAACC,SAAS,CAAC4B,eAAe,CAAC,IAAI,CAACL,UAAU,CAAC;MACtD,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;MACIM,OAAO,WAAAA,QAACC,MAAM,EAAE;QACd,IAAI,CAACA,MAAM,EAAE;UACX,OAAO,EAAE;QACX;;QAEA;QACA,IAAIC,IAAI,GAAGD,MAAM,CAACE,MAAM,CAAC,CAAC;QAE1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGJ,MAAM,CAACK,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;UAC7C,IAAIH,MAAM,CAACG,CAAC,CAAC,CAACvB,SAAS,EAAE;YACvBqB,IAAI,CAACK,IAAI,CAACC,KAAK,CAACN,IAAI,EAAE,IAAI,CAACF,OAAO,CAACC,MAAM,CAACG,CAAC,CAAC,CAACvB,SAAS,CAAC,CAAC;UAC1D;QACF;QAEA,OAAOqB,IAAI;MACb,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIO,QAAc,WAAAC,SAACC,MAAM,EAAEC,KAAK,EAAEhC,KAAK,EAAEiC,IAAI,EAAEC,WAAW,EAAE;QACtD;QACA,IAAI9B,OAAO,GAAGJ,KAAK,CAACK,SAAS;QAC7B,IAAID,OAAO,EAAE;UACX,KAAK,IAAI+B,GAAG,IAAI/B,OAAO,EAAE;YACvB,IAAId,EAAE,CAACC,SAAS,CAAC6C,UAAU,CAAChC,OAAO,CAAC+B,GAAG,CAAC,CAAC,EAAE;cACzC,IAAIE,gBAAgB,GAAG,IAAI,CAACC,QAAkB,CAACN,KAAK,EAAEG,GAAG,CAAC;cAC1D,IAAII,iBAAiB,GACnBF,gBAAgB,IAAI/C,EAAE,CAACC,SAAS,CAAC6C,UAAU,CAACL,MAAM,CAACI,GAAG,CAAC,CAAC;cAE1D,IAAI,CAACI,iBAAiB,EAAE;gBACtB,IAAIL,WAAW,EAAE;kBACf,MAAM,IAAIM,KAAK,CACb,4BAA4B,GAC1BL,GAAG,GACH,yBAAyB,GACzBH,KAAK,CAACS,SAAS,GACf,2BAA2B,GAC3BzC,KAAK,CAACJ,IAAI,GACV,GACJ,CAAC;gBACH,CAAC,MAAM;kBACL,OAAO,KAAK;gBACd;cACF;;cAEA;cACA;cACA,IAAI8C,kBAAkB,GACpBT,IAAI,KAAK,IAAI,IACb,CAACI,gBAAgB,IACjB,CAAC/C,EAAE,CAACqD,IAAI,CAACC,MAAM,CAACC,YAAY,CAACb,KAAK,EAAEhC,KAAK,CAAC;cAE5C,IAAI0C,kBAAkB,EAAE;gBACtBX,MAAM,CAACI,GAAG,CAAC,GAAG,IAAI,CAACW,QAAqB,CACtC9C,KAAK,EACL+B,MAAM,CAACI,GAAG,CAAC,EACXA,GAAG,EACH/B,OAAO,CAAC+B,GAAG,CACb,CAAC;cACH;YACF,CAAC,MAAM;cACL;cACA;cACA,IAAI,OAAOJ,MAAM,CAACI,GAAG,CAAC,KAAK,WAAW,EAAE;gBACtC,IAAID,WAAW,EAAE;kBACf,MAAM,IAAIM,KAAK,CACb,4BAA4B,GAC1BL,GAAG,GACH,yBAAyB,GACzBH,KAAK,CAACS,SAAS,GACf,2BAA2B,GAC3BzC,KAAK,CAACJ,IAAI,GACV,GACJ,CAAC;gBACH,CAAC,MAAM;kBACL,OAAO,KAAK;gBACd;cACF;YACF;UACF;QACF;QACA,IAAI,CAACsC,WAAW,EAAE;UAChB,OAAO,IAAI;QACb;MACF,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACII,QAAkB,WAAAS,SAACf,KAAK,EAAEgB,UAAU,EAAE;QACpC,IAAIC,KAAK,GAAGD,UAAU,CAACC,KAAK,CAAC,iCAAiC,CAAC;QAE/D,IAAI,CAACA,KAAK,EAAE;UACV,OAAO,KAAK;QACd;QAEA,IAAIC,YAAY,GAAG5D,EAAE,CAACC,SAAS,CAAC4D,QAAQ,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC;QAClD,IAAIZ,gBAAgB,GAAG/C,EAAE,CAACqD,IAAI,CAACC,MAAM,CAACQ,qBAAqB,CACzDpB,KAAK,EACLkB,YACF,CAAC;QAED,IAAI,CAACb,gBAAgB,EAAE;UACrB,OAAO,KAAK;QACd;QAEA,IAAIgB,SAAS,GAAGJ,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ;QAC1D,IAAII,SAAS,EAAE;UACb,OACE/D,EAAE,CAACqD,IAAI,CAACC,MAAM,CAACQ,qBAAqB,CAACpB,KAAK,EAAEkB,YAAY,CAAC,CAACI,KAAK,KAC/D,SAAS;QAEb;QAEA,OAAO,IAAI;MACb,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,QAAiB,WAAAC,SAACxB,KAAK,EAAEhC,KAAK,EAAEkC,WAAW,EAAE;QAC3C,IAAIlC,KAAK,CAACG,YAAY,EAAE;UACtB,KAAK,IAAIgC,GAAG,IAAInC,KAAK,CAACG,YAAY,EAAE;YAClC,IAAI,CAACb,EAAE,CAACqD,IAAI,CAACC,MAAM,CAACQ,qBAAqB,CAACpB,KAAK,EAAEG,GAAG,CAAC,EAAE;cACrD,IAAID,WAAW,EAAE;gBACf,MAAM,IAAIM,KAAK,CACb,gBAAgB,GACdL,GAAG,GACH,+BAA+B,GAC/BH,KAAK,CAACS,SAAS,GACf,IACJ,CAAC;cACH,CAAC,MAAM;gBACL,OAAO,KAAK;cACd;YACF;UACF;QACF;QACA,IAAI,CAACP,WAAW,EAAE;UAChB,OAAO,IAAI;QACb;MACF,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIuB,QAAa,WAAAC,SAAC1B,KAAK,EAAEhC,KAAK,EAAEkC,WAAW,EAAE;QACvC,IAAIlC,KAAK,CAACO,QAAQ,EAAE;UAClB,KAAK,IAAI4B,GAAG,IAAInC,KAAK,CAACO,QAAQ,EAAE;YAC9B,IAAI,CAACjB,EAAE,CAACqD,IAAI,CAACC,MAAM,CAACe,aAAa,CAAC3B,KAAK,EAAEG,GAAG,CAAC,EAAE;cAC7C,IAAID,WAAW,EAAE;gBACf,MAAM,IAAIM,KAAK,CACb,aAAa,GACXL,GAAG,GACH,+BAA+B,GAC/BH,KAAK,CAACS,SAAS,GACf,IACJ,CAAC;cACH,CAAC,MAAM;gBACL,OAAO,KAAK;cACd;YACF;UACF;QACF;QACA,IAAI,CAACP,WAAW,EAAE;UAChB,OAAO,IAAI;QACb;MACF,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;MACI0B,YAAY,WAAAA,aAAC7B,MAAM,EAAE/B,KAAK,EAAE;QAC1B,IAAIgC,KAAK,GAAGD,MAAM,CAAC8B,WAAW;QAC9B,IAAI,CAAChC,QAAc,CAACE,MAAM,EAAEC,KAAK,EAAEhC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC;QACtD,IAAI,CAACuD,QAAiB,CAACvB,KAAK,EAAEhC,KAAK,EAAE,IAAI,CAAC;QAC1C,IAAI,CAACyD,QAAa,CAACzB,KAAK,EAAEhC,KAAK,EAAE,IAAI,CAAC;;QAEtC;QACA,IAAIF,MAAM,GAAGE,KAAK,CAACC,SAAS;QAC5B,IAAIH,MAAM,EAAE;UACV,KAAK,IAAI0B,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG3B,MAAM,CAAC4B,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;YAC7C,IAAI,CAACoC,YAAY,CAAC7B,MAAM,EAAEjC,MAAM,CAAC0B,CAAC,CAAC,CAAC;UACtC;QACF;MACF,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;MACIsC,MAAM,WAAAA,OAAC9B,KAAK,EAAEhC,KAAK,EAAEiC,IAAI,EAAE;QACzB,IAAI,CAACJ,QAAc,CAACG,KAAK,CAAC+B,SAAS,EAAE/B,KAAK,EAAEhC,KAAK,EAAEiC,IAAI,EAAE,IAAI,CAAC;QAC9D,IAAI,CAACsB,QAAiB,CAACvB,KAAK,EAAEhC,KAAK,EAAE,IAAI,CAAC;QAC1C,IAAI,CAACyD,QAAa,CAACzB,KAAK,EAAEhC,KAAK,EAAE,IAAI,CAAC;;QAEtC;QACA,IAAIF,MAAM,GAAGE,KAAK,CAACC,SAAS;QAC5B,IAAIH,MAAM,EAAE;UACV,KAAK,IAAI0B,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG3B,MAAM,CAAC4B,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;YAC7C,IAAI,CAACsC,MAAM,CAAC9B,KAAK,EAAElC,MAAM,CAAC0B,CAAC,CAAC,EAAES,IAAI,CAAC;UACrC;QACF;MACF,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;MACI+B,gBAAgB,WAAAA,iBAACjC,MAAM,EAAE/B,KAAK,EAAE;QAC9B,IAAIgC,KAAK,GAAGD,MAAM,CAAC8B,WAAW;QAC9B,IACE,CAAC,IAAI,CAAChC,QAAc,CAACE,MAAM,EAAEC,KAAK,EAAEhC,KAAK,CAAC,IAC1C,CAAC,IAAI,CAACuD,QAAiB,CAACvB,KAAK,EAAEhC,KAAK,CAAC,IACrC,CAAC,IAAI,CAACyD,QAAa,CAACzB,KAAK,EAAEhC,KAAK,CAAC,EACjC;UACA,OAAO,KAAK;QACd;;QAEA;QACA,IAAIF,MAAM,GAAGE,KAAK,CAACC,SAAS;QAC5B,IAAIH,MAAM,EAAE;UACV,KAAK,IAAI0B,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG3B,MAAM,CAAC4B,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;YAC7C,IAAI,CAAC,IAAI,CAACwC,gBAAgB,CAACjC,MAAM,EAAEjC,MAAM,CAAC0B,CAAC,CAAC,CAAC,EAAE;cAC7C,OAAO,KAAK;YACd;UACF;QACF;QAEA,OAAO,IAAI;MACb,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;MACIyC,eAAe,WAAAA,gBAACjC,KAAK,EAAEhC,KAAK,EAAE;QAC5B,IACE,CAAC,IAAI,CAAC6B,QAAc,CAACG,KAAK,CAAC+B,SAAS,EAAE/B,KAAK,EAAEhC,KAAK,CAAC,IACnD,CAAC,IAAI,CAACuD,QAAiB,CAACvB,KAAK,EAAEhC,KAAK,CAAC,IACrC,CAAC,IAAI,CAACyD,QAAa,CAACzB,KAAK,EAAEhC,KAAK,CAAC,EACjC;UACA,OAAO,KAAK;QACd;;QAEA;QACA,IAAIF,MAAM,GAAGE,KAAK,CAACC,SAAS;QAC5B,IAAIH,MAAM,EAAE;UACV,KAAK,IAAI0B,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG3B,MAAM,CAAC4B,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;YAC7C,IAAI,CAAC,IAAI,CAAC0C,GAAG,CAAClC,KAAK,EAAElC,MAAM,CAAC0B,CAAC,CAAC,CAAC,EAAE;cAC/B,OAAO,KAAK;YACd;UACF;QACF;QAEA,OAAO,IAAI;MACb,CAAC;MAED;AACJ;AACA;AACA;AACA;MAEI;AACJ;AACA;AACA;AACA;AACA;AACA;MACId,eAAe,WAAAA,gBAAA,EAAG;QAChB,OAAO,aAAa,GAAG,IAAI,CAACd,IAAI,GAAG,GAAG;MACxC,CAAC;MAED;MACAkB,UAAU,EAAE,CAAC,CAAC;MAEd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIgC,QAAqB,EAAExD,EAAE,CAAC6E,IAAI,CAACC,WAAW,CAACC,MAAM,CAAC,UAAU,EAAE;QAAA,iBAAAC,MACvDtE,KAAK,EAAEuE,YAAY,EAAEC,YAAY,EAAEC,YAAY,EAAE;UACpD,SAASC,eAAeA,CAAA,EAAG;YACzB;YACAD,YAAY,CAAC7C,KAAK,CAAC,IAAI,EAAE+C,SAAS,CAAC;;YAEnC;YACA,OAAOJ,YAAY,CAAC3C,KAAK,CAAC,IAAI,EAAE+C,SAAS,CAAC;UAC5C;UAEAJ,YAAY,CAACK,OAAO,GAAGF,eAAe;UACtC,IAAIH,YAAY,CAACM,IAAI,KAAK5D,SAAS,EAAE;YACnC,IAAIyD,eAAe,CAACG,IAAI,KAAK5D,SAAS,EAAE;cACtC,MAAM,IAAIuB,KAAK,CAAC,kDAAkD,CAAC;YACrE;YACAkC,eAAe,CAACG,IAAI,GAAGN,YAAY,CAACM,IAAI;UAC1C;UACA,OAAOH,eAAe;QACxB,CAAC;QAAA,oBAAAI,SAEO9E,KAAK,EAAEuE,YAAY,EAAEC,YAAY,EAAEC,YAAY,EAAE,CAAC;MAC5D,CAAC,CAAC;MAEF;MACAM,QAAa,EAAEzF,EAAE,CAAC6E,IAAI,CAACC,WAAW,CAACC,MAAM,CAAC,UAAU,EAAE;QACpD,QAAM;UACJvE,MAAM,EAAE,QAAQ;UAAE;UAClBH,OAAO,EAAE,QAAQ;UAAE;UACnBS,OAAO,EAAE,QAAQ;UAAE;UACnBF,UAAU,EAAE,QAAQ;UAAE;UACtBI,MAAM,EAAE,QAAQ,CAAC;QACnB,CAAC;;QAED,WAAS;MACX,CAAC,CAAC;MAEF;AACJ;AACA;AACA;AACA;AACA;AACA;MACI0E,QAAgB,EAAE1F,EAAE,CAAC6E,IAAI,CAACC,WAAW,CAACC,MAAM,CAAC,UAAU,EAAE;QAAA,iBAAAC,MAClD1E,IAAI,EAAEC,MAAM,EAAE,CAuHnB,CAAC;QAAA,oBAAAiF,SAEOlF,IAAI,EAAEC,MAAM,EAAE,CAAC;MACzB,CAAC;IACH;EACF,CAAC,CAAC;EAjrBFP,EAAE,CAACuB,SAAS,CAACpB,aAAa,GAAGA,aAAa;AAAC"
}