{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/compiler/node_modules/@qooxdoo/framework/source/class/qx/io/remote/Rpc.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "url",
    "serviceName",
    "undefined",
    "setUrl",
    "setServiceName",
    "ServerSettings",
    "__currentServerSuffix",
    "serverPathSuffix",
    "events",
    "statics",
    "origin",
    "server",
    "application",
    "transport",
    "local",
    "localError",
    "timeout",
    "abort",
    "nodata",
    "CONVERT_DATES",
    "RESPONSE_JSON",
    "makeServerURL",
    "instanceId",
    "retVal",
    "serverPathPrefix",
    "properties",
    "check",
    "nullable",
    "crossDomain",
    "init",
    "serverData",
    "username",
    "password",
    "useBasicHttpAuth",
    "protocol",
    "val",
    "members",
    "__previousServerSuffix",
    "createRequest",
    "io",
    "remote",
    "Request",
    "getUrl",
    "createRpcData",
    "id",
    "method",
    "parameters",
    "requestObject",
    "service",
    "getProtocol",
    "getServiceName",
    "server_data",
    "_callInternal",
    "args",
    "callType",
    "refreshSession",
    "self",
    "offset",
    "whichMethod",
    "handler",
    "argsArray",
    "eventTarget",
    "i",
    "length",
    "push",
    "req",
    "getServerData",
    "rpcData",
    "getSequenceNumber",
    "setCrossDomain",
    "getCrossDomain",
    "getUsername",
    "setUseBasicHttpAuth",
    "getUseBasicHttpAuth",
    "setUsername",
    "setPassword",
    "getPassword",
    "setTimeout",
    "getTimeout",
    "ex",
    "result",
    "response",
    "handleRequestFinished",
    "eventType",
    "e",
    "error",
    "lang",
    "Json",
    "stringify",
    "fireDataEvent",
    "addToStringToObject",
    "obj",
    "toString",
    "Rpc",
    "code",
    "message",
    "ret",
    "data",
    "makeException",
    "addListener",
    "evt",
    "getStatusCode",
    "Exchange",
    "statusCodeToString",
    "debug",
    "getContent",
    "Type",
    "isObject",
    "_isConvertDates",
    "_isResponseJson",
    "parse",
    "key",
    "value",
    "indexOf",
    "m",
    "match",
    "Date",
    "UTC",
    "eval",
    "warn",
    "exTest",
    "newSuffix",
    "fixUrl",
    "replacer",
    "isDate",
    "dateParams",
    "getUTCFullYear",
    "getUTCMonth",
    "getUTCDate",
    "getUTCHours",
    "getUTCMinutes",
    "getUTCSeconds",
    "getUTCMilliseconds",
    "setData",
    "setAsynchronous",
    "setRequestHeader",
    "setParseJson",
    "send",
    "Error",
    "rpcdetails",
    "index",
    "substring",
    "callSync",
    "methodName",
    "arguments",
    "callAsync",
    "callAsyncListeners",
    "coalesce",
    "timeDiff",
    "getTime",
    "lastSessionRefresh",
    "sessionTimeoutInSeconds",
    "opaqueCallRef"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;AAAAA,EAAAA,EAAE,CAACC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEAH,EAAAA,EAAE,CAACI,KAAH,CAASC,MAAT,CAAgB,kBAAhB,EACA;AACEC,IAAAA,MAAM,EAAGN,EAAE,CAACO,IAAH,CAAQC,MADnB;;AAME;AACF;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,IAAAA,SAAS,EAAG,mBAASC,GAAT,EAAcC,WAAd,EACZ;AACE;;AAEA,UAAID,GAAG,KAAKE,SAAZ,EACA;AACE,aAAKC,MAAL,CAAYH,GAAZ;AACD;;AAED,UAAIC,WAAW,IAAI,IAAnB,EACA;AACE,aAAKG,cAAL,CAAoBH,WAApB;AACD;;AAED,UAAIX,EAAE,CAACO,IAAH,CAAQQ,cAAZ,EACA;AACE,aAAKC,SAAL,GAA6BhB,EAAE,CAACO,IAAH,CAAQQ,cAAR,CAAuBE,gBAApD;AACD;AACF,KA/CH;;AAoDE;AACF;AACA;AACA;AACA;AAEEC,IAAAA,MAAM,EACN;AACE;AACJ;AACA;AACI,mBAAc,qBAJhB;;AAME;AACJ;AACA;AACI,iBAAY,qBATd;;AAWE;AACJ;AACA;AACI,gBAAW,qBAdb;;AAgBE;AACJ;AACA;AACI,iBAAY;AAnBd,KA3DF;;AAmFE;AACF;AACA;AACA;A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AHxC,EAIA;AACE,iBAAON,GAAP;AACD;;AAED,YAAI4I,KAAK,GAAG5I,GAAG,CAACiH,OAAJ,CAAY,KAAK5E,SAAjB,CAAZ;;AAEA,YAAIuG,KAAK,IAAI,CAAC,CAAd,EACA;AACE,iBAAO5I,GAAP;AACD;;AAED,eAAQA,GAAG,CAAC6I,SAAJ,CAAc,CAAd,EAAiBD,KAAjB,IACA,KAAKtI,SADL,GAEAN,GAAG,CAAC6I,SAAJ,CAAcD,KAAK,GAAG,KAAKvG,SAAL,CAA4B0B,MAAlD,CAFR;AAGD,OAndH;;AAsdE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI+E,MAAAA,QAAQ,EAAG,kBAASC,UAAT,EAAoB1F,IAApB,EACX;AACE,eAAO,KAAKD,aAAL,CAAmB4F,SAAnB,EAA8B,CAA9B,CAAP;AACD,OA/eH;;AAkfE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,MAAAA,SAAS,EAAG,mBAAStF,OAAT,EAAkBoF,UAAlB,EAA8B1F,IAA9B,EACZ;AACE,eAAO,KAAKD,aAAL,CAAmB4F,SAAnB,EAA8B,CAA9B,CAAP;AACD,OAthBH;;AAyhBE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIE,MAAAA,kBAAkB,EAAG,4BAASC,QAAT,EAAmBJ,UAAnB,EAA+B1F,IAA/B,EACrB;AACE,eAAO,KAAKD,aAAL,CAAmB4F,SAAnB,EAA8B,CAA9B,CAAP;AACD,OA7kBH;;AAglBE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIzF,MAAAA,cAAc,EAAG,wBAASI,OAAT,EACjB;AACE,YAAIrE,EAAE,CAACO,IAAH,CAAQQ,cAAR,IACAf,EAAE,CAACO,IAAH,CAAQQ,cAAR,CAAuBE,gBAD3B,EAEA;AACE,cAAI6I,QAAQ,GACT,IAAIhC,IAAJ,EAAD,CAAaiC,OAAb,KAAyB/J,EAAE,CAACO,IAAH,CAAQQ,cAAR,CAAuBiJ,kBADlD;;AAGA,cAAIF,QAAQ,GAAG,IAAX,GACC9J,EAAE,CAACO,IAAH,CAAQQ,cAAR,CAAuBkJ,uBAAvB,GAAiD,EADtD,EAEA;AACE;AACA,iBAAKnG,aAAL,CAAmB,CAAEO,OAAF,CAAnB,EAAgC,CAAhC,EAAmC,IAAnC;AACD,WALD,MAOA;AACEA,YAAAA,OAAO,CAAC,IAAD,CAAP,CADF,CACiB;AAChB;AACF,SAhBD,MAkBA;AACEA,UAAAA,OAAO,CAAC,KAAD,CAAP,CADF,CACkB;AACjB;AACF,OAvnBH;;AA0nBE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIiD,MAAAA,eAAe,EAAE,2BAAW;AAC1B,eAAO,CAAC,CAAEtH,EAAE,CAACiD,EAAH,CAAMC,MAAN,CAAaqD,GAAb,CAAiB1E,aAA3B;AACD,OApoBH;;AAuoBE;AACJ;AACA;AACA;AACA;AACA;AACA;AACI0F,MAAAA,eAAe,EAAE,2BAAW;AAC1B,eAAO,CAAC,CAAEvH,EAAE,CAACiD,EAAH,CAAMC,MAAN,CAAaqD,GAAb,CAAiBzE,aAA3B;AACD,OAhpBH;;AAmpBE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIH,MAAAA,KAAK,EAAG,eAASuI,aAAT,EACR;AACEA,QAAAA,aAAa,CAACvI,KAAd;AACD;AA/pBH;AAnUF,GADA;AA/EA3B,EAAAA,EAAE,CAACiD,EAAH,CAAMC,MAAN,CAAaqD,GAAb,CAAiBpG,aAAjB,GAAiCA,aAAjC",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2006 STZ-IDA, Germany, http://www.stz-ida.de\n     2006 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Andreas Junghans (lucidcake)\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * Provides a Remote Procedure Call (RPC) implementation.\n *\n * Each instance of this class represents a \"Service\". These services can\n * correspond to various concepts on the server side (depending on the\n * programming language/environment being used), but usually, a service means\n * a class on the server.\n *\n * In case multiple instances of the same service are needed, they can be\n * distinguished by ids. If such an id is specified, the server routes all\n * calls to a service that have the same id to the same server-side instance.\n *\n * When calling a server-side method, the parameters and return values are\n * converted automatically. Supported types are int (and Integer), double\n * (and Double), String, Date, Map, and JavaBeans. Beans must have a default\n * constructor on the server side and are represented by simple JavaScript\n * objects on the client side (used as associative arrays with keys matching\n * the server-side properties). Beans can also be nested, but be careful not to\n * create circular references! There are no checks to detect these (which would\n * be expensive), so you as the user are responsible for avoiding them.\n *\n * A simple example:\n * <pre class='javascript'>\n *   function callRpcServer ()\n *   {\n *     var rpc = new qx.io.remote.Rpc();\n *     rpc.setTimeout(10000);\n *     rpc.setUrl(\"http://127.0.0.1:8007\");\n *     rpc.setServiceName(\"qooxdoo.admin\");\n *\n *     // call a remote procedure -- takes no arguments, returns a string\n *     var that = this;\n *     this.RpcRunning = rpc.callAsync(\n *       function(result, ex, id)\n *       {\n *         that.RpcRunning = null;\n *         if (ex == null) {\n *             alert(result);\n *         } else {\n *             alert(\"Async(\" + id + \") exception: \" + ex);\n *         }\n *       },\n *       \"fss.getBaseDir\");\n *   }\n * </pre>\n * __fss.getBaseDir__ is the remote procedure in this case, potential arguments\n * would be listed after the procedure name.\n * <p>\n * Passing data from the client (qooxdoo) side is demonstrated in the\n * qooxdoo-contrib project RpcExample. There are three ways to issue a remote\n * procedure call: synchronously (qx.io.remote.Rpc.callSync -- dangerous\n * because it blocks the whole browser, not just your application, so is\n * highly discouraged); async with results via a callback function\n * (qx.io.remote.Rpc.callAsync) and async with results via an event listener\n * (qx.io.remote.Rpc.callAsyncListeners).\n * <p>\n * @ignore(qx.core.ServerSettings.*)\n*/\n\nqx.Class.define(\"qx.io.remote.Rpc\",\n{\n  extend : qx.core.Object,\n\n\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  /**\n   * @param url {String}            identifies the url where the service\n   *                                is found.  Note that if the url is to\n   *                                a domain (server) other than where the\n   *                                qooxdoo script came from, i.e. it is\n   *                                cross-domain, then you must also call\n   *                                the setCrossDomain(true) method to\n   *                                enable the ScriptTransport instead of\n   *                                the XmlHttpTransport, since the latter\n   *                                can not handle cross-domain requests.\n   *\n   * @param serviceName {String}    identifies the service. For the Java\n   *                                implementation, this is the fully\n   *                                qualified name of the class that offers\n   *                                the service methods\n   *                                (e.g. \"my.pkg.MyService\").\n   */\n  construct : function(url, serviceName)\n  {\n    this.base(arguments);\n\n    if (url !== undefined)\n    {\n      this.setUrl(url);\n    }\n\n    if (serviceName != null)\n    {\n      this.setServiceName(serviceName);\n    }\n\n    if (qx.core.ServerSettings)\n    {\n      this.__currentServerSuffix = qx.core.ServerSettings.serverPathSuffix;\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     EVENTS\n  *****************************************************************************\n  */\n\n  events :\n  {\n    /**\n     * Fired when call is completed.\n     */\n    \"completed\" : \"qx.event.type.Event\",\n\n    /**\n     * Fired when call aborted.\n     */\n    \"aborted\" : \"qx.event.type.Event\",\n\n    /**\n     * Fired when call failed.\n     */\n    \"failed\" : \"qx.event.type.Event\",\n\n    /**\n     * Fired when call timed out.\n     */\n    \"timeout\" : \"qx.event.type.Event\"\n  },\n\n\n\n  /*\n  *****************************************************************************\n     STATICS\n  *****************************************************************************\n  */\n\n  statics :\n  {\n    /**\n     * Origins of errors\n     */\n    origin :\n    {\n      server      : 1,\n      application : 2,\n      transport   : 3,\n      local       : 4\n    },\n\n\n    /**\n     *  Locally-detected errors\n     */\n    localError :\n    {\n      timeout : 1,\n      abort   : 2,\n      nodata  : 3\n    },\n\n\n    /**\n     * Boolean flag which controls the stringification of date objects.\n     * <code>null</code> for the default behavior, acts like false\n     * <code>true</code> for stringifying dates the old, qooxdoo specific way\n     * <code>false</code> using the native toJSON of date objects.\n     *\n     * When enabled, dates are converted to and parsed from\n     * a literal that complies to the format\n     *\n     * <code>new Date(Date.UTC(year,month,day,hour,min,sec,ms))</code>\n     *\n     * The server can fairly easily parse this in its JSON\n     * implementation by stripping off \"new Date(Date.UTC(\"\n     * from the beginning of the string, and \"))\" from the\n     * end of the string. What remains is the set of\n     * comma-separated date components, which are also very\n     * easy to parse.\n     *\n     * The work-around compensates for the fact that while the\n     * Date object is a primitive type in Javascript, the\n     * specification neglects to provide a literal form for it.\n     */\n    CONVERT_DATES : null,\n\n\n    /**\n     * Boolean flag which controls whether to expect and verify a JSON\n     * response.\n     *\n     * Should be <code>true</code> when backend returns valid JSON.\n     *\n     * Date literals are parsed when CONVERT_DATES is <code>true</code>\n     * and comply to the format\n     *\n     * <code>\"new Date(Date.UTC(year,month,day,hour,min,sec,ms))\"</code>\n     *\n     * Note the surrounding quotes that encode the literal as string.\n     *\n     * Using valid JSON is recommended, because it allows to use\n     * {@link qx.lang.Json#parse} for parsing. {@link qx.lang.Json#parse}\n     * is preferred over the potentially insecure <code>eval</code>.\n     */\n    RESPONSE_JSON : null,\n\n\n    /**\n     * Creates an URL for talking to a local service. A local service is one that\n     * lives in the same application as the page calling the service. For backends\n     * that don't support this auto-generation, this method returns null.\n     *\n     * @param instanceId {String ? null} an optional identifier for the\n     *                                   server side instance that should be\n     *                                   used. All calls to the same service\n     *                                   with the same instance id are\n     *                                   routed to the same object instance\n     *                                   on the server. The instance id can\n     *                                   also be used to provide additional\n     *                                   data for the service instantiation\n     *                                   on the server.\n     * @return {String} the url.\n     */\n    makeServerURL : function(instanceId)\n    {\n      var retVal = null;\n\n      if (qx.core.ServerSettings)\n      {\n        retVal =\n          qx.core.ServerSettings.serverPathPrefix +\n          \"/.qxrpc\" +\n          qx.core.ServerSettings.serverPathSuffix;\n\n        if (instanceId != null)\n        {\n          retVal += \"?instanceId=\" + instanceId;\n        }\n      }\n\n      return retVal;\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties :\n  {\n    /*\n    ---------------------------------------------------------------------------\n      PROPERTIES\n    ---------------------------------------------------------------------------\n    */\n\n    /** The timeout for asynchronous calls in milliseconds. */\n    timeout :\n    {\n      check : \"Integer\",\n      nullable : true\n    },\n\n\n    /**\n     * Indicate that the request is cross domain.\n     *\n     * A request is cross domain if the request's URL points to a host other\n     * than the local host. This switches the concrete implementation that is\n     * used for sending the request from qx.io.remote.transport.XmlHttp to\n     * qx.io.remote.transport.Script because only the latter can handle cross\n     * domain requests.\n     */\n    crossDomain :\n    {\n      check : \"Boolean\",\n      init : false\n    },\n\n\n    /** The URL at which the service is located. */\n    url :\n    {\n      check : \"String\",\n      nullable : true\n    },\n\n\n    /** The service name.  */\n    serviceName :\n    {\n      check : \"String\",\n      nullable : true\n    },\n\n\n    /**\n     * Data sent as \"out of band\" data in the request to the server.  The\n     * format of the data is opaque to RPC and may be recognized only by\n     * particular servers It is up to the server to decide what to do with\n     * it: whether to ignore it, handle it locally before calling the\n     * specified method, or pass it on to the method.  This server data is\n     * not sent to the server if it has been set to 'null'.\n     */\n    serverData :\n    {\n      check : \"Object\",\n      nullable : true\n    },\n\n\n    /**\n     * Username to use for HTTP authentication. Null if HTTP authentication\n     * is not used.\n     */\n    username :\n    {\n      check : \"String\",\n      nullable : true\n    },\n\n\n    /**\n     * Password to use for HTTP authentication. Null if HTTP authentication\n     * is not used.\n     */\n    password :\n    {\n      check : \"String\",\n      nullable : true\n    },\n\n\n    /**\n      Use Basic HTTP Authentication\n    */\n    useBasicHttpAuth :\n    {\n      check : \"Boolean\",\n      nullable : true\n    },\n\n    /**\n     *\n     * Whether to use the original qooxdoo RPC protocol or the\n     * now-standardized Version 2 protocol.  Defaults to the original qooxdoo\n     * protocol for backward compatibility.\n     *\n     * Valid values are \"qx1\" and \"2.0\".\n     */\n    protocol :\n    {\n      init : \"2.0\",\n      check : function(val) { return val == \"qx1\" || val == \"2.0\"; }\n    }\n  },\n\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n\n    __previousServerSuffix : null,\n    __currentServerSuffix : null,\n\n    /**\n     * Factory method to create a request object. By default, a POST request\n     * will be made, and the expected response type will be\n     * \"application/json\". Classes extending this one may override this method\n     * to obtain a Request object with different parameters.\n     *\n     * @return {qx.io.remote.Request}\n     */\n    createRequest: function()\n    {\n      return new qx.io.remote.Request(this.getUrl(),\n                                \"POST\",\n                                \"application/json\");\n    },\n\n    /**\n     * Factory method to create the object containing the remote procedure\n     * call data. By default, a qooxdoo-style RPC request is built, which\n     * contains the following members: \"service\", \"method\", \"id\", and\n     * \"params\". If a different style of RPC request is desired, a class\n     * extending this one may override this method.\n     *\n     * @param id {Integer}\n     *   The unique sequence number of this request.\n     *\n     * @param method {String}\n     *   The name of the method to be called\n     *\n     * @param parameters {Array}\n     *   An array containing the arguments to the called method.\n     *\n     * @param serverData {var}\n     *   \"Out-of-band\" data to be provided to the server.\n     *\n     * @return {Object}\n     *   The object to be converted to JSON and passed to the JSON-RPC\n     *   server.\n     */\n    createRpcData: function(id, method, parameters, serverData)\n    {\n      var             requestObject;\n      var             service;\n\n      // Create a protocol-dependent request object\n      if (this.getProtocol() == \"qx1\")\n      {\n        // Create a qooxdoo-modified version 1.0 rpc data object\n        requestObject =\n          {\n            \"service\" :\n              method == \"refreshSession\" ? null : this.getServiceName(),\n            \"method\"  : method,\n            \"id\"      : id,\n            \"params\"  : parameters\n          };\n\n        // Only add the server_data member if there is actually server data\n        if (serverData)\n        {\n          requestObject.server_data = serverData;\n        }\n      }\n      else\n      {\n        // If there's a service name, we'll prepend it to the method name\n        service = this.getServiceName();\n        if (service && service != \"\")\n        {\n          service += \".\";\n        }\n        else\n        {\n          service = \"\";\n        }\n\n        // Create a standard version 2.0 rpc data object\n        requestObject =\n          {\n            \"jsonrpc\" : \"2.0\",\n            \"method\"  : service + method,\n            \"id\"      : id,\n            \"params\" : parameters\n          };\n      }\n\n      return requestObject;\n    },\n\n\n    /**\n     * Internal RPC call method\n     *\n     * @lint ignoreDeprecated(eval)\n     *\n     * @param args {Array}\n     *   array of arguments\n     *\n     * @param callType {Integer}\n     *   0 = sync,\n     *   1 = async with handler,\n     *   2 = async event listeners\n     *\n     * @param refreshSession {Boolean}\n     *   whether a new session should be requested\n     *\n     * @return {var} the method call reference.\n     * @throws {Error} An error.\n     */\n    _callInternal : function(args, callType, refreshSession)\n    {\n      var self = this;\n      var offset = (callType == 0 ? 0 : 1);\n      var whichMethod = (refreshSession ? \"refreshSession\" : args[offset]);\n      var handler = args[0];\n      var argsArray = [];\n      var eventTarget = this;\n      var protocol = this.getProtocol();\n\n      for (var i=offset+1; i<args.length; ++i)\n      {\n        argsArray.push(args[i]);\n      }\n\n      var req = this.createRequest();\n\n      // Get any additional out-of-band data to be sent to the server\n      var serverData = this.getServerData();\n\n      // Create the request object\n      var rpcData = this.createRpcData(req.getSequenceNumber(),\n                                       whichMethod,\n                                       argsArray,\n                                       serverData);\n\n      req.setCrossDomain(this.getCrossDomain());\n\n      if (this.getUsername())\n      {\n        req.setUseBasicHttpAuth(this.getUseBasicHttpAuth());\n        req.setUsername(this.getUsername());\n        req.setPassword(this.getPassword());\n      }\n\n      req.setTimeout(this.getTimeout());\n      var ex = null;\n      var id = null;\n      var result = null;\n      var response = null;\n\n      var handleRequestFinished = function(eventType, eventTarget)\n      {\n        switch(callType)\n        {\n          case 0: // sync\n            break;\n\n          case 1: // async with handler function\n            try\n            {\n              handler(result, ex, id);\n            }\n            catch(e)\n            {\n              eventTarget.error(\n                \"rpc handler threw an error:\" +\n                  \" id=\" + id +\n                  \" result=\" + qx.lang.Json.stringify(result) +\n                  \" ex=\" + qx.lang.Json.stringify(ex),\n                e);\n            }\n            break;\n\n          case 2: // async with event listeners\n            // Dispatch the event to our listeners.\n            if (!ex)\n            {\n              eventTarget.fireDataEvent(eventType, response);\n            }\n            else\n            {\n              // Add the id to the exception\n              ex.id = id;\n\n              if (args[0])      // coalesce\n              {\n                // They requested that we coalesce all failure types to\n                // \"failed\"\n                eventTarget.fireDataEvent(\"failed\", ex);\n              }\n              else\n              {\n                // No coalese so use original event type\n                eventTarget.fireDataEvent(eventType, ex);\n              }\n            }\n        }\n      };\n\n      var addToStringToObject = function(obj)\n      {\n        if (protocol == \"qx1\")\n        {\n          obj.toString = function()\n          {\n            switch(obj.origin)\n            {\n              case qx.io.remote.Rpc.origin.server:\n                return \"Server error \" + obj.code + \": \" + obj.message;\n\n              case qx.io.remote.Rpc.origin.application:\n                return \"Application error \" + obj.code + \": \" + obj.message;\n\n              case qx.io.remote.Rpc.origin.transport:\n                return \"Transport error \" + obj.code + \": \" + obj.message;\n\n              case qx.io.remote.Rpc.origin.local:\n                return \"Local error \" + obj.code + \": \" + obj.message;\n\n              default:\n                return (\"UNEXPECTED origin \" + obj.origin +\n                        \" error \" + obj.code + \": \" + obj.message);\n            }\n          };\n        }\n        else // protocol == \"2.0\"\n        {\n          obj.toString = function()\n          {\n            var             ret;\n\n            ret =  \"Error \" + obj.code + \": \" + obj.message;\n            if (obj.data)\n            {\n              ret += \" (\" + obj.data + \")\";\n            }\n\n            return ret;\n          };\n        }\n      };\n\n      var makeException = function(origin, code, message)\n      {\n        var ex = new Object();\n\n        if (protocol == \"qx1\")\n        {\n          ex.origin = origin;\n        }\n        ex.code = code;\n        ex.message = message;\n        addToStringToObject(ex);\n\n        return ex;\n      };\n\n      req.addListener(\"failed\", function(evt)\n      {\n        var code = evt.getStatusCode();\n        ex = makeException(qx.io.remote.Rpc.origin.transport,\n                           code,\n                           qx.io.remote.Exchange.statusCodeToString(code));\n        id = this.getSequenceNumber();\n        handleRequestFinished(\"failed\", eventTarget);\n      });\n\n      req.addListener(\"timeout\", function(evt)\n      {\n        this.debug(\"TIMEOUT OCCURRED\");\n        ex = makeException(qx.io.remote.Rpc.origin.local,\n                           qx.io.remote.Rpc.localError.timeout,\n                           \"Local time-out expired for \"+ whichMethod);\n        id = this.getSequenceNumber();\n        handleRequestFinished(\"timeout\", eventTarget);\n      });\n\n      req.addListener(\"aborted\", function(evt)\n      {\n        ex = makeException(qx.io.remote.Rpc.origin.local,\n                           qx.io.remote.Rpc.localError.abort,\n                           \"Aborted \" + whichMethod);\n        id = this.getSequenceNumber();\n        handleRequestFinished(\"aborted\", eventTarget);\n      });\n\n      req.addListener(\"completed\", function(evt)\n      {\n        response = evt.getContent();\n\n        // server may have reset, giving us no data on our requests\n        if (response === null)\n        {\n          ex = makeException(qx.io.remote.Rpc.origin.local,\n                             qx.io.remote.Rpc.localError.nodata,\n                             \"No data in response to \" + whichMethod);\n          id = this.getSequenceNumber();\n          handleRequestFinished(\"failed\", eventTarget);\n          return;\n        }\n\n        // Parse. Skip when response is already an object\n        // because the script transport was used.\n        if (!qx.lang.Type.isObject(response)) {\n\n          // Handle converted dates\n          if (self._isConvertDates()) {\n\n            // Parse as JSON and revive date literals\n            if (self._isResponseJson()) {\n              response = qx.lang.Json.parse(response, function(key, value) {\n                if (value && typeof value === \"string\") {\n                  if (value.indexOf(\"new Date(Date.UTC(\") >= 0) {\n                    var m = value.match(/new Date\\(Date.UTC\\((\\d+),(\\d+),(\\d+),(\\d+),(\\d+),(\\d+),(\\d+)\\)\\)/);\n                    return new Date(Date.UTC(m[1],m[2],m[3],m[4],m[5],m[6],m[7]));\n                  }\n                }\n                return value;\n              });\n\n            // Eval\n            } else {\n              response = response && response.length > 0 ? eval('(' + response + ')') : null;\n            }\n\n          // No special date handling required, JSON assumed\n          } else {\n            response = qx.lang.Json.parse(response);\n          }\n        }\n\n        id = response[\"id\"];\n\n        if (id != this.getSequenceNumber())\n        {\n          this.warn(\"Received id (\" + id + \") does not match requested id \" +\n                    \"(\" + this.getSequenceNumber() + \")!\");\n        }\n\n        // Determine if an error was returned. Assume no error, initially.\n        var eventType = \"completed\";\n        var exTest = response[\"error\"];\n\n        if (exTest != null)\n        {\n          // There was an error\n          result = null;\n          addToStringToObject(exTest);\n          ex = exTest;\n\n          // Change the event type\n          eventType = \"failed\";\n        }\n        else\n        {\n          result = response[\"result\"];\n\n          if (refreshSession)\n          {\n            result = eval(\"(\" + result + \")\");\n            var newSuffix = qx.core.ServerSettings.serverPathSuffix;\n\n            if (self.__currentServerSuffix != newSuffix)\n            {\n              self.__previousServerSuffix = self.__currentServerSuffix;\n              self.__currentServerSuffix = newSuffix;\n            }\n\n            self.setUrl(self.fixUrl(self.getUrl()));\n          }\n        }\n\n        handleRequestFinished(eventType, eventTarget);\n      });\n\n      // Provide a replacer when convert dates is enabled\n      var replacer = null;\n      if (this._isConvertDates()) {\n        replacer = function(key, value) {\n          // The value passed in is of type string, because the Date's\n          // toJson gets applied before. Get value from containing object.\n          value = this[key];\n\n          if (qx.lang.Type.isDate(value)) {\n            var dateParams =\n              value.getUTCFullYear() + \",\" +\n              value.getUTCMonth() + \",\" +\n              value.getUTCDate() + \",\" +\n              value.getUTCHours() + \",\" +\n              value.getUTCMinutes() + \",\" +\n              value.getUTCSeconds() + \",\" +\n              value.getUTCMilliseconds();\n            return \"new Date(Date.UTC(\" + dateParams + \"))\";\n          }\n          return value;\n        };\n      }\n\n      req.setData(qx.lang.Json.stringify(rpcData, replacer));\n      req.setAsynchronous(callType > 0);\n\n      if (req.getCrossDomain())\n      {\n        // Our choice here has no effect anyway.  This is purely informational.\n        req.setRequestHeader(\"Content-Type\",\n                             \"application/x-www-form-urlencoded\");\n      }\n      else\n      {\n        // When not cross-domain, set type to text/json\n        req.setRequestHeader(\"Content-Type\", \"application/json\");\n      }\n\n      // Do not parse as JSON. Later done conditionally.\n      req.setParseJson(false);\n\n      req.send();\n\n      if (callType == 0)\n      {\n        if (ex != null)\n        {\n          var error = new Error(ex.toString());\n          error.rpcdetails = ex;\n          throw error;\n        }\n\n        return result;\n      }\n      else\n      {\n        return req;\n      }\n    },\n\n\n    /**\n     * Helper method to rewrite a URL with a stale session id (so that it includes\n     * the correct session id afterwards).\n     *\n     * @param url {String} the URL to examine.\n     * @return {String} the (possibly re-written) URL.\n     */\n    fixUrl : function(url)\n    {\n      if (this.__previousServerSuffix == null ||\n          this.__currentServerSuffix == null ||\n          this.__previousServerSuffix == \"\" ||\n          this.__previousServerSuffix == this.__currentServerSuffix)\n      {\n        return url;\n      }\n\n      var index = url.indexOf(this.__previousServerSuffix);\n\n      if (index == -1)\n      {\n        return url;\n      }\n\n      return (url.substring(0, index) +\n              this.__currentServerSuffix +\n              url.substring(index + this.__previousServerSuffix.length));\n    },\n\n\n    /**\n     * Makes a synchronous server call. The method arguments (if any) follow\n     * after the method name (as normal JavaScript arguments, separated by\n     * commas, not as an array).\n     *\n     * If a problem occurs when making the call, an exception is thrown.\n     *\n     *\n     * WARNING.  With some browsers, the synchronous interface\n     * causes the browser to hang while awaiting a response!  If the server\n     * decides to pause for a minute or two, your browser may do nothing\n     * (including refreshing following window changes) until the response is\n     * received.  Instead, use the asynchronous interface.\n     *\n     *\n     * YOU HAVE BEEN WARNED.\n     *\n     *\n     * @param methodName {String} the name of the method to call.\n     * @param args {Array} an array of values passed through to the backend.\n     * @return {var} the result returned by the server.\n     */\n    callSync : function(methodName,args)\n    {\n      return this._callInternal(arguments, 0);\n    },\n\n\n    /**\n     * Makes an asynchronous server call. The method arguments (if any) follow\n     * after the method name (as normal JavaScript arguments, separated by\n     * commas, not as an array).\n     *\n     * When an answer from the server arrives, the <code>handler</code>\n     * function is called with the result of the call as the first, an\n     * exception as the second parameter, and the id (aka sequence number) of\n     * the invoking request as the third parameter. If the call was\n     * successful, the second parameter is <code>null</code>. If there was a\n     * problem, the second parameter contains an exception, and the first one\n     * is <code>null</code>.\n     *\n     *\n     * The return value of this method is a call reference that you can store\n     * if you want to abort the request later on. This value should be treated\n     * as opaque and can change completely in the future! The only thing you\n     * can rely on is that the <code>abort</code> method will accept this\n     * reference and that you can retrieve the sequence number of the request\n     * by invoking the getSequenceNumber() method (see below).\n     *\n     *\n     * If a specific method is being called, asynchronously, a number of times\n     * in succession, the getSequenceNumber() method may be used to\n     * disambiguate which request a response corresponds to.  The sequence\n     * number value is a value which increments with each request.)\n     *\n     *\n     * @param handler {Function} the callback function.\n     * @param methodName {String} the name of the method to call.\n     * @param args {Array} an array of values passed through to the backend.\n     * @return {var} the method call reference.\n     */\n    callAsync : function(handler, methodName, args)\n    {\n      return this._callInternal(arguments, 1);\n    },\n\n\n    /**\n     * Makes an asynchronous server call and dispatches an event upon completion\n     * or failure. The method arguments (if any) follow after the method name\n     * (as normal JavaScript arguments, separated by commas, not as an array).\n     *\n     * When an answer from the server arrives (or fails to arrive on time), if\n     * an exception occurred, a \"failed\", \"timeout\" or \"aborted\" event, as\n     * appropriate, is dispatched to any waiting event listeners.  If no\n     * exception occurred, a \"completed\" event is dispatched.\n     *\n     *\n     * When a \"failed\", \"timeout\" or \"aborted\" event is dispatched, the event\n     * data contains an object with the properties 'origin', 'code', 'message'\n     * and 'id'.  The object has a toString() function which may be called to\n     * convert the exception to a string.\n     *\n     *\n     * When a \"completed\" event is dispatched, the event data contains a\n     * map with the JSON-RPC sequence number and result:\n     * <p>\n     * {\n     *   id: rpc_id,\n     *   result: json-rpc result\n     * }\n     *\n     *\n     * The return value of this method is a call reference that you can store\n     * if you want to abort the request later on. This value should be treated\n     * as opaque and can change completely in the future! The only thing you\n     * can rely on is that the <code>abort</code> method will accept this\n     * reference and that you can retrieve the sequence number of the request\n     * by invoking the getSequenceNumber() method (see below).\n     *\n     *\n     * If a specific method is being called, asynchronously, a number of times\n     * in succession, the getSequenceNumber() method may be used to\n     * disambiguate which request a response corresponds to.  The sequence\n     * number value is a value which increments with each request.)\n     *\n     *\n     * @param coalesce {Boolean} coalesce all failure types (\"failed\",\n     *                           \"timeout\", and \"aborted\") to \"failed\".\n     *                           This is reasonable in many cases, as\n     *                           the provided exception contains adequate\n     *                           disambiguating information.\n     * @param methodName {String} the name of the method to call.\n     * @param args {Array} an array of values passed through to the backend.\n     * @return {var} the method call reference.\n     */\n    callAsyncListeners : function(coalesce, methodName, args)\n    {\n      return this._callInternal(arguments, 2);\n    },\n\n\n    /**\n     * Refreshes a server session by retrieving the session id again from the\n     * server.\n     *\n     * The specified handler function is called when the refresh is\n     * complete. The first parameter can be <code>true</code> (indicating that\n     * a refresh either wasn't necessary at this time or it was successful) or\n     * <code>false</code> (indicating that a refresh would have been necessary\n     * but can't be performed because the server backend doesn't support\n     * it). If there is a non-null second parameter, it's an exception\n     * indicating that there was an error when refreshing the session.\n     *\n     *\n     * @param handler {Function} a callback function that is called when the\n     *                           refresh is complete (or failed).\n     */\n    refreshSession : function(handler)\n    {\n      if (qx.core.ServerSettings &&\n          qx.core.ServerSettings.serverPathSuffix)\n      {\n        var timeDiff =\n          (new Date()).getTime() - qx.core.ServerSettings.lastSessionRefresh;\n\n        if (timeDiff / 1000 >\n            (qx.core.ServerSettings.sessionTimeoutInSeconds - 30))\n        {\n          // this.info(\"refreshing session\");\n          this._callInternal([ handler ], 1, true);\n        }\n        else\n        {\n          handler(true); // session refresh was OK (in this case: not needed)\n        }\n      }\n      else\n      {\n        handler(false); // no refresh possible, but would be necessary\n      }\n    },\n\n\n    /**\n     * Whether to convert date objects to pseudo literals and\n     * parse with eval.\n     *\n     * Controlled by {@link #CONVERT_DATES}.\n     *\n     * @return {Boolean} Whether to convert.\n     */\n    _isConvertDates: function() {\n      return !!(qx.io.remote.Rpc.CONVERT_DATES);\n    },\n\n\n    /**\n     * Whether to expect and verify a JSON response.\n     *\n     * Controlled by {@link #RESPONSE_JSON}.\n     *\n     * @return {Boolean} Whether to expect JSON.\n     */\n    _isResponseJson: function() {\n      return !!(qx.io.remote.Rpc.RESPONSE_JSON);\n    },\n\n\n    /**\n     * Aborts an asynchronous server call. Consequently, the callback function\n     * provided to <code>callAsync</code> or <code>callAsyncListeners</code>\n     * will be called with an exception.\n     *\n     * @param opaqueCallRef {var} the call reference as returned by\n     *                            <code>callAsync</code> or\n     *                            <code>callAsyncListeners</code>\n     */\n    abort : function(opaqueCallRef)\n    {\n      opaqueCallRef.abort();\n    }\n  }\n});\n"
  ]
}