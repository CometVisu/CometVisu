{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "url",
    "serviceName",
    "constructor",
    "call",
    "undefined",
    "setUrl",
    "setServiceName",
    "ServerSettings",
    "__currentServerSuffix",
    "serverPathSuffix",
    "events",
    "completed",
    "aborted",
    "failed",
    "timeout",
    "statics",
    "origin",
    "server",
    "application",
    "transport",
    "local",
    "localError",
    "abort",
    "nodata",
    "CONVERT_DATES",
    "RESPONSE_JSON",
    "makeServerURL",
    "instanceId",
    "retVal",
    "serverPathPrefix",
    "properties",
    "check",
    "nullable",
    "crossDomain",
    "init",
    "serverData",
    "username",
    "password",
    "useBasicHttpAuth",
    "protocol",
    "val",
    "members",
    "__previousServerSuffix",
    "createRequest",
    "io",
    "remote",
    "Request",
    "getUrl",
    "createRpcData",
    "id",
    "method",
    "parameters",
    "requestObject",
    "service",
    "getProtocol",
    "getServiceName",
    "params",
    "server_data",
    "jsonrpc",
    "_callInternal",
    "args",
    "callType",
    "refreshSession",
    "self",
    "offset",
    "whichMethod",
    "handler",
    "argsArray",
    "eventTarget",
    "i",
    "length",
    "push",
    "req",
    "getServerData",
    "rpcData",
    "getSequenceNumber",
    "setCrossDomain",
    "getCrossDomain",
    "getUsername",
    "setUseBasicHttpAuth",
    "getUseBasicHttpAuth",
    "setUsername",
    "setPassword",
    "getPassword",
    "setTimeout",
    "getTimeout",
    "ex",
    "result",
    "response",
    "handleRequestFinished",
    "eventType",
    "e",
    "error",
    "lang",
    "Json",
    "stringify",
    "fireDataEvent",
    "addToStringToObject",
    "obj",
    "toString",
    "Rpc",
    "code",
    "message",
    "ret",
    "data",
    "makeException",
    "addListener",
    "evt",
    "getStatusCode",
    "Exchange",
    "statusCodeToString",
    "debug",
    "getContent",
    "Type",
    "isObject",
    "_isConvertDates",
    "_isResponseJson",
    "parse",
    "key",
    "value",
    "indexOf",
    "m",
    "match",
    "Date",
    "UTC",
    "eval",
    "warn",
    "exTest",
    "newSuffix",
    "fixUrl",
    "replacer",
    "isDate",
    "dateParams",
    "getUTCFullYear",
    "getUTCMonth",
    "getUTCDate",
    "getUTCHours",
    "getUTCMinutes",
    "getUTCSeconds",
    "getUTCMilliseconds",
    "setData",
    "setAsynchronous",
    "setRequestHeader",
    "setParseJson",
    "send",
    "Error",
    "rpcdetails",
    "index",
    "substring",
    "callSync",
    "methodName",
    "arguments",
    "callAsync",
    "callAsyncListeners",
    "coalesce",
    "timeDiff",
    "getTime",
    "lastSessionRefresh",
    "sessionTimeoutInSeconds",
    "opaqueCallRef"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/qx_packages/qooxdoo_deprecated_qx_io_remote_v1_0_2/source/class/qx/io/remote/Rpc.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2006 STZ-IDA, Germany, http://www.stz-ida.de\n     2006 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Andreas Junghans (lucidcake)\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * Provides a Remote Procedure Call (RPC) implementation.\n *\n * Each instance of this class represents a \"Service\". These services can\n * correspond to various concepts on the server side (depending on the\n * programming language/environment being used), but usually, a service means\n * a class on the server.\n *\n * In case multiple instances of the same service are needed, they can be\n * distinguished by ids. If such an id is specified, the server routes all\n * calls to a service that have the same id to the same server-side instance.\n *\n * When calling a server-side method, the parameters and return values are\n * converted automatically. Supported types are int (and Integer), double\n * (and Double), String, Date, Map, and JavaBeans. Beans must have a default\n * constructor on the server side and are represented by simple JavaScript\n * objects on the client side (used as associative arrays with keys matching\n * the server-side properties). Beans can also be nested, but be careful not to\n * create circular references! There are no checks to detect these (which would\n * be expensive), so you as the user are responsible for avoiding them.\n *\n * A simple example:\n * <pre class='javascript'>\n *   function callRpcServer ()\n *   {\n *     var rpc = new qx.io.remote.Rpc();\n *     rpc.setTimeout(10000);\n *     rpc.setUrl(\"http://127.0.0.1:8007\");\n *     rpc.setServiceName(\"qooxdoo.admin\");\n *\n *     // call a remote procedure -- takes no arguments, returns a string\n *     var that = this;\n *     this.RpcRunning = rpc.callAsync(\n *       function(result, ex, id)\n *       {\n *         that.RpcRunning = null;\n *         if (ex == null) {\n *             alert(result);\n *         } else {\n *             alert(\"Async(\" + id + \") exception: \" + ex);\n *         }\n *       },\n *       \"fss.getBaseDir\");\n *   }\n * </pre>\n * __fss.getBaseDir__ is the remote procedure in this case, potential arguments\n * would be listed after the procedure name.\n * <p>\n * Passing data from the client (qooxdoo) side is demonstrated in the\n * qooxdoo-contrib project RpcExample. There are three ways to issue a remote\n * procedure call: synchronously (qx.io.remote.Rpc.callSync -- dangerous\n * because it blocks the whole browser, not just your application, so is\n * highly discouraged); async with results via a callback function\n * (qx.io.remote.Rpc.callAsync) and async with results via an event listener\n * (qx.io.remote.Rpc.callAsyncListeners).\n * <p>\n * @ignore(qx.core.ServerSettings.*)\n */\n\nqx.Class.define(\"qx.io.remote.Rpc\", {\n  extend: qx.core.Object,\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  /**\n   * @param url {String}            identifies the url where the service\n   *                                is found.  Note that if the url is to\n   *                                a domain (server) other than where the\n   *                                qooxdoo script came from, i.e. it is\n   *                                cross-domain, then you must also call\n   *                                the setCrossDomain(true) method to\n   *                                enable the ScriptTransport instead of\n   *                                the XmlHttpTransport, since the latter\n   *                                can not handle cross-domain requests.\n   *\n   * @param serviceName {String}    identifies the service. For the Java\n   *                                implementation, this is the fully\n   *                                qualified name of the class that offers\n   *                                the service methods\n   *                                (e.g. \"my.pkg.MyService\").\n   */\n  construct(url, serviceName) {\n    super();\n\n    if (url !== undefined) {\n      this.setUrl(url);\n    }\n\n    if (serviceName != null) {\n      this.setServiceName(serviceName);\n    }\n\n    if (qx.core.ServerSettings) {\n      this.__currentServerSuffix = qx.core.ServerSettings.serverPathSuffix;\n    }\n  },\n\n  /*\n  *****************************************************************************\n     EVENTS\n  *****************************************************************************\n  */\n\n  events: {\n    /**\n     * Fired when call is completed.\n     */\n    completed: \"qx.event.type.Event\",\n\n    /**\n     * Fired when call aborted.\n     */\n    aborted: \"qx.event.type.Event\",\n\n    /**\n     * Fired when call failed.\n     */\n    failed: \"qx.event.type.Event\",\n\n    /**\n     * Fired when call timed out.\n     */\n    timeout: \"qx.event.type.Event\",\n  },\n\n  /*\n  *****************************************************************************\n     STATICS\n  *****************************************************************************\n  */\n\n  statics: {\n    /**\n     * Origins of errors\n     */\n    origin: {\n      server: 1,\n      application: 2,\n      transport: 3,\n      local: 4,\n    },\n\n    /**\n     *  Locally-detected errors\n     */\n    localError: {\n      timeout: 1,\n      abort: 2,\n      nodata: 3,\n    },\n\n    /**\n     * Boolean flag which controls the stringification of date objects.\n     * <code>null</code> for the default behavior, acts like false\n     * <code>true</code> for stringifying dates the old, qooxdoo specific way\n     * <code>false</code> using the native toJSON of date objects.\n     *\n     * When enabled, dates are converted to and parsed from\n     * a literal that complies to the format\n     *\n     * <code>new Date(Date.UTC(year,month,day,hour,min,sec,ms))</code>\n     *\n     * The server can fairly easily parse this in its JSON\n     * implementation by stripping off \"new Date(Date.UTC(\"\n     * from the beginning of the string, and \"))\" from the\n     * end of the string. What remains is the set of\n     * comma-separated date components, which are also very\n     * easy to parse.\n     *\n     * The work-around compensates for the fact that while the\n     * Date object is a primitive type in Javascript, the\n     * specification neglects to provide a literal form for it.\n     */\n    CONVERT_DATES: null,\n\n    /**\n     * Boolean flag which controls whether to expect and verify a JSON\n     * response.\n     *\n     * Should be <code>true</code> when backend returns valid JSON.\n     *\n     * Date literals are parsed when CONVERT_DATES is <code>true</code>\n     * and comply to the format\n     *\n     * <code>\"new Date(Date.UTC(year,month,day,hour,min,sec,ms))\"</code>\n     *\n     * Note the surrounding quotes that encode the literal as string.\n     *\n     * Using valid JSON is recommended, because it allows to use\n     * {@link qx.lang.Json#parse} for parsing. {@link qx.lang.Json#parse}\n     * is preferred over the potentially insecure <code>eval</code>.\n     */\n    RESPONSE_JSON: null,\n\n    /**\n     * Creates an URL for talking to a local service. A local service is one that\n     * lives in the same application as the page calling the service. For backends\n     * that don't support this auto-generation, this method returns null.\n     *\n     * @param instanceId {String ? null} an optional identifier for the\n     *                                   server side instance that should be\n     *                                   used. All calls to the same service\n     *                                   with the same instance id are\n     *                                   routed to the same object instance\n     *                                   on the server. The instance id can\n     *                                   also be used to provide additional\n     *                                   data for the service instantiation\n     *                                   on the server.\n     * @return {String} the url.\n     */\n    makeServerURL(instanceId) {\n      var retVal = null;\n\n      if (qx.core.ServerSettings) {\n        retVal =\n          qx.core.ServerSettings.serverPathPrefix +\n          \"/.qxrpc\" +\n          qx.core.ServerSettings.serverPathSuffix;\n\n        if (instanceId != null) {\n          retVal += \"?instanceId=\" + instanceId;\n        }\n      }\n\n      return retVal;\n    },\n  },\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties: {\n    /*\n    ---------------------------------------------------------------------------\n      PROPERTIES\n    ---------------------------------------------------------------------------\n    */\n\n    /** The timeout for asynchronous calls in milliseconds. */\n    timeout: {\n      check: \"Integer\",\n      nullable: true,\n    },\n\n    /**\n     * Indicate that the request is cross domain.\n     *\n     * A request is cross domain if the request's URL points to a host other\n     * than the local host. This switches the concrete implementation that is\n     * used for sending the request from qx.io.remote.transport.XmlHttp to\n     * qx.io.remote.transport.Script because only the latter can handle cross\n     * domain requests.\n     */\n    crossDomain: {\n      check: \"Boolean\",\n      init: false,\n    },\n\n    /** The URL at which the service is located. */\n    url: {\n      check: \"String\",\n      nullable: true,\n    },\n\n    /** The service name.  */\n    serviceName: {\n      check: \"String\",\n      nullable: true,\n    },\n\n    /**\n     * Data sent as \"out of band\" data in the request to the server.  The\n     * format of the data is opaque to RPC and may be recognized only by\n     * particular servers It is up to the server to decide what to do with\n     * it: whether to ignore it, handle it locally before calling the\n     * specified method, or pass it on to the method.  This server data is\n     * not sent to the server if it has been set to 'null'.\n     */\n    serverData: {\n      check: \"Object\",\n      nullable: true,\n    },\n\n    /**\n     * Username to use for HTTP authentication. Null if HTTP authentication\n     * is not used.\n     */\n    username: {\n      check: \"String\",\n      nullable: true,\n    },\n\n    /**\n     * Password to use for HTTP authentication. Null if HTTP authentication\n     * is not used.\n     */\n    password: {\n      check: \"String\",\n      nullable: true,\n    },\n\n    /**\n      Use Basic HTTP Authentication\n    */\n    useBasicHttpAuth: {\n      check: \"Boolean\",\n      nullable: true,\n    },\n\n    /**\n     *\n     * Whether to use the original qooxdoo RPC protocol or the\n     * now-standardized Version 2 protocol.  Defaults to the original qooxdoo\n     * protocol for backward compatibility.\n     *\n     * Valid values are \"qx1\" and \"2.0\".\n     */\n    protocol: {\n      init: \"2.0\",\n      check(val) {\n        return val == \"qx1\" || val == \"2.0\";\n      },\n    },\n  },\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members: {\n    __previousServerSuffix: null,\n    __currentServerSuffix: null,\n\n    /**\n     * Factory method to create a request object. By default, a POST request\n     * will be made, and the expected response type will be\n     * \"application/json\". Classes extending this one may override this method\n     * to obtain a Request object with different parameters.\n     *\n     * @return {qx.io.remote.Request}\n     */\n    createRequest() {\n      return new qx.io.remote.Request(\n        this.getUrl(),\n        \"POST\",\n        \"application/json\"\n      );\n    },\n\n    /**\n     * Factory method to create the object containing the remote procedure\n     * call data. By default, a qooxdoo-style RPC request is built, which\n     * contains the following members: \"service\", \"method\", \"id\", and\n     * \"params\". If a different style of RPC request is desired, a class\n     * extending this one may override this method.\n     *\n     * @param id {Integer}\n     *   The unique sequence number of this request.\n     *\n     * @param method {String}\n     *   The name of the method to be called\n     *\n     * @param parameters {Array}\n     *   An array containing the arguments to the called method.\n     *\n     * @param serverData {var}\n     *   \"Out-of-band\" data to be provided to the server.\n     *\n     * @return {Object}\n     *   The object to be converted to JSON and passed to the JSON-RPC\n     *   server.\n     */\n    createRpcData(id, method, parameters, serverData) {\n      var requestObject;\n      var service;\n\n      // Create a protocol-dependent request object\n      if (this.getProtocol() == \"qx1\") {\n        // Create a qooxdoo-modified version 1.0 rpc data object\n        requestObject = {\n          service: method == \"refreshSession\" ? null : this.getServiceName(),\n          method: method,\n          id: id,\n          params: parameters,\n        };\n\n        // Only add the server_data member if there is actually server data\n        if (serverData) {\n          requestObject.server_data = serverData;\n        }\n      } else {\n        // If there's a service name, we'll prepend it to the method name\n        service = this.getServiceName();\n        if (service && service != \"\") {\n          service += \".\";\n        } else {\n          service = \"\";\n        }\n\n        // Create a standard version 2.0 rpc data object\n        requestObject = {\n          jsonrpc: \"2.0\",\n          method: service + method,\n          id: id,\n          params: parameters,\n        };\n      }\n\n      return requestObject;\n    },\n\n    /**\n     * Internal RPC call method\n     *\n     * @lint ignoreDeprecated(eval)\n     *\n     * @param args {Array}\n     *   array of arguments\n     *\n     * @param callType {Integer}\n     *   0 = sync,\n     *   1 = async with handler,\n     *   2 = async event listeners\n     *\n     * @param refreshSession {Boolean}\n     *   whether a new session should be requested\n     *\n     * @return {var} the method call reference.\n     * @throws {Error} An error.\n     */\n    _callInternal(args, callType, refreshSession) {\n      var self = this;\n      var offset = callType == 0 ? 0 : 1;\n      var whichMethod = refreshSession ? \"refreshSession\" : args[offset];\n      var handler = args[0];\n      var argsArray = [];\n      var eventTarget = this;\n      var protocol = this.getProtocol();\n\n      for (var i = offset + 1; i < args.length; ++i) {\n        argsArray.push(args[i]);\n      }\n\n      var req = this.createRequest();\n\n      // Get any additional out-of-band data to be sent to the server\n      var serverData = this.getServerData();\n\n      // Create the request object\n      var rpcData = this.createRpcData(\n        req.getSequenceNumber(),\n        whichMethod,\n        argsArray,\n        serverData\n      );\n\n      req.setCrossDomain(this.getCrossDomain());\n\n      if (this.getUsername()) {\n        req.setUseBasicHttpAuth(this.getUseBasicHttpAuth());\n        req.setUsername(this.getUsername());\n        req.setPassword(this.getPassword());\n      }\n\n      req.setTimeout(this.getTimeout());\n      var ex = null;\n      var id = null;\n      var result = null;\n      var response = null;\n\n      var handleRequestFinished = function (eventType, eventTarget) {\n        switch (callType) {\n          case 0: // sync\n            break;\n\n          case 1: // async with handler function\n            try {\n              handler(result, ex, id);\n            } catch (e) {\n              eventTarget.error(\n                \"rpc handler threw an error:\" +\n                  \" id=\" +\n                  id +\n                  \" result=\" +\n                  qx.lang.Json.stringify(result) +\n                  \" ex=\" +\n                  qx.lang.Json.stringify(ex),\n                e\n              );\n            }\n            break;\n\n          case 2: // async with event listeners\n            // Dispatch the event to our listeners.\n            if (!ex) {\n              eventTarget.fireDataEvent(eventType, response);\n            } else {\n              // Add the id to the exception\n              ex.id = id;\n\n              if (args[0]) {\n                // coalesce\n                // They requested that we coalesce all failure types to\n                // \"failed\"\n                eventTarget.fireDataEvent(\"failed\", ex);\n              } else {\n                // No coalese so use original event type\n                eventTarget.fireDataEvent(eventType, ex);\n              }\n            }\n        }\n      };\n\n      var addToStringToObject = function (obj) {\n        if (protocol == \"qx1\") {\n          obj.toString = function () {\n            switch (obj.origin) {\n              case qx.io.remote.Rpc.origin.server:\n                return \"Server error \" + obj.code + \": \" + obj.message;\n\n              case qx.io.remote.Rpc.origin.application:\n                return \"Application error \" + obj.code + \": \" + obj.message;\n\n              case qx.io.remote.Rpc.origin.transport:\n                return \"Transport error \" + obj.code + \": \" + obj.message;\n\n              case qx.io.remote.Rpc.origin.local:\n                return \"Local error \" + obj.code + \": \" + obj.message;\n\n              default:\n                return (\n                  \"UNEXPECTED origin \" +\n                  obj.origin +\n                  \" error \" +\n                  obj.code +\n                  \": \" +\n                  obj.message\n                );\n            }\n          };\n        }\n        // protocol == \"2.0\"\n        else {\n          obj.toString = function () {\n            var ret;\n\n            ret = \"Error \" + obj.code + \": \" + obj.message;\n            if (obj.data) {\n              ret += \" (\" + obj.data + \")\";\n            }\n\n            return ret;\n          };\n        }\n      };\n\n      var makeException = function (origin, code, message) {\n        var ex = {};\n        if (protocol == \"qx1\") {\n          ex.origin = origin;\n        }\n        ex.code = code;\n        ex.message = message;\n        addToStringToObject(ex);\n        return ex;\n      };\n\n      req.addListener(\"failed\", function (evt) {\n        var code = evt.getStatusCode();\n        ex = makeException(\n          qx.io.remote.Rpc.origin.transport,\n          code,\n          qx.io.remote.Exchange.statusCodeToString(code)\n        );\n        id = this.getSequenceNumber();\n        handleRequestFinished(\"failed\", eventTarget);\n      });\n\n      req.addListener(\"timeout\", function (evt) {\n        this.debug(\"TIMEOUT OCCURRED\");\n        ex = makeException(\n          qx.io.remote.Rpc.origin.local,\n          qx.io.remote.Rpc.localError.timeout,\n          \"Local time-out expired for \" + whichMethod\n        );\n        id = this.getSequenceNumber();\n        handleRequestFinished(\"timeout\", eventTarget);\n      });\n\n      req.addListener(\"aborted\", function (evt) {\n        ex = makeException(\n          qx.io.remote.Rpc.origin.local,\n          qx.io.remote.Rpc.localError.abort,\n          \"Aborted \" + whichMethod\n        );\n        id = this.getSequenceNumber();\n        handleRequestFinished(\"aborted\", eventTarget);\n      });\n\n      req.addListener(\"completed\", function (evt) {\n        response = evt.getContent();\n\n        // server may have reset, giving us no data on our requests\n        if (response === null) {\n          ex = makeException(\n            qx.io.remote.Rpc.origin.local,\n            qx.io.remote.Rpc.localError.nodata,\n            \"No data in response to \" + whichMethod\n          );\n          id = this.getSequenceNumber();\n          handleRequestFinished(\"failed\", eventTarget);\n          return;\n        }\n\n        // Parse. Skip when response is already an object\n        // because the script transport was used.\n        if (!qx.lang.Type.isObject(response)) {\n          // Handle converted dates\n          if (self._isConvertDates()) {\n            // Parse as JSON and revive date literals\n            if (self._isResponseJson()) {\n              response = qx.lang.Json.parse(response, function (key, value) {\n                if (value && typeof value === \"string\") {\n                  if (value.indexOf(\"new Date(Date.UTC(\") >= 0) {\n                    var m = value.match(\n                      /new Date\\(Date.UTC\\((\\d+),(\\d+),(\\d+),(\\d+),(\\d+),(\\d+),(\\d+)\\)\\)/\n                    );\n                    return new Date(\n                      Date.UTC(m[1], m[2], m[3], m[4], m[5], m[6], m[7])\n                    );\n                  }\n                }\n                return value;\n              });\n\n              // Eval\n            } else {\n              response =\n                response && response.length > 0\n                  ? eval(\"(\" + response + \")\")\n                  : null;\n            }\n\n            // No special date handling required, JSON assumed\n          } else {\n            response = qx.lang.Json.parse(response);\n          }\n        }\n\n        id = response[\"id\"];\n\n        if (id != this.getSequenceNumber()) {\n          this.warn(\n            \"Received id (\" +\n              id +\n              \") does not match requested id \" +\n              \"(\" +\n              this.getSequenceNumber() +\n              \")!\"\n          );\n        }\n\n        // Determine if an error was returned. Assume no error, initially.\n        var eventType = \"completed\";\n        var exTest = response[\"error\"];\n\n        if (exTest != null) {\n          // There was an error\n          result = null;\n          addToStringToObject(exTest);\n          ex = exTest;\n\n          // Change the event type\n          eventType = \"failed\";\n        } else {\n          result = response[\"result\"];\n\n          if (refreshSession) {\n            result = eval(\"(\" + result + \")\");\n            var newSuffix = qx.core.ServerSettings.serverPathSuffix;\n\n            if (self.__currentServerSuffix != newSuffix) {\n              self.__previousServerSuffix = self.__currentServerSuffix;\n              self.__currentServerSuffix = newSuffix;\n            }\n\n            self.setUrl(self.fixUrl(self.getUrl()));\n          }\n        }\n\n        handleRequestFinished(eventType, eventTarget);\n      });\n\n      // Provide a replacer when convert dates is enabled\n      var replacer = null;\n      if (this._isConvertDates()) {\n        replacer = function (key, value) {\n          // The value passed in is of type string, because the Date's\n          // toJson gets applied before. Get value from containing object.\n          value = this[key];\n\n          if (qx.lang.Type.isDate(value)) {\n            var dateParams =\n              value.getUTCFullYear() +\n              \",\" +\n              value.getUTCMonth() +\n              \",\" +\n              value.getUTCDate() +\n              \",\" +\n              value.getUTCHours() +\n              \",\" +\n              value.getUTCMinutes() +\n              \",\" +\n              value.getUTCSeconds() +\n              \",\" +\n              value.getUTCMilliseconds();\n            return \"new Date(Date.UTC(\" + dateParams + \"))\";\n          }\n          return value;\n        };\n      }\n\n      req.setData(qx.lang.Json.stringify(rpcData, replacer));\n      req.setAsynchronous(callType > 0);\n\n      if (req.getCrossDomain()) {\n        // Our choice here has no effect anyway.  This is purely informational.\n        req.setRequestHeader(\n          \"Content-Type\",\n          \"application/x-www-form-urlencoded\"\n        );\n      } else {\n        // When not cross-domain, set type to text/json\n        req.setRequestHeader(\"Content-Type\", \"application/json\");\n      }\n\n      // Do not parse as JSON. Later done conditionally.\n      req.setParseJson(false);\n\n      req.send();\n\n      if (callType == 0) {\n        if (ex != null) {\n          var error = new Error(ex.toString());\n          error.rpcdetails = ex;\n          throw error;\n        }\n\n        return result;\n      } else {\n        return req;\n      }\n    },\n\n    /**\n     * Helper method to rewrite a URL with a stale session id (so that it includes\n     * the correct session id afterwards).\n     *\n     * @param url {String} the URL to examine.\n     * @return {String} the (possibly re-written) URL.\n     */\n    fixUrl(url) {\n      if (\n        this.__previousServerSuffix == null ||\n        this.__currentServerSuffix == null ||\n        this.__previousServerSuffix == \"\" ||\n        this.__previousServerSuffix == this.__currentServerSuffix\n      ) {\n        return url;\n      }\n\n      var index = url.indexOf(this.__previousServerSuffix);\n\n      if (index == -1) {\n        return url;\n      }\n\n      return (\n        url.substring(0, index) +\n        this.__currentServerSuffix +\n        url.substring(index + this.__previousServerSuffix.length)\n      );\n    },\n\n    /**\n     * Makes a synchronous server call. The method arguments (if any) follow\n     * after the method name (as normal JavaScript arguments, separated by\n     * commas, not as an array).\n     *\n     * If a problem occurs when making the call, an exception is thrown.\n     *\n     *\n     * WARNING.  With some browsers, the synchronous interface\n     * causes the browser to hang while awaiting a response!  If the server\n     * decides to pause for a minute or two, your browser may do nothing\n     * (including refreshing following window changes) until the response is\n     * received.  Instead, use the asynchronous interface.\n     *\n     *\n     * YOU HAVE BEEN WARNED.\n     *\n     *\n     * @param methodName {String} the name of the method to call.\n     * @param args {Array} an array of values passed through to the backend.\n     * @return {var} the result returned by the server.\n     */\n    callSync(methodName, args) {\n      return this._callInternal(arguments, 0);\n    },\n\n    /**\n     * Makes an asynchronous server call. The method arguments (if any) follow\n     * after the method name (as normal JavaScript arguments, separated by\n     * commas, not as an array).\n     *\n     * When an answer from the server arrives, the <code>handler</code>\n     * function is called with the result of the call as the first, an\n     * exception as the second parameter, and the id (aka sequence number) of\n     * the invoking request as the third parameter. If the call was\n     * successful, the second parameter is <code>null</code>. If there was a\n     * problem, the second parameter contains an exception, and the first one\n     * is <code>null</code>.\n     *\n     *\n     * The return value of this method is a call reference that you can store\n     * if you want to abort the request later on. This value should be treated\n     * as opaque and can change completely in the future! The only thing you\n     * can rely on is that the <code>abort</code> method will accept this\n     * reference and that you can retrieve the sequence number of the request\n     * by invoking the getSequenceNumber() method (see below).\n     *\n     *\n     * If a specific method is being called, asynchronously, a number of times\n     * in succession, the getSequenceNumber() method may be used to\n     * disambiguate which request a response corresponds to.  The sequence\n     * number value is a value which increments with each request.)\n     *\n     *\n     * @param handler {Function} the callback function.\n     * @param methodName {String} the name of the method to call.\n     * @param args {Array} an array of values passed through to the backend.\n     * @return {var} the method call reference.\n     */\n    callAsync(handler, methodName, args) {\n      return this._callInternal(arguments, 1);\n    },\n\n    /**\n     * Makes an asynchronous server call and dispatches an event upon completion\n     * or failure. The method arguments (if any) follow after the method name\n     * (as normal JavaScript arguments, separated by commas, not as an array).\n     *\n     * When an answer from the server arrives (or fails to arrive on time), if\n     * an exception occurred, a \"failed\", \"timeout\" or \"aborted\" event, as\n     * appropriate, is dispatched to any waiting event listeners.  If no\n     * exception occurred, a \"completed\" event is dispatched.\n     *\n     *\n     * When a \"failed\", \"timeout\" or \"aborted\" event is dispatched, the event\n     * data contains an object with the properties 'origin', 'code', 'message'\n     * and 'id'.  The object has a toString() function which may be called to\n     * convert the exception to a string.\n     *\n     *\n     * When a \"completed\" event is dispatched, the event data contains a\n     * map with the JSON-RPC sequence number and result:\n     * <p>\n     * {\n     *   id: rpc_id,\n     *   result: json-rpc result\n     * }\n     *\n     *\n     * The return value of this method is a call reference that you can store\n     * if you want to abort the request later on. This value should be treated\n     * as opaque and can change completely in the future! The only thing you\n     * can rely on is that the <code>abort</code> method will accept this\n     * reference and that you can retrieve the sequence number of the request\n     * by invoking the getSequenceNumber() method (see below).\n     *\n     *\n     * If a specific method is being called, asynchronously, a number of times\n     * in succession, the getSequenceNumber() method may be used to\n     * disambiguate which request a response corresponds to.  The sequence\n     * number value is a value which increments with each request.)\n     *\n     *\n     * @param coalesce {Boolean} coalesce all failure types (\"failed\",\n     *                           \"timeout\", and \"aborted\") to \"failed\".\n     *                           This is reasonable in many cases, as\n     *                           the provided exception contains adequate\n     *                           disambiguating information.\n     * @param methodName {String} the name of the method to call.\n     * @param args {Array} an array of values passed through to the backend.\n     * @return {var} the method call reference.\n     */\n    callAsyncListeners(coalesce, methodName, args) {\n      return this._callInternal(arguments, 2);\n    },\n\n    /**\n     * Refreshes a server session by retrieving the session id again from the\n     * server.\n     *\n     * The specified handler function is called when the refresh is\n     * complete. The first parameter can be <code>true</code> (indicating that\n     * a refresh either wasn't necessary at this time or it was successful) or\n     * <code>false</code> (indicating that a refresh would have been necessary\n     * but can't be performed because the server backend doesn't support\n     * it). If there is a non-null second parameter, it's an exception\n     * indicating that there was an error when refreshing the session.\n     *\n     *\n     * @param handler {Function} a callback function that is called when the\n     *                           refresh is complete (or failed).\n     */\n    refreshSession(handler) {\n      if (qx.core.ServerSettings && qx.core.ServerSettings.serverPathSuffix) {\n        var timeDiff =\n          new Date().getTime() - qx.core.ServerSettings.lastSessionRefresh;\n\n        if (\n          timeDiff / 1000 >\n          qx.core.ServerSettings.sessionTimeoutInSeconds - 30\n        ) {\n          // this.info(\"refreshing session\");\n          this._callInternal([handler], 1, true);\n        } else {\n          handler(true); // session refresh was OK (in this case: not needed)\n        }\n      } else {\n        handler(false); // no refresh possible, but would be necessary\n      }\n    },\n\n    /**\n     * Whether to convert date objects to pseudo literals and\n     * parse with eval.\n     *\n     * Controlled by {@link #CONVERT_DATES}.\n     *\n     * @return {Boolean} Whether to convert.\n     */\n    _isConvertDates() {\n      return !!qx.io.remote.Rpc.CONVERT_DATES;\n    },\n\n    /**\n     * Whether to expect and verify a JSON response.\n     *\n     * Controlled by {@link #RESPONSE_JSON}.\n     *\n     * @return {Boolean} Whether to expect JSON.\n     */\n    _isResponseJson() {\n      return !!qx.io.remote.Rpc.RESPONSE_JSON;\n    },\n\n    /**\n     * Aborts an asynchronous server call. Consequently, the callback function\n     * provided to <code>callAsync</code> or <code>callAsyncListeners</code>\n     * will be called with an exception.\n     *\n     * @param opaqueCallRef {var} the call reference as returned by\n     *                            <code>callAsync</code> or\n     *                            <code>callAsyncListeners</code>\n     */\n    abort(opaqueCallRef) {\n      opaqueCallRef.abort();\n    },\n  },\n});\n"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAS,CAACC,oBAAoB,CAACC,aAAa,CAAC;EAAhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEAH,EAAE,CAACI,KAAK,CAACC,MAAM,CAAC,kBAAkB,EAAE;IAClCC,MAAM,EAAEN,EAAE,CAACO,IAAI,CAACC,MAAM;IAEtB;AACF;AACA;AACA;AACA;IAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACEC,SAAS,WAAAA,UAACC,GAAG,EAAEC,WAAW,EAAE;MAC1BX,EAAA,CAAAO,IAAA,CAAAC,MAAA,CAAAI,WAAA,CAAAC,IAAA;MAEA,IAAIH,GAAG,KAAKI,SAAS,EAAE;QACrB,IAAI,CAACC,MAAM,CAACL,GAAG,CAAC;MAClB;MAEA,IAAIC,WAAW,IAAI,IAAI,EAAE;QACvB,IAAI,CAACK,cAAc,CAACL,WAAW,CAAC;MAClC;MAEA,IAAIX,EAAE,CAACO,IAAI,CAACU,cAAc,EAAE;QAC1B,IAAI,CAACC,SAAqB,GAAGlB,EAAE,CAACO,IAAI,CAACU,cAAc,CAACE,gBAAgB;MACtE;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;;IAEEC,MAAM,EAAE;MACN;AACJ;AACA;MACIC,SAAS,EAAE,qBAAqB;MAEhC;AACJ;AACA;MACIC,OAAO,EAAE,qBAAqB;MAE9B;AACJ;AACA;MACIC,MAAM,EAAE,qBAAqB;MAE7B;AACJ;AACA;MACIC,OAAO,EAAE;IACX,CAAC;IAED;AACF;AACA;AACA;AACA;;IAEEC,OAAO,EAAE;MACP;AACJ;AACA;MACIC,MAAM,EAAE;QACNC,MAAM,EAAE,CAAC;QACTC,WAAW,EAAE,CAAC;QACdC,SAAS,EAAE,CAAC;QACZC,KAAK,EAAE;MACT,CAAC;MAED;AACJ;AACA;MACIC,UAAU,EAAE;QACVP,OAAO,EAAE,CAAC;QACVQ,KAAK,EAAE,CAAC;QACRC,MAAM,EAAE;MACV,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,aAAa,EAAE,IAAI;MAEnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,aAAa,EAAE,IAAI;MAEnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,aAAa,WAAAA,cAACC,UAAU,EAAE;QACxB,IAAIC,MAAM,GAAG,IAAI;QAEjB,IAAItC,EAAE,CAACO,IAAI,CAACU,cAAc,EAAE;UAC1BqB,MAAM,GACJtC,EAAE,CAACO,IAAI,CAACU,cAAc,CAACsB,gBAAgB,GACvC,SAAS,GACTvC,EAAE,CAACO,IAAI,CAACU,cAAc,CAACE,gBAAgB;UAEzC,IAAIkB,UAAU,IAAI,IAAI,EAAE;YACtBC,MAAM,IAAI,cAAc,GAAGD,UAAU;UACvC;QACF;QAEA,OAAOC,MAAM;MACf;IACF,CAAC;IAED;AACF;AACA;AACA;AACA;;IAEEE,UAAU,EAAE;MACV;AACJ;AACA;AACA;AACA;;MAEI;MACAhB,OAAO,EAAE;QACPiB,KAAK,EAAE,SAAS;QAChBC,QAAQ,EAAE;MACZ,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,WAAW,EAAE;QACXF,KAAK,EAAE,SAAS;QAChBG,IAAI,EAAE;MACR,CAA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ACA;AACA;AACA;AACA;AACA;AACA;AACA;MACI+E,QAAQ,WAAAA,SAACC,UAAU,EAAE1F,IAAI,EAAE;QACzB,OAAO,IAAI,CAACD,aAAa,CAAC4F,SAAS,EAAE,CAAC,CAAC;MACzC,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,SAAS,WAAAA,UAACtF,OAAO,EAAEoF,UAAU,EAAE1F,IAAI,EAAE;QACnC,OAAO,IAAI,CAACD,aAAa,CAAC4F,SAAS,EAAE,CAAC,CAAC;MACzC,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,kBAAkB,WAAAA,mBAACC,QAAQ,EAAEJ,UAAU,EAAE1F,IAAI,EAAE;QAC7C,OAAO,IAAI,CAACD,aAAa,CAAC4F,SAAS,EAAE,CAAC,CAAC;MACzC,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIzF,cAAc,WAAAA,eAACI,OAAO,EAAE;QACtB,IAAI5E,EAAE,CAACO,IAAI,CAACU,cAAc,IAAIjB,EAAE,CAACO,IAAI,CAACU,cAAc,CAACE,gBAAgB,EAAE;UACrE,IAAIkJ,QAAQ,GACV,IAAIhC,IAAI,CAAC,CAAC,CAACiC,OAAO,CAAC,CAAC,GAAGtK,EAAE,CAACO,IAAI,CAACU,cAAc,CAACsJ,kBAAkB;UAElE,IACEF,QAAQ,GAAG,IAAI,GACfrK,EAAE,CAACO,IAAI,CAACU,cAAc,CAACuJ,uBAAuB,GAAG,EAAE,EACnD;YACA;YACA,IAAI,CAACnG,aAAa,CAAC,CAACO,OAAO,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC;UACxC,CAAC,MAAM;YACLA,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;UACjB;QACF,CAAC,MAAM;UACLA,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QAClB;MACF,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;MACIiD,eAAe,WAAAA,gBAAA,EAAG;QAChB,OAAO,CAAC,CAAC7H,EAAE,CAACsD,EAAE,CAACC,MAAM,CAACuD,GAAG,CAAC5E,aAAa;MACzC,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;MACI4F,eAAe,WAAAA,gBAAA,EAAG;QAChB,OAAO,CAAC,CAAC9H,EAAE,CAACsD,EAAE,CAACC,MAAM,CAACuD,GAAG,CAAC3E,aAAa;MACzC,CAAC;MAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIH,KAAK,WAAAA,MAACyI,aAAa,EAAE;QACnBA,aAAa,CAACzI,KAAK,CAAC,CAAC;MACvB;IACF;EACF,CAAC,CAAC;EAx+BFhC,EAAE,CAACsD,EAAE,CAACC,MAAM,CAACuD,GAAG,CAAC3G,aAAa,GAAGA,aAAa;AAAC"
}