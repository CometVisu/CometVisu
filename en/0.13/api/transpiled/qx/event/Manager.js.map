{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "Object",
    "implement",
    "core",
    "IDisposable",
    "construct",
    "win",
    "registration",
    "__window",
    "__windowId",
    "ObjectRegistry",
    "toHashCode",
    "__registration",
    "self",
    "method",
    "bom",
    "Event",
    "removeNativeListener",
    "dispose",
    "addNativeListener",
    "event",
    "GlobalError",
    "observeMethod",
    "__listeners",
    "__handlers",
    "__dispatchers",
    "__handlerCache",
    "__clearBlackList",
    "util",
    "DeferredCall",
    "__blacklist",
    "$$blackListCleaner",
    "statics",
    "__lastUnique",
    "getNextUniqueId",
    "__globalEventMonitors",
    "addGlobalEventMonitor",
    "fn",
    "context",
    "Assert",
    "assertFunction",
    "$$context",
    "push",
    "removeGlobalEventMonitor",
    "lang",
    "Array",
    "remove",
    "resetGlobalEventMonitors",
    "Manager",
    "getGlobalEventMonitor",
    "setGlobalEventMonitor",
    "members",
    "__disposeWrapper",
    "getWindow",
    "getWindowId",
    "getHandler",
    "clazz",
    "handler",
    "classname",
    "getDispatcher",
    "dispatcher",
    "getListeners",
    "target",
    "type",
    "capture",
    "targetKey",
    "$$hash",
    "targetMap",
    "entryKey",
    "entryList",
    "concat",
    "getAllListeners",
    "serializeListeners",
    "result",
    "indexOf",
    "entry",
    "substring",
    "charAt",
    "i",
    "l",
    "length",
    "toggleAttachedEvents",
    "enable",
    "charCodeAt",
    "__registerAtHandler",
    "__unregisterAtHandler",
    "hasListener",
    "importListeners",
    "list",
    "listKey",
    "item",
    "listener",
    "unique",
    "addListener",
    "findHandler",
    "isDomNode",
    "isWindow",
    "isObject",
    "isDocument",
    "key",
    "nodeType",
    "tagName",
    "toLowerCase",
    "cache",
    "classes",
    "getHandlers",
    "IEventHandler",
    "instance",
    "supportedTypes",
    "targetCheck",
    "SUPPORTED_TYPES",
    "TARGET_CHECK",
    "found",
    "TARGET_DOMNODE",
    "TARGET_WINDOW",
    "TARGET_OBJECT",
    "TARGET_DOCUMENT",
    "IGNORE_CAN_HANDLE",
    "canHandleEvent",
    "__P_209_12",
    "registerEvent",
    "removeListener",
    "removeAt",
    "__addToBlacklist",
    "removeListenerById",
    "id",
    "split",
    "removeAllListeners",
    "forEach",
    "deleteAllListeners",
    "__P_209_13",
    "unregisterEvent",
    "dispatchEvent",
    "monitors",
    "preventDefault",
    "getDefaultPrevented",
    "call",
    "ex",
    "log",
    "Logger",
    "error",
    "toString",
    "slice",
    "Error",
    "getType",
    "getBubbles",
    "Pool",
    "getInstance",
    "poolObject",
    "getTarget",
    "setTarget",
    "getDispatchers",
    "dispatched",
    "tracker",
    "canDispatchEvent",
    "Utils",
    "track",
    "then",
    "removeManager",
    "DisposeUtil",
    "disposeMap",
    "__P_209_14",
    "uid",
    "schedule",
    "isBlacklisted"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/event/Manager.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2007-2008 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Fabian Jakobs (fjakobs)\r\n     * Sebastian Werner (wpbasti)\r\n     * John Spackman (johnspackman)\r\n     * Christian Boulanger (cboulanger)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * Wrapper for browser DOM event handling for each browser window/frame.\r\n *\r\n * @require(qx.bom.Event)\r\n */\r\nqx.Class.define(\"qx.event.Manager\", {\r\n  extend: Object,\r\n  implement: [qx.core.IDisposable],\r\n\r\n  /*\r\n  *****************************************************************************\r\n     CONSTRUCTOR\r\n  *****************************************************************************\r\n  */\r\n\r\n  /**\r\n   * Creates a new instance of the event handler.\r\n   *\r\n   * @param win {Window} The DOM window this manager handles the events for\r\n   * @param registration {qx.event.Registration} The event registration to use\r\n   */\r\n  construct(win, registration) {\r\n    // Assign window object\r\n    this.__window = win;\r\n    this.__windowId = qx.core.ObjectRegistry.toHashCode(win);\r\n    this.__registration = registration;\r\n\r\n    // Register to the page unload event.\r\n    // Only for iframes and other secondary documents.\r\n    if (win.qx !== qx) {\r\n      var self = this;\r\n      var method = function () {\r\n        qx.bom.Event.removeNativeListener(win, \"unload\", method);\r\n        self.dispose();\r\n      };\r\n      if (qx.core.Environment.get(\"qx.globalErrorHandling\")) {\r\n        qx.bom.Event.addNativeListener(\r\n          win,\r\n          \"unload\",\r\n          qx.event.GlobalError.observeMethod(method)\r\n        );\r\n      } else {\r\n        qx.bom.Event.addNativeListener(win, \"unload\", method);\r\n      }\r\n    }\r\n\r\n    // Registry for event listeners\r\n    this.__listeners = {};\r\n\r\n    // The handler and dispatcher instances\r\n    this.__handlers = {};\r\n    this.__dispatchers = {};\r\n\r\n    this.__handlerCache = {};\r\n\r\n    this.__clearBlackList = new qx.util.DeferredCall(function () {\r\n      this.__blacklist = null;\r\n    }, this);\r\n    this.__clearBlackList.$$blackListCleaner = true;\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     STATICS\r\n  *****************************************************************************\r\n  */\r\n\r\n  statics: {\r\n    /** @type {Integer} Last used ID for an event */\r\n    __lastUnique: 0,\r\n\r\n    /**\r\n     * Returns an unique ID which may be used in combination with a target and\r\n     * a type to identify an event entry.\r\n     *\r\n     * @return {String} The next free identifier (auto-incremented)\r\n     */\r\n    getNextUniqueId() {\r\n      return this.__lastUnique++ + \"\";\r\n    },\r\n\r\n    /**\r\n     * @type {Array} private list of global event monitor functions\r\n     */\r\n    __globalEventMonitors: [],\r\n\r\n    /**\r\n     * Adds a global event monitor function which is called for each event fired\r\n     * anywhere in the application. The function is called with the signature\r\n     * (target: {@link qx.core.Object}, event: {@link qx.event.type.Event}).\r\n     * Since for performance reasons, the original event object is passed,\r\n     * the monitor function must not change this event in any way.\r\n     *\r\n     * @param fn {Function} Monitor function\r\n     * @param context {Object?} Optional execution context of the function\r\n     */\r\n    addGlobalEventMonitor(fn, context) {\r\n      qx.core.Assert.assertFunction(fn);\r\n      fn.$$context = context;\r\n      this.__globalEventMonitors.push(fn);\r\n    },\r\n\r\n    /**\r\n     * Removes a global event monitor function that had\r\n     * previously been added.\r\n     * @param fn {Function} The global monitor function\r\n     */\r\n    removeGlobalEventMonitor(fn) {\r\n      qx.core.Assert.assertFunction(fn);\r\n      qx.lang.Array.remove(this.__globalEventMonitors, fn);\r\n    },\r\n\r\n    /**\r\n     * Remove all registered event monitors\r\n     */\r\n    resetGlobalEventMonitors() {\r\n      qx.event.Manager.__globalEventMonitors = [];\r\n    },\r\n\r\n    /**\r\n     * Returns the global event monitor. Not compatible with the {@link\r\n     * qx.event.Manager.addGlobalEventMonitor} API. Will be removed in v7.0.0\r\n     *\r\n     * @deprecated {6.0}\r\n     * @return {Function?} the global monitor function\r\n     */\r\n    getGlobalEventMonitor() {\r\n      return this.__globalEventMonitors[0];\r\n    },\r\n\r\n    /**\r\n     * Sets the global event monitor. Not compatible with the {@link\r\n     * qx.event.Manager.addGlobalEventMonitor} API. Will be removed in\r\n     * v7.0.0. Use {@link qx.event.Manager.addGlobalEventMonitor} instead.\r\n     *\r\n     * @deprecated {6.0}\r\n     * @param fn {Function?} the global monitor function\r\n     */\r\n    setGlobalEventMonitor(fn) {\r\n      qx.core.Assert.assertFunction(fn);\r\n      this.__globalEventMonitors[0] = fn;\r\n    }\r\n  },\r\n\r\n  /*\r\n  *****************************************************************************\r\n     MEMBERS\r\n  *****************************************************************************\r\n  */\r\n\r\n  members: {\r\n    __registration: null,\r\n    __listeners: null,\r\n\r\n    __dispatchers: null,\r\n    __disposeWrapper: null,\r\n\r\n    __handlers: null,\r\n    __handlerCache: null,\r\n    __window: null,\r\n    __windowId: null,\r\n\r\n    __blacklist: null,\r\n    __clearBlackList: null,\r\n\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n      HELPERS\r\n    ---------------------------------------------------------------------------\r\n    */\r\n\r\n    /**\r\n     * Get the window instance the event manager is responsible for\r\n     *\r\n     * @return {Window} DOM window instance\r\n     */\r\n    getWindow() {\r\n      return this.__window;\r\n    },\r\n\r\n    /**\r\n     * Get the hashcode of the manager's window\r\n     *\r\n     * @return {String} The window's hashcode\r\n     */\r\n    getWindowId() {\r\n      return this.__windowId;\r\n    },\r\n\r\n    /**\r\n     * Returns an instance of the given handler class for this manager(window).\r\n     *\r\n     * @param clazz {Class} Any class which implements {@link qx.event.IEventHandler}\r\n     * @return {Object} The instance used by this manager\r\n     */\r\n    getHandler(clazz) {\r\n      var handler = this.__handlers[clazz.classname];\r\n\r\n      if (handler) {\r\n        return handler;\r\n      }\r\n\r\n      return (this.__handlers[clazz.classname] = new clazz(this));\r\n    },\r\n\r\n    /**\r\n     * Returns an instance of the given dispatcher class for this manager(window).\r\n     *\r\n     * @param clazz {Class} Any class which implements {@link qx.event.IEventHandler}\r\n     * @return {Object} The instance used by this manager\r\n     */\r\n    getDispatcher(clazz) {\r\n      var dispatcher = this.__dispatchers[clazz.classname];\r\n\r\n      if (dispatcher) {\r\n        return dispatcher;\r\n      }\r\n\r\n      return (this.__dispatchers[clazz.classname] = new clazz(\r\n        this,\r\n        this.__registration\r\n      ));\r\n    },\r\n\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n      EVENT LISTENER MANAGEMENT\r\n    ---------------------------------------------------------------------------\r\n    */\r\n\r\n    /**\r\n     * Get a copy of all event listeners for the given combination\r\n     * of target, event type and phase.\r\n     *\r\n     * This method is especially useful and for event handlers to\r\n     * to query the listeners registered in the manager.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} Event type\r\n     * @param capture {Boolean ? false} Whether the listener is for the\r\n     *       capturing phase of the bubbling phase.\r\n     * @return {Array|null} Array of registered event handlers. May return\r\n     *       null when no listener were found.\r\n     */\r\n    getListeners(target, type, capture) {\r\n      var targetKey =\r\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\r\n      var targetMap = this.__listeners[targetKey];\r\n\r\n      if (!targetMap) {\r\n        return null;\r\n      }\r\n\r\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\r\n      var entryList = targetMap[entryKey];\r\n\r\n      return entryList ? entryList.concat() : null;\r\n    },\r\n\r\n    /**\r\n     * Returns all registered listeners.\r\n     *\r\n     * @internal\r\n     *\r\n     * @return {Map} All registered listeners. The key is the hash code form an object.\r\n     */\r\n    getAllListeners() {\r\n      return this.__listeners;\r\n    },\r\n\r\n    /**\r\n     * Returns a serialized array of all events attached on the given target.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @return {Map[]} Array of maps where everyone contains the keys:\r\n     *   <code>handler</code>, <code>self</code>, <code>type</code> and <code>capture</code>.\r\n     */\r\n    serializeListeners(target) {\r\n      var targetKey =\r\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\r\n      var targetMap = this.__listeners[targetKey];\r\n      var result = [];\r\n\r\n      if (targetMap) {\r\n        var indexOf, type, capture, entryList, entry;\r\n        for (var entryKey in targetMap) {\r\n          indexOf = entryKey.indexOf(\"|\");\r\n          type = entryKey.substring(0, indexOf);\r\n          capture = entryKey.charAt(indexOf + 1) == \"c\";\r\n          entryList = targetMap[entryKey];\r\n\r\n          for (var i = 0, l = entryList.length; i < l; i++) {\r\n            entry = entryList[i];\r\n            result.push({\r\n              self: entry.context,\r\n              handler: entry.handler,\r\n              type: type,\r\n              capture: capture\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * This method might be used to temporally remove all events\r\n     * directly attached to the given target. This do not work\r\n     * have any effect on bubbling events normally.\r\n     *\r\n     * This is mainly thought for detaching events in IE, before\r\n     * cloning them. It also removes all leak scenarios\r\n     * when unloading a document and may be used here as well.\r\n     *\r\n     * @internal\r\n     * @param target {Object} Any valid event target\r\n     * @param enable {Boolean} Whether to enable or disable the events\r\n     */\r\n    toggleAttachedEvents(target, enable) {\r\n      var targetKey =\r\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\r\n      var targetMap = this.__listeners[targetKey];\r\n\r\n      if (targetMap) {\r\n        var indexOf, type, capture, entryList;\r\n        for (var entryKey in targetMap) {\r\n          indexOf = entryKey.indexOf(\"|\");\r\n          type = entryKey.substring(0, indexOf);\r\n          capture = entryKey.charCodeAt(indexOf + 1) === 99; // checking for character \"c\".\r\n          entryList = targetMap[entryKey];\r\n\r\n          if (enable) {\r\n            this.__registerAtHandler(target, type, capture);\r\n          } else {\r\n            this.__unregisterAtHandler(target, type, capture);\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Check whether there are one or more listeners for an event type\r\n     * registered at the target.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} The event type\r\n     * @param capture {Boolean ? false} Whether to check for listeners of\r\n     *         the bubbling or of the capturing phase.\r\n     * @return {Boolean} Whether the target has event listeners of the given type.\r\n     */\r\n    hasListener(target, type, capture) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        if (target == null) {\r\n          qx.log.Logger.trace(this);\r\n          throw new Error(\"Invalid object: \" + target);\r\n        }\r\n      }\r\n\r\n      var targetKey =\r\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\r\n      var targetMap = this.__listeners[targetKey];\r\n\r\n      if (!targetMap) {\r\n        return false;\r\n      }\r\n\r\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\r\n      var entryList = targetMap[entryKey];\r\n\r\n      return !!(entryList && entryList.length > 0);\r\n    },\r\n\r\n    /**\r\n     * Imports a list of event listeners at once. This only\r\n     * works for newly created elements as it replaces\r\n     * all existing data structures.\r\n     *\r\n     * Works with a map of data. Each entry in this map should be a\r\n     * map again with the keys <code>type</code>, <code>listener</code>,\r\n     * <code>self</code>, <code>capture</code> and an optional <code>unique</code>.\r\n     *\r\n     * The values are identical to the parameters of {@link #addListener}.\r\n     * For details please have a look there.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param list {Map} A map where every listener has an unique key.\r\n     */\r\n    importListeners(target, list) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        if (target == null) {\r\n          qx.log.Logger.trace(this);\r\n          throw new Error(\"Invalid object: \" + target);\r\n        }\r\n      }\r\n\r\n      var targetKey =\r\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\r\n      var targetMap = (this.__listeners[targetKey] = {});\r\n      var clazz = qx.event.Manager;\r\n\r\n      for (var listKey in list) {\r\n        var item = list[listKey];\r\n\r\n        var entryKey = item.type + (item.capture ? \"|capture\" : \"|bubble\");\r\n        var entryList = targetMap[entryKey];\r\n\r\n        if (!entryList) {\r\n          entryList = targetMap[entryKey] = [];\r\n\r\n          // This is the first event listener for this type and target\r\n          // Inform the event handler about the new event\r\n          // they perform the event registration at DOM level if needed\r\n          this.__registerAtHandler(target, item.type, item.capture);\r\n        }\r\n\r\n        // Append listener to list\r\n        entryList.push({\r\n          handler: item.listener,\r\n          context: item.self,\r\n          unique: item.unique || clazz.__lastUnique++ + \"\"\r\n        });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Add an event listener to any valid target. The event listener is passed an\r\n     * instance of {@link qx.event.type.Event} containing all relevant information\r\n     * about the event as parameter.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} Name of the event e.g. \"click\", \"keydown\", ...\r\n     * @param listener {Function} Event listener function\r\n     * @param self {Object ? null} Reference to the 'this' variable inside\r\n     *         the event listener. When not given, the corresponding dispatcher\r\n     *         usually falls back to a default, which is the target\r\n     *         by convention. Note this is not a strict requirement, i.e.\r\n     *         custom dispatchers can follow a different strategy.\r\n     * @param capture {Boolean ? false} Whether to attach the event to the\r\n     *         capturing phase or the bubbling phase of the event. The default is\r\n     *         to attach the event handler to the bubbling phase.\r\n     * @return {String} An opaque ID, which can be used to remove the event listener\r\n     *         using the {@link #removeListenerById} method.\r\n     * @throws {Error} if the parameters are wrong\r\n     */\r\n    addListener(target, type, listener, self, capture) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        var msg =\r\n          \"Failed to add event listener for type '\" +\r\n          type +\r\n          \"'\" +\r\n          \" to the target '\" +\r\n          target.classname +\r\n          \"': \";\r\n\r\n        qx.core.Assert.assertObject(target, msg + \"Invalid Target.\");\r\n        qx.core.Assert.assertString(type, msg + \"Invalid event type.\");\r\n        qx.core.Assert.assertFunctionOrAsyncFunction(\r\n          listener,\r\n          msg + \"Invalid callback function\"\r\n        );\r\n\r\n        if (capture !== undefined) {\r\n          qx.core.Assert.assertBoolean(capture, \"Invalid capture flag.\");\r\n        }\r\n      }\r\n\r\n      var targetKey =\r\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\r\n      var targetMap = this.__listeners[targetKey];\r\n\r\n      if (!targetMap) {\r\n        targetMap = this.__listeners[targetKey] = {};\r\n      }\r\n\r\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\r\n      var entryList = targetMap[entryKey];\r\n\r\n      if (!entryList) {\r\n        entryList = targetMap[entryKey] = [];\r\n      }\r\n\r\n      // This is the first event listener for this type and target\r\n      // Inform the event handler about the new event\r\n      // they perform the event registration at DOM level if needed\r\n      if (entryList.length === 0) {\r\n        this.__registerAtHandler(target, type, capture);\r\n      }\r\n\r\n      // Append listener to list\r\n      var unique = qx.event.Manager.__lastUnique++ + \"\";\r\n      var entry = {\r\n        handler: listener,\r\n        context: self,\r\n        unique: unique\r\n      };\r\n\r\n      entryList.push(entry);\r\n\r\n      return entryKey + \"|\" + unique;\r\n    },\r\n\r\n    /**\r\n     * Get the event handler class matching the given event target and type\r\n     *\r\n     * @param target {var} The event target\r\n     * @param type {String} The event type\r\n     * @return {qx.event.IEventHandler|null} The best matching event handler or\r\n     *     <code>null</code>.\r\n     */\r\n    findHandler(target, type) {\r\n      var isDomNode = false,\r\n        isWindow = false,\r\n        isObject = false,\r\n        isDocument = false;\r\n      var key;\r\n\r\n      if (target.nodeType === 1) {\r\n        isDomNode = true;\r\n        key = \"DOM_\" + target.tagName.toLowerCase() + \"_\" + type;\r\n      } else if (target.nodeType === 9) {\r\n        isDocument = true;\r\n        key = \"DOCUMENT_\" + type;\r\n      }\r\n\r\n      // Please note:\r\n      // Identical operator does not work in IE (as of version 7) because\r\n      // document.parentWindow is not identical to window. Crazy stuff.\r\n      else if (target == this.__window) {\r\n        isWindow = true;\r\n        key = \"WIN_\" + type;\r\n      } else if (target.classname) {\r\n        isObject = true;\r\n        key = \"QX_\" + target.classname + \"_\" + type;\r\n      } else {\r\n        key = \"UNKNOWN_\" + target + \"_\" + type;\r\n      }\r\n\r\n      var cache = this.__handlerCache;\r\n      if (cache[key]) {\r\n        return cache[key];\r\n      }\r\n\r\n      var classes = this.__registration.getHandlers();\r\n      var IEventHandler = qx.event.IEventHandler;\r\n      var clazz, instance, supportedTypes, targetCheck;\r\n\r\n      for (var i = 0, l = classes.length; i < l; i++) {\r\n        clazz = classes[i];\r\n\r\n        // shortcut type check\r\n        supportedTypes = clazz.SUPPORTED_TYPES;\r\n        if (supportedTypes && !supportedTypes[type]) {\r\n          continue;\r\n        }\r\n\r\n        // shortcut target check\r\n        targetCheck = clazz.TARGET_CHECK;\r\n        if (targetCheck) {\r\n          // use bitwise & to compare for the bitmask!\r\n          var found = false;\r\n          if (isDomNode && (targetCheck & IEventHandler.TARGET_DOMNODE) != 0) {\r\n            found = true;\r\n          } else if (\r\n            isWindow &&\r\n            (targetCheck & IEventHandler.TARGET_WINDOW) != 0\r\n          ) {\r\n            found = true;\r\n          } else if (\r\n            isObject &&\r\n            (targetCheck & IEventHandler.TARGET_OBJECT) != 0\r\n          ) {\r\n            found = true;\r\n          } else if (\r\n            isDocument &&\r\n            (targetCheck & IEventHandler.TARGET_DOCUMENT) != 0\r\n          ) {\r\n            found = true;\r\n          }\r\n\r\n          if (!found) {\r\n            continue;\r\n          }\r\n        }\r\n\r\n        instance = this.getHandler(classes[i]);\r\n        if (clazz.IGNORE_CAN_HANDLE || instance.canHandleEvent(target, type)) {\r\n          cache[key] = instance;\r\n          return instance;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * This method is called each time an event listener for one of the\r\n     * supported events is added using {qx.event.Manager#addListener}.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} event type\r\n     * @param capture {Boolean} Whether to attach the event to the\r\n     *         capturing phase or the bubbling phase of the event.\r\n     * @throws {Error} if there is no handler for the event\r\n     */\r\n    __registerAtHandler(target, type, capture) {\r\n      var handler = this.findHandler(target, type);\r\n\r\n      if (handler) {\r\n        handler.registerEvent(target, type, capture);\r\n        return;\r\n      }\r\n\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        qx.log.Logger.warn(\r\n          this,\r\n          \"There is no event handler for the event '\" +\r\n            type +\r\n            \"' on target '\" +\r\n            target +\r\n            \"'!\"\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Remove an event listener from an event target.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} Name of the event\r\n     * @param listener {Function} The pointer to the event listener\r\n     * @param self {Object ? null} Reference to the 'this' variable inside\r\n     *         the event listener.\r\n     * @param capture {Boolean ? false} Whether to remove the event listener of\r\n     *         the bubbling or of the capturing phase.\r\n     * @return {Boolean} Whether the event was removed successfully (was existant)\r\n     * @throws {Error} if the parameters are wrong\r\n     */\r\n    removeListener(target, type, listener, self, capture) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        var msg =\r\n          \"Failed to remove event listener for type '\" +\r\n          type +\r\n          \"'\" +\r\n          \" from the target '\" +\r\n          target.classname +\r\n          \"': \";\r\n\r\n        qx.core.Assert.assertObject(target, msg + \"Invalid Target.\");\r\n        qx.core.Assert.assertString(type, msg + \"Invalid event type.\");\r\n        qx.core.Assert.assertFunction(\r\n          listener,\r\n          msg + \"Invalid callback function\"\r\n        );\r\n\r\n        if (self !== undefined) {\r\n          qx.core.Assert.assertObject(self, \"Invalid context for callback.\");\r\n        }\r\n\r\n        if (capture !== undefined) {\r\n          qx.core.Assert.assertBoolean(capture, \"Invalid capture flag.\");\r\n        }\r\n      }\r\n\r\n      var targetKey =\r\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\r\n      var targetMap = this.__listeners[targetKey];\r\n\r\n      if (!targetMap) {\r\n        return false;\r\n      }\r\n\r\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\r\n      var entryList = targetMap[entryKey];\r\n\r\n      if (!entryList) {\r\n        return false;\r\n      }\r\n\r\n      var entry;\r\n      for (var i = 0, l = entryList.length; i < l; i++) {\r\n        entry = entryList[i];\r\n\r\n        if (entry.handler === listener && entry.context === self) {\r\n          qx.lang.Array.removeAt(entryList, i);\r\n          this.__addToBlacklist(entry.unique);\r\n\r\n          if (entryList.length == 0) {\r\n            this.__unregisterAtHandler(target, type, capture);\r\n          }\r\n\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Removes an event listener from an event target by an ID returned by\r\n     * {@link #addListener}.\r\n     *\r\n     * @param target {Object} The event target\r\n     * @param id {String} The ID returned by {@link #addListener}\r\n     * @return {Boolean} <code>true</code> if the handler was removed\r\n     */\r\n    removeListenerById(target, id) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        var msg =\r\n          \"Failed to remove event listener for id '\" +\r\n          id +\r\n          \"'\" +\r\n          \" from the target '\" +\r\n          target.classname +\r\n          \"': \";\r\n\r\n        qx.core.Assert.assertObject(target, msg + \"Invalid Target.\");\r\n        qx.core.Assert.assertString(id, msg + \"Invalid id type.\");\r\n      }\r\n\r\n      var split = id.split(\"|\");\r\n      var type = split[0];\r\n      var capture = split[1].charCodeAt(0) == 99; // detect leading \"c\"\r\n      var unique = split[2];\r\n\r\n      var targetKey =\r\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\r\n      var targetMap = this.__listeners[targetKey];\r\n\r\n      if (!targetMap) {\r\n        return false;\r\n      }\r\n\r\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\r\n      var entryList = targetMap[entryKey];\r\n\r\n      if (!entryList) {\r\n        return false;\r\n      }\r\n\r\n      var entry;\r\n      for (var i = 0, l = entryList.length; i < l; i++) {\r\n        entry = entryList[i];\r\n\r\n        if (entry.unique === unique) {\r\n          qx.lang.Array.removeAt(entryList, i);\r\n          this.__addToBlacklist(entry.unique);\r\n\r\n          if (entryList.length == 0) {\r\n            this.__unregisterAtHandler(target, type, capture);\r\n          }\r\n\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Remove all event listeners, which are attached to the given event target.\r\n     *\r\n     * @param target {Object} The event target to remove all event listeners from.\r\n     * @return {Boolean} Whether the events were existant and were removed successfully.\r\n     */\r\n    removeAllListeners(target) {\r\n      var targetKey =\r\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\r\n      var targetMap = this.__listeners[targetKey];\r\n      if (!targetMap) {\r\n        return false;\r\n      }\r\n\r\n      // Deregister from event handlers\r\n      var split, type, capture;\r\n      for (var entryKey in targetMap) {\r\n        if (targetMap[entryKey].length > 0) {\r\n          // This is quite expensive, see bug #1283\r\n          split = entryKey.split(\"|\");\r\n\r\n          targetMap[entryKey].forEach(function (entry) {\r\n            this.__addToBlacklist(entry.unique);\r\n          }, this);\r\n\r\n          type = split[0];\r\n          capture = split[1] === \"capture\";\r\n\r\n          this.__unregisterAtHandler(target, type, capture);\r\n        }\r\n      }\r\n\r\n      delete this.__listeners[targetKey];\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Internal helper for deleting the internal listener  data structure for\r\n     * the given targetKey.\r\n     *\r\n     * @param targetKey {String} Hash code for the object to delete its\r\n     *   listeners.\r\n     *\r\n     * @internal\r\n     */\r\n    deleteAllListeners(targetKey) {\r\n      delete this.__listeners[targetKey];\r\n    },\r\n\r\n    /**\r\n     * This method is called each time the an event listener for one of the\r\n     * supported events is removed by using {qx.event.Manager#removeListener}\r\n     * and no other event listener is listening on this type.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} event type\r\n     * @param capture {Boolean} Whether to attach the event to the\r\n     *         capturing phase or the bubbling phase of the event.\r\n     * @throws {Error} if there is no handler for the event\r\n     */\r\n    __unregisterAtHandler(target, type, capture) {\r\n      var handler = this.findHandler(target, type);\r\n\r\n      if (handler) {\r\n        handler.unregisterEvent(target, type, capture);\r\n        return;\r\n      }\r\n\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        qx.log.Logger.warn(\r\n          this,\r\n          \"There is no event handler for the event '\" +\r\n            type +\r\n            \"' on target '\" +\r\n            target +\r\n            \"'!\"\r\n        );\r\n      }\r\n    },\r\n\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n      EVENT DISPATCH\r\n    ---------------------------------------------------------------------------\r\n    */\r\n\r\n    /**\r\n     * Dispatches an event object using the qooxdoo event handler system. The\r\n     * event will only be visible in event listeners attached using\r\n     * {@link #addListener}. After dispatching the event object will be pooled\r\n     * for later reuse or disposed.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param event {qx.event.type.Event} The event object to dispatch. The event\r\n     *     object must be obtained using {@link qx.event.Registration#createEvent}\r\n     *     and initialized using {@link qx.event.type.Event#init}.\r\n     * @return {Boolean|qx.Promise} whether the event default was prevented or not.\r\n     *     Returns true, when the event was NOT prevented.\r\n     * @throws {Error} if there is no dispatcher for the event\r\n     */\r\n    dispatchEvent(target, event) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        var msg =\r\n          \"Could not dispatch event '\" +\r\n          event +\r\n          \"' on target '\" +\r\n          target.classname +\r\n          \"': \";\r\n\r\n        qx.core.Assert.assertNotUndefined(\r\n          target,\r\n          msg + \"Invalid event target.\"\r\n        );\r\n\r\n        qx.core.Assert.assertNotNull(target, msg + \"Invalid event target.\");\r\n        qx.core.Assert.assertInstance(\r\n          event,\r\n          qx.event.type.Event,\r\n          msg + \"Invalid event object.\"\r\n        );\r\n      }\r\n\r\n      // Show the decentrally fired events to one or more global monitor functions\r\n      var monitors = qx.event.Manager.__globalEventMonitors;\r\n      if (monitors.length) {\r\n        for (var i = 0; i < monitors.length; i++) {\r\n          var preventDefault = event.getDefaultPrevented();\r\n          try {\r\n            monitors[i].call(monitors[i].$$context, target, event);\r\n          } catch (ex) {\r\n            qx.log.Logger.error(\r\n              \"Error in global event monitor function \" +\r\n                monitors[i].toString().slice(0, 50) +\r\n                \"...\"\r\n            );\r\n\r\n            // since 6.0.0-beta-2020051X: throw a real error to stop execution instead of just a warning\r\n            throw ex;\r\n          }\r\n          if (preventDefault != event.getDefaultPrevented()) {\r\n            // since 6.0.0-beta-2020051X: throw a real error to stop execution instead of just a warning\r\n            throw new Error(\r\n              \"Unexpected change by global event monitor function, modifications to event \" +\r\n                event.getType() +\r\n                \" is not allowed.\"\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // Preparations\r\n      var type = event.getType();\r\n\r\n      if (!event.getBubbles() && !this.hasListener(target, type)) {\r\n        qx.event.Pool.getInstance().poolObject(event);\r\n        return true;\r\n      }\r\n\r\n      if (!event.getTarget()) {\r\n        event.setTarget(target);\r\n      }\r\n\r\n      // Interacion data\r\n      var classes = this.__registration.getDispatchers();\r\n      var instance;\r\n\r\n      // Loop through the dispatchers\r\n      var dispatched = false;\r\n      var tracker = {};\r\n\r\n      for (var i = 0, l = classes.length; i < l; i++) {\r\n        instance = this.getDispatcher(classes[i]);\r\n\r\n        // Ask if the dispatcher can handle this event\r\n        if (instance.canDispatchEvent(target, event, type)) {\r\n          qx.event.Utils.track(\r\n            tracker,\r\n            instance.dispatchEvent(target, event, type)\r\n          );\r\n\r\n          dispatched = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!dispatched) {\r\n        if (qx.core.Environment.get(\"qx.debug\")) {\r\n          qx.log.Logger.error(\r\n            this,\r\n            \"No dispatcher can handle event of type \" + type + \" on \" + target\r\n          );\r\n        }\r\n        return true;\r\n      }\r\n\r\n      return qx.event.Utils.then(tracker, function () {\r\n        // check whether \"preventDefault\" has been called\r\n        var preventDefault = event.getDefaultPrevented();\r\n\r\n        // Release the event instance to the event pool\r\n        qx.event.Pool.getInstance().poolObject(event);\r\n\r\n        return !preventDefault;\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Dispose the event manager\r\n     */\r\n    dispose() {\r\n      // Remove from manager list\r\n      this.__registration.removeManager(this);\r\n\r\n      qx.util.DisposeUtil.disposeMap(this, \"__handlers\");\r\n      qx.util.DisposeUtil.disposeMap(this, \"__dispatchers\");\r\n\r\n      // Dispose data fields\r\n      this.__listeners = this.__window = this.__disposeWrapper = null;\r\n      this.__registration = this.__handlerCache = null;\r\n    },\r\n\r\n    /**\r\n     * Add event to blacklist.\r\n     *\r\n     * @param uid {number} unique event id\r\n     */\r\n    __addToBlacklist(uid) {\r\n      if (this.__blacklist === null) {\r\n        this.__blacklist = {};\r\n        this.__clearBlackList.schedule();\r\n      }\r\n      this.__blacklist[uid] = true;\r\n    },\r\n\r\n    /**\r\n     * Check if the event with the given id has been removed and is therefore blacklisted for event handling\r\n     *\r\n     * @param uid {number} unique event id\r\n     * @return {boolean}\r\n     */\r\n    isBlacklisted(uid) {\r\n      return this.__blacklist !== null && this.__blacklist[uid] === true;\r\n    }\r\n  }\r\n});\r\n"
  ],
  "mappings": "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"
}