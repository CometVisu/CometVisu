{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "Object",
    "implement",
    "core",
    "IDisposable",
    "construct",
    "win",
    "registration",
    "__window",
    "__windowId",
    "ObjectRegistry",
    "toHashCode",
    "__registration",
    "self",
    "method",
    "bom",
    "Event",
    "removeNativeListener",
    "dispose",
    "addNativeListener",
    "event",
    "GlobalError",
    "observeMethod",
    "__listeners",
    "__handlers",
    "__dispatchers",
    "__handlerCache",
    "__clearBlackList",
    "util",
    "DeferredCall",
    "__blacklist",
    "$$blackListCleaner",
    "statics",
    "__lastUnique",
    "getNextUniqueId",
    "__globalEventMonitors",
    "addGlobalEventMonitor",
    "fn",
    "context",
    "Assert",
    "assertFunction",
    "$$context",
    "push",
    "removeGlobalEventMonitor",
    "lang",
    "Array",
    "remove",
    "resetGlobalEventMonitors",
    "Manager",
    "getGlobalEventMonitor",
    "setGlobalEventMonitor",
    "members",
    "__disposeWrapper",
    "getWindow",
    "getWindowId",
    "getHandler",
    "clazz",
    "handler",
    "classname",
    "getDispatcher",
    "dispatcher",
    "getListeners",
    "target",
    "type",
    "capture",
    "targetKey",
    "$$hash",
    "targetMap",
    "entryKey",
    "entryList",
    "concat",
    "getAllListeners",
    "serializeListeners",
    "result",
    "indexOf",
    "entry",
    "substring",
    "charAt",
    "i",
    "l",
    "length",
    "toggleAttachedEvents",
    "enable",
    "charCodeAt",
    "__registerAtHandler",
    "__unregisterAtHandler",
    "hasListener",
    "importListeners",
    "list",
    "listKey",
    "item",
    "listener",
    "unique",
    "addListener",
    "findHandler",
    "isDomNode",
    "isWindow",
    "isObject",
    "isDocument",
    "key",
    "nodeType",
    "tagName",
    "toLowerCase",
    "cache",
    "classes",
    "getHandlers",
    "IEventHandler",
    "instance",
    "supportedTypes",
    "targetCheck",
    "SUPPORTED_TYPES",
    "TARGET_CHECK",
    "found",
    "TARGET_DOMNODE",
    "TARGET_WINDOW",
    "TARGET_OBJECT",
    "TARGET_DOCUMENT",
    "IGNORE_CAN_HANDLE",
    "canHandleEvent",
    "registerEvent",
    "removeListener",
    "removeAt",
    "__addToBlacklist",
    "removeListenerById",
    "id",
    "split",
    "removeAllListeners",
    "forEach",
    "deleteAllListeners",
    "unregisterEvent",
    "dispatchEvent",
    "monitors",
    "preventDefault",
    "getDefaultPrevented",
    "call",
    "ex",
    "log",
    "Logger",
    "error",
    "toString",
    "slice",
    "Error",
    "getType",
    "getBubbles",
    "Pool",
    "getInstance",
    "poolObject",
    "getTarget",
    "setTarget",
    "getDispatchers",
    "dispatched",
    "tracker",
    "canDispatchEvent",
    "Utils",
    "track",
    "then",
    "removeManager",
    "DisposeUtil",
    "disposeMap",
    "uid",
    "schedule",
    "isBlacklisted"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/event/Manager.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n     * Sebastian Werner (wpbasti)\n     * John Spackman (johnspackman)\n     * Christian Boulanger (cboulanger)\n\n************************************************************************ */\n\n/**\n * Wrapper for browser DOM event handling for each browser window/frame.\n *\n * @require(qx.bom.Event)\n */\nqx.Class.define(\"qx.event.Manager\", {\n  extend: Object,\n  implement: [qx.core.IDisposable],\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  /**\n   * Creates a new instance of the event handler.\n   *\n   * @param win {Window} The DOM window this manager handles the events for\n   * @param registration {qx.event.Registration} The event registration to use\n   */\n  construct(win, registration) {\n    // Assign window object\n    this.__window = win;\n    this.__windowId = qx.core.ObjectRegistry.toHashCode(win);\n    this.__registration = registration;\n\n    // Register to the page unload event.\n    // Only for iframes and other secondary documents.\n    if (win.qx !== qx) {\n      var self = this;\n      var method = function () {\n        qx.bom.Event.removeNativeListener(win, \"unload\", method);\n        self.dispose();\n      };\n      if (qx.core.Environment.get(\"qx.globalErrorHandling\")) {\n        qx.bom.Event.addNativeListener(\n          win,\n          \"unload\",\n          qx.event.GlobalError.observeMethod(method)\n        );\n      } else {\n        qx.bom.Event.addNativeListener(win, \"unload\", method);\n      }\n    }\n\n    // Registry for event listeners\n    this.__listeners = {};\n\n    // The handler and dispatcher instances\n    this.__handlers = {};\n    this.__dispatchers = {};\n\n    this.__handlerCache = {};\n\n    this.__clearBlackList = new qx.util.DeferredCall(function () {\n      this.__blacklist = null;\n    }, this);\n    this.__clearBlackList.$$blackListCleaner = true;\n  },\n\n  /*\n  *****************************************************************************\n     STATICS\n  *****************************************************************************\n  */\n\n  statics: {\n    /** @type {Integer} Last used ID for an event */\n    __lastUnique: 0,\n\n    /**\n     * Returns an unique ID which may be used in combination with a target and\n     * a type to identify an event entry.\n     *\n     * @return {String} The next free identifier (auto-incremented)\n     */\n    getNextUniqueId() {\n      return this.__lastUnique++ + \"\";\n    },\n\n    /**\n     * @type {Array} private list of global event monitor functions\n     */\n    __globalEventMonitors: [],\n\n    /**\n     * Adds a global event monitor function which is called for each event fired\n     * anywhere in the application. The function is called with the signature\n     * (target: {@link qx.core.Object}, event: {@link qx.event.type.Event}).\n     * Since for performance reasons, the original event object is passed,\n     * the monitor function must not change this event in any way.\n     *\n     * @param fn {Function} Monitor function\n     * @param context {Object?} Optional execution context of the function\n     */\n    addGlobalEventMonitor(fn, context) {\n      qx.core.Assert.assertFunction(fn);\n      fn.$$context = context;\n      this.__globalEventMonitors.push(fn);\n    },\n\n    /**\n     * Removes a global event monitor function that had\n     * previously been added.\n     * @param fn {Function} The global monitor function\n     */\n    removeGlobalEventMonitor(fn) {\n      qx.core.Assert.assertFunction(fn);\n      qx.lang.Array.remove(this.__globalEventMonitors, fn);\n    },\n\n    /**\n     * Remove all registered event monitors\n     */\n    resetGlobalEventMonitors() {\n      qx.event.Manager.__globalEventMonitors = [];\n    },\n\n    /**\n     * Returns the global event monitor. Not compatible with the {@link\n     * qx.event.Manager.addGlobalEventMonitor} API. Will be removed in v7.0.0\n     *\n     * @deprecated {6.0}\n     * @return {Function?} the global monitor function\n     */\n    getGlobalEventMonitor() {\n      return this.__globalEventMonitors[0];\n    },\n\n    /**\n     * Sets the global event monitor. Not compatible with the {@link\n     * qx.event.Manager.addGlobalEventMonitor} API. Will be removed in\n     * v7.0.0. Use {@link qx.event.Manager.addGlobalEventMonitor} instead.\n     *\n     * @deprecated {6.0}\n     * @param fn {Function?} the global monitor function\n     */\n    setGlobalEventMonitor(fn) {\n      qx.core.Assert.assertFunction(fn);\n      this.__globalEventMonitors[0] = fn;\n    }\n  },\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members: {\n    __registration: null,\n    __listeners: null,\n\n    __dispatchers: null,\n    __disposeWrapper: null,\n\n    __handlers: null,\n    __handlerCache: null,\n    __window: null,\n    __windowId: null,\n\n    __blacklist: null,\n    __clearBlackList: null,\n\n    /*\n    ---------------------------------------------------------------------------\n      HELPERS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Get the window instance the event manager is responsible for\n     *\n     * @return {Window} DOM window instance\n     */\n    getWindow() {\n      return this.__window;\n    },\n\n    /**\n     * Get the hashcode of the manager's window\n     *\n     * @return {String} The window's hashcode\n     */\n    getWindowId() {\n      return this.__windowId;\n    },\n\n    /**\n     * Returns an instance of the given handler class for this manager(window).\n     *\n     * @param clazz {Class} Any class which implements {@link qx.event.IEventHandler}\n     * @return {Object} The instance used by this manager\n     */\n    getHandler(clazz) {\n      var handler = this.__handlers[clazz.classname];\n\n      if (handler) {\n        return handler;\n      }\n\n      return (this.__handlers[clazz.classname] = new clazz(this));\n    },\n\n    /**\n     * Returns an instance of the given dispatcher class for this manager(window).\n     *\n     * @param clazz {Class} Any class which implements {@link qx.event.IEventHandler}\n     * @return {Object} The instance used by this manager\n     */\n    getDispatcher(clazz) {\n      var dispatcher = this.__dispatchers[clazz.classname];\n\n      if (dispatcher) {\n        return dispatcher;\n      }\n\n      return (this.__dispatchers[clazz.classname] = new clazz(\n        this,\n        this.__registration\n      ));\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT LISTENER MANAGEMENT\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Get a copy of all event listeners for the given combination\n     * of target, event type and phase.\n     *\n     * This method is especially useful and for event handlers to\n     * to query the listeners registered in the manager.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type\n     * @param capture {Boolean ? false} Whether the listener is for the\n     *       capturing phase of the bubbling phase.\n     * @return {Array|null} Array of registered event handlers. May return\n     *       null when no listener were found.\n     */\n    getListeners(target, type, capture) {\n      var targetKey =\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n\n      if (!targetMap) {\n        return null;\n      }\n\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\n      var entryList = targetMap[entryKey];\n\n      return entryList ? entryList.concat() : null;\n    },\n\n    /**\n     * Returns all registered listeners.\n     *\n     * @internal\n     *\n     * @return {Map} All registered listeners. The key is the hash code form an object.\n     */\n    getAllListeners() {\n      return this.__listeners;\n    },\n\n    /**\n     * Returns a serialized array of all events attached on the given target.\n     *\n     * @param target {Object} Any valid event target\n     * @return {Map[]} Array of maps where everyone contains the keys:\n     *   <code>handler</code>, <code>self</code>, <code>type</code> and <code>capture</code>.\n     */\n    serializeListeners(target) {\n      var targetKey =\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n      var result = [];\n\n      if (targetMap) {\n        var indexOf, type, capture, entryList, entry;\n        for (var entryKey in targetMap) {\n          indexOf = entryKey.indexOf(\"|\");\n          type = entryKey.substring(0, indexOf);\n          capture = entryKey.charAt(indexOf + 1) == \"c\";\n          entryList = targetMap[entryKey];\n\n          for (var i = 0, l = entryList.length; i < l; i++) {\n            entry = entryList[i];\n            result.push({\n              self: entry.context,\n              handler: entry.handler,\n              type: type,\n              capture: capture\n            });\n          }\n        }\n      }\n\n      return result;\n    },\n\n    /**\n     * This method might be used to temporally remove all events\n     * directly attached to the given target. This do not work\n     * have any effect on bubbling events normally.\n     *\n     * This is mainly thought for detaching events in IE, before\n     * cloning them. It also removes all leak scenarios\n     * when unloading a document and may be used here as well.\n     *\n     * @internal\n     * @param target {Object} Any valid event target\n     * @param enable {Boolean} Whether to enable or disable the events\n     */\n    toggleAttachedEvents(target, enable) {\n      var targetKey =\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n\n      if (targetMap) {\n        var indexOf, type, capture, entryList;\n        for (var entryKey in targetMap) {\n          indexOf = entryKey.indexOf(\"|\");\n          type = entryKey.substring(0, indexOf);\n          capture = entryKey.charCodeAt(indexOf + 1) === 99; // checking for character \"c\".\n          entryList = targetMap[entryKey];\n\n          if (enable) {\n            this.__registerAtHandler(target, type, capture);\n          } else {\n            this.__unregisterAtHandler(target, type, capture);\n          }\n        }\n      }\n    },\n\n    /**\n     * Check whether there are one or more listeners for an event type\n     * registered at the target.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} The event type\n     * @param capture {Boolean ? false} Whether to check for listeners of\n     *         the bubbling or of the capturing phase.\n     * @return {Boolean} Whether the target has event listeners of the given type.\n     */\n    hasListener(target, type, capture) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (target == null) {\n          qx.log.Logger.trace(this);\n          throw new Error(\"Invalid object: \" + target);\n        }\n      }\n\n      var targetKey =\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n\n      if (!targetMap) {\n        return false;\n      }\n\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\n      var entryList = targetMap[entryKey];\n\n      return !!(entryList && entryList.length > 0);\n    },\n\n    /**\n     * Imports a list of event listeners at once. This only\n     * works for newly created elements as it replaces\n     * all existing data structures.\n     *\n     * Works with a map of data. Each entry in this map should be a\n     * map again with the keys <code>type</code>, <code>listener</code>,\n     * <code>self</code>, <code>capture</code> and an optional <code>unique</code>.\n     *\n     * The values are identical to the parameters of {@link #addListener}.\n     * For details please have a look there.\n     *\n     * @param target {Object} Any valid event target\n     * @param list {Map} A map where every listener has an unique key.\n     */\n    importListeners(target, list) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (target == null) {\n          qx.log.Logger.trace(this);\n          throw new Error(\"Invalid object: \" + target);\n        }\n      }\n\n      var targetKey =\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = (this.__listeners[targetKey] = {});\n      var clazz = qx.event.Manager;\n\n      for (var listKey in list) {\n        var item = list[listKey];\n\n        var entryKey = item.type + (item.capture ? \"|capture\" : \"|bubble\");\n        var entryList = targetMap[entryKey];\n\n        if (!entryList) {\n          entryList = targetMap[entryKey] = [];\n\n          // This is the first event listener for this type and target\n          // Inform the event handler about the new event\n          // they perform the event registration at DOM level if needed\n          this.__registerAtHandler(target, item.type, item.capture);\n        }\n\n        // Append listener to list\n        entryList.push({\n          handler: item.listener,\n          context: item.self,\n          unique: item.unique || clazz.__lastUnique++ + \"\"\n        });\n      }\n    },\n\n    /**\n     * Add an event listener to any valid target. The event listener is passed an\n     * instance of {@link qx.event.type.Event} containing all relevant information\n     * about the event as parameter.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Name of the event e.g. \"click\", \"keydown\", ...\n     * @param listener {Function} Event listener function\n     * @param self {Object ? null} Reference to the 'this' variable inside\n     *         the event listener. When not given, the corresponding dispatcher\n     *         usually falls back to a default, which is the target\n     *         by convention. Note this is not a strict requirement, i.e.\n     *         custom dispatchers can follow a different strategy.\n     * @param capture {Boolean ? false} Whether to attach the event to the\n     *         capturing phase or the bubbling phase of the event. The default is\n     *         to attach the event handler to the bubbling phase.\n     * @return {String} An opaque ID, which can be used to remove the event listener\n     *         using the {@link #removeListenerById} method.\n     * @throws {Error} if the parameters are wrong\n     */\n    addListener(target, type, listener, self, capture) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        var msg =\n          \"Failed to add event listener for type '\" +\n          type +\n          \"'\" +\n          \" to the target '\" +\n          target.classname +\n          \"': \";\n\n        qx.core.Assert.assertObject(target, msg + \"Invalid Target.\");\n        qx.core.Assert.assertString(type, msg + \"Invalid event type.\");\n        qx.core.Assert.assertFunctionOrAsyncFunction(\n          listener,\n          msg + \"Invalid callback function\"\n        );\n\n        if (capture !== undefined) {\n          qx.core.Assert.assertBoolean(capture, \"Invalid capture flag.\");\n        }\n      }\n\n      var targetKey =\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n\n      if (!targetMap) {\n        targetMap = this.__listeners[targetKey] = {};\n      }\n\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\n      var entryList = targetMap[entryKey];\n\n      if (!entryList) {\n        entryList = targetMap[entryKey] = [];\n      }\n\n      // This is the first event listener for this type and target\n      // Inform the event handler about the new event\n      // they perform the event registration at DOM level if needed\n      if (entryList.length === 0) {\n        this.__registerAtHandler(target, type, capture);\n      }\n\n      // Append listener to list\n      var unique = qx.event.Manager.__lastUnique++ + \"\";\n      var entry = {\n        handler: listener,\n        context: self,\n        unique: unique\n      };\n\n      entryList.push(entry);\n\n      return entryKey + \"|\" + unique;\n    },\n\n    /**\n     * Get the event handler class matching the given event target and type\n     *\n     * @param target {var} The event target\n     * @param type {String} The event type\n     * @return {qx.event.IEventHandler|null} The best matching event handler or\n     *     <code>null</code>.\n     */\n    findHandler(target, type) {\n      var isDomNode = false,\n        isWindow = false,\n        isObject = false,\n        isDocument = false;\n      var key;\n\n      if (target.nodeType === 1) {\n        isDomNode = true;\n        key = \"DOM_\" + target.tagName.toLowerCase() + \"_\" + type;\n      } else if (target.nodeType === 9) {\n        isDocument = true;\n        key = \"DOCUMENT_\" + type;\n      }\n\n      // Please note:\n      // Identical operator does not work in IE (as of version 7) because\n      // document.parentWindow is not identical to window. Crazy stuff.\n      else if (target == this.__window) {\n        isWindow = true;\n        key = \"WIN_\" + type;\n      } else if (target.classname) {\n        isObject = true;\n        key = \"QX_\" + target.classname + \"_\" + type;\n      } else {\n        key = \"UNKNOWN_\" + target + \"_\" + type;\n      }\n\n      var cache = this.__handlerCache;\n      if (cache[key]) {\n        return cache[key];\n      }\n\n      var classes = this.__registration.getHandlers();\n      var IEventHandler = qx.event.IEventHandler;\n      var clazz, instance, supportedTypes, targetCheck;\n\n      for (var i = 0, l = classes.length; i < l; i++) {\n        clazz = classes[i];\n\n        // shortcut type check\n        supportedTypes = clazz.SUPPORTED_TYPES;\n        if (supportedTypes && !supportedTypes[type]) {\n          continue;\n        }\n\n        // shortcut target check\n        targetCheck = clazz.TARGET_CHECK;\n        if (targetCheck) {\n          // use bitwise & to compare for the bitmask!\n          var found = false;\n          if (isDomNode && (targetCheck & IEventHandler.TARGET_DOMNODE) != 0) {\n            found = true;\n          } else if (\n            isWindow &&\n            (targetCheck & IEventHandler.TARGET_WINDOW) != 0\n          ) {\n            found = true;\n          } else if (\n            isObject &&\n            (targetCheck & IEventHandler.TARGET_OBJECT) != 0\n          ) {\n            found = true;\n          } else if (\n            isDocument &&\n            (targetCheck & IEventHandler.TARGET_DOCUMENT) != 0\n          ) {\n            found = true;\n          }\n\n          if (!found) {\n            continue;\n          }\n        }\n\n        instance = this.getHandler(classes[i]);\n        if (clazz.IGNORE_CAN_HANDLE || instance.canHandleEvent(target, type)) {\n          cache[key] = instance;\n          return instance;\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * This method is called each time an event listener for one of the\n     * supported events is added using {qx.event.Manager#addListener}.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} event type\n     * @param capture {Boolean} Whether to attach the event to the\n     *         capturing phase or the bubbling phase of the event.\n     * @throws {Error} if there is no handler for the event\n     */\n    __registerAtHandler(target, type, capture) {\n      var handler = this.findHandler(target, type);\n\n      if (handler) {\n        handler.registerEvent(target, type, capture);\n        return;\n      }\n\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.log.Logger.warn(\n          this,\n          \"There is no event handler for the event '\" +\n            type +\n            \"' on target '\" +\n            target +\n            \"'!\"\n        );\n      }\n    },\n\n    /**\n     * Remove an event listener from an event target.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Name of the event\n     * @param listener {Function} The pointer to the event listener\n     * @param self {Object ? null} Reference to the 'this' variable inside\n     *         the event listener.\n     * @param capture {Boolean ? false} Whether to remove the event listener of\n     *         the bubbling or of the capturing phase.\n     * @return {Boolean} Whether the event was removed successfully (was existant)\n     * @throws {Error} if the parameters are wrong\n     */\n    removeListener(target, type, listener, self, capture) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        var msg =\n          \"Failed to remove event listener for type '\" +\n          type +\n          \"'\" +\n          \" from the target '\" +\n          target.classname +\n          \"': \";\n\n        qx.core.Assert.assertObject(target, msg + \"Invalid Target.\");\n        qx.core.Assert.assertString(type, msg + \"Invalid event type.\");\n        qx.core.Assert.assertFunction(\n          listener,\n          msg + \"Invalid callback function\"\n        );\n\n        if (self !== undefined) {\n          qx.core.Assert.assertObject(self, \"Invalid context for callback.\");\n        }\n\n        if (capture !== undefined) {\n          qx.core.Assert.assertBoolean(capture, \"Invalid capture flag.\");\n        }\n      }\n\n      var targetKey =\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n\n      if (!targetMap) {\n        return false;\n      }\n\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\n      var entryList = targetMap[entryKey];\n\n      if (!entryList) {\n        return false;\n      }\n\n      var entry;\n      for (var i = 0, l = entryList.length; i < l; i++) {\n        entry = entryList[i];\n\n        if (entry.handler === listener && entry.context === self) {\n          qx.lang.Array.removeAt(entryList, i);\n          this.__addToBlacklist(entry.unique);\n\n          if (entryList.length == 0) {\n            this.__unregisterAtHandler(target, type, capture);\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Removes an event listener from an event target by an ID returned by\n     * {@link #addListener}.\n     *\n     * @param target {Object} The event target\n     * @param id {String} The ID returned by {@link #addListener}\n     * @return {Boolean} <code>true</code> if the handler was removed\n     */\n    removeListenerById(target, id) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        var msg =\n          \"Failed to remove event listener for id '\" +\n          id +\n          \"'\" +\n          \" from the target '\" +\n          target.classname +\n          \"': \";\n\n        qx.core.Assert.assertObject(target, msg + \"Invalid Target.\");\n        qx.core.Assert.assertString(id, msg + \"Invalid id type.\");\n      }\n\n      var split = id.split(\"|\");\n      var type = split[0];\n      var capture = split[1].charCodeAt(0) == 99; // detect leading \"c\"\n      var unique = split[2];\n\n      var targetKey =\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n\n      if (!targetMap) {\n        return false;\n      }\n\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\n      var entryList = targetMap[entryKey];\n\n      if (!entryList) {\n        return false;\n      }\n\n      var entry;\n      for (var i = 0, l = entryList.length; i < l; i++) {\n        entry = entryList[i];\n\n        if (entry.unique === unique) {\n          qx.lang.Array.removeAt(entryList, i);\n          this.__addToBlacklist(entry.unique);\n\n          if (entryList.length == 0) {\n            this.__unregisterAtHandler(target, type, capture);\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Remove all event listeners, which are attached to the given event target.\n     *\n     * @param target {Object} The event target to remove all event listeners from.\n     * @return {Boolean} Whether the events were existant and were removed successfully.\n     */\n    removeAllListeners(target) {\n      var targetKey =\n        target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n      if (!targetMap) {\n        return false;\n      }\n\n      // Deregister from event handlers\n      var split, type, capture;\n      for (var entryKey in targetMap) {\n        if (targetMap[entryKey].length > 0) {\n          // This is quite expensive, see bug #1283\n          split = entryKey.split(\"|\");\n\n          targetMap[entryKey].forEach(function (entry) {\n            this.__addToBlacklist(entry.unique);\n          }, this);\n\n          type = split[0];\n          capture = split[1] === \"capture\";\n\n          this.__unregisterAtHandler(target, type, capture);\n        }\n      }\n\n      delete this.__listeners[targetKey];\n      return true;\n    },\n\n    /**\n     * Internal helper for deleting the internal listener  data structure for\n     * the given targetKey.\n     *\n     * @param targetKey {String} Hash code for the object to delete its\n     *   listeners.\n     *\n     * @internal\n     */\n    deleteAllListeners(targetKey) {\n      delete this.__listeners[targetKey];\n    },\n\n    /**\n     * This method is called each time the an event listener for one of the\n     * supported events is removed by using {qx.event.Manager#removeListener}\n     * and no other event listener is listening on this type.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} event type\n     * @param capture {Boolean} Whether to attach the event to the\n     *         capturing phase or the bubbling phase of the event.\n     * @throws {Error} if there is no handler for the event\n     */\n    __unregisterAtHandler(target, type, capture) {\n      var handler = this.findHandler(target, type);\n\n      if (handler) {\n        handler.unregisterEvent(target, type, capture);\n        return;\n      }\n\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.log.Logger.warn(\n          this,\n          \"There is no event handler for the event '\" +\n            type +\n            \"' on target '\" +\n            target +\n            \"'!\"\n        );\n      }\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT DISPATCH\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Dispatches an event object using the qooxdoo event handler system. The\n     * event will only be visible in event listeners attached using\n     * {@link #addListener}. After dispatching the event object will be pooled\n     * for later reuse or disposed.\n     *\n     * @param target {Object} Any valid event target\n     * @param event {qx.event.type.Event} The event object to dispatch. The event\n     *     object must be obtained using {@link qx.event.Registration#createEvent}\n     *     and initialized using {@link qx.event.type.Event#init}.\n     * @return {Boolean|qx.Promise} whether the event default was prevented or not.\n     *     Returns true, when the event was NOT prevented.\n     * @throws {Error} if there is no dispatcher for the event\n     */\n    dispatchEvent(target, event) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        var msg =\n          \"Could not dispatch event '\" +\n          event +\n          \"' on target '\" +\n          target.classname +\n          \"': \";\n\n        qx.core.Assert.assertNotUndefined(\n          target,\n          msg + \"Invalid event target.\"\n        );\n\n        qx.core.Assert.assertNotNull(target, msg + \"Invalid event target.\");\n        qx.core.Assert.assertInstance(\n          event,\n          qx.event.type.Event,\n          msg + \"Invalid event object.\"\n        );\n      }\n\n      // Show the decentrally fired events to one or more global monitor functions\n      var monitors = qx.event.Manager.__globalEventMonitors;\n      if (monitors.length) {\n        for (var i = 0; i < monitors.length; i++) {\n          var preventDefault = event.getDefaultPrevented();\n          try {\n            monitors[i].call(monitors[i].$$context, target, event);\n          } catch (ex) {\n            qx.log.Logger.error(\n              \"Error in global event monitor function \" +\n                monitors[i].toString().slice(0, 50) +\n                \"...\"\n            );\n\n            // since 6.0.0-beta-2020051X: throw a real error to stop execution instead of just a warning\n            throw ex;\n          }\n          if (preventDefault != event.getDefaultPrevented()) {\n            // since 6.0.0-beta-2020051X: throw a real error to stop execution instead of just a warning\n            throw new Error(\n              \"Unexpected change by global event monitor function, modifications to event \" +\n                event.getType() +\n                \" is not allowed.\"\n            );\n          }\n        }\n      }\n\n      // Preparations\n      var type = event.getType();\n\n      if (!event.getBubbles() && !this.hasListener(target, type)) {\n        qx.event.Pool.getInstance().poolObject(event);\n        return true;\n      }\n\n      if (!event.getTarget()) {\n        event.setTarget(target);\n      }\n\n      // Interacion data\n      var classes = this.__registration.getDispatchers();\n      var instance;\n\n      // Loop through the dispatchers\n      var dispatched = false;\n      var tracker = {};\n\n      for (var i = 0, l = classes.length; i < l; i++) {\n        instance = this.getDispatcher(classes[i]);\n\n        // Ask if the dispatcher can handle this event\n        if (instance.canDispatchEvent(target, event, type)) {\n          qx.event.Utils.track(\n            tracker,\n            instance.dispatchEvent(target, event, type)\n          );\n\n          dispatched = true;\n          break;\n        }\n      }\n\n      if (!dispatched) {\n        if (qx.core.Environment.get(\"qx.debug\")) {\n          qx.log.Logger.error(\n            this,\n            \"No dispatcher can handle event of type \" + type + \" on \" + target\n          );\n        }\n        return true;\n      }\n\n      return qx.event.Utils.then(tracker, function () {\n        // check whether \"preventDefault\" has been called\n        var preventDefault = event.getDefaultPrevented();\n\n        // Release the event instance to the event pool\n        qx.event.Pool.getInstance().poolObject(event);\n\n        return !preventDefault;\n      });\n    },\n\n    /**\n     * Dispose the event manager\n     */\n    dispose() {\n      // Remove from manager list\n      this.__registration.removeManager(this);\n\n      qx.util.DisposeUtil.disposeMap(this, \"__handlers\");\n      qx.util.DisposeUtil.disposeMap(this, \"__dispatchers\");\n\n      // Dispose data fields\n      this.__listeners = this.__window = this.__disposeWrapper = null;\n      this.__registration = this.__handlerCache = null;\n    },\n\n    /**\n     * Add event to blacklist.\n     *\n     * @param uid {number} unique event id\n     */\n    __addToBlacklist(uid) {\n      if (this.__blacklist === null) {\n        this.__blacklist = {};\n        this.__clearBlackList.schedule();\n      }\n      this.__blacklist[uid] = true;\n    },\n\n    /**\n     * Check if the event with the given id has been removed and is therefore blacklisted for event handling\n     *\n     * @param uid {number} unique event id\n     * @return {boolean}\n     */\n    isBlacklisted(uid) {\n      return this.__blacklist !== null && this.__blacklist[uid] === true;\n    }\n  }\n});\n"
  ],
  "mappings": "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"
}