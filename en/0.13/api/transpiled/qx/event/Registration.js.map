{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "statics",
    "__managers",
    "getManager",
    "target",
    "window",
    "nodeType",
    "dom",
    "Node",
    "getWindow",
    "isWindow",
    "hash",
    "$$hash",
    "core",
    "ObjectRegistry",
    "toHashCode",
    "manager",
    "event",
    "Manager",
    "removeManager",
    "mgr",
    "id",
    "getWindowId",
    "addListener",
    "type",
    "listener",
    "self",
    "capture",
    "removeListener",
    "removeListenerById",
    "removeAllListeners",
    "deleteAllListeners",
    "targetKey",
    "hasListener",
    "serializeListeners",
    "createEvent",
    "clazz",
    "args",
    "Event",
    "obj",
    "Pool",
    "getInstance",
    "getObject",
    "init",
    "apply",
    "setType",
    "dispatchEvent",
    "__fireEvent",
    "__P_211_1",
    "evt",
    "fireEvent",
    "tracker",
    "Utils",
    "then",
    "getDefaultPrevented",
    "fireEventAsync",
    "Environment",
    "get",
    "Promise",
    "resolve",
    "Error",
    "classname",
    "__fireNonBubblingEvent",
    "__P_211_2",
    "fireNonBubblingEvent",
    "arguments",
    "fireNonBubblingEventAsync",
    "select",
    "_true",
    "promise",
    "_false",
    "PRIORITY_FIRST",
    "PRIORITY_NORMAL",
    "PRIORITY_LAST",
    "__handlers",
    "addHandler",
    "handler",
    "push",
    "sort",
    "a",
    "b",
    "PRIORITY",
    "getHandlers",
    "__dispatchers",
    "addDispatcher",
    "dispatcher",
    "priority",
    "getDispatchers",
    "Registration"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/event/Registration.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2007-2008 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Fabian Jakobs (fjakobs)\r\n     * Sebastian Werner (wpbasti)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * Wrapper for browser generic event handling.\r\n *\r\n * Supported events differ from target to target. Generally the handlers\r\n * in {@link qx.event.handler} defines the available features.\r\n *\r\n * @require(qx.event.Manager)\r\n * @require(qx.dom.Node)\r\n * @require(qx.lang.Function)\r\n */\r\nqx.Class.define(\"qx.event.Registration\", {\r\n  /*\r\n  *****************************************************************************\r\n     STATICS\r\n  *****************************************************************************\r\n  */\r\n\r\n  statics: {\r\n    /**\r\n     * Static list of all instantiated event managers. The key is the qooxdoo\r\n     * hash value of the corresponding window\r\n     */\r\n    __managers: {},\r\n\r\n    /**\r\n     * Get an instance of the event manager, which can handle events for the\r\n     * given target.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @return {qx.event.Manager} The event manger for the target.\r\n     */\r\n    getManager(target) {\r\n      if (target == null) {\r\n        if (qx.core.Environment.get(\"qx.debug\")) {\r\n          qx.log.Logger.error(\r\n            \"qx.event.Registration.getManager(null) was called!\"\r\n          );\r\n\r\n          qx.log.Logger.trace(this);\r\n        }\r\n\r\n        target = window;\r\n      } else if (target.nodeType) {\r\n        target = qx.dom.Node.getWindow(target);\r\n      } else if (!qx.dom.Node.isWindow(target)) {\r\n        target = window;\r\n      }\r\n\r\n      var hash = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\r\n      var manager = this.__managers[hash];\r\n\r\n      if (!manager) {\r\n        manager = new qx.event.Manager(target, this);\r\n        this.__managers[hash] = manager;\r\n      }\r\n\r\n      return manager;\r\n    },\r\n\r\n    /**\r\n     * Removes a manager for a specific window from the list.\r\n     *\r\n     * Normally only used when the manager gets disposed through\r\n     * an unload event of the attached window.\r\n     *\r\n     * @param mgr {qx.event.Manager} The manager to remove\r\n     */\r\n    removeManager(mgr) {\r\n      var id = mgr.getWindowId();\r\n      delete this.__managers[id];\r\n    },\r\n\r\n    /**\r\n     * Add an event listener to a DOM target. The event listener is passed an\r\n     * instance of {@link qx.event.type.Event} containing all relevant information\r\n     * about the event as parameter.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} Name of the event e.g. \"click\", \"keydown\", ...\r\n     * @param listener {Function} Event listener function\r\n     * @param self {Object ? null} Reference to the 'this' variable inside\r\n     *         the event listener. When not given, the corresponding dispatcher\r\n     *         usually falls back to a default, which is the target\r\n     *         by convention. Note this is not a strict requirement, i.e.\r\n     *         custom dispatchers can follow a different strategy.\r\n     * @param capture {Boolean} Whether to attach the event to the\r\n     *         capturing phase or the bubbling phase of the event. The default is\r\n     *         to attach the event handler to the bubbling phase.\r\n     * @return {var} An opaque id, which can be used to remove the event listener\r\n     *         using the {@link #removeListenerById} method.\r\n     */\r\n    addListener(target, type, listener, self, capture) {\r\n      return this.getManager(target).addListener(\r\n        target,\r\n        type,\r\n        listener,\r\n        self,\r\n        capture\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Remove an event listener from an event target.\r\n     *\r\n     * Note: All registered event listeners will automatically at page unload\r\n     *   so it is not necessary to detach events in the destructor.\r\n     *\r\n     * @param target {Object} The event target\r\n     * @param type {String} Name of the event\r\n     * @param listener {Function} The pointer to the event listener\r\n     * @param self {Object ? null} Reference to the 'this' variable inside\r\n     *         the event listener.\r\n     * @param capture {Boolean} Whether to remove the event listener of\r\n     *    the bubbling or of the capturing phase.\r\n     * @return {Boolean} Whether the event was removed. Return <code>false</code> if\r\n     *    the event was already removed before.\r\n     */\r\n    removeListener(target, type, listener, self, capture) {\r\n      return this.getManager(target).removeListener(\r\n        target,\r\n        type,\r\n        listener,\r\n        self,\r\n        capture\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Removes an event listener from an event target by an id returned by\r\n     * {@link #addListener}\r\n     *\r\n     * @param target {Object} The event target\r\n     * @param id {var} The id returned by {@link #addListener}\r\n     * @return {Boolean} Whether the event was removed. Return <code>false</code> if\r\n     *    the event was already removed before.\r\n     */\r\n    removeListenerById(target, id) {\r\n      return this.getManager(target).removeListenerById(target, id);\r\n    },\r\n\r\n    /**\r\n     * Remove all event listeners, which are attached to the given event target.\r\n     *\r\n     * @param target {Object} The event target to remove all event listeners from.\r\n     * @return {Boolean} Whether the events were existant and were removed successfully.\r\n     */\r\n    removeAllListeners(target) {\r\n      return this.getManager(target).removeAllListeners(target);\r\n    },\r\n\r\n    /**\r\n     * Internal helper for deleting the listeners map used during shutdown.\r\n     *\r\n     * @param target {Object} The event target to delete the internal map for\r\n     *    all event listeners.\r\n     *\r\n     * @internal\r\n     */\r\n    deleteAllListeners(target) {\r\n      var targetKey = target.$$hash;\r\n      if (targetKey) {\r\n        this.getManager(target).deleteAllListeners(targetKey);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Check whether there are one or more listeners for an event type\r\n     * registered at the target.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} The event type\r\n     * @param capture {Boolean ? false} Whether to check for listeners of\r\n     *         the bubbling or of the capturing phase.\r\n     * @return {Boolean} Whether the target has event listeners of the given type.\r\n     */\r\n    hasListener(target, type, capture) {\r\n      return this.getManager(target).hasListener(target, type, capture);\r\n    },\r\n\r\n    /**\r\n     * Returns a serialized array of all events attached on the given target.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @return {Map[]} Array of maps where everyone contains the keys:\r\n     *   <code>handler</code>, <code>self</code>, <code>type</code> and <code>capture</code>.\r\n     */\r\n    serializeListeners(target) {\r\n      return this.getManager(target).serializeListeners(target);\r\n    },\r\n\r\n    /**\r\n     * Get an event instance of the given class, which can be dispatched using\r\n     * an event manager. The created events must be initialized using\r\n     * {@link qx.event.type.Event#init}.\r\n     *\r\n     * @param type {String} The type of the event to create\r\n     * @param clazz {Object?qx.event.type.Event} The event class to use\r\n     * @param args {Array?null} Array which will be passed to\r\n     *       the event's init method.\r\n     * @return {qx.event.type.Event} An instance of the given class.\r\n     */\r\n    createEvent(type, clazz, args) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        if (arguments.length > 1 && clazz === undefined) {\r\n          throw new Error(\r\n            \"Create event of type \" +\r\n              type +\r\n              \" with undefined class. Please use null to explicit fallback to default event type!\"\r\n          );\r\n        }\r\n      }\r\n\r\n      // Fallback to default\r\n      if (clazz == null) {\r\n        clazz = qx.event.type.Event;\r\n      }\r\n\r\n      var obj = qx.event.Pool.getInstance().getObject(clazz);\r\n\r\n      // Initialize with given arguments\r\n      args ? obj.init.apply(obj, args) : obj.init();\r\n\r\n      // Setup the type\r\n      // Note: Native event may setup this later or using init() above\r\n      // using the native information.\r\n      if (type) {\r\n        obj.setType(type);\r\n      }\r\n\r\n      return obj;\r\n    },\r\n\r\n    /**\r\n     * Dispatch an event object on the given target.\r\n     *\r\n     * It is normally better to use {@link #fireEvent} because it uses\r\n     * the event pooling and is quite handy otherwise as well. After dispatching\r\n     * the event object will be pooled for later reuse or disposed.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param event {qx.event.type.Event} The event object to dispatch. The event\r\n     *       object must be obtained using {@link #createEvent} and initialized\r\n     *       using {@link qx.event.type.Event#init}.\r\n     * @return {Boolean|qx.Promise} whether the event default was prevented or not.\r\n     *     Returns true, when the event was NOT prevented.\r\n     */\r\n    dispatchEvent(target, event) {\r\n      return this.getManager(target).dispatchEvent(target, event);\r\n    },\r\n\r\n    /**\r\n     * Create an event object and dispatch it on the given target.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} Event type to fire\r\n     * @param clazz {Class?qx.event.type.Event} The event class\r\n     * @param args {Array?null} Arguments, which will be passed to\r\n     *       the event's init method.\r\n     * @return {Event} the event\r\n     * @see #createEvent\r\n     */\r\n    __fireEvent(target, type, clazz, args) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        if (arguments.length > 2 && clazz === undefined && args !== undefined) {\r\n          throw new Error(\r\n            \"Create event of type \" +\r\n              type +\r\n              \" with undefined class. Please use null to explicit fallback to default event type!\"\r\n          );\r\n        }\r\n\r\n        var msg =\r\n          \"Could not fire event '\" +\r\n          type +\r\n          \"' on target '\" +\r\n          (target ? target.classname : \"undefined\") +\r\n          \"': \";\r\n\r\n        qx.core.Assert.assertNotUndefined(\r\n          target,\r\n          msg + \"Invalid event target.\"\r\n        );\r\n\r\n        qx.core.Assert.assertNotNull(target, msg + \"Invalid event target.\");\r\n      }\r\n\r\n      var evt = this.createEvent(type, clazz || null, args);\r\n      this.getManager(target).dispatchEvent(target, evt);\r\n      return evt;\r\n    },\r\n\r\n    /**\r\n     * Create an event object and dispatch it on the given target.\r\n     *\r\n     * Note about Promises in v6.0: this method has changed to return either a boolean (true if the\r\n     * event was prevented) or a promise which will evaluate to the same thing; this is\r\n     * because events are now asynchronous and preventDefault is inherently synchronous.\r\n     * However, although this changing in the return type is conspicuous it does not necessarily\r\n     * introduce a backwards compatibility issue because the \"truthy\" nature of the return\r\n     * is preserved.  Code which needs to take care of asynchronous issues will need to change,\r\n     * but that was necessary anyway, and it is rare to use the return value of this method (only\r\n     * one class in Qooxdoo used it).\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} Event type to fire\r\n     * @param clazz {Class?qx.event.type.Event} The event class\r\n     * @param args {Array?null} Arguments, which will be passed to\r\n     *       the event's init method.\r\n     * @return {Boolean|qx.Promise} whether the event default was prevented or not.\r\n     *     Returns true, when the event was NOT prevented.\r\n     * @see #createEvent\r\n     */\r\n    fireEvent(target, type, clazz, args) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        if (arguments.length > 2 && clazz === undefined && args !== undefined) {\r\n          throw new Error(\r\n            \"Create event of type \" +\r\n              type +\r\n              \" with undefined class. Please use null to explicit fallback to default event type!\"\r\n          );\r\n        }\r\n\r\n        var msg =\r\n          \"Could not fire event '\" +\r\n          type +\r\n          \"' on target '\" +\r\n          (target ? target.classname : \"undefined\") +\r\n          \"': \";\r\n\r\n        qx.core.Assert.assertNotUndefined(\r\n          target,\r\n          msg + \"Invalid event target.\"\r\n        );\r\n\r\n        qx.core.Assert.assertNotNull(target, msg + \"Invalid event target.\");\r\n      }\r\n\r\n      var evt = this.createEvent(type, clazz || null, args);\r\n      var tracker = {};\r\n      var self = this;\r\n      qx.event.Utils.then(tracker, function () {\r\n        return self.getManager(target).dispatchEvent(target, evt);\r\n      });\r\n      return qx.event.Utils.then(tracker, function () {\r\n        return !evt.getDefaultPrevented();\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Create an event object and dispatch it on the given target; equivalent to fireEvent, except that it\r\n     * always returns a promise\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} Event type to fire\r\n     * @param clazz {Class?qx.event.type.Event} The event class\r\n     * @param args {Array?null} Arguments, which will be passed to\r\n     *       the event's init method.\r\n     * @return {qx.Promise} a promise aggregated from the event handlers;\r\n     * \tif the default was prevented, the promise is rejected\r\n     * @see #createEvent\r\n     */\r\n    fireEventAsync(target, type, clazz, args) {\r\n      if (qx.core.Environment.get(\"qx.promise\")) {\r\n        return qx.Promise.resolve(this.fireEvent(target, type, clazz, args));\r\n      } else {\r\n        throw new Error(\r\n          this.classname +\r\n            \".fireEventAsync not supported because qx.promise==false\"\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Create an event object and dispatch it on the given target.\r\n     * The event dispatched with this method does never bubble! Use only if you\r\n     * are sure that bubbling is not required.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} Event type to fire\r\n     * @param clazz {Class?qx.event.type.Event} The event class\r\n     * @param args {Array?null} Arguments, which will be passed to\r\n     *       the event's init method.\r\n     * @return {Event} the event\r\n     * @see #createEvent\r\n     */\r\n    __fireNonBubblingEvent(target, type, clazz, args) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        if (arguments.length > 2 && clazz === undefined && args !== undefined) {\r\n          throw new Error(\r\n            \"Create event of type \" +\r\n              type +\r\n              \" with undefined class. Please use null to explicit fallback to default event type!\"\r\n          );\r\n        }\r\n      }\r\n\r\n      var mgr = this.getManager(target);\r\n      if (!mgr.hasListener(target, type, false)) {\r\n        return null;\r\n      }\r\n\r\n      var evt = this.createEvent(type, clazz || null, args);\r\n      mgr.dispatchEvent(target, evt);\r\n      return evt;\r\n    },\r\n\r\n    /**\r\n     * Create an event object and dispatch it on the given target.\r\n     * The event dispatched with this method does never bubble! Use only if you\r\n     * are sure that bubbling is not required.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} Event type to fire\r\n     * @param clazz {Class?qx.event.type.Event} The event class\r\n     * @param args {Array?null} Arguments, which will be passed to\r\n     *       the event's init method.\r\n     * @return {Boolean} whether the event default was prevented or not.\r\n     *     Returns true, when the event was NOT prevented.\r\n     * @see #createEvent\r\n     */\r\n    fireNonBubblingEvent(target, type, clazz, args) {\r\n      var evt = this.__fireNonBubblingEvent.apply(this, arguments);\r\n      if (evt === null) {\r\n        return true;\r\n      }\r\n      return !evt.getDefaultPrevented();\r\n    },\r\n\r\n    /**\r\n     * Create an event object and dispatch it on the given target.\r\n     * The event dispatched with this method does never bubble! Use only if you\r\n     * are sure that bubbling is not required.\r\n     *\r\n     * @param target {Object} Any valid event target\r\n     * @param type {String} Event type to fire\r\n     * @param clazz {Class?qx.event.type.Event} The event class\r\n     * @param args {Array?null} Arguments, which will be passed to\r\n     *       the event's init method.\r\n     * @return {qx.Promise} a promise aggregated from the event handlers;\r\n     * \tif the default was prevented, the promise is rejected\r\n     * @see #createEvent\r\n     */\r\n    fireNonBubblingEventAsync: qx.core.Environment.select(\"qx.promise\", {\r\n      true(target, type, clazz, args) {\r\n        var evt = this.__fireNonBubblingEvent.apply(this, arguments);\r\n        if (evt === null) {\r\n          return qx.Promise.resolve(true);\r\n        }\r\n        return evt.promise();\r\n      },\r\n      false() {\r\n        throw new Error(\r\n          this.classname +\r\n            \".fireNonBubblingEventAsync not supported because qx.promise==false\"\r\n        );\r\n      }\r\n    }),\r\n\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n      EVENT HANDLER/DISPATCHER PRIORITY\r\n    ---------------------------------------------------------------------------\r\n    */\r\n\r\n    /** @type {Integer} Highest priority. Used by handlers and dispatchers. */\r\n    PRIORITY_FIRST: -32000,\r\n\r\n    /** @type {Integer} Default priority. Used by handlers and dispatchers. */\r\n    PRIORITY_NORMAL: 0,\r\n\r\n    /** @type {Integer} Lowest priority. Used by handlers and dispatchers. */\r\n    PRIORITY_LAST: 32000,\r\n\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n      EVENT HANDLER REGISTRATION\r\n    ---------------------------------------------------------------------------\r\n    */\r\n\r\n    /** @type {Array} Contains all known event handlers */\r\n    __handlers: [],\r\n\r\n    /**\r\n     * Register an event handler.\r\n     *\r\n     * @param handler {qx.event.IEventHandler} Event handler to add\r\n     * @throws {Error} if the handler does not have the IEventHandler interface.\r\n     */\r\n    addHandler(handler) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        qx.core.Assert.assertInterface(\r\n          handler,\r\n          qx.event.IEventHandler,\r\n          \"Invalid event handler.\"\r\n        );\r\n      }\r\n\r\n      // Append to list\r\n      this.__handlers.push(handler);\r\n\r\n      // Re-sort list\r\n      this.__handlers.sort(function (a, b) {\r\n        return a.PRIORITY - b.PRIORITY;\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Get a list of registered event handlers.\r\n     *\r\n     * @return {qx.event.IEventHandler[]} registered event handlers\r\n     */\r\n    getHandlers() {\r\n      return this.__handlers;\r\n    },\r\n\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n      EVENT DISPATCHER REGISTRATION\r\n    ---------------------------------------------------------------------------\r\n    */\r\n\r\n    /** @type {Array} Contains all known event dispatchers */\r\n    __dispatchers: [],\r\n\r\n    /**\r\n     * Register an event dispatcher.\r\n     *\r\n     * @param dispatcher {qx.event.IEventDispatcher} Event dispatcher to add\r\n     * @param priority {Integer} One of\r\n     * {@link qx.event.Registration#PRIORITY_FIRST},\r\n     * {@link qx.event.Registration#PRIORITY_NORMAL}\r\n     *       or {@link qx.event.Registration#PRIORITY_LAST}.\r\n     * @throws {Error} if the dispatcher does not have the IEventHandler interface.\r\n     */\r\n    addDispatcher(dispatcher, priority) {\r\n      if (qx.core.Environment.get(\"qx.debug\")) {\r\n        qx.core.Assert.assertInterface(\r\n          dispatcher,\r\n          qx.event.IEventDispatcher,\r\n          \"Invalid event dispatcher!\"\r\n        );\r\n      }\r\n\r\n      // Append to list\r\n      this.__dispatchers.push(dispatcher);\r\n\r\n      // Re-sort list\r\n      this.__dispatchers.sort(function (a, b) {\r\n        return a.PRIORITY - b.PRIORITY;\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Get a list of registered event dispatchers.\r\n     *\r\n     * @return {qx.event.IEventDispatcher[]} all registered event dispatcher\r\n     */\r\n    getDispatchers() {\r\n      return this.__dispatchers;\r\n    }\r\n  }\r\n});\r\n"
  ],
  "mappings": "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"
}