{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "statics",
    "__managers",
    "getManager",
    "target",
    "window",
    "nodeType",
    "dom",
    "Node",
    "getWindow",
    "isWindow",
    "hash",
    "$$hash",
    "core",
    "ObjectRegistry",
    "toHashCode",
    "manager",
    "event",
    "Manager",
    "removeManager",
    "mgr",
    "id",
    "getWindowId",
    "addListener",
    "type",
    "listener",
    "self",
    "capture",
    "removeListener",
    "removeListenerById",
    "removeAllListeners",
    "deleteAllListeners",
    "targetKey",
    "hasListener",
    "serializeListeners",
    "createEvent",
    "clazz",
    "args",
    "Event",
    "obj",
    "Pool",
    "getInstance",
    "getObject",
    "init",
    "apply",
    "setType",
    "dispatchEvent",
    "__fireEvent",
    "evt",
    "fireEvent",
    "tracker",
    "Utils",
    "then",
    "getDefaultPrevented",
    "fireEventAsync",
    "Environment",
    "get",
    "Promise",
    "resolve",
    "Error",
    "classname",
    "__fireNonBubblingEvent",
    "fireNonBubblingEvent",
    "arguments",
    "fireNonBubblingEventAsync",
    "select",
    "promise",
    "PRIORITY_FIRST",
    "PRIORITY_NORMAL",
    "PRIORITY_LAST",
    "__handlers",
    "addHandler",
    "handler",
    "push",
    "sort",
    "a",
    "b",
    "PRIORITY",
    "getHandlers",
    "__dispatchers",
    "addDispatcher",
    "dispatcher",
    "priority",
    "getDispatchers",
    "Registration"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/event/Registration.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n     * Sebastian Werner (wpbasti)\n\n************************************************************************ */\n\n/**\n * Wrapper for browser generic event handling.\n *\n * Supported events differ from target to target. Generally the handlers\n * in {@link qx.event.handler} defines the available features.\n *\n * @require(qx.event.Manager)\n * @require(qx.dom.Node)\n * @require(qx.lang.Function)\n */\nqx.Class.define(\"qx.event.Registration\", {\n  /*\n  *****************************************************************************\n     STATICS\n  *****************************************************************************\n  */\n\n  statics: {\n    /**\n     * Static list of all instantiated event managers. The key is the qooxdoo\n     * hash value of the corresponding window\n     */\n    __managers: {},\n\n    /**\n     * Get an instance of the event manager, which can handle events for the\n     * given target.\n     *\n     * @param target {Object} Any valid event target\n     * @return {qx.event.Manager} The event manger for the target.\n     */\n    getManager(target) {\n      if (target == null) {\n        if (qx.core.Environment.get(\"qx.debug\")) {\n          qx.log.Logger.error(\n            \"qx.event.Registration.getManager(null) was called!\"\n          );\n\n          qx.log.Logger.trace(this);\n        }\n\n        target = window;\n      } else if (target.nodeType) {\n        target = qx.dom.Node.getWindow(target);\n      } else if (!qx.dom.Node.isWindow(target)) {\n        target = window;\n      }\n\n      var hash = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var manager = this.__managers[hash];\n\n      if (!manager) {\n        manager = new qx.event.Manager(target, this);\n        this.__managers[hash] = manager;\n      }\n\n      return manager;\n    },\n\n    /**\n     * Removes a manager for a specific window from the list.\n     *\n     * Normally only used when the manager gets disposed through\n     * an unload event of the attached window.\n     *\n     * @param mgr {qx.event.Manager} The manager to remove\n     */\n    removeManager(mgr) {\n      var id = mgr.getWindowId();\n      delete this.__managers[id];\n    },\n\n    /**\n     * Add an event listener to a DOM target. The event listener is passed an\n     * instance of {@link qx.event.type.Event} containing all relevant information\n     * about the event as parameter.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Name of the event e.g. \"click\", \"keydown\", ...\n     * @param listener {Function} Event listener function\n     * @param self {Object ? null} Reference to the 'this' variable inside\n     *         the event listener. When not given, the corresponding dispatcher\n     *         usually falls back to a default, which is the target\n     *         by convention. Note this is not a strict requirement, i.e.\n     *         custom dispatchers can follow a different strategy.\n     * @param capture {Boolean} Whether to attach the event to the\n     *         capturing phase or the bubbling phase of the event. The default is\n     *         to attach the event handler to the bubbling phase.\n     * @return {var} An opaque id, which can be used to remove the event listener\n     *         using the {@link #removeListenerById} method.\n     */\n    addListener(target, type, listener, self, capture) {\n      return this.getManager(target).addListener(\n        target,\n        type,\n        listener,\n        self,\n        capture\n      );\n    },\n\n    /**\n     * Remove an event listener from an event target.\n     *\n     * Note: All registered event listeners will automatically at page unload\n     *   so it is not necessary to detach events in the destructor.\n     *\n     * @param target {Object} The event target\n     * @param type {String} Name of the event\n     * @param listener {Function} The pointer to the event listener\n     * @param self {Object ? null} Reference to the 'this' variable inside\n     *         the event listener.\n     * @param capture {Boolean} Whether to remove the event listener of\n     *    the bubbling or of the capturing phase.\n     * @return {Boolean} Whether the event was removed. Return <code>false</code> if\n     *    the event was already removed before.\n     */\n    removeListener(target, type, listener, self, capture) {\n      return this.getManager(target).removeListener(\n        target,\n        type,\n        listener,\n        self,\n        capture\n      );\n    },\n\n    /**\n     * Removes an event listener from an event target by an id returned by\n     * {@link #addListener}\n     *\n     * @param target {Object} The event target\n     * @param id {var} The id returned by {@link #addListener}\n     * @return {Boolean} Whether the event was removed. Return <code>false</code> if\n     *    the event was already removed before.\n     */\n    removeListenerById(target, id) {\n      return this.getManager(target).removeListenerById(target, id);\n    },\n\n    /**\n     * Remove all event listeners, which are attached to the given event target.\n     *\n     * @param target {Object} The event target to remove all event listeners from.\n     * @return {Boolean} Whether the events were existant and were removed successfully.\n     */\n    removeAllListeners(target) {\n      return this.getManager(target).removeAllListeners(target);\n    },\n\n    /**\n     * Internal helper for deleting the listeners map used during shutdown.\n     *\n     * @param target {Object} The event target to delete the internal map for\n     *    all event listeners.\n     *\n     * @internal\n     */\n    deleteAllListeners(target) {\n      var targetKey = target.$$hash;\n      if (targetKey) {\n        this.getManager(target).deleteAllListeners(targetKey);\n      }\n    },\n\n    /**\n     * Check whether there are one or more listeners for an event type\n     * registered at the target.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} The event type\n     * @param capture {Boolean ? false} Whether to check for listeners of\n     *         the bubbling or of the capturing phase.\n     * @return {Boolean} Whether the target has event listeners of the given type.\n     */\n    hasListener(target, type, capture) {\n      return this.getManager(target).hasListener(target, type, capture);\n    },\n\n    /**\n     * Returns a serialized array of all events attached on the given target.\n     *\n     * @param target {Object} Any valid event target\n     * @return {Map[]} Array of maps where everyone contains the keys:\n     *   <code>handler</code>, <code>self</code>, <code>type</code> and <code>capture</code>.\n     */\n    serializeListeners(target) {\n      return this.getManager(target).serializeListeners(target);\n    },\n\n    /**\n     * Get an event instance of the given class, which can be dispatched using\n     * an event manager. The created events must be initialized using\n     * {@link qx.event.type.Event#init}.\n     *\n     * @param type {String} The type of the event to create\n     * @param clazz {Object?qx.event.type.Event} The event class to use\n     * @param args {Array?null} Array which will be passed to\n     *       the event's init method.\n     * @return {qx.event.type.Event} An instance of the given class.\n     */\n    createEvent(type, clazz, args) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (arguments.length > 1 && clazz === undefined) {\n          throw new Error(\n            \"Create event of type \" +\n              type +\n              \" with undefined class. Please use null to explicit fallback to default event type!\"\n          );\n        }\n      }\n\n      // Fallback to default\n      if (clazz == null) {\n        clazz = qx.event.type.Event;\n      }\n\n      var obj = qx.event.Pool.getInstance().getObject(clazz);\n\n      // Initialize with given arguments\n      args ? obj.init.apply(obj, args) : obj.init();\n\n      // Setup the type\n      // Note: Native event may setup this later or using init() above\n      // using the native information.\n      if (type) {\n        obj.setType(type);\n      }\n\n      return obj;\n    },\n\n    /**\n     * Dispatch an event object on the given target.\n     *\n     * It is normally better to use {@link #fireEvent} because it uses\n     * the event pooling and is quite handy otherwise as well. After dispatching\n     * the event object will be pooled for later reuse or disposed.\n     *\n     * @param target {Object} Any valid event target\n     * @param event {qx.event.type.Event} The event object to dispatch. The event\n     *       object must be obtained using {@link #createEvent} and initialized\n     *       using {@link qx.event.type.Event#init}.\n     * @return {Boolean|qx.Promise} whether the event default was prevented or not.\n     *     Returns true, when the event was NOT prevented.\n     */\n    dispatchEvent(target, event) {\n      return this.getManager(target).dispatchEvent(target, event);\n    },\n\n    /**\n     * Create an event object and dispatch it on the given target.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {Event} the event\n     * @see #createEvent\n     */\n    __fireEvent(target, type, clazz, args) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (arguments.length > 2 && clazz === undefined && args !== undefined) {\n          throw new Error(\n            \"Create event of type \" +\n              type +\n              \" with undefined class. Please use null to explicit fallback to default event type!\"\n          );\n        }\n\n        var msg =\n          \"Could not fire event '\" +\n          type +\n          \"' on target '\" +\n          (target ? target.classname : \"undefined\") +\n          \"': \";\n\n        qx.core.Assert.assertNotUndefined(\n          target,\n          msg + \"Invalid event target.\"\n        );\n\n        qx.core.Assert.assertNotNull(target, msg + \"Invalid event target.\");\n      }\n\n      var evt = this.createEvent(type, clazz || null, args);\n      this.getManager(target).dispatchEvent(target, evt);\n      return evt;\n    },\n\n    /**\n     * Create an event object and dispatch it on the given target.\n     *\n     * Note about Promises in v6.0: this method has changed to return either a boolean (true if the\n     * event was prevented) or a promise which will evaluate to the same thing; this is\n     * because events are now asynchronous and preventDefault is inherently synchronous.\n     * However, although this changing in the return type is conspicuous it does not necessarily\n     * introduce a backwards compatibility issue because the \"truthy\" nature of the return\n     * is preserved.  Code which needs to take care of asynchronous issues will need to change,\n     * but that was necessary anyway, and it is rare to use the return value of this method (only\n     * one class in Qooxdoo used it).\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {Boolean|qx.Promise} whether the event default was prevented or not.\n     *     Returns true, when the event was NOT prevented.\n     * @see #createEvent\n     */\n    fireEvent(target, type, clazz, args) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (arguments.length > 2 && clazz === undefined && args !== undefined) {\n          throw new Error(\n            \"Create event of type \" +\n              type +\n              \" with undefined class. Please use null to explicit fallback to default event type!\"\n          );\n        }\n\n        var msg =\n          \"Could not fire event '\" +\n          type +\n          \"' on target '\" +\n          (target ? target.classname : \"undefined\") +\n          \"': \";\n\n        qx.core.Assert.assertNotUndefined(\n          target,\n          msg + \"Invalid event target.\"\n        );\n\n        qx.core.Assert.assertNotNull(target, msg + \"Invalid event target.\");\n      }\n\n      var evt = this.createEvent(type, clazz || null, args);\n      var tracker = {};\n      var self = this;\n      qx.event.Utils.then(tracker, function () {\n        return self.getManager(target).dispatchEvent(target, evt);\n      });\n      return qx.event.Utils.then(tracker, function () {\n        return !evt.getDefaultPrevented();\n      });\n    },\n\n    /**\n     * Create an event object and dispatch it on the given target; equivalent to fireEvent, except that it\n     * always returns a promise\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {qx.Promise} a promise aggregated from the event handlers;\n     * \tif the default was prevented, the promise is rejected\n     * @see #createEvent\n     */\n    fireEventAsync(target, type, clazz, args) {\n      if (qx.core.Environment.get(\"qx.promise\")) {\n        return qx.Promise.resolve(this.fireEvent(target, type, clazz, args));\n      } else {\n        throw new Error(\n          this.classname +\n            \".fireEventAsync not supported because qx.promise==false\"\n        );\n      }\n    },\n\n    /**\n     * Create an event object and dispatch it on the given target.\n     * The event dispatched with this method does never bubble! Use only if you\n     * are sure that bubbling is not required.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {Event} the event\n     * @see #createEvent\n     */\n    __fireNonBubblingEvent(target, type, clazz, args) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (arguments.length > 2 && clazz === undefined && args !== undefined) {\n          throw new Error(\n            \"Create event of type \" +\n              type +\n              \" with undefined class. Please use null to explicit fallback to default event type!\"\n          );\n        }\n      }\n\n      var mgr = this.getManager(target);\n      if (!mgr.hasListener(target, type, false)) {\n        return null;\n      }\n\n      var evt = this.createEvent(type, clazz || null, args);\n      mgr.dispatchEvent(target, evt);\n      return evt;\n    },\n\n    /**\n     * Create an event object and dispatch it on the given target.\n     * The event dispatched with this method does never bubble! Use only if you\n     * are sure that bubbling is not required.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {Boolean} whether the event default was prevented or not.\n     *     Returns true, when the event was NOT prevented.\n     * @see #createEvent\n     */\n    fireNonBubblingEvent(target, type, clazz, args) {\n      var evt = this.__fireNonBubblingEvent.apply(this, arguments);\n      if (evt === null) {\n        return true;\n      }\n      return !evt.getDefaultPrevented();\n    },\n\n    /**\n     * Create an event object and dispatch it on the given target.\n     * The event dispatched with this method does never bubble! Use only if you\n     * are sure that bubbling is not required.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {qx.Promise} a promise aggregated from the event handlers;\n     * \tif the default was prevented, the promise is rejected\n     * @see #createEvent\n     */\n    fireNonBubblingEventAsync: qx.core.Environment.select(\"qx.promise\", {\n      true(target, type, clazz, args) {\n        var evt = this.__fireNonBubblingEvent.apply(this, arguments);\n        if (evt === null) {\n          return qx.Promise.resolve(true);\n        }\n        return evt.promise();\n      },\n      false() {\n        throw new Error(\n          this.classname +\n            \".fireNonBubblingEventAsync not supported because qx.promise==false\"\n        );\n      }\n    }),\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT HANDLER/DISPATCHER PRIORITY\n    ---------------------------------------------------------------------------\n    */\n\n    /** @type {Integer} Highest priority. Used by handlers and dispatchers. */\n    PRIORITY_FIRST: -32000,\n\n    /** @type {Integer} Default priority. Used by handlers and dispatchers. */\n    PRIORITY_NORMAL: 0,\n\n    /** @type {Integer} Lowest priority. Used by handlers and dispatchers. */\n    PRIORITY_LAST: 32000,\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT HANDLER REGISTRATION\n    ---------------------------------------------------------------------------\n    */\n\n    /** @type {Array} Contains all known event handlers */\n    __handlers: [],\n\n    /**\n     * Register an event handler.\n     *\n     * @param handler {qx.event.IEventHandler} Event handler to add\n     * @throws {Error} if the handler does not have the IEventHandler interface.\n     */\n    addHandler(handler) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert.assertInterface(\n          handler,\n          qx.event.IEventHandler,\n          \"Invalid event handler.\"\n        );\n      }\n\n      // Append to list\n      this.__handlers.push(handler);\n\n      // Re-sort list\n      this.__handlers.sort(function (a, b) {\n        return a.PRIORITY - b.PRIORITY;\n      });\n    },\n\n    /**\n     * Get a list of registered event handlers.\n     *\n     * @return {qx.event.IEventHandler[]} registered event handlers\n     */\n    getHandlers() {\n      return this.__handlers;\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT DISPATCHER REGISTRATION\n    ---------------------------------------------------------------------------\n    */\n\n    /** @type {Array} Contains all known event dispatchers */\n    __dispatchers: [],\n\n    /**\n     * Register an event dispatcher.\n     *\n     * @param dispatcher {qx.event.IEventDispatcher} Event dispatcher to add\n     * @param priority {Integer} One of\n     * {@link qx.event.Registration#PRIORITY_FIRST},\n     * {@link qx.event.Registration#PRIORITY_NORMAL}\n     *       or {@link qx.event.Registration#PRIORITY_LAST}.\n     * @throws {Error} if the dispatcher does not have the IEventHandler interface.\n     */\n    addDispatcher(dispatcher, priority) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert.assertInterface(\n          dispatcher,\n          qx.event.IEventDispatcher,\n          \"Invalid event dispatcher!\"\n        );\n      }\n\n      // Append to list\n      this.__dispatchers.push(dispatcher);\n\n      // Re-sort list\n      this.__dispatchers.sort(function (a, b) {\n        return a.PRIORITY - b.PRIORITY;\n      });\n    },\n\n    /**\n     * Get a list of registered event dispatchers.\n     *\n     * @return {qx.event.IEventDispatcher[]} all registered event dispatcher\n     */\n    getDispatchers() {\n      return this.__dispatchers;\n    }\n  }\n});\n"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC;;EAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAH,EAAE,CAACI,KAAH,CAASC,MAAT,CAAgB,uBAAhB,EAAyC;IACvC;AACF;AACA;AACA;AACA;IAEEC,OAAO,EAAE;MACP;AACJ;AACA;AACA;MACIC,SAAU,EAAE,EALL;;MAOP;AACJ;AACA;AACA;AACA;AACA;AACA;MACIC,UAdO,sBAcIC,MAdJ,EAcY;QACjB,IAAIA,MAAM,IAAI,IAAd,EAAoB;UASlBA,MAAM,GAAGC,MAAT;QACD,CAVD,MAUO,IAAID,MAAM,CAACE,QAAX,EAAqB;UAC1BF,MAAM,GAAGT,EAAE,CAACY,GAAH,CAAOC,IAAP,CAAYC,SAAZ,CAAsBL,MAAtB,CAAT;QACD,CAFM,MAEA,IAAI,CAACT,EAAE,CAACY,GAAH,CAAOC,IAAP,CAAYE,QAAZ,CAAqBN,MAArB,CAAL,EAAmC;UACxCA,MAAM,GAAGC,MAAT;QACD;;QAED,IAAIM,IAAI,GAAGP,MAAM,CAACQ,MAAP,IAAiBjB,EAAE,CAACkB,IAAH,CAAQC,cAAR,CAAuBC,UAAvB,CAAkCX,MAAlC,CAA5B;QACA,IAAIY,OAAO,GAAG,KAAKd,SAAL,CAAgBS,IAAhB,CAAd;;QAEA,IAAI,CAACK,OAAL,EAAc;UACZA,OAAO,GAAG,IAAIrB,EAAE,CAACsB,KAAH,CAASC,OAAb,CAAqBd,MAArB,EAA6B,IAA7B,CAAV;UACA,KAAKF,SAAL,CAAgBS,IAAhB,IAAwBK,OAAxB;QACD;;QAED,OAAOA,OAAP;MACD,CAxCM;;MA0CP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;MACIG,aAlDO,yBAkDOC,GAlDP,EAkDY;QACjB,IAAIC,EAAE,GAAGD,GAAG,CAACE,WAAJ,EAAT;QACA,OAAO,KAAKpB,SAAL,CAAgBmB,EAAhB,CAAP;MACD,CArDM;;MAuDP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,WA1EO,uBA0EKnB,MA1EL,EA0EaoB,IA1Eb,EA0EmBC,QA1EnB,EA0E6BC,IA1E7B,EA0EmCC,OA1EnC,EA0E4C;QACjD,OAAO,KAAKxB,UAAL,CAAgBC,MAAhB,EAAwBmB,WAAxB,CACLnB,MADK,EAELoB,IAFK,EAGLC,QAHK,EAILC,IAJK,EAKLC,OALK,CAAP;MAOD,CAlFM;;MAoFP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,cApGO,0BAoGQxB,MApGR,EAoGgBoB,IApGhB,EAoGsBC,QApGtB,EAoGgCC,IApGhC,EAoGsCC,OApGtC,EAoG+C;QACpD,OAAO,KAAKxB,UAAL,CAAgBC,MAAhB,EAAwBwB,cAAxB,CACLxB,MADK,EAELoB,IAFK,EAGLC,QAHK,EAILC,IAJK,EAKLC,OALK,CAAP;MAOD,CA5GM;;MA8GP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIE,kBAvHO,8BAuHYzB,MAvHZ,EAuHoBiB,EAvHpB,EAuHwB;QAC7B,OAAO,KAAKlB,UAAL,CAAgBC,MAAhB,EAAwByB,kBAAxB,CAA2CzB,MAA3C,EAAmDiB,EAAnD,CAAP;MACD,CAzHM;;MA2HP;AACJ;AACA;AACA;AACA;AACA;MACIS,kBAjIO,8BAiIY1B,MAjIZ,EAiIoB;QACzB,OAAO,KAAKD,UAAL,CAAgBC,MAAhB,EAAwB0B,kBAAxB,CAA2C1B,MAA3C,CAAP;MACD,CAnIM;;MAqIP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;MACI2B,kBA7IO,8BA6IY3B,MA7IZ,EA6IoB;QACzB,IAAI4B,SAAS,GAAG5B,MAAM,CAACQ,MAAvB;;QACA,IAAIoB,SAAJ,EAAe;UACb,KAAK7B,UAAL,CAAgBC,MAAhB,EAAwB2B,kBAAxB,CAA2CC,SAA3C;QACD;MACF,CAlJM;;MAoJP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,WA9JO,uBA8JK7B,MA9JL,EA8JaoB,IA9Jb,EA8JmBG,OA9JnB,EA8J4B;QACjC,OAAO,KAAKxB,UAAL,CAAgBC,MAAhB,EAAwB6B,WAAxB,CAAoC7B,MAApC,EAA4CoB,IAA5C,EAAkDG,OAAlD,CAAP;MACD,CAhKM;;MAkKP;AACJ;AACA;AACA;AACA;AACA;AACA;MACIO,kBAzKO,8BAyKY9B,MAzKZ,EAyKoB;QACzB,OAAO,KAAKD,UAAL,CAAgBC,MAAhB,EAAwB8B,kBAAxB,CAA2C9B,MAA3C,CAAP;MACD,CA3KM;;MA6KP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACI+B,WAxLO,uBAwLKX,IAxLL,EAwLWY,KAxLX,EAwLkBC,IAxLlB,EAwLwB;QAW7B;QACA,IAAID,KAAK,IAAI,IAAb,EAAmB;UACjBA,KAAK,GAAGzC,EAAE,CAACsB,KAAH,CAASO,IAAT,CAAcc,KAAtB;QACD;;QAED,IAAIC,GAAG,GAAG5C,EAAE,CAACsB,KAAH,CAASuB,IAAT,CAAcC,WAAd,GAA4BC,SAA5B,CAAsCN,KAAtC,CAAV,CAhB6B,CAkB7B;;QACAC,IAAI,GAAGE,GAAG,CAACI,IAAJ,CAASC,KAAT,CAAeL,GAAf,EAAoBF,IAApB,CAAH,GAA+BE,GAAG,CAACI,IAAJ,EAAnC,CAnB6B,CAqB7B;QACA;QACA;;QACA,IAAInB,IAAJ,EAAU;UACRe,GAAG,CAACM,OAAJ,CAAYrB,IAAZ;QACD;;QAED,OAAOe,GAAP;MACD,CArNM;;MAuNP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIO,aArOO,yBAqOO1C,MArOP,EAqOea,KArOf,EAqOsB;QAC3B,OAAO,KAAKd,UAAL,CAAgBC,MAAhB,EAAwB0C,aAAxB,CAAsC1C,MAAtC,EAA8Ca,KAA9C,CAAP;MACD,CAvOM;;MAyOP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACI8B,SApPO,qBAoPK3C,MApPL,EAoPaoB,IApPb,EAoPmBY,KApPnB,EAoP0BC,IApP1B,EAoPgC;QAyBrC,IAAIW,GAAG,GAAG,KAAKb,WAAL,CAAiBX,IAAjB,EAAuBY,KAAK,IAAI,IAAhC,EAAsCC,IAAtC,CAAV;QACA,KAAKlC,UAAL,CAAgBC,MAAhB,EAAwB0C,aAAxB,CAAsC1C,MAAtC,EAA8C4C,GAA9C;QACA,OAAOA,GAAP;MACD,CAhRM;;MAkRP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,SAvSO,qBAuSG7C,MAvSH,EAuSWoB,IAvSX,EAuSiBY,KAvSjB,EAuSwBC,IAvSxB,EAuS8B;QAyBnC,IAAIW,GAAG,GAAG,KAAKb,WAAL,CAAiBX,IAAjB,EAAuBY,KAAK,IAAI,IAAhC,EAAsCC,IAAtC,CAAV;QACA,IAAIa,OAAO,GAAG,EAAd;QACA,IAAIxB,IAAI,GAAG,IAAX;QACA/B,EAAE,CAACsB,KAAH,CAASkC,KAAT,CAAeC,IAAf,CAAoBF,OAApB,EAA6B,YAAY;UACvC,OAAOxB,IAAI,CAACvB,UAAL,CAAgBC,MAAhB,EAAwB0C,aAAxB,CAAsC1C,MAAtC,EAA8C4C,GAA9C,CAAP;QACD,CAFD;QAGA,OAAOrD,EAAE,CAACsB,KAAH,CAASkC,KAAT,CAAeC,IAAf,CAAoBF,OAApB,EAA6B,YAAY;UAC9C,OAAO,CAACF,GAAG,CAACK,mBAAJ,EAAR;QACD,CAFM,CAAP;MAGD,CAzUM;;MA2UP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,cAxVO,0BAwVQlD,MAxVR,EAwVgBoB,IAxVhB,EAwVsBY,KAxVtB,EAwV6BC,IAxV7B,EAwVmC;QACxC,IAAI1C,EAAE,CAACkB,IAAH,CAAQ0C,WAAR,CAAoBC,GAApB,CAAwB,YAAxB,CAAJ,EAA2C;UACzC,OAAO7D,EAAE,CAAC8D,OAAH,CAAWC,OAAX,CAAmB,KAAKT,SAAL,CAAe7C,MAAf,EAAuBoB,IAAvB,EAA6BY,KAA7B,EAAoCC,IAApC,CAAnB,CAAP;QACD,CAFD,MAEO;UACL,MAAM,IAAIsB,KAAJ,CACJ,KAAKC,SAAL,GACE,yDAFE,CAAN;QAID;MACF,CAjWM;;MAmWP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,SAhXO,qBAgXgBzD,MAhXhB,EAgXwBoB,IAhXxB,EAgX8BY,KAhX9B,EAgXqCC,IAhXrC,EAgX2C;QAWhD,IAAIjB,GAAG,GAAG,KAAKjB,UAAL,CAAgBC,MAAhB,CAAV;;QACA,IAAI,CAACgB,GAAG,CAACa,WAAJ,CAAgB7B,MAAhB,EAAwBoB,IAAxB,EAA8B,KAA9B,CAAL,EAA2C;UACzC,OAAO,IAAP;QACD;;QAED,IAAIwB,GAAG,GAAG,KAAKb,WAAL,CAAiBX,IAAjB,EAAuBY,KAAK,IAAI,IAAhC,EAAsCC,IAAtC,CAAV;QACAjB,GAAG,CAAC0B,aAAJ,CAAkB1C,MAAlB,EAA0B4C,GAA1B;QACA,OAAOA,GAAP;MACD,CAnYM;;MAqYP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIc,oBAnZO,gCAmZc1D,MAnZd,EAmZsBoB,IAnZtB,EAmZ4BY,KAnZ5B,EAmZmCC,IAnZnC,EAmZyC;QAC9C,IAAIW,GAAG,GAAG,KAAKa,SAAL,CAA4BjB,KAA5B,CAAkC,IAAlC,EAAwCmB,SAAxC,CAAV;;QACA,IAAIf,GAAG,KAAK,IAAZ,EAAkB;UAChB,OAAO,IAAP;QACD;;QACD,OAAO,CAACA,GAAG,CAACK,mBAAJ,EAAR;MACD,CAzZM;;MA2ZP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIW,yBAAyB,EAAErE,EAAE,CAACkB,IAAH,CAAQ0C,WAAR,CAAoBU,MAApB,CAA2B,YAA3B,EAAyC;QAAA,uBAC7D7D,MAD6D,EACrDoB,IADqD,EAC/CY,KAD+C,EACxCC,IADwC,EAClC;UAC9B,IAAIW,GAAG,GAAG,KAAKa,SAAL,CAA4BjB,KAA5B,CAAkC,IAAlC,EAAwCmB,SAAxC,CAAV;;UACA,IAAIf,GAAG,KAAK,IAAZ,EAAkB;YAChB,OAAOrD,EAAE,CAAC8D,OAAH,CAAWC,OAAX,CAAmB,IAAnB,CAAP;UACD;;UACD,OAAOV,GAAG,CAACkB,OAAJ,EAAP;QACD,CAPiE;QAAA,2BAQ1D;UACN,MAAM,IAAIP,KAAJ,CACJ,KAAKC,SAAL,GACE,oEAFE,CAAN;QAID;MAbiE,CAAzC,CAzapB;;MAybP;AACJ;AACA;AACA;AACA;;MAEI;MACAO,cAAc,EAAE,CAAC,KAhcV;;MAkcP;MACAC,eAAe,EAAE,CAncV;;MAqcP;MACAC,aAAa,EAAE,KAtcR;;MAwcP;AACJ;AACA;AACA;AACA;;MAEI;MACAC,SAAU,EAAE,EA/cL;;MAidP;AACJ;AACA;AACA;AACA;AACA;MACIC,UAvdO,sBAudIC,OAvdJ,EAuda;QASlB;QACA,KAAKF,SAAL,CAAgBG,IAAhB,CAAqBD,OAArB,EAVkB,CAYlB;;;QACA,KAAKF,SAAL,CAAgBI,IAAhB,CAAqB,UAAUC,CAAV,EAAaC,CAAb,EAAgB;UACnC,OAAOD,CAAC,CAACE,QAAF,GAAaD,CAAC,CAACC,QAAtB;QACD,CAFD;MAGD,CAveM;;MAyeP;AACJ;AACA;AACA;AACA;MACIC,WA9eO,yBA8eO;QACZ,OAAO,KAAKR,SAAZ;MACD,CAhfM;;MAkfP;AACJ;AACA;AACA;AACA;;MAEI;MACAS,SAAa,EAAE,EAzfR;;MA2fP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACIC,aArgBO,yBAqgBOC,UArgBP,EAqgBmBC,QArgBnB,EAqgB6B;QASlC;QACA,KAAKH,SAAL,CAAmBN,IAAnB,CAAwBQ,UAAxB,EAVkC,CAYlC;;;QACA,KAAKF,SAAL,CAAmBL,IAAnB,CAAwB,UAAUC,CAAV,EAAaC,CAAb,EAAgB;UACtC,OAAOD,CAAC,CAACE,QAAF,GAAaD,CAAC,CAACC,QAAtB;QACD,CAFD;MAGD,CArhBM;;MAuhBP;AACJ;AACA;AACA;AACA;MACIM,cA5hBO,4BA4hBU;QACf,OAAO,KAAKJ,SAAZ;MACD;IA9hBM;EAP8B,CAAzC;EA7BApF,EAAE,CAACsB,KAAH,CAASmE,YAAT,CAAsBtF,aAAtB,GAAsCA,aAAtC"
}