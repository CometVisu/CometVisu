{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__logError",
    "__fail",
    "__P_164_1",
    "comment",
    "msgvarargs",
    "msg",
    "i",
    "l",
    "arguments",
    "length",
    "__toString",
    "undefined",
    "fullComment",
    "errorMsg",
    "Class",
    "isDefined",
    "err",
    "core",
    "AssertionError",
    "error",
    "getStackTrace",
    "Error",
    "__P_164_2",
    "value",
    "stringValue",
    "lang",
    "Type",
    "isArray",
    "Object",
    "toString",
    "Json",
    "stringify",
    "e",
    "assert",
    "condition",
    "fail",
    "compact",
    "assertTrue",
    "assertFalse",
    "assertEquals",
    "expected",
    "found",
    "assertNotEquals",
    "assertEqualsFloat",
    "assertNumber",
    "Number",
    "equals",
    "assertNotEqualsFloat",
    "assertIdentical",
    "assertNotIdentical",
    "assertNotUndefined",
    "assertUndefined",
    "assertNotNull",
    "assertNull",
    "assertJsonEquals",
    "assertMatch",
    "str",
    "re",
    "assertString",
    "isRegExp",
    "isString",
    "search",
    "assertArgumentsCount",
    "args",
    "minCount",
    "maxCount",
    "argCount",
    "assertEventFired",
    "obj",
    "event",
    "invokeFunc",
    "listenerFunc",
    "called",
    "listener",
    "call",
    "id",
    "addListener",
    "ex",
    "removeListenerById",
    "assertEventNotFired",
    "assertException",
    "callback",
    "exception",
    "assertInArray",
    "array",
    "indexOf",
    "assertNotInArray",
    "String",
    "format",
    "assertArrayEquals",
    "assertArray",
    "join",
    "assertKeyInMap",
    "map",
    "assertFunction",
    "isFunction",
    "assertFunctionOrAsyncFunction",
    "isFunctionOrAsyncFunction",
    "assertBoolean",
    "isBoolean",
    "isNumber",
    "isFinite",
    "assertPositiveNumber",
    "assertInteger",
    "assertPositiveInteger",
    "assertInRange",
    "min",
    "max",
    "assertObject",
    "isObject",
    "_typeof",
    "assertMap",
    "assertRegExp",
    "assertType",
    "type",
    "assertInstance",
    "clazz",
    "className",
    "classname",
    "assertInterface",
    "iface",
    "implementsInterface",
    "assertCssColor",
    "ColorUtil",
    "getByName",
    "expectedRgb",
    "stringToRgb",
    "valueRgb",
    "assertElement",
    "nodeType",
    "assertQxObject",
    "__isQxInstance",
    "assertQxWidget",
    "__P_164_3",
    "object",
    "constructor",
    "superclass",
    "Assert"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/core/Assert.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\r\n\r\n   qooxdoo - the new era of web development\r\n\r\n   http://qooxdoo.org\r\n\r\n   Copyright:\r\n     2007-2008 1&1 Internet AG, Germany, http://www.1und1.de\r\n\r\n   License:\r\n     MIT: https://opensource.org/licenses/MIT\r\n     See the LICENSE file in the project's top-level directory for details.\r\n\r\n   Authors:\r\n     * Fabian Jakobs (fjakobs)\r\n\r\n************************************************************************ */\r\n\r\n/**\r\n * A collection of assertions.\r\n *\r\n * These methods can be used to assert incoming parameters, return values, ...\r\n * If an assertion fails an {@link AssertionError} is thrown.\r\n *\r\n * Assertions are used in unit tests as well.\r\n *\r\n * @require(qx.lang.Type)\r\n * @ignore(qx.Class.*)\r\n */\r\nqx.Bootstrap.define(\"qx.core.Assert\", {\r\n  statics: {\r\n    __logError: true,\r\n\r\n    /**\r\n     * Assert that the condition evaluates to <code>true</code>. An\r\n     * {@link AssertionError} is thrown if otherwise.\r\n     *\r\n     * @param comment {String} Message to be shown if the assertion fails. This\r\n     *    message is provided by the user.\r\n     * @param msgvarargs {var} any number of parts of a message to show if assertion\r\n     *                         triggers. Each will be converted to a string and all\r\n     *                         parts will be concatenated. E. g. instead of\r\n     *                         \"Got invalid value \" + this.__toString(val) + \"!!!!!\"\r\n     *                         use\r\n     *                         \"Got invalid value \", val, \"!!!!!\"\r\n     *                         (much better performance)\r\n     *\r\n     */\r\n    __fail(comment, msgvarargs) {\r\n      // Build up message from message varargs. It's not really important\r\n      // how long this takes as it is done only when assertion is triggered\r\n      var msg = \"\";\r\n      for (var i = 1, l = arguments.length; i < l; i++) {\r\n        msg =\r\n          msg +\r\n          this.__toString(\r\n            arguments[i] === undefined ? \"'undefined'\" : arguments[i]\r\n          );\r\n      }\r\n\r\n      var fullComment = \"\";\r\n      if (msg) {\r\n        fullComment = comment + \": \" + msg;\r\n      } else {\r\n        fullComment = comment;\r\n      }\r\n      var errorMsg = \"Assertion error! \" + fullComment;\r\n\r\n      if (qx.Class && qx.Class.isDefined(\"qx.core.AssertionError\")) {\r\n        var err = new qx.core.AssertionError(comment, msg);\r\n        if (this.__logError) {\r\n          qx.Bootstrap.error(\r\n            errorMsg + \"\\n Stack trace: \\n\" + err.getStackTrace()\r\n          );\r\n        }\r\n        throw err;\r\n      } else {\r\n        if (this.__logError) {\r\n          qx.Bootstrap.error(errorMsg);\r\n        }\r\n        throw new Error(errorMsg);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Convert an unknown value to a string to display in error messages\r\n     *\r\n     * @param value {var} any value\r\n     * @return {String} a string representation of the value\r\n     */\r\n    __toString(value) {\r\n      var stringValue;\r\n\r\n      if (value === null) {\r\n        stringValue = \"null\";\r\n      } else if (qx.lang.Type.isArray(value) && value.length > 10) {\r\n        stringValue = \"Array[\" + value.length + \"]\";\r\n      } else if (value instanceof Object && value.toString == null) {\r\n        stringValue = qx.lang.Json.stringify(value, null, 2);\r\n      } else {\r\n        try {\r\n          stringValue = value.toString();\r\n        } catch (e) {\r\n          stringValue = \"\";\r\n        }\r\n      }\r\n      return stringValue;\r\n    },\r\n\r\n    /**\r\n     * Assert that the condition evaluates to <code>true</code>.\r\n     *\r\n     * @param condition {var} Condition to check for. Must evaluate to\r\n     *    <code>true</code>.\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assert(condition, msg) {\r\n      condition == true || this.__fail(msg || \"\", \"Called assert with 'false'\");\r\n    },\r\n\r\n    /**\r\n     * Raise an {@link AssertionError}.\r\n     *\r\n     * @param msg {String} Message to be shown if the assertion fails.\r\n     * @param compact {Boolean?false} Show less verbose message. Default: false.\r\n     */\r\n    fail(msg, compact) {\r\n      var msgvarargs = compact ? \"\" : \"Called fail().\";\r\n      this.__fail(msg || \"\", msgvarargs);\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is <code>true</code> (Identity check).\r\n     *\r\n     * @param value {Boolean} Condition to check for. Must be identical to\r\n     *    <code>true</code>.\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertTrue(value, msg) {\r\n      value === true ||\r\n        this.__fail(msg || \"\", \"Called assertTrue with '\", value, \"'\");\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is <code>false</code> (Identity check).\r\n     *\r\n     * @param value {Boolean} Condition to check for. Must be identical to\r\n     *    <code>false</code>.\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertFalse(value, msg) {\r\n      value === false ||\r\n        this.__fail(msg || \"\", \"Called assertFalse with '\", value, \"'\");\r\n    },\r\n\r\n    /**\r\n     * Assert that both values are equal. (Uses the equality operator\r\n     * <code>==</code>.)\r\n     *\r\n     * @param expected {var} Reference value\r\n     * @param found {var} found value\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertEquals(expected, found, msg) {\r\n      expected == found ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected '\",\r\n          expected,\r\n          \"' but found '\",\r\n          found,\r\n          \"'!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that both values are not equal. (Uses the not equality operator\r\n     * <code>!=</code>.)\r\n     *\r\n     * @param expected {var} Reference value\r\n     * @param found {var} found value\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertNotEquals(expected, found, msg) {\r\n      expected != found ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected '\",\r\n          expected,\r\n          \"' to be not equal with '\",\r\n          found,\r\n          \"'!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that both float values are equal. This might be needed because\r\n     * of the natural floating point inaccuracy of computers.\r\n     *\r\n     * @param expected {Float} Reference value\r\n     * @param found {Float} Found value\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertEqualsFloat(expected, found, msg) {\r\n      this.assertNumber(expected);\r\n      this.assertNumber(found);\r\n\r\n      qx.lang.Number.equals(expected, found) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected '\",\r\n          expected,\r\n          \"' to be equal with '\",\r\n          found,\r\n          \"'!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that both float values are not equal. This might be needed\r\n     * because of the natural floating point inaccuracy of computers.\r\n     *\r\n     * @param expected {Float} Reference value\r\n     * @param found {Float} Found value\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertNotEqualsFloat(expected, found, msg) {\r\n      this.assertNumber(expected);\r\n      this.assertNumber(found);\r\n\r\n      !qx.lang.Number.equals(expected, found) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected '\",\r\n          expected,\r\n          \"' to be not equal with '\",\r\n          found,\r\n          \"'!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that both values are identical. (Uses the identity operator\r\n     * <code>===</code>.)\r\n     *\r\n     * @param expected {var} Reference value\r\n     * @param found {var} found value\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertIdentical(expected, found, msg) {\r\n      expected === found ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected '\",\r\n          expected,\r\n          \"' (identical) but found '\",\r\n          found,\r\n          \"'!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that both values are not identical. (Uses the not identity operator\r\n     * <code>!==</code>.)\r\n     *\r\n     * @param expected {var} Reference value\r\n     * @param found {var} found value\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertNotIdentical(expected, found, msg) {\r\n      expected !== found ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected '\",\r\n          expected,\r\n          \"' to be not identical with '\",\r\n          found,\r\n          \"'!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is not <code>undefined</code>.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertNotUndefined(value, msg) {\r\n      value !== undefined ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value not to be undefined but found undefined!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is <code>undefined</code>.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertUndefined(value, msg) {\r\n      value === undefined ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be undefined but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is not <code>null</code>.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertNotNull(value, msg) {\r\n      value !== null ||\r\n        this.__fail(msg || \"\", \"Expected value not to be null but found null!\");\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is <code>null</code>.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertNull(value, msg) {\r\n      value === null ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be null but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the first two arguments are equal, when serialized into\r\n     * JSON.\r\n     *\r\n     * @param expected {var} The the expected value\r\n     * @param found {var} The found value\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertJsonEquals(expected, found, msg) {\r\n      this.assertEquals(\r\n        qx.lang.Json.stringify(expected),\r\n        qx.lang.Json.stringify(found),\r\n        msg\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Assert that the given string matches the regular expression\r\n     *\r\n     * @param str {String} String, which should match the regular expression\r\n     * @param re {String|RegExp} Regular expression to match\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertMatch(str, re, msg) {\r\n      this.assertString(str);\r\n      this.assert(\r\n        qx.lang.Type.isRegExp(re) || qx.lang.Type.isString(re),\r\n        \"The parameter 're' must be a string or a regular expression.\"\r\n      );\r\n\r\n      str.search(re) >= 0 ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"The String '\",\r\n          str,\r\n          \"' does not match the regular expression '\",\r\n          re.toString(),\r\n          \"'!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the number of arguments is within the given range\r\n     *\r\n     * @param args {arguments} The <code>arguments<code> variable of a function\r\n     * @param minCount {Integer} Minimal number of arguments\r\n     * @param maxCount {Integer} Maximum number of arguments\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertArgumentsCount(args, minCount, maxCount, msg) {\r\n      var argCount = args.length;\r\n      (argCount >= minCount && argCount <= maxCount) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Wrong number of arguments given. Expected '\",\r\n          minCount,\r\n          \"' to '\",\r\n          maxCount,\r\n          \"' arguments but found '\",\r\n          argCount,\r\n          \"' arguments.\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that an event is fired.\r\n     *\r\n     * @param obj {Object} The object on which the event should be fired.\r\n     * @param event {String} The event which should be fired.\r\n     * @param invokeFunc {Function} The function which will be invoked and which\r\n     *   fires the event.\r\n     * @param listenerFunc {Function?null} The function which will be invoked in the\r\n     *   listener. The function receives one parameter which is the event.\r\n     * @param msg {String?\"\"} Message to be shows if the assertion fails.\r\n     */\r\n    assertEventFired(obj, event, invokeFunc, listenerFunc, msg) {\r\n      var called = false;\r\n      var listener = function (e) {\r\n        if (listenerFunc) {\r\n          listenerFunc.call(obj, e);\r\n        }\r\n        called = true;\r\n      };\r\n\r\n      var id;\r\n      try {\r\n        id = obj.addListener(event, listener, obj);\r\n        invokeFunc.call(obj);\r\n      } catch (ex) {\r\n        throw ex;\r\n      } finally {\r\n        try {\r\n          obj.removeListenerById(id);\r\n        } catch (ex) {\r\n          /* ignore */\r\n        }\r\n      }\r\n\r\n      called === true ||\r\n        this.__fail(msg || \"\", \"Event (\", event, \") not fired.\");\r\n    },\r\n\r\n    /**\r\n     * Assert that an event is not fired.\r\n     *\r\n     * @param obj {Object} The object on which the event should be fired.\r\n     * @param event {String} The event which should be fired.\r\n     * @param invokeFunc {Function} The function which will be invoked and which\r\n     *   should not fire the event.\r\n     * @param msg {String?} Message to be shows if the assertion fails.\r\n     */\r\n    assertEventNotFired(obj, event, invokeFunc, msg) {\r\n      var called = false;\r\n      var listener = function (e) {\r\n        called = true;\r\n      };\r\n      var id = obj.addListener(event, listener, obj);\r\n\r\n      invokeFunc.call();\r\n      called === false ||\r\n        this.__fail(msg || \"\", \"Event (\", event, \") was fired.\");\r\n\r\n      obj.removeListenerById(id);\r\n    },\r\n\r\n    /**\r\n     * Asserts that the callback raises a matching exception.\r\n     *\r\n     * @param callback {Function} function to check\r\n     * @param exception {Error?Error} Expected constructor of the exception.\r\n     *   The assertion fails if the raised exception is not an instance of the\r\n     *   parameter.\r\n     * @param re {String|RegExp} The assertion fails if the error message does\r\n     *   not match this parameter\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertException(callback, exception, re, msg) {\r\n      var exception = exception || Error;\r\n      var error;\r\n\r\n      try {\r\n        this.__logError = false;\r\n        callback();\r\n      } catch (ex) {\r\n        error = ex;\r\n      } finally {\r\n        this.__logError = true;\r\n      }\r\n\r\n      if (error == null) {\r\n        this.__fail(msg || \"\", \"The function did not raise an exception!\");\r\n      }\r\n\r\n      error instanceof exception ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"The raised exception does not have the expected type! \",\r\n          exception,\r\n          \" != \",\r\n          error\r\n        );\r\n\r\n      if (re) {\r\n        this.assertMatch(error.toString(), re, msg);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is an item in the given array.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param array {Array} List of valid values\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertInArray(value, array, msg) {\r\n      array.indexOf(value) !== -1 ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"The value '\",\r\n          value,\r\n          \"' must have any of the values defined in the array '\",\r\n          array,\r\n          \"'\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is NOT an item in the given array\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param array {Array} List of values\r\n     * @param msg {String?} Message to be shown if the assertion fails\r\n     */\r\n    assertNotInArray(value, array, msg) {\r\n      array.indexOf(value) === -1 ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          qx.lang.String.format(\r\n            \"The value '%1' must not have any of the values defined in the array '%2'\",\r\n            [value, array]\r\n          )\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that both array have identical array items.\r\n     *\r\n     * @param expected {Array} The expected array\r\n     * @param found {Array} The found array\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertArrayEquals(expected, found, msg) {\r\n      this.assertArray(expected, msg);\r\n      this.assertArray(found, msg);\r\n\r\n      msg =\r\n        msg ||\r\n        \"Expected [\" +\r\n          expected.join(\", \") +\r\n          \"], but found [\" +\r\n          found.join(\", \") +\r\n          \"]\";\r\n\r\n      if (expected.length !== found.length) {\r\n        this.fail(msg, true);\r\n      }\r\n\r\n      for (var i = 0; i < expected.length; i++) {\r\n        if (expected[i] !== found[i]) {\r\n          this.fail(msg, true);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is a key in the given map.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param map {Map} Map, where the keys represent the valid values\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertKeyInMap(value, map, msg) {\r\n      map[value] !== undefined ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"The value '\",\r\n          value,\r\n          \"' must must be a key of the map '\",\r\n          map,\r\n          \"'\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is a function.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertFunction(value, msg) {\r\n      qx.lang.Type.isFunction(value) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be typeof function but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is a function or an async function.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertFunctionOrAsyncFunction(value, msg) {\r\n      qx.lang.Type.isFunctionOrAsyncFunction(value) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be typeof function or typeof async function but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is a string.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertString(value, msg) {\r\n      qx.lang.Type.isString(value) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be a string but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is a boolean.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertBoolean(value, msg) {\r\n      qx.lang.Type.isBoolean(value) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be a boolean but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is a number.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertNumber(value, msg) {\r\n      (qx.lang.Type.isNumber(value) && isFinite(value)) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be a number but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is a number >= 0.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertPositiveNumber(value, msg) {\r\n      (qx.lang.Type.isNumber(value) && isFinite(value) && value >= 0) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be a number >= 0 but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is an integer.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertInteger(value, msg) {\r\n      (qx.lang.Type.isNumber(value) && isFinite(value) && value % 1 === 0) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be an integer but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is an integer >= 0.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertPositiveInteger(value, msg) {\r\n      var condition =\r\n        qx.lang.Type.isNumber(value) &&\r\n        isFinite(value) &&\r\n        value % 1 === 0 &&\r\n        value >= 0;\r\n\r\n      condition ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be an integer >= 0 but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is inside the given range.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param min {Number} lower bound\r\n     * @param max {Number} upper bound\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertInRange(value, min, max, msg) {\r\n      (value >= min && value <= max) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          qx.lang.String.format(\r\n            \"Expected value '%1' to be in the range '%2'..'%3'!\",\r\n            [value, min, max]\r\n          )\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is an object.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertObject(value, msg) {\r\n      var condition =\r\n        value !== null &&\r\n        (qx.lang.Type.isObject(value) || typeof value === \"object\");\r\n      condition ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be typeof object but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is an array.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertArray(value, msg) {\r\n      qx.lang.Type.isArray(value) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be an array but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is a map either created using <code>new Object</code>\r\n     * or by using the object literal notation <code>{ ... }</code>.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertMap(value, msg) {\r\n      qx.lang.Type.isObject(value) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be a map but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is a regular expression.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertRegExp(value, msg) {\r\n      qx.lang.Type.isRegExp(value) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be a regular expression but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value has the given type using the <code>typeof</code>\r\n     * operator. Because the type is not always what it is supposed to be it is\r\n     * better to use more explicit checks like {@link #assertString} or\r\n     * {@link #assertArray}.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param type {String} expected type of the value\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertType(value, type, msg) {\r\n      this.assertString(type, \"Invalid argument 'type'\");\r\n\r\n      typeof value === type ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be typeof '\",\r\n          type,\r\n          \"' but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is an instance of the given class.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param clazz {Class} The value must be an instance of this class\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertInstance(value, clazz, msg) {\r\n      var className = clazz.classname || clazz + \"\";\r\n\r\n      value instanceof clazz ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be instanceof '\",\r\n          className,\r\n          \"' but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value implements the given interface.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param iface {Class} The value must implement this interface\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertInterface(value, iface, msg) {\r\n      (qx.Class && qx.Class.implementsInterface(value, iface)) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected object '\",\r\n          value,\r\n          \"' to implement the interface '\",\r\n          iface,\r\n          \"'!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value represents the given CSS color value. This method\r\n     * parses the color strings and compares the RGB values. It is able to\r\n     * parse values supported by {@link qx.util.ColorUtil#stringToRgb}.\r\n     *\r\n     *  @param expected {String} The expected color\r\n     *  @param value {String} The value to check\r\n     *  @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertCssColor(expected, value, msg) {\r\n      var ColorUtil = qx.Class ? qx.Class.getByName(\"qx.util.ColorUtil\") : null;\r\n      if (!ColorUtil) {\r\n        throw new Error(\r\n          \"qx.util.ColorUtil not available! Your code must have a dependency on 'qx.util.ColorUtil'\"\r\n        );\r\n      }\r\n\r\n      var expectedRgb = ColorUtil.stringToRgb(expected);\r\n      try {\r\n        var valueRgb = ColorUtil.stringToRgb(value);\r\n      } catch (ex) {\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be the CSS color '\",\r\n          expected,\r\n          \"' (rgb(\",\r\n          expectedRgb.join(\",\"),\r\n          \")), but found value '\",\r\n          value,\r\n          \"', which cannot be converted to a CSS color!\"\r\n        );\r\n      }\r\n\r\n      var condition =\r\n        expectedRgb[0] == valueRgb[0] &&\r\n        expectedRgb[1] == valueRgb[1] &&\r\n        expectedRgb[2] == valueRgb[2];\r\n      condition ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be the CSS color '\",\r\n          expectedRgb,\r\n          \"' (rgb(\",\r\n          expectedRgb.join(\",\"),\r\n          \")), but found value '\",\r\n          value,\r\n          \"' (rgb(\",\r\n          valueRgb.join(\",\"),\r\n          \"))!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is a DOM element.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertElement(value, msg) {\r\n      // see qx.dom.Node.isElement\r\n      !!(value && value.nodeType === 1) ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be a DOM element but found  '\",\r\n          value,\r\n          \"'!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is an instance of {@link qx.core.Object}.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertQxObject(value, msg) {\r\n      this.__isQxInstance(value, \"qx.core.Object\") ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be a qooxdoo object but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Assert that the value is an instance of {@link qx.ui.core.Widget}.\r\n     *\r\n     * @param value {var} Value to check\r\n     * @param msg {String?} Message to be shown if the assertion fails.\r\n     */\r\n    assertQxWidget(value, msg) {\r\n      this.__isQxInstance(value, \"qx.ui.core.Widget\") ||\r\n        this.__fail(\r\n          msg || \"\",\r\n          \"Expected value to be a qooxdoo widget but found \",\r\n          value,\r\n          \"!\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Internal helper for checking the instance of a qooxdoo object using the\r\n     * classname.\r\n     *\r\n     * @param object {var} The object to check.\r\n     * @param classname {String} The classname of the class as string.\r\n     * @return {Boolean} <code>true</code> if the object is an instance of the\r\n     * class\r\n     */\r\n    __isQxInstance(object, classname) {\r\n      if (!object) {\r\n        return false;\r\n      }\r\n      var clazz = object.constructor;\r\n      while (clazz) {\r\n        if (clazz.classname === classname) {\r\n          return true;\r\n        }\r\n        clazz = clazz.superclass;\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n});\r\n"
  ],
  "mappings": "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"
}