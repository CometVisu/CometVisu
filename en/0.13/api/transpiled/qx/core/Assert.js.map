{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__logError",
    "__fail",
    "comment",
    "msgvarargs",
    "msg",
    "i",
    "l",
    "arguments",
    "length",
    "__toString",
    "undefined",
    "fullComment",
    "errorMsg",
    "Class",
    "isDefined",
    "err",
    "core",
    "AssertionError",
    "error",
    "getStackTrace",
    "Error",
    "value",
    "stringValue",
    "lang",
    "Type",
    "isArray",
    "Object",
    "toString",
    "Json",
    "stringify",
    "e",
    "assert",
    "condition",
    "fail",
    "compact",
    "assertTrue",
    "assertFalse",
    "assertEquals",
    "expected",
    "found",
    "assertNotEquals",
    "assertEqualsFloat",
    "assertNumber",
    "Number",
    "equals",
    "assertNotEqualsFloat",
    "assertIdentical",
    "assertNotIdentical",
    "assertNotUndefined",
    "assertUndefined",
    "assertNotNull",
    "assertNull",
    "assertJsonEquals",
    "assertMatch",
    "str",
    "re",
    "assertString",
    "isRegExp",
    "isString",
    "search",
    "assertArgumentsCount",
    "args",
    "minCount",
    "maxCount",
    "argCount",
    "assertEventFired",
    "obj",
    "event",
    "invokeFunc",
    "listenerFunc",
    "called",
    "listener",
    "call",
    "id",
    "addListener",
    "ex",
    "removeListenerById",
    "assertEventNotFired",
    "assertException",
    "callback",
    "exception",
    "assertInArray",
    "array",
    "indexOf",
    "assertNotInArray",
    "String",
    "format",
    "assertArrayEquals",
    "assertArray",
    "join",
    "assertKeyInMap",
    "map",
    "assertFunction",
    "isFunction",
    "assertFunctionOrAsyncFunction",
    "isFunctionOrAsyncFunction",
    "assertBoolean",
    "isBoolean",
    "isNumber",
    "isFinite",
    "assertPositiveNumber",
    "assertInteger",
    "assertPositiveInteger",
    "assertInRange",
    "min",
    "max",
    "assertObject",
    "isObject",
    "assertMap",
    "assertRegExp",
    "assertType",
    "type",
    "assertInstance",
    "clazz",
    "className",
    "classname",
    "assertInterface",
    "iface",
    "implementsInterface",
    "assertCssColor",
    "ColorUtil",
    "getByName",
    "expectedRgb",
    "stringToRgb",
    "valueRgb",
    "assertElement",
    "nodeType",
    "assertQxObject",
    "__isQxInstance",
    "assertQxWidget",
    "object",
    "constructor",
    "superclass",
    "Assert"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/core/Assert.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * A collection of assertions.\n *\n * These methods can be used to assert incoming parameters, return values, ...\n * If an assertion fails an {@link AssertionError} is thrown.\n *\n * Assertions are used in unit tests as well.\n *\n * @require(qx.lang.Type)\n * @ignore(qx.Class.*)\n */\nqx.Bootstrap.define(\"qx.core.Assert\", {\n  statics: {\n    __logError: true,\n\n    /**\n     * Assert that the condition evaluates to <code>true</code>. An\n     * {@link AssertionError} is thrown if otherwise.\n     *\n     * @param comment {String} Message to be shown if the assertion fails. This\n     *    message is provided by the user.\n     * @param msgvarargs {var} any number of parts of a message to show if assertion\n     *                         triggers. Each will be converted to a string and all\n     *                         parts will be concatenated. E. g. instead of\n     *                         \"Got invalid value \" + this.__toString(val) + \"!!!!!\"\n     *                         use\n     *                         \"Got invalid value \", val, \"!!!!!\"\n     *                         (much better performance)\n     *\n     */\n    __fail(comment, msgvarargs) {\n      // Build up message from message varargs. It's not really important\n      // how long this takes as it is done only when assertion is triggered\n      var msg = \"\";\n      for (var i = 1, l = arguments.length; i < l; i++) {\n        msg =\n          msg +\n          this.__toString(\n            arguments[i] === undefined ? \"'undefined'\" : arguments[i]\n          );\n      }\n\n      var fullComment = \"\";\n      if (msg) {\n        fullComment = comment + \": \" + msg;\n      } else {\n        fullComment = comment;\n      }\n      var errorMsg = \"Assertion error! \" + fullComment;\n\n      if (qx.Class && qx.Class.isDefined(\"qx.core.AssertionError\")) {\n        var err = new qx.core.AssertionError(comment, msg);\n        if (this.__logError) {\n          qx.Bootstrap.error(\n            errorMsg + \"\\n Stack trace: \\n\" + err.getStackTrace()\n          );\n        }\n        throw err;\n      } else {\n        if (this.__logError) {\n          qx.Bootstrap.error(errorMsg);\n        }\n        throw new Error(errorMsg);\n      }\n    },\n\n    /**\n     * Convert an unknown value to a string to display in error messages\n     *\n     * @param value {var} any value\n     * @return {String} a string representation of the value\n     */\n    __toString(value) {\n      var stringValue;\n\n      if (value === null) {\n        stringValue = \"null\";\n      } else if (qx.lang.Type.isArray(value) && value.length > 10) {\n        stringValue = \"Array[\" + value.length + \"]\";\n      } else if (value instanceof Object && value.toString == null) {\n        stringValue = qx.lang.Json.stringify(value, null, 2);\n      } else {\n        try {\n          stringValue = value.toString();\n        } catch (e) {\n          stringValue = \"\";\n        }\n      }\n      return stringValue;\n    },\n\n    /**\n     * Assert that the condition evaluates to <code>true</code>.\n     *\n     * @param condition {var} Condition to check for. Must evaluate to\n     *    <code>true</code>.\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assert(condition, msg) {\n      condition == true || this.__fail(msg || \"\", \"Called assert with 'false'\");\n    },\n\n    /**\n     * Raise an {@link AssertionError}.\n     *\n     * @param msg {String} Message to be shown if the assertion fails.\n     * @param compact {Boolean?false} Show less verbose message. Default: false.\n     */\n    fail(msg, compact) {\n      var msgvarargs = compact ? \"\" : \"Called fail().\";\n      this.__fail(msg || \"\", msgvarargs);\n    },\n\n    /**\n     * Assert that the value is <code>true</code> (Identity check).\n     *\n     * @param value {Boolean} Condition to check for. Must be identical to\n     *    <code>true</code>.\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertTrue(value, msg) {\n      value === true ||\n        this.__fail(msg || \"\", \"Called assertTrue with '\", value, \"'\");\n    },\n\n    /**\n     * Assert that the value is <code>false</code> (Identity check).\n     *\n     * @param value {Boolean} Condition to check for. Must be identical to\n     *    <code>false</code>.\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertFalse(value, msg) {\n      value === false ||\n        this.__fail(msg || \"\", \"Called assertFalse with '\", value, \"'\");\n    },\n\n    /**\n     * Assert that both values are equal. (Uses the equality operator\n     * <code>==</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertEquals(expected, found, msg) {\n      expected == found ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' but found '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both values are not equal. (Uses the not equality operator\n     * <code>!=</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotEquals(expected, found, msg) {\n      expected != found ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' to be not equal with '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both float values are equal. This might be needed because\n     * of the natural floating point inaccuracy of computers.\n     *\n     * @param expected {Float} Reference value\n     * @param found {Float} Found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertEqualsFloat(expected, found, msg) {\n      this.assertNumber(expected);\n      this.assertNumber(found);\n\n      qx.lang.Number.equals(expected, found) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' to be equal with '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both float values are not equal. This might be needed\n     * because of the natural floating point inaccuracy of computers.\n     *\n     * @param expected {Float} Reference value\n     * @param found {Float} Found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotEqualsFloat(expected, found, msg) {\n      this.assertNumber(expected);\n      this.assertNumber(found);\n\n      !qx.lang.Number.equals(expected, found) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' to be not equal with '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both values are identical. (Uses the identity operator\n     * <code>===</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertIdentical(expected, found, msg) {\n      expected === found ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' (identical) but found '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both values are not identical. (Uses the not identity operator\n     * <code>!==</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotIdentical(expected, found, msg) {\n      expected !== found ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' to be not identical with '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that the value is not <code>undefined</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotUndefined(value, msg) {\n      value !== undefined ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value not to be undefined but found undefined!\"\n        );\n    },\n\n    /**\n     * Assert that the value is <code>undefined</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertUndefined(value, msg) {\n      value === undefined ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be undefined but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is not <code>null</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotNull(value, msg) {\n      value !== null ||\n        this.__fail(msg || \"\", \"Expected value not to be null but found null!\");\n    },\n\n    /**\n     * Assert that the value is <code>null</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNull(value, msg) {\n      value === null ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be null but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the first two arguments are equal, when serialized into\n     * JSON.\n     *\n     * @param expected {var} The the expected value\n     * @param found {var} The found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertJsonEquals(expected, found, msg) {\n      this.assertEquals(\n        qx.lang.Json.stringify(expected),\n        qx.lang.Json.stringify(found),\n        msg\n      );\n    },\n\n    /**\n     * Assert that the given string matches the regular expression\n     *\n     * @param str {String} String, which should match the regular expression\n     * @param re {String|RegExp} Regular expression to match\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertMatch(str, re, msg) {\n      this.assertString(str);\n      this.assert(\n        qx.lang.Type.isRegExp(re) || qx.lang.Type.isString(re),\n        \"The parameter 're' must be a string or a regular expression.\"\n      );\n\n      str.search(re) >= 0 ||\n        this.__fail(\n          msg || \"\",\n          \"The String '\",\n          str,\n          \"' does not match the regular expression '\",\n          re.toString(),\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that the number of arguments is within the given range\n     *\n     * @param args {arguments} The <code>arguments<code> variable of a function\n     * @param minCount {Integer} Minimal number of arguments\n     * @param maxCount {Integer} Maximum number of arguments\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertArgumentsCount(args, minCount, maxCount, msg) {\n      var argCount = args.length;\n      (argCount >= minCount && argCount <= maxCount) ||\n        this.__fail(\n          msg || \"\",\n          \"Wrong number of arguments given. Expected '\",\n          minCount,\n          \"' to '\",\n          maxCount,\n          \"' arguments but found '\",\n          argCount,\n          \"' arguments.\"\n        );\n    },\n\n    /**\n     * Assert that an event is fired.\n     *\n     * @param obj {Object} The object on which the event should be fired.\n     * @param event {String} The event which should be fired.\n     * @param invokeFunc {Function} The function which will be invoked and which\n     *   fires the event.\n     * @param listenerFunc {Function?null} The function which will be invoked in the\n     *   listener. The function receives one parameter which is the event.\n     * @param msg {String?\"\"} Message to be shows if the assertion fails.\n     */\n    assertEventFired(obj, event, invokeFunc, listenerFunc, msg) {\n      var called = false;\n      var listener = function (e) {\n        if (listenerFunc) {\n          listenerFunc.call(obj, e);\n        }\n        called = true;\n      };\n\n      var id;\n      try {\n        id = obj.addListener(event, listener, obj);\n        invokeFunc.call(obj);\n      } catch (ex) {\n        throw ex;\n      } finally {\n        try {\n          obj.removeListenerById(id);\n        } catch (ex) {\n          /* ignore */\n        }\n      }\n\n      called === true ||\n        this.__fail(msg || \"\", \"Event (\", event, \") not fired.\");\n    },\n\n    /**\n     * Assert that an event is not fired.\n     *\n     * @param obj {Object} The object on which the event should be fired.\n     * @param event {String} The event which should be fired.\n     * @param invokeFunc {Function} The function which will be invoked and which\n     *   should not fire the event.\n     * @param msg {String?} Message to be shows if the assertion fails.\n     */\n    assertEventNotFired(obj, event, invokeFunc, msg) {\n      var called = false;\n      var listener = function (e) {\n        called = true;\n      };\n      var id = obj.addListener(event, listener, obj);\n\n      invokeFunc.call();\n      called === false ||\n        this.__fail(msg || \"\", \"Event (\", event, \") was fired.\");\n\n      obj.removeListenerById(id);\n    },\n\n    /**\n     * Asserts that the callback raises a matching exception.\n     *\n     * @param callback {Function} function to check\n     * @param exception {Error?Error} Expected constructor of the exception.\n     *   The assertion fails if the raised exception is not an instance of the\n     *   parameter.\n     * @param re {String|RegExp} The assertion fails if the error message does\n     *   not match this parameter\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertException(callback, exception, re, msg) {\n      var exception = exception || Error;\n      var error;\n\n      try {\n        this.__logError = false;\n        callback();\n      } catch (ex) {\n        error = ex;\n      } finally {\n        this.__logError = true;\n      }\n\n      if (error == null) {\n        this.__fail(msg || \"\", \"The function did not raise an exception!\");\n      }\n\n      error instanceof exception ||\n        this.__fail(\n          msg || \"\",\n          \"The raised exception does not have the expected type! \",\n          exception,\n          \" != \",\n          error\n        );\n\n      if (re) {\n        this.assertMatch(error.toString(), re, msg);\n      }\n    },\n\n    /**\n     * Assert that the value is an item in the given array.\n     *\n     * @param value {var} Value to check\n     * @param array {Array} List of valid values\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInArray(value, array, msg) {\n      array.indexOf(value) !== -1 ||\n        this.__fail(\n          msg || \"\",\n          \"The value '\",\n          value,\n          \"' must have any of the values defined in the array '\",\n          array,\n          \"'\"\n        );\n    },\n\n    /**\n     * Assert that the value is NOT an item in the given array\n     *\n     * @param value {var} Value to check\n     * @param array {Array} List of values\n     * @param msg {String?} Message to be shown if the assertion fails\n     */\n    assertNotInArray(value, array, msg) {\n      array.indexOf(value) === -1 ||\n        this.__fail(\n          msg || \"\",\n          qx.lang.String.format(\n            \"The value '%1' must not have any of the values defined in the array '%2'\",\n            [value, array]\n          )\n        );\n    },\n\n    /**\n     * Assert that both array have identical array items.\n     *\n     * @param expected {Array} The expected array\n     * @param found {Array} The found array\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertArrayEquals(expected, found, msg) {\n      this.assertArray(expected, msg);\n      this.assertArray(found, msg);\n\n      msg =\n        msg ||\n        \"Expected [\" +\n          expected.join(\", \") +\n          \"], but found [\" +\n          found.join(\", \") +\n          \"]\";\n\n      if (expected.length !== found.length) {\n        this.fail(msg, true);\n      }\n\n      for (var i = 0; i < expected.length; i++) {\n        if (expected[i] !== found[i]) {\n          this.fail(msg, true);\n        }\n      }\n    },\n\n    /**\n     * Assert that the value is a key in the given map.\n     *\n     * @param value {var} Value to check\n     * @param map {Map} Map, where the keys represent the valid values\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertKeyInMap(value, map, msg) {\n      map[value] !== undefined ||\n        this.__fail(\n          msg || \"\",\n          \"The value '\",\n          value,\n          \"' must must be a key of the map '\",\n          map,\n          \"'\"\n        );\n    },\n\n    /**\n     * Assert that the value is a function.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertFunction(value, msg) {\n      qx.lang.Type.isFunction(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be typeof function but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a function or an async function.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertFunctionOrAsyncFunction(value, msg) {\n      qx.lang.Type.isFunctionOrAsyncFunction(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be typeof function or typeof async function but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a string.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertString(value, msg) {\n      qx.lang.Type.isString(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a string but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a boolean.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertBoolean(value, msg) {\n      qx.lang.Type.isBoolean(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a boolean but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a number.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNumber(value, msg) {\n      (qx.lang.Type.isNumber(value) && isFinite(value)) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a number but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a number >= 0.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertPositiveNumber(value, msg) {\n      (qx.lang.Type.isNumber(value) && isFinite(value) && value >= 0) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a number >= 0 but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an integer.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInteger(value, msg) {\n      (qx.lang.Type.isNumber(value) && isFinite(value) && value % 1 === 0) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be an integer but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an integer >= 0.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertPositiveInteger(value, msg) {\n      var condition =\n        qx.lang.Type.isNumber(value) &&\n        isFinite(value) &&\n        value % 1 === 0 &&\n        value >= 0;\n\n      condition ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be an integer >= 0 but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is inside the given range.\n     *\n     * @param value {var} Value to check\n     * @param min {Number} lower bound\n     * @param max {Number} upper bound\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInRange(value, min, max, msg) {\n      (value >= min && value <= max) ||\n        this.__fail(\n          msg || \"\",\n          qx.lang.String.format(\n            \"Expected value '%1' to be in the range '%2'..'%3'!\",\n            [value, min, max]\n          )\n        );\n    },\n\n    /**\n     * Assert that the value is an object.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertObject(value, msg) {\n      var condition =\n        value !== null &&\n        (qx.lang.Type.isObject(value) || typeof value === \"object\");\n      condition ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be typeof object but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an array.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertArray(value, msg) {\n      qx.lang.Type.isArray(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be an array but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a map either created using <code>new Object</code>\n     * or by using the object literal notation <code>{ ... }</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertMap(value, msg) {\n      qx.lang.Type.isObject(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a map but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a regular expression.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertRegExp(value, msg) {\n      qx.lang.Type.isRegExp(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a regular expression but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value has the given type using the <code>typeof</code>\n     * operator. Because the type is not always what it is supposed to be it is\n     * better to use more explicit checks like {@link #assertString} or\n     * {@link #assertArray}.\n     *\n     * @param value {var} Value to check\n     * @param type {String} expected type of the value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertType(value, type, msg) {\n      this.assertString(type, \"Invalid argument 'type'\");\n\n      typeof value === type ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be typeof '\",\n          type,\n          \"' but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an instance of the given class.\n     *\n     * @param value {var} Value to check\n     * @param clazz {Class} The value must be an instance of this class\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInstance(value, clazz, msg) {\n      var className = clazz.classname || clazz + \"\";\n\n      value instanceof clazz ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be instanceof '\",\n          className,\n          \"' but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value implements the given interface.\n     *\n     * @param value {var} Value to check\n     * @param iface {Class} The value must implement this interface\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInterface(value, iface, msg) {\n      (qx.Class && qx.Class.implementsInterface(value, iface)) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected object '\",\n          value,\n          \"' to implement the interface '\",\n          iface,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that the value represents the given CSS color value. This method\n     * parses the color strings and compares the RGB values. It is able to\n     * parse values supported by {@link qx.util.ColorUtil#stringToRgb}.\n     *\n     *  @param expected {String} The expected color\n     *  @param value {String} The value to check\n     *  @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertCssColor(expected, value, msg) {\n      var ColorUtil = qx.Class ? qx.Class.getByName(\"qx.util.ColorUtil\") : null;\n      if (!ColorUtil) {\n        throw new Error(\n          \"qx.util.ColorUtil not available! Your code must have a dependency on 'qx.util.ColorUtil'\"\n        );\n      }\n\n      var expectedRgb = ColorUtil.stringToRgb(expected);\n      try {\n        var valueRgb = ColorUtil.stringToRgb(value);\n      } catch (ex) {\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be the CSS color '\",\n          expected,\n          \"' (rgb(\",\n          expectedRgb.join(\",\"),\n          \")), but found value '\",\n          value,\n          \"', which cannot be converted to a CSS color!\"\n        );\n      }\n\n      var condition =\n        expectedRgb[0] == valueRgb[0] &&\n        expectedRgb[1] == valueRgb[1] &&\n        expectedRgb[2] == valueRgb[2];\n      condition ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be the CSS color '\",\n          expectedRgb,\n          \"' (rgb(\",\n          expectedRgb.join(\",\"),\n          \")), but found value '\",\n          value,\n          \"' (rgb(\",\n          valueRgb.join(\",\"),\n          \"))!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a DOM element.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertElement(value, msg) {\n      // see qx.dom.Node.isElement\n      !!(value && value.nodeType === 1) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a DOM element but found  '\",\n          value,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an instance of {@link qx.core.Object}.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertQxObject(value, msg) {\n      this.__isQxInstance(value, \"qx.core.Object\") ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a qooxdoo object but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an instance of {@link qx.ui.core.Widget}.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertQxWidget(value, msg) {\n      this.__isQxInstance(value, \"qx.ui.core.Widget\") ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a qooxdoo widget but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Internal helper for checking the instance of a qooxdoo object using the\n     * classname.\n     *\n     * @param object {var} The object to check.\n     * @param classname {String} The classname of the class as string.\n     * @return {Boolean} <code>true</code> if the object is an instance of the\n     * class\n     */\n    __isQxInstance(object, classname) {\n      if (!object) {\n        return false;\n      }\n      var clazz = object.constructor;\n      while (clazz) {\n        if (clazz.classname === classname) {\n          return true;\n        }\n        clazz = clazz.superclass;\n      }\n      return false;\n    }\n  }\n});\n"
  ],
  "mappings": "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"
}