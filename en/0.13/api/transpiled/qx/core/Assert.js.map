{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__logError",
    "__fail",
    "comment",
    "msgvarargs",
    "msg",
    "i",
    "l",
    "arguments",
    "length",
    "__toString",
    "undefined",
    "fullComment",
    "errorMsg",
    "Class",
    "isDefined",
    "err",
    "core",
    "AssertionError",
    "error",
    "getStackTrace",
    "Error",
    "value",
    "stringValue",
    "lang",
    "Type",
    "isArray",
    "Object",
    "toString",
    "Json",
    "stringify",
    "e",
    "assert",
    "condition",
    "fail",
    "compact",
    "assertTrue",
    "assertFalse",
    "assertEquals",
    "expected",
    "found",
    "assertNotEquals",
    "assertEqualsFloat",
    "assertNumber",
    "Number",
    "equals",
    "assertNotEqualsFloat",
    "assertIdentical",
    "assertNotIdentical",
    "assertNotUndefined",
    "assertUndefined",
    "assertNotNull",
    "assertNull",
    "assertJsonEquals",
    "assertMatch",
    "str",
    "re",
    "assertString",
    "isRegExp",
    "isString",
    "search",
    "assertArgumentsCount",
    "args",
    "minCount",
    "maxCount",
    "argCount",
    "assertEventFired",
    "obj",
    "event",
    "invokeFunc",
    "listenerFunc",
    "called",
    "listener",
    "call",
    "id",
    "addListener",
    "ex",
    "removeListenerById",
    "assertEventNotFired",
    "assertException",
    "callback",
    "exception",
    "assertInArray",
    "array",
    "indexOf",
    "assertNotInArray",
    "String",
    "format",
    "assertArrayEquals",
    "assertArray",
    "join",
    "assertKeyInMap",
    "map",
    "assertFunction",
    "isFunction",
    "assertFunctionOrAsyncFunction",
    "isFunctionOrAsyncFunction",
    "assertBoolean",
    "isBoolean",
    "isNumber",
    "isFinite",
    "assertPositiveNumber",
    "assertInteger",
    "assertPositiveInteger",
    "assertInRange",
    "min",
    "max",
    "assertObject",
    "isObject",
    "_typeof",
    "assertMap",
    "assertRegExp",
    "assertType",
    "type",
    "assertInstance",
    "clazz",
    "className",
    "classname",
    "assertInterface",
    "iface",
    "implementsInterface",
    "assertCssColor",
    "ColorUtil",
    "getByName",
    "expectedRgb",
    "stringToRgb",
    "valueRgb",
    "assertElement",
    "nodeType",
    "assertQxObject",
    "__isQxInstance",
    "assertQxWidget",
    "object",
    "constructor",
    "superclass",
    "Assert"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/core/Assert.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * A collection of assertions.\n *\n * These methods can be used to assert incoming parameters, return values, ...\n * If an assertion fails an {@link AssertionError} is thrown.\n *\n * Assertions are used in unit tests as well.\n *\n * @require(qx.lang.Type)\n * @ignore(qx.Class.*)\n */\nqx.Bootstrap.define(\"qx.core.Assert\", {\n  statics: {\n    __logError: true,\n\n    /**\n     * Assert that the condition evaluates to <code>true</code>. An\n     * {@link AssertionError} is thrown if otherwise.\n     *\n     * @param comment {String} Message to be shown if the assertion fails. This\n     *    message is provided by the user.\n     * @param msgvarargs {var} any number of parts of a message to show if assertion\n     *                         triggers. Each will be converted to a string and all\n     *                         parts will be concatenated. E. g. instead of\n     *                         \"Got invalid value \" + this.__toString(val) + \"!!!!!\"\n     *                         use\n     *                         \"Got invalid value \", val, \"!!!!!\"\n     *                         (much better performance)\n     *\n     */\n    __fail(comment, msgvarargs) {\n      // Build up message from message varargs. It's not really important\n      // how long this takes as it is done only when assertion is triggered\n      var msg = \"\";\n      for (var i = 1, l = arguments.length; i < l; i++) {\n        msg =\n          msg +\n          this.__toString(\n            arguments[i] === undefined ? \"'undefined'\" : arguments[i]\n          );\n      }\n\n      var fullComment = \"\";\n      if (msg) {\n        fullComment = comment + \": \" + msg;\n      } else {\n        fullComment = comment;\n      }\n      var errorMsg = \"Assertion error! \" + fullComment;\n\n      if (qx.Class && qx.Class.isDefined(\"qx.core.AssertionError\")) {\n        var err = new qx.core.AssertionError(comment, msg);\n        if (this.__logError) {\n          qx.Bootstrap.error(\n            errorMsg + \"\\n Stack trace: \\n\" + err.getStackTrace()\n          );\n        }\n        throw err;\n      } else {\n        if (this.__logError) {\n          qx.Bootstrap.error(errorMsg);\n        }\n        throw new Error(errorMsg);\n      }\n    },\n\n    /**\n     * Convert an unknown value to a string to display in error messages\n     *\n     * @param value {var} any value\n     * @return {String} a string representation of the value\n     */\n    __toString(value) {\n      var stringValue;\n\n      if (value === null) {\n        stringValue = \"null\";\n      } else if (qx.lang.Type.isArray(value) && value.length > 10) {\n        stringValue = \"Array[\" + value.length + \"]\";\n      } else if (value instanceof Object && value.toString == null) {\n        stringValue = qx.lang.Json.stringify(value, null, 2);\n      } else {\n        try {\n          stringValue = value.toString();\n        } catch (e) {\n          stringValue = \"\";\n        }\n      }\n      return stringValue;\n    },\n\n    /**\n     * Assert that the condition evaluates to <code>true</code>.\n     *\n     * @param condition {var} Condition to check for. Must evaluate to\n     *    <code>true</code>.\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assert(condition, msg) {\n      condition == true || this.__fail(msg || \"\", \"Called assert with 'false'\");\n    },\n\n    /**\n     * Raise an {@link AssertionError}.\n     *\n     * @param msg {String} Message to be shown if the assertion fails.\n     * @param compact {Boolean?false} Show less verbose message. Default: false.\n     */\n    fail(msg, compact) {\n      var msgvarargs = compact ? \"\" : \"Called fail().\";\n      this.__fail(msg || \"\", msgvarargs);\n    },\n\n    /**\n     * Assert that the value is <code>true</code> (Identity check).\n     *\n     * @param value {Boolean} Condition to check for. Must be identical to\n     *    <code>true</code>.\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertTrue(value, msg) {\n      value === true ||\n        this.__fail(msg || \"\", \"Called assertTrue with '\", value, \"'\");\n    },\n\n    /**\n     * Assert that the value is <code>false</code> (Identity check).\n     *\n     * @param value {Boolean} Condition to check for. Must be identical to\n     *    <code>false</code>.\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertFalse(value, msg) {\n      value === false ||\n        this.__fail(msg || \"\", \"Called assertFalse with '\", value, \"'\");\n    },\n\n    /**\n     * Assert that both values are equal. (Uses the equality operator\n     * <code>==</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertEquals(expected, found, msg) {\n      expected == found ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' but found '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both values are not equal. (Uses the not equality operator\n     * <code>!=</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotEquals(expected, found, msg) {\n      expected != found ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' to be not equal with '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both float values are equal. This might be needed because\n     * of the natural floating point inaccuracy of computers.\n     *\n     * @param expected {Float} Reference value\n     * @param found {Float} Found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertEqualsFloat(expected, found, msg) {\n      this.assertNumber(expected);\n      this.assertNumber(found);\n\n      qx.lang.Number.equals(expected, found) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' to be equal with '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both float values are not equal. This might be needed\n     * because of the natural floating point inaccuracy of computers.\n     *\n     * @param expected {Float} Reference value\n     * @param found {Float} Found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotEqualsFloat(expected, found, msg) {\n      this.assertNumber(expected);\n      this.assertNumber(found);\n\n      !qx.lang.Number.equals(expected, found) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' to be not equal with '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both values are identical. (Uses the identity operator\n     * <code>===</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertIdentical(expected, found, msg) {\n      expected === found ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' (identical) but found '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that both values are not identical. (Uses the not identity operator\n     * <code>!==</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotIdentical(expected, found, msg) {\n      expected !== found ||\n        this.__fail(\n          msg || \"\",\n          \"Expected '\",\n          expected,\n          \"' to be not identical with '\",\n          found,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that the value is not <code>undefined</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotUndefined(value, msg) {\n      value !== undefined ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value not to be undefined but found undefined!\"\n        );\n    },\n\n    /**\n     * Assert that the value is <code>undefined</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertUndefined(value, msg) {\n      value === undefined ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be undefined but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is not <code>null</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotNull(value, msg) {\n      value !== null ||\n        this.__fail(msg || \"\", \"Expected value not to be null but found null!\");\n    },\n\n    /**\n     * Assert that the value is <code>null</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNull(value, msg) {\n      value === null ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be null but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the first two arguments are equal, when serialized into\n     * JSON.\n     *\n     * @param expected {var} The the expected value\n     * @param found {var} The found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertJsonEquals(expected, found, msg) {\n      this.assertEquals(\n        qx.lang.Json.stringify(expected),\n        qx.lang.Json.stringify(found),\n        msg\n      );\n    },\n\n    /**\n     * Assert that the given string matches the regular expression\n     *\n     * @param str {String} String, which should match the regular expression\n     * @param re {String|RegExp} Regular expression to match\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertMatch(str, re, msg) {\n      this.assertString(str);\n      this.assert(\n        qx.lang.Type.isRegExp(re) || qx.lang.Type.isString(re),\n        \"The parameter 're' must be a string or a regular expression.\"\n      );\n\n      str.search(re) >= 0 ||\n        this.__fail(\n          msg || \"\",\n          \"The String '\",\n          str,\n          \"' does not match the regular expression '\",\n          re.toString(),\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that the number of arguments is within the given range\n     *\n     * @param args {arguments} The <code>arguments<code> variable of a function\n     * @param minCount {Integer} Minimal number of arguments\n     * @param maxCount {Integer} Maximum number of arguments\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertArgumentsCount(args, minCount, maxCount, msg) {\n      var argCount = args.length;\n      (argCount >= minCount && argCount <= maxCount) ||\n        this.__fail(\n          msg || \"\",\n          \"Wrong number of arguments given. Expected '\",\n          minCount,\n          \"' to '\",\n          maxCount,\n          \"' arguments but found '\",\n          argCount,\n          \"' arguments.\"\n        );\n    },\n\n    /**\n     * Assert that an event is fired.\n     *\n     * @param obj {Object} The object on which the event should be fired.\n     * @param event {String} The event which should be fired.\n     * @param invokeFunc {Function} The function which will be invoked and which\n     *   fires the event.\n     * @param listenerFunc {Function?null} The function which will be invoked in the\n     *   listener. The function receives one parameter which is the event.\n     * @param msg {String?\"\"} Message to be shows if the assertion fails.\n     */\n    assertEventFired(obj, event, invokeFunc, listenerFunc, msg) {\n      var called = false;\n      var listener = function (e) {\n        if (listenerFunc) {\n          listenerFunc.call(obj, e);\n        }\n        called = true;\n      };\n\n      var id;\n      try {\n        id = obj.addListener(event, listener, obj);\n        invokeFunc.call(obj);\n      } catch (ex) {\n        throw ex;\n      } finally {\n        try {\n          obj.removeListenerById(id);\n        } catch (ex) {\n          /* ignore */\n        }\n      }\n\n      called === true ||\n        this.__fail(msg || \"\", \"Event (\", event, \") not fired.\");\n    },\n\n    /**\n     * Assert that an event is not fired.\n     *\n     * @param obj {Object} The object on which the event should be fired.\n     * @param event {String} The event which should be fired.\n     * @param invokeFunc {Function} The function which will be invoked and which\n     *   should not fire the event.\n     * @param msg {String?} Message to be shows if the assertion fails.\n     */\n    assertEventNotFired(obj, event, invokeFunc, msg) {\n      var called = false;\n      var listener = function (e) {\n        called = true;\n      };\n      var id = obj.addListener(event, listener, obj);\n\n      invokeFunc.call();\n      called === false ||\n        this.__fail(msg || \"\", \"Event (\", event, \") was fired.\");\n\n      obj.removeListenerById(id);\n    },\n\n    /**\n     * Asserts that the callback raises a matching exception.\n     *\n     * @param callback {Function} function to check\n     * @param exception {Error?Error} Expected constructor of the exception.\n     *   The assertion fails if the raised exception is not an instance of the\n     *   parameter.\n     * @param re {String|RegExp} The assertion fails if the error message does\n     *   not match this parameter\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertException(callback, exception, re, msg) {\n      var exception = exception || Error;\n      var error;\n\n      try {\n        this.__logError = false;\n        callback();\n      } catch (ex) {\n        error = ex;\n      } finally {\n        this.__logError = true;\n      }\n\n      if (error == null) {\n        this.__fail(msg || \"\", \"The function did not raise an exception!\");\n      }\n\n      error instanceof exception ||\n        this.__fail(\n          msg || \"\",\n          \"The raised exception does not have the expected type! \",\n          exception,\n          \" != \",\n          error\n        );\n\n      if (re) {\n        this.assertMatch(error.toString(), re, msg);\n      }\n    },\n\n    /**\n     * Assert that the value is an item in the given array.\n     *\n     * @param value {var} Value to check\n     * @param array {Array} List of valid values\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInArray(value, array, msg) {\n      array.indexOf(value) !== -1 ||\n        this.__fail(\n          msg || \"\",\n          \"The value '\",\n          value,\n          \"' must have any of the values defined in the array '\",\n          array,\n          \"'\"\n        );\n    },\n\n    /**\n     * Assert that the value is NOT an item in the given array\n     *\n     * @param value {var} Value to check\n     * @param array {Array} List of values\n     * @param msg {String?} Message to be shown if the assertion fails\n     */\n    assertNotInArray(value, array, msg) {\n      array.indexOf(value) === -1 ||\n        this.__fail(\n          msg || \"\",\n          qx.lang.String.format(\n            \"The value '%1' must not have any of the values defined in the array '%2'\",\n            [value, array]\n          )\n        );\n    },\n\n    /**\n     * Assert that both array have identical array items.\n     *\n     * @param expected {Array} The expected array\n     * @param found {Array} The found array\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertArrayEquals(expected, found, msg) {\n      this.assertArray(expected, msg);\n      this.assertArray(found, msg);\n\n      msg =\n        msg ||\n        \"Expected [\" +\n          expected.join(\", \") +\n          \"], but found [\" +\n          found.join(\", \") +\n          \"]\";\n\n      if (expected.length !== found.length) {\n        this.fail(msg, true);\n      }\n\n      for (var i = 0; i < expected.length; i++) {\n        if (expected[i] !== found[i]) {\n          this.fail(msg, true);\n        }\n      }\n    },\n\n    /**\n     * Assert that the value is a key in the given map.\n     *\n     * @param value {var} Value to check\n     * @param map {Map} Map, where the keys represent the valid values\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertKeyInMap(value, map, msg) {\n      map[value] !== undefined ||\n        this.__fail(\n          msg || \"\",\n          \"The value '\",\n          value,\n          \"' must must be a key of the map '\",\n          map,\n          \"'\"\n        );\n    },\n\n    /**\n     * Assert that the value is a function.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertFunction(value, msg) {\n      qx.lang.Type.isFunction(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be typeof function but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a function or an async function.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertFunctionOrAsyncFunction(value, msg) {\n      qx.lang.Type.isFunctionOrAsyncFunction(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be typeof function or typeof async function but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a string.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertString(value, msg) {\n      qx.lang.Type.isString(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a string but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a boolean.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertBoolean(value, msg) {\n      qx.lang.Type.isBoolean(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a boolean but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a number.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNumber(value, msg) {\n      (qx.lang.Type.isNumber(value) && isFinite(value)) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a number but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a number >= 0.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertPositiveNumber(value, msg) {\n      (qx.lang.Type.isNumber(value) && isFinite(value) && value >= 0) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a number >= 0 but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an integer.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInteger(value, msg) {\n      (qx.lang.Type.isNumber(value) && isFinite(value) && value % 1 === 0) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be an integer but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an integer >= 0.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertPositiveInteger(value, msg) {\n      var condition =\n        qx.lang.Type.isNumber(value) &&\n        isFinite(value) &&\n        value % 1 === 0 &&\n        value >= 0;\n\n      condition ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be an integer >= 0 but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is inside the given range.\n     *\n     * @param value {var} Value to check\n     * @param min {Number} lower bound\n     * @param max {Number} upper bound\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInRange(value, min, max, msg) {\n      (value >= min && value <= max) ||\n        this.__fail(\n          msg || \"\",\n          qx.lang.String.format(\n            \"Expected value '%1' to be in the range '%2'..'%3'!\",\n            [value, min, max]\n          )\n        );\n    },\n\n    /**\n     * Assert that the value is an object.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertObject(value, msg) {\n      var condition =\n        value !== null &&\n        (qx.lang.Type.isObject(value) || typeof value === \"object\");\n      condition ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be typeof object but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an array.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertArray(value, msg) {\n      qx.lang.Type.isArray(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be an array but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a map either created using <code>new Object</code>\n     * or by using the object literal notation <code>{ ... }</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertMap(value, msg) {\n      qx.lang.Type.isObject(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a map but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a regular expression.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertRegExp(value, msg) {\n      qx.lang.Type.isRegExp(value) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a regular expression but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value has the given type using the <code>typeof</code>\n     * operator. Because the type is not always what it is supposed to be it is\n     * better to use more explicit checks like {@link #assertString} or\n     * {@link #assertArray}.\n     *\n     * @param value {var} Value to check\n     * @param type {String} expected type of the value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertType(value, type, msg) {\n      this.assertString(type, \"Invalid argument 'type'\");\n\n      typeof value === type ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be typeof '\",\n          type,\n          \"' but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an instance of the given class.\n     *\n     * @param value {var} Value to check\n     * @param clazz {Class} The value must be an instance of this class\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInstance(value, clazz, msg) {\n      var className = clazz.classname || clazz + \"\";\n\n      value instanceof clazz ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be instanceof '\",\n          className,\n          \"' but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value implements the given interface.\n     *\n     * @param value {var} Value to check\n     * @param iface {Class} The value must implement this interface\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInterface(value, iface, msg) {\n      (qx.Class && qx.Class.implementsInterface(value, iface)) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected object '\",\n          value,\n          \"' to implement the interface '\",\n          iface,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that the value represents the given CSS color value. This method\n     * parses the color strings and compares the RGB values. It is able to\n     * parse values supported by {@link qx.util.ColorUtil#stringToRgb}.\n     *\n     *  @param expected {String} The expected color\n     *  @param value {String} The value to check\n     *  @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertCssColor(expected, value, msg) {\n      var ColorUtil = qx.Class ? qx.Class.getByName(\"qx.util.ColorUtil\") : null;\n      if (!ColorUtil) {\n        throw new Error(\n          \"qx.util.ColorUtil not available! Your code must have a dependency on 'qx.util.ColorUtil'\"\n        );\n      }\n\n      var expectedRgb = ColorUtil.stringToRgb(expected);\n      try {\n        var valueRgb = ColorUtil.stringToRgb(value);\n      } catch (ex) {\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be the CSS color '\",\n          expected,\n          \"' (rgb(\",\n          expectedRgb.join(\",\"),\n          \")), but found value '\",\n          value,\n          \"', which cannot be converted to a CSS color!\"\n        );\n      }\n\n      var condition =\n        expectedRgb[0] == valueRgb[0] &&\n        expectedRgb[1] == valueRgb[1] &&\n        expectedRgb[2] == valueRgb[2];\n      condition ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be the CSS color '\",\n          expectedRgb,\n          \"' (rgb(\",\n          expectedRgb.join(\",\"),\n          \")), but found value '\",\n          value,\n          \"' (rgb(\",\n          valueRgb.join(\",\"),\n          \"))!\"\n        );\n    },\n\n    /**\n     * Assert that the value is a DOM element.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertElement(value, msg) {\n      // see qx.dom.Node.isElement\n      !!(value && value.nodeType === 1) ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a DOM element but found  '\",\n          value,\n          \"'!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an instance of {@link qx.core.Object}.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertQxObject(value, msg) {\n      this.__isQxInstance(value, \"qx.core.Object\") ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a qooxdoo object but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Assert that the value is an instance of {@link qx.ui.core.Widget}.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertQxWidget(value, msg) {\n      this.__isQxInstance(value, \"qx.ui.core.Widget\") ||\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be a qooxdoo widget but found \",\n          value,\n          \"!\"\n        );\n    },\n\n    /**\n     * Internal helper for checking the instance of a qooxdoo object using the\n     * classname.\n     *\n     * @param object {var} The object to check.\n     * @param classname {String} The classname of the class as string.\n     * @return {Boolean} <code>true</code> if the object is an instance of the\n     * class\n     */\n    __isQxInstance(object, classname) {\n      if (!object) {\n        return false;\n      }\n      var clazz = object.constructor;\n      while (clazz) {\n        if (clazz.classname === classname) {\n          return true;\n        }\n        clazz = clazz.superclass;\n      }\n      return false;\n    }\n  }\n});\n"
  ],
  "mappings": "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",
  "ignoreList": []
}