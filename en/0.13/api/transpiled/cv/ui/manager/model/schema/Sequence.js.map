{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/model/schema/Sequence.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "cv",
    "ui",
    "manager",
    "model",
    "schema",
    "Base",
    "construct",
    "node",
    "parse",
    "properties",
    "type",
    "refine",
    "init",
    "elementsHaveOrder",
    "members",
    "getSchema",
    "subNodes",
    "Array",
    "from",
    "getNode",
    "children",
    "forEach",
    "subNode",
    "subObject",
    "nodeName",
    "Element",
    "setSortable",
    "_allowedElements",
    "getName",
    "Choice",
    "_subGroupings",
    "push",
    "Sequence",
    "Group",
    "Any",
    "_sortedContent",
    "getCommentNodeSchemaElement",
    "getRegex",
    "separator",
    "nocapture",
    "_regexCache",
    "regexString",
    "elementRegexes",
    "element",
    "join",
    "bounds",
    "getBounds",
    "min",
    "undefined",
    "max",
    "Number",
    "POSITIVE_INFINITY",
    "getBoundsForElementName",
    "childName",
    "elementBounds",
    "sequenceBounds",
    "resultBounds",
    "Object",
    "prototype",
    "hasOwnProperty",
    "call",
    "isNaN",
    "childBounds",
    "tmpBounds",
    "i",
    "length",
    "getAllowedElementsSorting",
    "sortNumber",
    "namesWithSorting",
    "item",
    "mySortNumber",
    "getType",
    "subSortedElements",
    "assign"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;AAAAA,EAAAA,EAAE,CAACC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACAH,EAAAA,EAAE,CAACI,KAAH,CAASC,MAAT,CAAgB,qCAAhB,EAAuD;AACrDC,IAAAA,MAAM,EAAEC,EAAE,CAACC,EAAH,CAAMC,OAAN,CAAcC,KAAd,CAAoBC,MAApB,CAA2BC,IADkB;;AAGrD;AACF;AACA;AACA;AACA;AACEC,IAAAA,SAAS,EAAE,mBAAUC,IAAV,EAAgBH,MAAhB,EAAwB;AACjC,6DAAqBG,IAArB,EAA2BH,MAA3B;AACA,WAAKI,KAAL;AACD,KAXoD;;AAarD;AACF;AACA;AACA;AACA;AACEC,IAAAA,UAAU,EAAE;AACVC,MAAAA,IAAI,EAAE;AACJC,QAAAA,MAAM,EAAE,IADJ;AAEJC,QAAAA,IAAI,EAAE;AAFF,OADI;AAKVC,MAAAA,iBAAiB,EAAE;AACjBF,QAAAA,MAAM,EAAE,IADS;AAEjBC,QAAAA,IAAI,EAAE;AAFW;AALT,KAlByC;;AA6BrD;AACF;AACA;AACA;AACA;AACEE,IAAAA,OAAO,EAAE;AAEP;AACJ;AACA;AACA;AACA;AACIN,MAAAA,KAAK,EAAE,iBAAY;AAAA;;AACjB;AACA,YAAMJ,MAAM,GAAG,KAAKW,SAAL,EAAf,CAFiB,CAIjB;AACA;;AACA,YAAMC,QAAQ,GAAGC,KAAK,CAACC,IAAN,CAAW,KAAKC,OAAL,GAAeC,QAA1B,CAAjB;AAEAJ,QAAAA,QAAQ,CAACK,OAAT,CAAiB,UAAAC,OAAO,EAAI;AAC1B,cAAIC,SAAJ;;AAEA,kBAAQD,OAAO,CAACE,QAAhB;AACE,iBAAK,aAAL;AACA,iBAAK,SAAL;AACED,cAAAA,SAAS,GAAG,IAAIvB,EAAE,CAACC,EAAH,CAAMC,OAAN,CAAcC,KAAd,CAAoBC,MAApB,CAA2BqB,OAA/B,CAAuCH,OAAvC,EAAgDlB,MAAhD,CAAZ,CADF,CAEE;;AACAmB,cAAAA,SAAS,CAACG,WAAV,CAAsB,KAAtB;AACA,cAAA,KAAI,CAACC,gBAAL,CAAsBJ,SAAS,CAACK,OAAV,EAAtB,IAA6CL,SAA7C;AACA;;AACF,iBAAK,YAAL;AACA,iBAAK,QAAL;AACEA,cAAAA,SAAS,GAAG,IAAIvB,EAAE,CAACC,EAAH,CAAMC,OAAN,CAAcC,KAAd,CAAoBC,MAApB,CAA2ByB,MAA/B,CAAsCP,OAAtC,EAA+ClB,MAA/C,CAAZ;;AACA,cAAA,KAAI,CAAC0B,aAAL,CAAmBC,IAAnB,CAAwBR,SAAxB;;AACA;;AACF,iBAAK,cAAL;AACA,iBAAK,UAAL;AACEA,cAAAA,SAAS,GAAG,IAAIvB,EAAE,CAACC,EAAH,CAAMC,OAAN,CAAcC,KAAd,CAAoBC,MAApB,CAA2B4B,QAA/B,CAAwCV,OAAxC,EAAiDlB,MAAjD,CAAZ;;AACA,cAAA,KAAI,CAAC0B,aAAL,CAAmBC,IAAnB,CAAwBR,SAAxB;;AACA;;AACF,iBAAK,WAAL;AACA,iBAAK,OAAL;AACEA,cAAAA,SAAS,GAAG,IAAIvB,EAAE,CAACC,EAAH,CAAMC,OAAN,CAAcC,KAAd,CAAoBC,MAApB,CAA2B6B,KAA/B,CAAqCX,OAArC,EAA8ClB,MAA9C,CAAZ;;AACA,cAAA,KAAI,CAAC0B,aAAL,CAAmBC,IAAnB,CAAwBR,SAAxB;;AACA;;AACF,iBAAK,SAAL;AACA,iBAAK,KAAL;AACEA,cAAAA,SAAS,GAAG,IAAIvB,EAAE,CAACC,EAAH,CAAMC,OAAN,CAAcC,KAAd,CAAoBC,MAApB,CAA2B8B,GAA/B,CAAmCZ,OAAnC,EAA4ClB,MAA5C,CAAZ;;AACA,cAAA,KAAI,CAAC0B,aAAL,CAAmBC,IAAnB,CAAwBR,SAAxB;;AACA;AA3BJ;;AA8BA,UAAA,KAAI,CAACY,cAAL,CAAoBJ,IAApB,CAAyBR,SAAzB;AACD,SAlCD;AAmCA,aAAKI,gBAAL,CAAsB,UAAtB,IAAoC,KAAKZ,SAAL,GAAiBqB,2BAAjB,EAApC;AACD,OAnDM;;AAqDP;AACJ;AACA;AACA;AACA;AACA;AACA;AACIC,MAAAA,QAAQ,EAAE,kBAAUC,SAAV,EAAqBC,SAArB,EAAgC;AACxC,YAAI,KAAKC,WAAL,KAAqB,IAAzB,EAA+B;AAC7B;AACA,iBAAO,KAAKA,WAAZ;AACD;;AAED,YAAIC,WAAW,GAAG,GAAlB,CANwC,CAQxC;;AACA,YAAIF,SAAJ,EAAe;AACbE,UAAAA,WAAW,IAAI,IAAf;AACD;;AAED,YAAMC,cAAc,GAAG,EAAvB,CAbwC,CAexC;;AACA,aAAKP,cAAL,CAAoBd,OAApB,CAA4B,UAAAsB,OAAO,EAAI;AACrCD,UAAAA,cAAc,CAACX,IAAf,CAAoBY,OAAO,CAACN,QAAR,CAAiBC,SAAjB,EAA4BC,SAA5B,CAApB;AACD,SAFD;;AAIAE,QAAAA,WAAW,IAAIC,cAAc,CAACE,IAAf,CAAoB,EAApB,CAAf;AAEAH,QAAAA,WAAW,IAAI,GAAf,CAtBwC,CAyBxC;;AACAA,QAAAA,WAAW,IAAI,GAAf;AACA,YAAMI,MAAM,GAAG,KAAKC,SAAL,EAAf;AACAL,QAAAA,WAAW,IAAII,MAAM,CAACE,GAAP,KAAeC,SAAf,GAA2B,CAA3B,GAA+BH,MAAM,CAACE,GAArD;AACAN,QAAAA,WAAW,IAAI,GAAf;;AACA,YAAII,MAAM,CAACI,GAAP,KAAeC,MAAM,CAACC,iBAA1B,EAA6C;AAC3CV,UAAAA,WAAW,IAAII,MAAM,CAACI,GAAP,KAAeD,SAAf,GAA2B,CAA3B,GAA+BH,MAAM,CAACI,GAArD;AACD;;AACDR,QAAAA,WAAW,IAAI,GAAf,CAjCwC,CAmCxC;;AACA,aAAKD,WAAL,GAAmBC,WAAnB,CApCwC,CAsCxC;;AACA,eAAOA,WAAP;AACD,OApGM;AAsGPW,MAAAA,uBAAuB,EAAE,iCAAUC,SAAV,EAAqB;AAC5C;AACA,YAAI,OAAO,KAAK1B,gBAAL,CAAsB0B,SAAtB,CAAP,KAA4C,WAAhD,EAA6D;AAC3D,cAAMC,aAAa,GAAG,KAAK3B,gBAAL,CAAsB0B,SAAtB,EAAiCP,SAAjC,EAAtB;;AACA,cAAMS,cAAc,GAAG,KAAKT,SAAL,EAAvB;AAEA,cAAMU,YAAY,GAAG;AACnBT,YAAAA,GAAG,EAAE,CADc;AAEnBE,YAAAA,GAAG,EAAE;AAFc,WAArB,CAJ2D,CAS3D;AACA;AACA;;AACA,cAAIQ,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCN,aAArC,EAAoD,KAApD,CAAJ,EAAgE;AAC9DE,YAAAA,YAAY,CAACT,GAAb,GAAmBO,aAAa,CAACP,GAAjC;AACD;;AAED,cAAIU,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,cAArC,EAAqD,KAArD,KAA+D,CAACM,KAAK,CAACN,cAAc,CAACR,GAAhB,CAAzE,EAA+F;AAC7FS,YAAAA,YAAY,CAACT,GAAb,IAAoBQ,cAAc,CAACR,GAAnC;AACD;;AAED,cAAIO,aAAa,CAACL,GAAd,KAAsBC,MAAM,CAACC,iBAA7B,IAAkDI,cAAc,CAACN,GAAf,KAAuBC,MAAM,CAACC,iBAApF,EAAuG;AACrGK,YAAAA,YAAY,CAACP,GAAb,GAAmBC,MAAM,CAACC,iBAA1B;AACD,WAFD,MAEO;AACL,gBAAIM,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCN,aAArC,EAAoD,KAApD,CAAJ,EAAgE;AAC9DE,cAAAA,YAAY,CAACP,GAAb,GAAmBK,aAAa,CAACL,GAAjC;AACD;;AAED,gBAAIQ,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,cAArC,EAAqD,KAArD,KAA+D,CAACM,KAAK,CAACN,cAAc,CAACN,GAAhB,CAAzE,EAA+F;AAC7FO,cAAAA,YAAY,CAACP,GAAb,IAAoBM,cAAc,CAACN,GAAnC;AACD;AACF;;AAED,iBAAOO,YAAP;AACD;;AAED,YAAIM,WAAJ;AAEA,YAAIC,SAAJ;;AAEA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKlC,aAAL,CAAmBmC,MAAvC,EAA+C,EAAED,CAAjD,EAAoD;AAClDD,UAAAA,SAAS,GAAG,KAAKjC,aAAL,CAAmBkC,CAAnB,EAAsBZ,uBAAtB,CAA8CC,SAA9C,CAAZ;;AAEA,cAAIL,SAAS,KAAKe,SAAlB,EAA6B;AAC3B;AACAD,YAAAA,WAAW,GAAGC,SAAd;AACA;AACD;AACF;;AAED,eAAOD,WAAP;AACD,OA1JM;;AA4JP;AACJ;AACA;AACA;AACA;AACA;AACA;AACII,MAAAA,yBAAyB,EAAE,mCAAUC,UAAV,EAAsB;AAC/C,YAAMC,gBAAgB,GAAG,EAAzB;;AAEA,aAAKjC,cAAL,CAAoBd,OAApB,CAA4B,UAACgD,IAAD,EAAOL,CAAP,EAAa;AACvC,cAAIM,YAAY,GAAGN,CAAnB;;AACA,cAAIG,UAAU,KAAKnB,SAAnB,EAA8B;AAC5BsB,YAAAA,YAAY,GAAGH,UAAU,GAAG,GAAb,GAAmBH,CAAlC;AACD;;AAED,cAAIK,IAAI,CAACE,OAAL,OAAmB,SAAvB,EAAkC;AAChCH,YAAAA,gBAAgB,CAACC,IAAI,CAACzC,OAAL,EAAD,CAAhB,GAAmC0C,YAAnC;AACD,WAFD,MAEO;AACL;AACA,gBAAME,iBAAiB,GAAGH,IAAI,CAACH,yBAAL,CAA+BI,YAA/B,CAA1B;AACAb,YAAAA,MAAM,CAACgB,MAAP,CAAcL,gBAAd,EAAgCI,iBAAhC;AACD;AACF,SAbD;;AAeA,eAAOJ,gBAAP;AACD;AAtLM;AAlC4C,GAAvD;AAxBApE,EAAAA,EAAE,CAACC,EAAH,CAAMC,OAAN,CAAcC,KAAd,CAAoBC,MAApB,CAA2B4B,QAA3B,CAAoCpC,aAApC,GAAoDA,aAApD",
  "sourcesContent": [
    "/* Sequence.js \n * \n * copyright (c) 2010-2022, Christian Mayer and the CometVisu contributers.\n * \n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n */\n\n\n/**\n * a single sequence.\n * may be recursive\n */\nqx.Class.define('cv.ui.manager.model.schema.Sequence', {\n  extend: cv.ui.manager.model.schema.Base,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  construct: function (node, schema) {\n    this.base(arguments, node, schema);\n    this.parse();\n  },\n\n  /*\n  ***********************************************\n    PROPERTIES\n  ***********************************************\n  */\n  properties: {\n    type: {\n      refine: true,\n      init: 'sequence'\n    },\n    elementsHaveOrder: {\n      refine: true,\n      init: true\n    }\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n\n    /**\n     * parse a list of elements in this group.\n     * Group is allowed (all|choice|sequence)? as per the definition.\n     * We do all of those (except for 'all')\n     */\n    parse: function () {\n      this.base(arguments);\n      const schema = this.getSchema();\n\n      // for a sequence, we need to keep the order of the elements\n      // so we have to use a 'mixed' approach in reading them\n      const subNodes = Array.from(this.getNode().children);\n\n      subNodes.forEach(subNode => {\n        let subObject;\n\n        switch (subNode.nodeName) {\n          case 'xsd:element':\n          case 'element':\n            subObject = new cv.ui.manager.model.schema.Element(subNode, schema);\n            // sequences' children are non-sortable\n            subObject.setSortable(false);\n            this._allowedElements[subObject.getName()] = subObject;\n            break;\n          case 'xsd:choice':\n          case 'choice':\n            subObject = new cv.ui.manager.model.schema.Choice(subNode, schema);\n            this._subGroupings.push(subObject);\n            break;\n          case 'xsd:sequence':\n          case 'sequence':\n            subObject = new cv.ui.manager.model.schema.Sequence(subNode, schema);\n            this._subGroupings.push(subObject);\n            break;\n          case 'xsd:group':\n          case 'group':\n            subObject = new cv.ui.manager.model.schema.Group(subNode, schema);\n            this._subGroupings.push(subObject);\n            break;\n          case 'xsd:any':\n          case 'any':\n            subObject = new cv.ui.manager.model.schema.Any(subNode, schema);\n            this._subGroupings.push(subObject);\n            break;\n        }\n\n        this._sortedContent.push(subObject);\n      });\n      this._allowedElements['#comment'] = this.getSchema().getCommentNodeSchemaElement();\n    },\n\n    /**\n     * get a regex (string) describing this choice\n     *\n     * @param   separator   string  the string used to separate different elements, e.g. ';'\n     * @param   nocapture   bool    when set to true non capturing groups are used\n     * @return  string  regex\n     */\n    getRegex: function (separator, nocapture) {\n      if (this._regexCache !== null) {\n        // use the cache if primed\n        return this._regexCache;\n      }\n\n      let regexString = '(';\n\n      // create list of allowed elements\n      if (nocapture) {\n        regexString += '?:';\n      }\n\n      const elementRegexes = [];\n\n      // this goes over ALL elements AND sub-groupings\n      this._sortedContent.forEach(element => {\n        elementRegexes.push(element.getRegex(separator, nocapture));\n      });\n\n      regexString += elementRegexes.join('');\n\n      regexString += ')';\n\n\n      // append bounds to regex\n      regexString += '{';\n      const bounds = this.getBounds();\n      regexString += bounds.min === undefined ? 1 : bounds.min;\n      regexString += ',';\n      if (bounds.max !== Number.POSITIVE_INFINITY) {\n        regexString += bounds.max === undefined ? 1 : bounds.max;\n      }\n      regexString += '}';\n\n      // fill the cache\n      this._regexCache = regexString;\n\n      // thats about it.\n      return regexString;\n    },\n\n    getBoundsForElementName: function (childName) {\n      // we are a sequence-element; there is actually a lot of sayings ...\n      if (typeof this._allowedElements[childName] !== 'undefined') {\n        const elementBounds = this._allowedElements[childName].getBounds();\n        const sequenceBounds = this.getBounds();\n\n        const resultBounds = {\n          min: 1,\n          max: 1\n        };\n\n        // if it is bounded, we must duplicate element and sequence bounds\n        // (an element may appear as often as the number of sequences times the number of elements\n        // in each sequence - roughly)\n        if (Object.prototype.hasOwnProperty.call(elementBounds, 'min')) {\n          resultBounds.min = elementBounds.min;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(sequenceBounds, 'min') && !isNaN(sequenceBounds.min)) {\n          resultBounds.min *= sequenceBounds.min;\n        }\n\n        if (elementBounds.max === Number.POSITIVE_INFINITY || sequenceBounds.max === Number.POSITIVE_INFINITY) {\n          resultBounds.max = Number.POSITIVE_INFINITY;\n        } else {\n          if (Object.prototype.hasOwnProperty.call(elementBounds, 'max')) {\n            resultBounds.max = elementBounds.max;\n          }\n\n          if (Object.prototype.hasOwnProperty.call(sequenceBounds, 'max') && !isNaN(sequenceBounds.max)) {\n            resultBounds.max *= sequenceBounds.max;\n          }\n        }\n\n        return resultBounds;\n      }\n\n      let childBounds;\n\n      let tmpBounds;\n\n      for (let i = 0; i < this._subGroupings.length; ++i) {\n        tmpBounds = this._subGroupings[i].getBoundsForElementName(childName);\n\n        if (undefined !== tmpBounds) {\n          // once we find the first set of bounds, we return that\n          childBounds = tmpBounds;\n          break;\n        }\n      }\n\n      return childBounds;\n    },\n\n    /**\n     * get the sorting of the allowed elements\n     *\n     * Warning: this only works if any element can have only ONE position in the parent.\n     * @param sortNumber  integer the sortNumber of a parent (only used when recursive)\n     * @return object     list of allowed elements, with their sort-number as value\n     */\n    getAllowedElementsSorting: function (sortNumber) {\n      const namesWithSorting = {};\n\n      this._sortedContent.forEach((item, i) => {\n        let mySortNumber = i;\n        if (sortNumber !== undefined) {\n          mySortNumber = sortNumber + '.' + i;\n        }\n\n        if (item.getType() === 'element') {\n          namesWithSorting[item.getName()] = mySortNumber;\n        } else {\n          // go recursive\n          const subSortedElements = item.getAllowedElementsSorting(mySortNumber);\n          Object.assign(namesWithSorting, subSortedElements);\n        }\n      });\n\n      return namesWithSorting;\n    }\n  }\n});\n"
  ]
}