{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "cv",
    "ui",
    "manager",
    "model",
    "schema",
    "Base",
    "include",
    "MAnnotation",
    "construct",
    "node",
    "constructor",
    "call",
    "parse",
    "statics",
    "getElementName",
    "e",
    "hasAttribute",
    "getAttribute",
    "refName",
    "ref",
    "getReferencedNode",
    "length",
    "Error",
    "getTypeNode",
    "type",
    "match",
    "querySelector",
    "sortChildNodes",
    "sorting",
    "a",
    "b",
    "aSortvalue",
    "name",
    "bSortvalue",
    "undefined",
    "toString",
    "aSortvaluesList",
    "split",
    "bSortvaluesList",
    "i",
    "properties",
    "refine",
    "init",
    "check",
    "defaultValue",
    "nullable",
    "sortable",
    "event",
    "mixed",
    "members",
    "__allowedContentLoaded",
    "__allowedContent",
    "__allowedAttributes",
    "__textNodeSchemaElement",
    "_type",
    "Element",
    "superclass",
    "prototype",
    "getNode",
    "getSchema",
    "setName",
    "setDefaultValue",
    "setMixed",
    "getAllowedContent",
    "allowedContent",
    "_grouping",
    "_text",
    "querySelectorAll",
    "SimpleType",
    "tmpDOMGrouping",
    "nodeName",
    "Choice",
    "Sequence",
    "Group",
    "Any",
    "children",
    "Array",
    "from",
    "forEach",
    "sub",
    "subElement",
    "getName",
    "getAllowedAttributes",
    "_this",
    "allowedAttributes",
    "attributes",
    "attributeGroups",
    "aGroup",
    "attributeGroup",
    "child",
    "push",
    "attr",
    "attribute",
    "Attribute",
    "areChildrenSortable",
    "getElementsHaveOrder",
    "getRequiredElements",
    "getAllowedElements",
    "excludeComment",
    "allowedElements",
    "Object",
    "assign",
    "textOnly",
    "isMixed",
    "getTextNodeSchemaElement",
    "getCommentNodeSchemaElement",
    "getAllowedElementsSorting",
    "getFirstLevelElementSorting",
    "allowedSorting",
    "keys",
    "sort",
    "parseInt",
    "getChildBounds",
    "hasMultiLevelBounds",
    "getBounds",
    "getBoundsForElementName",
    "childName",
    "isTextContentAllowed",
    "isTextContentRequired",
    "isValueValid",
    "isChildElementAllowed",
    "isElementAllowed",
    "getSchemaElementForElementName",
    "elementName",
    "tmpXML",
    "getSchemaDOM",
    "createElement",
    "setAttribute",
    "value",
    "getRegex",
    "separator",
    "nocapture",
    "regexString",
    "boundsMin",
    "boundsMax",
    "bounds",
    "min",
    "max",
    "Number",
    "POSITIVE_INFINITY",
    "getChildrenRegex",
    "destruct",
    "_disposeMap",
    "_disposeObjects"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/model/schema/Element.js"
  ],
  "sourcesContent": [
    "/* Element.js\n *\n * copyright (c) 2010-2022, Christian Mayer and the CometVisu contributers.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n */\n\n/**\n * a single element from the schema\n */\nqx.Class.define('cv.ui.manager.model.schema.Element', {\n  extend: cv.ui.manager.model.schema.Base,\n  include: cv.ui.manager.model.schema.MAnnotation,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  construct(node, schema) {\n    super(node, schema);\n    this.parse();\n  },\n\n  /*\n  ***********************************************\n    STATICS\n  ***********************************************\n  */\n  statics: {\n    /**\n     * Get the name of a schema-element\n     * @param e object  element to find the name of\n     * @param schema\n     * @return  string          name of the element\n     * @throws  if the name can not be found\n     */\n    getElementName(e, schema) {\n      if (e.hasAttribute('name')) {\n        return e.getAttribute('name');\n      }\n\n      if (e.hasAttribute('ref')) {\n        // it's a ref, seek other element!\n        const refName = e.getAttribute('ref');\n        const ref = schema.getReferencedNode('element', refName);\n\n        if (ref.length !== 1) {\n          throw new Error('schema/xsd appears to be invalid, can not find element ' + refName);\n        }\n\n        return ref.getAttribute('name');\n      }\n\n      return 'unknown';\n    },\n\n    /**\n     * find the type-node for this element\n     * @param node\n     * @param schema\n     * @return  object  object of the type-Node\n     */\n    getTypeNode(node, schema) {\n      let type;\n\n      if (node.hasAttribute('type')) {\n        if (node.getAttribute('type').match(/^xsd:/)) {\n          // if it starts with xsd:, it's actually a simple type\n          // does not start with\n          type = node;\n        } else {\n          // otherwise, the element is linked to a complexType\n          type = schema.getTypeNode('complex', node.getAttribute('type'));\n        }\n      } else if (node.hasAttribute('ref')) {\n        // the link is a reference to another element, which means it does not even have it's own name.\n        // this one is most certainly deprecated, as we do not have many root-level-elements, and only those can\n        // be ref'ed\n      } else {\n        // the element is it's own type\n        type = node.querySelector(':scope > complexType');\n      }\n\n      return type;\n    },\n\n    sortChildNodes(sorting) {\n      /**\n       * the comparison-function that helps the sorting\n       *\n       * @param   a   mixed   whatever sort gives us\n       * @param   b   mixed   whatever sort gives us\n       * @return  integer     -1, 0, 1 - depending on sort-order\n       */\n      return function (a, b) {\n        let aSortvalue = sorting[a.name];\n        let bSortvalue = sorting[b.name];\n\n        if (aSortvalue === undefined || bSortvalue === undefined) {\n          // undefined means: no sorting available\n          return 0;\n        }\n\n        if (aSortvalue === bSortvalue) {\n          // identical means 'no sorting necessary'\n          return 0;\n        }\n\n        // we need to go through the complete list of values the sorting is composed of,\n        // to find the first one that distinguishes a from b\n\n        // first, typecast to string!\n        if (typeof aSortvalue !== 'string') {\n          aSortvalue = aSortvalue.toString();\n        }\n        if (typeof bSortvalue !== 'string') {\n          bSortvalue = bSortvalue.toString();\n        }\n\n        let aSortvaluesList = aSortvalue.split('.');\n        let bSortvaluesList = bSortvalue.split('.');\n\n        for (let i = 0; i < aSortvaluesList.length; ++i) {\n          if (aSortvaluesList[i] < bSortvaluesList[i]) {\n            return -1;\n          } else if (aSortvaluesList[i] > bSortvaluesList[i]) {\n            return 1;\n          }\n        }\n\n        // if nothing else matched, then they are treated equal\n        return 0;\n      };\n    }\n  },\n\n  /*\n  ***********************************************\n    PROPERTIES\n  ***********************************************\n  */\n  properties: {\n    type: {\n      refine: true,\n      init: 'element'\n    },\n\n    name: {\n      check: 'String',\n      init: ''\n    },\n\n    defaultValue: {\n      check: 'String',\n      nullable: true\n    },\n\n    sortable: {\n      check: 'Boolean',\n      init: false,\n      event: 'changeSortable'\n    },\n\n    mixed: {\n      check: 'Boolean',\n      init: false\n    }\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n    __allowedContentLoaded: false,\n    __allowedContent: null,\n    __allowedAttributes: null,\n    __textNodeSchemaElement: null,\n\n    /**\n     * get and set the type-node for the element\n     * @var object  Type-Node (most certainly a complexType)\n     */\n    _type: null,\n\n    parse() {\n      super.parse();\n      const node = this.getNode();\n      const schema = this.getSchema();\n\n      this._type = cv.ui.manager.model.schema.Element.getTypeNode(node, schema);\n      this.setName(cv.ui.manager.model.schema.Element.getElementName(node, schema));\n\n      if (node.hasAttribute('default')) {\n        this.setDefaultValue(node.getAttribute('default'));\n      }\n      this.setMixed(this._type.hasAttribute('mixed') && this._type.getAttribute('mixed') === 'true');\n    },\n\n    /**\n     * get a list of allowed elements for this element\n     *\n     * @return  object  object of SchemaElement-elements, key is the name\n     */\n    getAllowedContent() {\n      if (this.__allowedContent !== null) {\n        // if we have parsed this already, we can simply return the 'cache'\n        return this.__allowedContent;\n      }\n      const schema = this.getSchema();\n\n      const allowedContent = {\n        _grouping: undefined,\n        _text: false\n      };\n\n      // allowed sub-elements\n      // can be either simpleContent, or (choice|sequence|group|all)?\n      // 'all' is not supported yet.\n\n      if (this._type.querySelectorAll(':scope > simpleContent').length > 0) {\n        // it's simpleContent? Then it's either extension or restriction\n        // anyways, we will handle it, as if it were a simpleType\n        allowedContent._text = new cv.ui.manager.model.schema.SimpleType(\n          this._type.querySelector(':scope > simpleContent'),\n          schema\n        );\n      } else if (\n        this._type.querySelectorAll('complexType > choice, complexType> sequence, complexType > group').length > 0\n      ) {\n        // we have a choice, group or sequence. great\n        // as per the W3C, only one of these may appear per element/type\n\n        let tmpDOMGrouping = this._type.querySelector(\n          'complexType > choice, complexType > sequence, complexType > group'\n        );\n\n        // create the appropriate Schema*-object and append it to this very element\n        switch (tmpDOMGrouping.nodeName) {\n          case 'xsd:choice':\n          case 'choice':\n            allowedContent._grouping = new cv.ui.manager.model.schema.Choice(tmpDOMGrouping, schema);\n\n            break;\n          case 'xsd:sequence':\n          case 'sequence':\n            allowedContent._grouping = new cv.ui.manager.model.schema.Sequence(tmpDOMGrouping, schema);\n\n            break;\n          case 'xsd:group':\n          case 'group':\n            allowedContent._grouping = new cv.ui.manager.model.schema.Group(tmpDOMGrouping, schema);\n\n            break;\n          case 'xsd:any':\n          case 'any':\n            allowedContent._grouping = new cv.ui.manager.model.schema.Any(tmpDOMGrouping, schema);\n\n            break;\n        }\n      } else if (this._type.hasAttribute('type') && this._type.getAttribute('type').match(/^xsd:/)) {\n        // this is a really simple node that defines its own baseType\n        allowedContent._text = new cv.ui.manager.model.schema.SimpleType(this._type, schema);\n      } else {\n        // no type, no children, no choice - this is an element with NO allowed content/children\n        this.__allowedContent = allowedContent;\n        return allowedContent;\n      }\n\n      const children = Array.from(this._type.querySelectorAll(':scope > element'));\n\n      children.forEach(sub => {\n        const subElement = new cv.ui.manager.model.schema.Element(sub, schema);\n        allowedContent[subElement.getName()] = subElement;\n      });\n\n      // fill the cache\n      this.__allowedContent = allowedContent;\n\n      return allowedContent;\n    },\n\n    /**\n     * get and set the list of allowed attributes\n     * @var array   List of SchemaAttribute-objects\n     */\n    getAllowedAttributes() {\n      if (this.__allowedAttributes === null) {\n        const allowedAttributes = {};\n\n        // allowed attributes\n        const attributes = Array.from(\n          this._type.querySelectorAll(':scope > attribute, :scope > simpleContent > extension > attribute')\n        );\n\n        // now add any attribute that comes from an attribute-group\n        const attributeGroups = Array.from(\n          this._type.querySelectorAll(':scope > attributeGroup, :scope > simpleContent > extension > attributeGroup')\n        );\n\n        attributeGroups.forEach(aGroup => {\n          // get get group itself, by reference if necessary\n          // then extract all attributes, and add them to the list of already know attributes\n\n          let attributeGroup = {};\n          if (aGroup.hasAttribute('ref')) {\n            // we do have a reffed group\n            attributeGroup = this.getSchema().getReferencedNode('attributeGroup', aGroup.getAttribute('ref'));\n          } else {\n            attributeGroup = aGroup;\n          }\n\n          Array.from(attributeGroup.querySelectorAll(':scope > attribute')).forEach(child => {\n            attributes.push(child);\n          });\n        });\n\n        // convert all allowed attributes to a more object-oriented approach\n        attributes.forEach(attr => {\n          const attribute = new cv.ui.manager.model.schema.Attribute(attr, this.getSchema());\n\n          allowedAttributes[attribute.getName()] = attribute;\n        });\n\n        this.__allowedAttributes = allowedAttributes;\n      }\n      return this.__allowedAttributes;\n    },\n\n    /**\n     * are this elements children sortable? this is not the case if a sequence is used, e.g.\n     *\n     * @return  boolean     are children sortable?\n     */\n    areChildrenSortable() {\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping === undefined) {\n        return true;\n      }\n\n      // the inverse of \"do the elements have a given order?\"\n      return !allowedContent._grouping.getElementsHaveOrder();\n    },\n\n    /**\n     * get a list of required elements.\n     * if an element is required multiple times, it is listed multiple times\n     *\n     * @return  array   list of required elements\n     */\n    getRequiredElements() {\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping !== undefined) {\n        // we do have a grouping as a child\n        return allowedContent._grouping.getRequiredElements();\n      }\n\n      // there is no grouping, hence no elements defined as children\n      return [];\n    },\n\n    /**\n     * get a list of all allowed elements for this element\n     * @param excludeComment\n     * @return  object  list of SchemaElement-elements, key is the name\n     */\n    getAllowedElements(excludeComment) {\n      const allowedContent = this.getAllowedContent();\n\n      const allowedElements = {};\n      if (allowedContent._grouping !== undefined) {\n        Object.assign(allowedElements, allowedContent._grouping.getAllowedElements());\n      }\n\n      let textOnly = false;\n      if (this.isMixed()) {\n        // mixed elements are allowed to have #text-nodes\n        allowedElements['#text'] = this.getSchema().getTextNodeSchemaElement();\n      } else if (allowedContent._text && allowedContent._grouping === undefined) {\n        // text only\n        allowedElements['#text'] = allowedContent._text;\n        textOnly = true;\n      }\n\n      if (!textOnly && !excludeComment) {\n        // although its basically allowed to add comments in a text-only content, we do not allow it\n        allowedElements['#comment'] = this.getSchema().getCommentNodeSchemaElement();\n      }\n\n      return allowedElements;\n    },\n\n    /**\n     * get the sorting of the allowed elements.\n     *\n     * @return  object              list of allowed elements, with their sort-number as value\n     */\n    getAllowedElementsSorting() {\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping !== undefined) {\n        return allowedContent._grouping.getAllowedElementsSorting();\n      }\n\n      return undefined;\n    },\n\n    getFirstLevelElementSorting() {\n      const allowedSorting = this.getAllowedElementsSorting();\n      if (allowedSorting) {\n        // we only care about the first level here\n        Object.keys(allowedSorting).forEach(name => {\n          let sort = allowedSorting[name];\n          if (typeof sort === 'string') {\n            sort = parseInt(sort.split('.')[0]);\n          }\n          allowedSorting[name] = sort;\n        });\n      }\n      return allowedSorting;\n    },\n\n    /**\n     * get the bounds for this elements children (as defined by a choice)\n     *\n     * @return  object  bounds ({min: x, max: y})\n     */\n    getChildBounds() {\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping === undefined) {\n        // no choice = no idea about bounds\n        return undefined;\n      }\n\n      if (allowedContent._grouping.hasMultiLevelBounds() === true) {\n        // if our choice has sub-choices, then we have not fucking clue about bounds (or we can not process them)\n        return undefined;\n      }\n\n      return allowedContent._grouping.getBounds();\n    },\n\n    /**\n     * get the bounds for a specific element-name\n     * will go through all of the groupings-tree to find out, just how many elements of this may appear\n     *\n     * @param   childName   string  name of the child-to-be\n     * @return  object              {min: x, max: y}\n     */\n    getBoundsForElementName(childName) {\n      const allowedContent = this.getAllowedContent();\n\n      return allowedContent._grouping.getBoundsForElementName(childName);\n    },\n\n    /**\n     * check if a text-only-node is allowed ...\n     *\n     * @return  boolean\n     */\n    isTextContentAllowed() {\n      if (this.isMixed()) {\n        // mixed means that we allow for text-content\n        return true;\n      }\n\n      // first, get a list of allowed content (don't worry, it's cached)\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._text !== undefined && allowedContent._text !== false) {\n        // if _text is defined and there, we assume that text-content is allowed\n        return true;\n      }\n\n      // had no reason to allow text-content, so gtfoml!\n      return false;\n    },\n\n    isTextContentRequired() {\n      if (this.isTextContentAllowed()) {\n        return !this.isMixed() && !this.getAllowedContent()._text.isValueValid('');\n      }\n      return false;\n    },\n\n    /**\n     * check if an element (specified by its name) is allowed as one of our immediate children\n     * Goes recursive if we have choices.\n     *\n     * @param   child   string  name of the element we want to check\n     * @return  boolean         is this element allowed?\n     */\n    isChildElementAllowed(child) {\n      if (child === '#text' || child === '#cdata-section') {\n        // text-nodes are somewhat special :)\n        return this.isTextContentAllowed();\n      } else if (child === '#comment') {\n        return true;\n      }\n\n      // first, get a list of allowed content (don't worry, it's cached)\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping === undefined) {\n        // when there is no choice, then there is no allowed element\n        return false;\n      }\n      // see, if this child is allowed with our choice\n      return allowedContent._grouping.isElementAllowed(child);\n    },\n\n    /**\n     * get the SchemaElement-object for a certain element-name.\n     * May return undefined if no element is found, so you might be interested in checking isElementAllowed beforehand.\n     *\n     * @param   elementName string  name of the element to find the SchemaElement for\n     * @return  object              SchemaElement-object, or undefined if none is found\n     */\n    getSchemaElementForElementName(elementName) {\n      // first, get a list of allowed content (don't worry, it's cached)\n      const allowedContent = this.getAllowedContent();\n\n      if (elementName === '#text' || elementName === '#cdata-section') {\n        // no special handling for mixed nodes, they do have a #text-SchemaElement already!\n        // text-nodes may be allowed. we will see ...\n        if (this.isTextContentAllowed() === false) {\n          return undefined;\n        }\n\n        if (!this.__textNodeSchemaElement) {\n          const tmpXML = this.getSchema().getSchemaDOM().createElement('element');\n          tmpXML.setAttribute('name', '#text');\n          tmpXML.setAttribute('type', 'xsd:string');\n          this.__textNodeSchemaElement = new cv.ui.manager.model.schema.Element(tmpXML, this.getSchema());\n\n          if (allowedContent._text) {\n            this.__textNodeSchemaElement.getAllowedContent()._text = allowedContent._text;\n          } else if (this.isMixed()) {\n            this.__textNodeSchemaElement.getAllowedContent._text = this.getSchema().getTextNodeSchemaElement();\n          }\n        }\n        return this.__textNodeSchemaElement;\n      } else if (elementName === '#comment') {\n        // comments are always allowed\n        return this.getSchema().getCommentNodeSchemaElement();\n      }\n\n      if (allowedContent._grouping === undefined) {\n        // when there is no choice, then there is no allowed element\n        return undefined;\n      }\n\n      // go over our choice, if the element is allowed with it\n      if (allowedContent._grouping.isElementAllowed(elementName)) {\n        // only look in this tree, if the element is allowed there.\n        return allowedContent._grouping.getSchemaElementForElementName(elementName);\n      }\n\n      return undefined;\n    },\n\n    /**\n     * return the DOM this Schema is based on\n     *\n     * @return  object  DOM of $xsd\n     */\n    getSchemaDOM() {\n      return this.getSchema().getSchemaDOM();\n    },\n\n    /**\n     * check if a given value is valid for this element\n     *\n     * @param   value   string  value to check\n     * @return  boolean         is it valid?\n     */\n    isValueValid(value) {\n      if (this.isTextContentAllowed() === false) {\n        // if no text-content is allowed, then it can not be valid\n        return false;\n      }\n\n      if (this.isMixed()) {\n        // mixed is always good!\n        return true;\n      }\n\n      const allowedContent = this.getAllowedContent();\n\n      return allowedContent._text.isValueValid(value);\n    },\n\n    /**\n     * create and retrieve the part of a regular expression which describes this very element\n     *\n     * @param   separator   string  the string used to separate different elements, e.g. ';'\n     * @param   nocapture   bool    when set to true non capturing groups are used\n     * @return  string\n     */\n    getRegex(separator, nocapture) {\n      if (typeof separator === 'undefined' || separator === undefined) {\n        // default to an empty string\n        separator = '';\n      }\n\n      let regexString = '(';\n      if (nocapture) {\n        regexString += '?:';\n      }\n\n      // start with the name of the element\n      regexString += this.getName() + separator + ')';\n\n      // append bounds\n      let boundsMin = '';\n      let boundsMax = '';\n      const bounds = this.getBounds();\n      if (bounds.min !== undefined) {\n        boundsMin = bounds.min;\n      }\n\n      if (bounds.max !== undefined) {\n        if (bounds.max !== Number.POSITIVE_INFINITY) {\n          boundsMax = bounds.max;\n        }\n      }\n\n      if (boundsMin !== '' || boundsMax !== '') {\n        // append bounds to the regex-string\n        regexString += '{' + boundsMin + ',' + boundsMax + '}';\n      }\n\n      // and thats all\n      return regexString;\n    },\n\n    /**\n     * create a full-blown regular expression that describes this elements immediate children\n     * @param separator   string  the string used to separate different elements, e.g. ';'\n     * @param nocapture\n     * @return  string              the regular expression\n     */\n    getChildrenRegex(separator, nocapture) {\n      if (typeof separator == 'undefined' || separator === undefined) {\n        // default to an empty string\n        separator = '';\n      }\n\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping === undefined) {\n        // not really something to match\n        return '^';\n      }\n\n      return allowedContent._grouping.getRegex(separator, nocapture);\n    }\n  },\n\n  /*\n  ***********************************************\n    DESTRUCTOR\n  ***********************************************\n  */\n  destruct() {\n    this._disposeMap('__allowedAttributes');\n    this._disposeMap('__allowedContent');\n    this._disposeObjects('__textNodeSchemaElement');\n  }\n});\n"
  ],
  "mappings": "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"
}