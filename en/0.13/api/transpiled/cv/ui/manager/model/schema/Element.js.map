{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "cv",
    "ui",
    "manager",
    "model",
    "schema",
    "Base",
    "include",
    "MAnnotation",
    "construct",
    "node",
    "constructor",
    "call",
    "parse",
    "statics",
    "getElementName",
    "e",
    "hasAttribute",
    "getAttribute",
    "refName",
    "ref",
    "getReferencedNode",
    "length",
    "Error",
    "getTypeNode",
    "type",
    "match",
    "localName",
    "querySelector",
    "sortChildNodes",
    "sorting",
    "a",
    "b",
    "aSortvalue",
    "name",
    "bSortvalue",
    "undefined",
    "toString",
    "aSortvaluesList",
    "split",
    "bSortvaluesList",
    "i",
    "properties",
    "refine",
    "init",
    "check",
    "defaultValue",
    "nullable",
    "sortable",
    "event",
    "mixed",
    "members",
    "__allowedContentLoaded",
    "__allowedContent",
    "__allowedAttributes",
    "__textNodeSchemaElement",
    "__extendedElement",
    "_type",
    "Element",
    "superclass",
    "prototype",
    "getNode",
    "getSchema",
    "setName",
    "setDefaultValue",
    "setMixed",
    "getExtendedElement",
    "querySelectorAll",
    "complex",
    "extension",
    "baseType",
    "extendedNode",
    "getAllowedContent",
    "allowedContent",
    "_grouping",
    "_text",
    "SimpleType",
    "_parseGrouping",
    "complexType",
    "children",
    "Array",
    "from",
    "forEach",
    "sub",
    "subElement",
    "getName",
    "tmpDOMGrouping",
    "nodeName",
    "Choice",
    "Sequence",
    "Group",
    "Any",
    "getAllowedAttributes",
    "_this",
    "allowedAttributes",
    "attributes",
    "attributeGroups",
    "extendedElement",
    "Object",
    "assign",
    "_iterator",
    "_createForOfIteratorHelper",
    "_step",
    "s",
    "n",
    "done",
    "attr",
    "value",
    "push",
    "err",
    "f",
    "_iterator2",
    "_step2",
    "aGroup",
    "attributeGroup",
    "child",
    "attribute",
    "Attribute",
    "areChildrenSortable",
    "getElementsHaveOrder",
    "getRequiredElements",
    "required",
    "_iterator3",
    "_step3",
    "r",
    "_iterator4",
    "_step4",
    "getAllowedElements",
    "excludeComment",
    "allowedElements",
    "textOnly",
    "isMixed",
    "getTextNodeSchemaElement",
    "getCommentNodeSchemaElement",
    "getAllowedElementsSorting",
    "getFirstLevelElementSorting",
    "allowedSorting",
    "keys",
    "sort",
    "parseInt",
    "getChildBounds",
    "hasMultiLevelBounds",
    "getBounds",
    "getBoundsForElementName",
    "childName",
    "isTextContentAllowed",
    "isTextContentRequired",
    "isValueValid",
    "isChildElementAllowed",
    "isElementAllowed",
    "getSchemaElementForElementName",
    "elementName",
    "tmpXML",
    "getSchemaDOM",
    "createElement",
    "setAttribute",
    "getRegex",
    "separator",
    "nocapture",
    "regexString",
    "boundsMin",
    "boundsMax",
    "bounds",
    "min",
    "max",
    "Number",
    "POSITIVE_INFINITY",
    "getChildrenRegex",
    "destruct",
    "_disposeMap",
    "_disposeObjects"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/model/schema/Element.js"
  ],
  "sourcesContent": [
    "/* Element.js\n *\n * copyright (c) 2010-2022, Christian Mayer and the CometVisu contributers.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n */\n\n/**\n * a single element from the schema\n */\nqx.Class.define('cv.ui.manager.model.schema.Element', {\n  extend: cv.ui.manager.model.schema.Base,\n  include: cv.ui.manager.model.schema.MAnnotation,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  construct(node, schema) {\n    super(node, schema);\n    this.parse();\n  },\n\n  /*\n  ***********************************************\n    STATICS\n  ***********************************************\n  */\n  statics: {\n    /**\n     * Get the name of a schema-element\n     * @param e object  element to find the name of\n     * @param schema\n     * @return  string          name of the element\n     * @throws  if the name can not be found\n     */\n    getElementName(e, schema) {\n      if (e.hasAttribute('name')) {\n        return e.getAttribute('name');\n      }\n\n      if (e.hasAttribute('ref')) {\n        // it's a ref, seek other element!\n        const refName = e.getAttribute('ref');\n        const ref = schema.getReferencedNode('element', refName);\n\n        if (ref.length !== 1) {\n          throw new Error('schema/xsd appears to be invalid, can not find element ' + refName);\n        }\n\n        return ref.getAttribute('name');\n      }\n\n      return 'unknown';\n    },\n\n    /**\n     * find the type-node for this element\n     * @param node\n     * @param schema\n     * @return  object  object of the type-Node\n     */\n    getTypeNode(node, schema) {\n      let type;\n\n      if (node.hasAttribute('type')) {\n        if (node.getAttribute('type').match(/^xsd:/)) {\n          // if it starts with xsd:, it's actually a simple type\n          // does not start with\n          type = node;\n        } else {\n          // otherwise, the element is linked to a complexType\n          type = schema.getTypeNode('complex', node.getAttribute('type'));\n        }\n      } else if (node.hasAttribute('ref')) {\n        // the link is a reference to another element, which means it does not even have it's own name.\n        // this one is most certainly deprecated, as we do not have many root-level-elements, and only those can\n        // be ref'ed\n      } else if (node.localName === 'complexType') {\n        // the element is a type\n        type = node;\n      } else {\n        // the element is it's own type\n        type = node.querySelector(':scope > complexType');\n      }\n\n      return type;\n    },\n\n    sortChildNodes(sorting) {\n      /**\n       * the comparison-function that helps the sorting\n       *\n       * @param   a   mixed   whatever sort gives us\n       * @param   b   mixed   whatever sort gives us\n       * @return  integer     -1, 0, 1 - depending on sort-order\n       */\n      return function (a, b) {\n        let aSortvalue = sorting[a.name];\n        let bSortvalue = sorting[b.name];\n\n        if (aSortvalue === undefined || bSortvalue === undefined) {\n          // undefined means: no sorting available\n          return 0;\n        }\n\n        if (aSortvalue === bSortvalue) {\n          // identical means 'no sorting necessary'\n          return 0;\n        }\n\n        // we need to go through the complete list of values the sorting is composed of,\n        // to find the first one that distinguishes a from b\n\n        // first, typecast to string!\n        if (typeof aSortvalue !== 'string') {\n          aSortvalue = aSortvalue.toString();\n        }\n        if (typeof bSortvalue !== 'string') {\n          bSortvalue = bSortvalue.toString();\n        }\n\n        let aSortvaluesList = aSortvalue.split('.');\n        let bSortvaluesList = bSortvalue.split('.');\n\n        for (let i = 0; i < aSortvaluesList.length; ++i) {\n          if (aSortvaluesList[i] < bSortvaluesList[i]) {\n            return -1;\n          } else if (aSortvaluesList[i] > bSortvaluesList[i]) {\n            return 1;\n          }\n        }\n\n        // if nothing else matched, then they are treated equal\n        return 0;\n      };\n    }\n  },\n\n  /*\n  ***********************************************\n    PROPERTIES\n  ***********************************************\n  */\n  properties: {\n    type: {\n      refine: true,\n      init: 'element'\n    },\n\n    name: {\n      check: 'String',\n      init: ''\n    },\n\n    defaultValue: {\n      check: 'String',\n      nullable: true\n    },\n\n    sortable: {\n      check: 'Boolean',\n      init: false,\n      event: 'changeSortable'\n    },\n\n    mixed: {\n      check: 'Boolean',\n      init: false\n    }\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n    __allowedContentLoaded: false,\n    __allowedContent: null,\n    __allowedAttributes: null,\n    __textNodeSchemaElement: null,\n    __extendedElement: undefined,\n\n    /**\n     * get and set the type-node for the element\n     * @var object  Type-Node (most certainly a complexType)\n     */\n    _type: null,\n\n    parse() {\n      super.parse();\n      const node = this.getNode();\n      const schema = this.getSchema();\n\n      this._type = cv.ui.manager.model.schema.Element.getTypeNode(node, schema);\n      this.setName(cv.ui.manager.model.schema.Element.getElementName(node, schema));\n\n      if (node.hasAttribute('default')) {\n        this.setDefaultValue(node.getAttribute('default'));\n      }\n      this.setMixed(this._type.hasAttribute('mixed') && this._type.getAttribute('mixed') === 'true');\n    },\n\n    getExtendedElement() {\n      if (this.__extendedElement === undefined) {\n        this.__extendedElement = null;\n        if (this._type.querySelectorAll(':scope > complexContent').length > 0) {\n          const complex = this._type.querySelector(':scope > complexContent');\n          const extension = complex.querySelector(':scope > extension');\n          if (extension) {\n            const schema = this.getSchema();\n            const baseType = extension.getAttribute('base');\n            const extendedNode = schema.getReferencedNode('complexType', baseType);\n            if (extendedNode) {\n              this.__extendedElement = new cv.ui.manager.model.schema.Element(extendedNode, schema);\n            }\n          }\n        }\n      }\n      return this.__extendedElement;\n    },\n\n    /**\n     * get a list of allowed elements for this element\n     *\n     * @return  object  object of SchemaElement-elements, key is the name\n     */\n    getAllowedContent() {\n      if (this.__allowedContent !== null) {\n        // if we have parsed this already, we can simply return the 'cache'\n        return this.__allowedContent;\n      }\n      const schema = this.getSchema();\n\n      const allowedContent = {\n        _grouping: undefined,\n        _text: false\n      };\n\n      // allowed sub-elements\n      // can be either simpleContent, or (choice|sequence|group|all)?\n      // 'all' is not supported yet.\n\n      if (this._type.querySelectorAll(':scope > simpleContent').length > 0) {\n        // it's simpleContent? Then it's either extension or restriction\n        // anyway, we will handle it, as if it were a simpleType\n        allowedContent._text = new cv.ui.manager.model.schema.SimpleType(\n          this._type.querySelector(':scope > simpleContent'),\n          schema\n        );\n      } else if (this._type.querySelectorAll(':scope > complexContent').length > 0) {\n        const complex = this._type.querySelector(':scope > complexContent');\n        const extension = complex.querySelector(':scope > extension');\n        if (extension) {\n          allowedContent._grouping = this._parseGrouping(extension, schema);\n        }\n      } else if (\n        this._type.querySelectorAll('complexType > choice, complexType > sequence, complexType > group').length > 0\n      ) {\n        // we have a choice, group or sequence. great\n        // as per the W3C, only one of these may appear per element/type\n        let complexType = this._type.localName === 'complexType' ? this._type : this._type.querySelector('complexType');\n        allowedContent._grouping = this._parseGrouping(complexType, schema);\n      } else if (this._type.hasAttribute('type') && this._type.getAttribute('type').match(/^xsd:/)) {\n        // this is a really simple node that defines its own baseType\n        allowedContent._text = new cv.ui.manager.model.schema.SimpleType(this._type, schema);\n      } else {\n        // no type, no children, no choice - this is an element with NO allowed content/children\n        this.__allowedContent = allowedContent;\n        return allowedContent;\n      }\n\n      const children = Array.from(this._type.querySelectorAll(':scope > element'));\n\n      children.forEach(sub => {\n        const subElement = new cv.ui.manager.model.schema.Element(sub, schema);\n        allowedContent[subElement.getName()] = subElement;\n      });\n\n      // fill the cache\n      this.__allowedContent = allowedContent;\n\n      return allowedContent;\n    },\n\n    _parseGrouping(node, schema) {\n      let tmpDOMGrouping = node.querySelector(\n        ':scope > choice, :scope > sequence, :scope > group'\n      );\n      if (!tmpDOMGrouping) {\n        return null;\n      }\n\n      // create the appropriate Schema*-object and append it to this very element\n      switch (tmpDOMGrouping.nodeName) {\n        case 'xsd:choice':\n        case 'choice':\n          return new cv.ui.manager.model.schema.Choice(tmpDOMGrouping, schema);\n\n        case 'xsd:sequence':\n        case 'sequence':\n          return new cv.ui.manager.model.schema.Sequence(tmpDOMGrouping, schema);\n\n        case 'xsd:group':\n        case 'group':\n          return new cv.ui.manager.model.schema.Group(tmpDOMGrouping, schema);\n\n        case 'xsd:any':\n        case 'any':\n          return new cv.ui.manager.model.schema.Any(tmpDOMGrouping, schema);\n      }\n\n      return null;\n    },\n\n    /**\n     * get and set the list of allowed attributes\n     * @var array   List of SchemaAttribute-objects\n     */\n    getAllowedAttributes() {\n      if (this.__allowedAttributes === null) {\n        const allowedAttributes = {};\n\n        const attributes = [];\n        const attributeGroups = [];\n        const extendedElement = this.getExtendedElement();\n        if (extendedElement) {\n          Object.assign(allowedAttributes, extendedElement.getAllowedAttributes());\n        }\n\n        // allowed attributes\n        for (const attr of this._type.querySelectorAll(':scope > attribute, :scope > simpleContent > extension > attribute, :scope > complexContent > extension > attribute')) {\n          attributes.push(attr);\n        }\n\n        // now add any attribute that comes from an attribute-group\n        for (const aGroup of this._type.querySelectorAll(':scope > attributeGroup, :scope > simpleContent > extension > attributeGroup, :scope > complexContent > extension > attributeGroup')) {\n          attributeGroups.push(aGroup);\n        }\n\n        attributeGroups.forEach(aGroup => {\n          // get group itself, by reference if necessary\n          // then extract all attributes, and add them to the list of already know attributes\n\n          let attributeGroup = {};\n          if (aGroup.hasAttribute('ref')) {\n            // we do have a reffed group\n            attributeGroup = this.getSchema().getReferencedNode('attributeGroup', aGroup.getAttribute('ref'));\n          } else {\n            attributeGroup = aGroup;\n          }\n\n          Array.from(attributeGroup.querySelectorAll(':scope > attribute')).forEach(child => {\n            attributes.push(child);\n          });\n        });\n\n        // convert all allowed attributes to a more object-oriented approach\n        attributes.forEach(attr => {\n          const attribute = new cv.ui.manager.model.schema.Attribute(attr, this.getSchema());\n\n          allowedAttributes[attribute.getName()] = attribute;\n        });\n\n        this.__allowedAttributes = allowedAttributes;\n      }\n      return this.__allowedAttributes;\n    },\n\n    /**\n     * are these elements children sortable? this is not the case if a sequence is used, e.g.\n     *\n     * @return  boolean     are children sortable?\n     */\n    areChildrenSortable() {\n      const allowedContent = this.getAllowedContent();\n\n      if (!allowedContent._grouping) {\n        return true;\n      }\n\n      // the inverse of \"do the elements have a given order?\"\n      return !allowedContent._grouping.getElementsHaveOrder();\n    },\n\n    /**\n     * get a list of required elements.\n     * if an element is required multiple times, it is listed multiple times\n     *\n     * @return  array   list of required elements\n     */\n    getRequiredElements() {\n      const allowedContent = this.getAllowedContent();\n\n      const required = [];\n\n      const extendedElement = this.getExtendedElement();\n      if (extendedElement) {\n        for (const r of extendedElement.getRequiredElements()) {\n          required.push(r);\n        }\n      }\n\n      if (allowedContent._grouping) {\n        // we do have a grouping as a child\n        for (const r of allowedContent._grouping.getRequiredElements()) {\n          required.push(r);\n        }\n      }\n\n      // there is no grouping, hence no elements defined as children\n      return required;\n    },\n\n    /**\n     * get a list of all allowed elements for this element\n     * @param excludeComment\n     * @return  object  list of SchemaElement-elements, key is the name\n     */\n    getAllowedElements(excludeComment) {\n      const allowedContent = this.getAllowedContent();\n\n      let allowedElements = {};\n      const extendedElement = this.getExtendedElement();\n      if (extendedElement) {\n        Object.assign(allowedElements, extendedElement.getAllowedElements(excludeComment));\n      }\n      if (allowedContent._grouping) {\n        Object.assign(allowedElements, allowedContent._grouping.getAllowedElements());\n      }\n\n      let textOnly = false;\n      if (this.isMixed()) {\n        // mixed elements are allowed to have #text-nodes\n        allowedElements['#text'] = this.getSchema().getTextNodeSchemaElement();\n      } else if (allowedContent._text && !allowedContent._grouping) {\n        // text only\n        allowedElements['#text'] = allowedContent._text;\n        textOnly = true;\n      }\n\n      if (!textOnly && !excludeComment) {\n        // although its basically allowed to add comments in a text-only content, we do not allow it\n        allowedElements['#comment'] = this.getSchema().getCommentNodeSchemaElement();\n      }\n\n      return allowedElements;\n    },\n\n    /**\n     * get the sorting of the allowed elements.\n     *\n     * @return  object              list of allowed elements, with their sort-number as value\n     */\n    getAllowedElementsSorting() {\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping) {\n        return allowedContent._grouping.getAllowedElementsSorting();\n      }\n\n      return undefined;\n    },\n\n    getFirstLevelElementSorting() {\n      const allowedSorting = this.getAllowedElementsSorting();\n      if (allowedSorting) {\n        // we only care about the first level here\n        Object.keys(allowedSorting).forEach(name => {\n          let sort = allowedSorting[name];\n          if (typeof sort === 'string') {\n            sort = parseInt(sort.split('.')[0]);\n          }\n          allowedSorting[name] = sort;\n        });\n      }\n      return allowedSorting;\n    },\n\n    /**\n     * get the bounds for this elements children (as defined by a choice)\n     *\n     * @return  object  bounds ({min: x, max: y})\n     */\n    getChildBounds() {\n      const allowedContent = this.getAllowedContent();\n\n      if (!allowedContent._grouping) {\n        // no choice = no idea about bounds\n        return undefined;\n      }\n\n      if (allowedContent._grouping.hasMultiLevelBounds() === true) {\n        // if our choice has sub-choices, then we have not fucking clue about bounds (or we can not process them)\n        return undefined;\n      }\n\n      return allowedContent._grouping.getBounds();\n    },\n\n    /**\n     * get the bounds for a specific element-name\n     * will go through all of the groupings-tree to find out, just how many elements of this may appear\n     *\n     * @param   childName   string  name of the child-to-be\n     * @return  object              {min: x, max: y}\n     */\n    getBoundsForElementName(childName) {\n      const allowedContent = this.getAllowedContent();\n\n      return allowedContent._grouping.getBoundsForElementName(childName);\n    },\n\n    /**\n     * check if a text-only-node is allowed ...\n     *\n     * @return  boolean\n     */\n    isTextContentAllowed() {\n      if (this.isMixed()) {\n        // mixed means that we allow for text-content\n        return true;\n      }\n\n      // first, get a list of allowed content (don't worry, it's cached)\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._text !== undefined && allowedContent._text !== false) {\n        // if _text is defined and there, we assume that text-content is allowed\n        return true;\n      }\n\n      // had no reason to allow text-content, so gtfoml!\n      return false;\n    },\n\n    isTextContentRequired() {\n      if (this.isTextContentAllowed()) {\n        return !this.isMixed() && !this.getAllowedContent()._text.isValueValid('');\n      }\n      return false;\n    },\n\n    /**\n     * check if an element (specified by its name) is allowed as one of our immediate children\n     * Goes recursive if we have choices.\n     *\n     * @param   child   string  name of the element we want to check\n     * @return  boolean         is this element allowed?\n     */\n    isChildElementAllowed(child) {\n      if (child === '#text' || child === '#cdata-section') {\n        // text-nodes are somewhat special :)\n        return this.isTextContentAllowed();\n      } else if (child === '#comment') {\n        return true;\n      }\n\n      // first, get a list of allowed content (don't worry, it's cached)\n      const allowedContent = this.getAllowedContent();\n\n      const extendedElement = this.getExtendedElement();\n      if (extendedElement && extendedElement.isChildElementAllowed(child)) {\n        return true;\n      }\n\n      if (!allowedContent._grouping) {\n        // when there is no choice, then there is no allowed element\n        return false;\n      }\n      // see, if this child is allowed with our choice\n      return allowedContent._grouping.isElementAllowed(child);\n    },\n\n    /**\n     * get the SchemaElement-object for a certain element-name.\n     * May return undefined if no element is found, so you might be interested in checking isElementAllowed beforehand.\n     *\n     * @param   elementName string  name of the element to find the SchemaElement for\n     * @return  object              SchemaElement-object, or undefined if none is found\n     */\n    getSchemaElementForElementName(elementName) {\n      // first, get a list of allowed content (don't worry, it's cached)\n      const allowedContent = this.getAllowedContent();\n\n      if (elementName === '#text' || elementName === '#cdata-section') {\n        // no special handling for mixed nodes, they do have a #text-SchemaElement already!\n        // text-nodes may be allowed. we will see ...\n        if (this.isTextContentAllowed() === false) {\n          return undefined;\n        }\n\n        if (!this.__textNodeSchemaElement) {\n          const tmpXML = this.getSchema().getSchemaDOM().createElement('element');\n          tmpXML.setAttribute('name', '#text');\n          tmpXML.setAttribute('type', 'xsd:string');\n          this.__textNodeSchemaElement = new cv.ui.manager.model.schema.Element(tmpXML, this.getSchema());\n\n          if (allowedContent._text) {\n            this.__textNodeSchemaElement.getAllowedContent()._text = allowedContent._text;\n          } else if (this.isMixed()) {\n            this.__textNodeSchemaElement.getAllowedContent._text = this.getSchema().getTextNodeSchemaElement();\n          }\n        }\n        return this.__textNodeSchemaElement;\n      } else if (elementName === '#comment') {\n        // comments are always allowed\n        return this.getSchema().getCommentNodeSchemaElement();\n      }\n\n      const extendedElement = this.getExtendedElement();\n      if (extendedElement && extendedElement.isElementAllowed(elementName)) {\n        return extendedElement.getSchemaElementForElementName(elementName);\n      }\n\n      if (!allowedContent._grouping) {\n        // when there is no choice, then there is no allowed element\n        return undefined;\n      }\n\n      // go over our choice, if the element is allowed with it\n      if (allowedContent._grouping.isElementAllowed(elementName)) {\n        // only look in this tree, if the element is allowed there.\n        return allowedContent._grouping.getSchemaElementForElementName(elementName);\n      }\n\n      return undefined;\n    },\n\n    /**\n     * return the DOM this Schema is based on\n     *\n     * @return  object  DOM of $xsd\n     */\n    getSchemaDOM() {\n      return this.getSchema().getSchemaDOM();\n    },\n\n    /**\n     * check if a given value is valid for this element\n     *\n     * @param   value   string  value to check\n     * @return  boolean         is it valid?\n     */\n    isValueValid(value) {\n      if (this.isTextContentAllowed() === false) {\n        // if no text-content is allowed, then it can not be valid\n        return false;\n      }\n\n      if (this.isMixed()) {\n        // mixed is always good!\n        return true;\n      }\n\n      const allowedContent = this.getAllowedContent();\n\n      return allowedContent._text.isValueValid(value);\n    },\n\n    /**\n     * create and retrieve the part of a regular expression which describes this very element\n     *\n     * @param   separator   string  the string used to separate different elements, e.g. ';'\n     * @param   nocapture   bool    when set to true non capturing groups are used\n     * @return  string\n     */\n    getRegex(separator, nocapture) {\n      if (typeof separator === 'undefined' || separator === undefined) {\n        // default to an empty string\n        separator = '';\n      }\n\n      let regexString = '(';\n      if (nocapture) {\n        regexString += '?:';\n      }\n\n      // start with the name of the element\n      regexString += this.getName() + separator + ')';\n\n      // append bounds\n      let boundsMin = '';\n      let boundsMax = '';\n      const bounds = this.getBounds();\n      if (bounds.min !== undefined) {\n        boundsMin = bounds.min;\n      }\n\n      if (bounds.max !== undefined) {\n        if (bounds.max !== Number.POSITIVE_INFINITY) {\n          boundsMax = bounds.max;\n        }\n      }\n\n      if (boundsMin !== '' || boundsMax !== '') {\n        // append bounds to the regex-string\n        regexString += '{' + boundsMin + ',' + boundsMax + '}';\n      }\n\n      // and thats all\n      return regexString;\n    },\n\n    /**\n     * create a full-blown regular expression that describes this elements immediate children\n     * @param separator   string  the string used to separate different elements, e.g. ';'\n     * @param nocapture\n     * @return  string              the regular expression\n     */\n    getChildrenRegex(separator, nocapture) {\n      if (typeof separator == 'undefined' || separator === undefined) {\n        // default to an empty string\n        separator = '';\n      }\n\n      const allowedContent = this.getAllowedContent();\n\n      if (!allowedContent._grouping) {\n        // not really something to match\n        return '^';\n      }\n\n      return allowedContent._grouping.getRegex(separator, nocapture);\n    }\n  },\n\n  /*\n  ***********************************************\n    DESTRUCTOR\n  ***********************************************\n  */\n  destruct() {\n    this._disposeMap('__allowedAttributes');\n    this._disposeMap('__allowedContent');\n    this._disposeObjects('__textNodeSchemaElement', '__extendedElement');\n  }\n});\n"
  ],
  "mappings": "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",
  "ignoreList": []
}