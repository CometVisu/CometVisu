{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "cv",
    "ui",
    "manager",
    "model",
    "schema",
    "Base",
    "include",
    "MAnnotation",
    "construct",
    "node",
    "parse",
    "statics",
    "getElementName",
    "e",
    "hasAttribute",
    "getAttribute",
    "refName",
    "ref",
    "getReferencedNode",
    "length",
    "Error",
    "getTypeNode",
    "type",
    "match",
    "querySelector",
    "sortChildNodes",
    "sorting",
    "a",
    "b",
    "aSortvalue",
    "name",
    "bSortvalue",
    "undefined",
    "toString",
    "aSortvaluesList",
    "split",
    "bSortvaluesList",
    "i",
    "properties",
    "refine",
    "init",
    "check",
    "defaultValue",
    "nullable",
    "sortable",
    "event",
    "mixed",
    "members",
    "__allowedContentLoaded",
    "__allowedContent",
    "__allowedAttributes",
    "__textNodeSchemaElement",
    "_type",
    "getNode",
    "getSchema",
    "Element",
    "setName",
    "setDefaultValue",
    "setMixed",
    "getAllowedContent",
    "allowedContent",
    "_grouping",
    "_text",
    "querySelectorAll",
    "SimpleType",
    "tmpDOMGrouping",
    "nodeName",
    "Choice",
    "Sequence",
    "Group",
    "Any",
    "children",
    "Array",
    "from",
    "forEach",
    "sub",
    "subElement",
    "getName",
    "getAllowedAttributes",
    "allowedAttributes",
    "attributes",
    "attributeGroups",
    "aGroup",
    "attributeGroup",
    "child",
    "push",
    "attr",
    "attribute",
    "Attribute",
    "areChildrenSortable",
    "getElementsHaveOrder",
    "getRequiredElements",
    "getAllowedElements",
    "excludeComment",
    "allowedElements",
    "Object",
    "assign",
    "textOnly",
    "isMixed",
    "getTextNodeSchemaElement",
    "getCommentNodeSchemaElement",
    "getAllowedElementsSorting",
    "getFirstLevelElementSorting",
    "allowedSorting",
    "keys",
    "sort",
    "parseInt",
    "getChildBounds",
    "hasMultiLevelBounds",
    "getBounds",
    "getBoundsForElementName",
    "childName",
    "isTextContentAllowed",
    "isTextContentRequired",
    "isValueValid",
    "isChildElementAllowed",
    "isElementAllowed",
    "getSchemaElementForElementName",
    "elementName",
    "tmpXML",
    "getSchemaDOM",
    "createElement",
    "setAttribute",
    "value",
    "getRegex",
    "separator",
    "nocapture",
    "regexString",
    "boundsMin",
    "boundsMax",
    "bounds",
    "min",
    "max",
    "Number",
    "POSITIVE_INFINITY",
    "getChildrenRegex",
    "destruct",
    "_disposeMap",
    "_disposeObjects"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/model/schema/Element.js"
  ],
  "sourcesContent": [
    "/* Element.js\n *\n * copyright (c) 2010-2022, Christian Mayer and the CometVisu contributers.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n */\n\n/**\n * a single element from the schema\n */\nqx.Class.define('cv.ui.manager.model.schema.Element', {\n  extend: cv.ui.manager.model.schema.Base,\n  include: cv.ui.manager.model.schema.MAnnotation,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  construct(node, schema) {\n    super(node, schema);\n    this.parse();\n  },\n\n  /*\n  ***********************************************\n    STATICS\n  ***********************************************\n  */\n  statics: {\n    /**\n     * Get the name of a schema-element\n     * @param e object  element to find the name of\n     * @param schema\n     * @return  string          name of the element\n     * @throws  if the name can not be found\n     */\n    getElementName(e, schema) {\n      if (e.hasAttribute('name')) {\n        return e.getAttribute('name');\n      }\n\n      if (e.hasAttribute('ref')) {\n        // it's a ref, seek other element!\n        const refName = e.getAttribute('ref');\n        const ref = schema.getReferencedNode('element', refName);\n\n        if (ref.length !== 1) {\n          throw new Error('schema/xsd appears to be invalid, can not find element ' + refName);\n        }\n\n        return ref.getAttribute('name');\n      }\n\n      return 'unknown';\n    },\n\n    /**\n     * find the type-node for this element\n     * @param node\n     * @param schema\n     * @return  object  object of the type-Node\n     */\n    getTypeNode(node, schema) {\n      let type;\n\n      if (node.hasAttribute('type')) {\n        if (node.getAttribute('type').match(/^xsd:/)) {\n          // if it starts with xsd:, it's actually a simple type\n          // does not start with\n          type = node;\n        } else {\n          // otherwise, the element is linked to a complexType\n          type = schema.getTypeNode('complex', node.getAttribute('type'));\n        }\n      } else if (node.hasAttribute('ref')) {\n        // the link is a reference to another element, which means it does not even have it's own name.\n        // this one is most certainly deprecated, as we do not have many root-level-elements, and only those can\n        // be ref'ed\n      } else {\n        // the element is it's own type\n        type = node.querySelector(':scope > complexType');\n      }\n\n      return type;\n    },\n\n    sortChildNodes(sorting) {\n      /**\n       * the comparison-function that helps the sorting\n       *\n       * @param   a   mixed   whatever sort gives us\n       * @param   b   mixed   whatever sort gives us\n       * @return  integer     -1, 0, 1 - depending on sort-order\n       */\n      return function (a, b) {\n        let aSortvalue = sorting[a.name];\n        let bSortvalue = sorting[b.name];\n\n        if (aSortvalue === undefined || bSortvalue === undefined) {\n          // undefined means: no sorting available\n          return 0;\n        }\n\n        if (aSortvalue === bSortvalue) {\n          // identical means 'no sorting necessary'\n          return 0;\n        }\n\n        // we need to go through the complete list of values the sorting is composed of,\n        // to find the first one that distinguishes a from b\n\n        // first, typecast to string!\n        if (typeof aSortvalue !== 'string') {\n          aSortvalue = aSortvalue.toString();\n        }\n        if (typeof bSortvalue !== 'string') {\n          bSortvalue = bSortvalue.toString();\n        }\n\n        let aSortvaluesList = aSortvalue.split('.');\n        let bSortvaluesList = bSortvalue.split('.');\n\n        for (let i = 0; i < aSortvaluesList.length; ++i) {\n          if (aSortvaluesList[i] < bSortvaluesList[i]) {\n            return -1;\n          } else if (aSortvaluesList[i] > bSortvaluesList[i]) {\n            return 1;\n          }\n        }\n\n        // if nothing else matched, then they are treated equal\n        return 0;\n      };\n    }\n  },\n\n  /*\n  ***********************************************\n    PROPERTIES\n  ***********************************************\n  */\n  properties: {\n    type: {\n      refine: true,\n      init: 'element'\n    },\n\n    name: {\n      check: 'String',\n      init: ''\n    },\n\n    defaultValue: {\n      check: 'String',\n      nullable: true\n    },\n\n    sortable: {\n      check: 'Boolean',\n      init: false,\n      event: 'changeSortable'\n    },\n\n    mixed: {\n      check: 'Boolean',\n      init: false\n    }\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n    __allowedContentLoaded: false,\n    __allowedContent: null,\n    __allowedAttributes: null,\n    __textNodeSchemaElement: null,\n\n    /**\n     * get and set the type-node for the element\n     * @var object  Type-Node (most certainly a complexType)\n     */\n    _type: null,\n\n    parse() {\n      super.parse();\n      const node = this.getNode();\n      const schema = this.getSchema();\n\n      this._type = cv.ui.manager.model.schema.Element.getTypeNode(node, schema);\n      this.setName(cv.ui.manager.model.schema.Element.getElementName(node, schema));\n\n      if (node.hasAttribute('default')) {\n        this.setDefaultValue(node.getAttribute('default'));\n      }\n      this.setMixed(this._type.hasAttribute('mixed') && this._type.getAttribute('mixed') === 'true');\n    },\n\n    /**\n     * get a list of allowed elements for this element\n     *\n     * @return  object  object of SchemaElement-elements, key is the name\n     */\n    getAllowedContent() {\n      if (this.__allowedContent !== null) {\n        // if we have parsed this already, we can simply return the 'cache'\n        return this.__allowedContent;\n      }\n      const schema = this.getSchema();\n\n      const allowedContent = {\n        _grouping: undefined,\n        _text: false\n      };\n\n      // allowed sub-elements\n      // can be either simpleContent, or (choice|sequence|group|all)?\n      // 'all' is not supported yet.\n\n      if (this._type.querySelectorAll(':scope > simpleContent').length > 0) {\n        // it's simpleContent? Then it's either extension or restriction\n        // anyways, we will handle it, as if it were a simpleType\n        allowedContent._text = new cv.ui.manager.model.schema.SimpleType(\n          this._type.querySelector(':scope > simpleContent'),\n          schema\n        );\n      } else if (\n        this._type.querySelectorAll('complexType > choice, complexType> sequence, complexType > group').length > 0\n      ) {\n        // we have a choice, group or sequence. great\n        // as per the W3C, only one of these may appear per element/type\n\n        let tmpDOMGrouping = this._type.querySelector(\n          'complexType > choice, complexType > sequence, complexType > group'\n        );\n\n        // create the appropriate Schema*-object and append it to this very element\n        switch (tmpDOMGrouping.nodeName) {\n          case 'xsd:choice':\n          case 'choice':\n            allowedContent._grouping = new cv.ui.manager.model.schema.Choice(tmpDOMGrouping, schema);\n\n            break;\n          case 'xsd:sequence':\n          case 'sequence':\n            allowedContent._grouping = new cv.ui.manager.model.schema.Sequence(tmpDOMGrouping, schema);\n\n            break;\n          case 'xsd:group':\n          case 'group':\n            allowedContent._grouping = new cv.ui.manager.model.schema.Group(tmpDOMGrouping, schema);\n\n            break;\n          case 'xsd:any':\n          case 'any':\n            allowedContent._grouping = new cv.ui.manager.model.schema.Any(tmpDOMGrouping, schema);\n\n            break;\n        }\n      } else if (this._type.hasAttribute('type') && this._type.getAttribute('type').match(/^xsd:/)) {\n        // this is a really simple node that defines its own baseType\n        allowedContent._text = new cv.ui.manager.model.schema.SimpleType(this._type, schema);\n      } else {\n        // no type, no children, no choice - this is an element with NO allowed content/children\n        this.__allowedContent = allowedContent;\n        return allowedContent;\n      }\n\n      const children = Array.from(this._type.querySelectorAll(':scope > element'));\n\n      children.forEach(sub => {\n        const subElement = new cv.ui.manager.model.schema.Element(sub, schema);\n        allowedContent[subElement.getName()] = subElement;\n      });\n\n      // fill the cache\n      this.__allowedContent = allowedContent;\n\n      return allowedContent;\n    },\n\n    /**\n     * get and set the list of allowed attributes\n     * @var array   List of SchemaAttribute-objects\n     */\n    getAllowedAttributes() {\n      if (this.__allowedAttributes === null) {\n        const allowedAttributes = {};\n\n        // allowed attributes\n        const attributes = Array.from(\n          this._type.querySelectorAll(':scope > attribute, :scope > simpleContent > extension > attribute')\n        );\n\n        // now add any attribute that comes from an attribute-group\n        const attributeGroups = Array.from(\n          this._type.querySelectorAll(':scope > attributeGroup, :scope > simpleContent > extension > attributeGroup')\n        );\n\n        attributeGroups.forEach(aGroup => {\n          // get get group itself, by reference if necessary\n          // then extract all attributes, and add them to the list of already know attributes\n\n          let attributeGroup = {};\n          if (aGroup.hasAttribute('ref')) {\n            // we do have a reffed group\n            attributeGroup = this.getSchema().getReferencedNode('attributeGroup', aGroup.getAttribute('ref'));\n          } else {\n            attributeGroup = aGroup;\n          }\n\n          Array.from(attributeGroup.querySelectorAll(':scope > attribute')).forEach(child => {\n            attributes.push(child);\n          });\n        });\n\n        // convert all allowed attributes to a more object-oriented approach\n        attributes.forEach(attr => {\n          const attribute = new cv.ui.manager.model.schema.Attribute(attr, this.getSchema());\n\n          allowedAttributes[attribute.getName()] = attribute;\n        });\n\n        this.__allowedAttributes = allowedAttributes;\n      }\n      return this.__allowedAttributes;\n    },\n\n    /**\n     * are this elements children sortable? this is not the case if a sequence is used, e.g.\n     *\n     * @return  boolean     are children sortable?\n     */\n    areChildrenSortable() {\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping === undefined) {\n        return true;\n      }\n\n      // the inverse of \"do the elements have a given order?\"\n      return !allowedContent._grouping.getElementsHaveOrder();\n    },\n\n    /**\n     * get a list of required elements.\n     * if an element is required multiple times, it is listed multiple times\n     *\n     * @return  array   list of required elements\n     */\n    getRequiredElements() {\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping !== undefined) {\n        // we do have a grouping as a child\n        return allowedContent._grouping.getRequiredElements();\n      }\n\n      // there is no grouping, hence no elements defined as children\n      return [];\n    },\n\n    /**\n     * get a list of all allowed elements for this element\n     * @param excludeComment\n     * @return  object  list of SchemaElement-elements, key is the name\n     */\n    getAllowedElements(excludeComment) {\n      const allowedContent = this.getAllowedContent();\n\n      const allowedElements = {};\n      if (allowedContent._grouping !== undefined) {\n        Object.assign(allowedElements, allowedContent._grouping.getAllowedElements());\n      }\n\n      let textOnly = false;\n      if (this.isMixed()) {\n        // mixed elements are allowed to have #text-nodes\n        allowedElements['#text'] = this.getSchema().getTextNodeSchemaElement();\n      } else if (allowedContent._text && allowedContent._grouping === undefined) {\n        // text only\n        allowedElements['#text'] = allowedContent._text;\n        textOnly = true;\n      }\n\n      if (!textOnly && !excludeComment) {\n        // although its basically allowed to add comments in a text-only content, we do not allow it\n        allowedElements['#comment'] = this.getSchema().getCommentNodeSchemaElement();\n      }\n\n      return allowedElements;\n    },\n\n    /**\n     * get the sorting of the allowed elements.\n     *\n     * @return  object              list of allowed elements, with their sort-number as value\n     */\n    getAllowedElementsSorting() {\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping !== undefined) {\n        return allowedContent._grouping.getAllowedElementsSorting();\n      }\n\n      return undefined;\n    },\n\n    getFirstLevelElementSorting() {\n      const allowedSorting = this.getAllowedElementsSorting();\n      if (allowedSorting) {\n        // we only care about the first level here\n        Object.keys(allowedSorting).forEach(name => {\n          let sort = allowedSorting[name];\n          if (typeof sort === 'string') {\n            sort = parseInt(sort.split('.')[0]);\n          }\n          allowedSorting[name] = sort;\n        });\n      }\n      return allowedSorting;\n    },\n\n    /**\n     * get the bounds for this elements children (as defined by a choice)\n     *\n     * @return  object  bounds ({min: x, max: y})\n     */\n    getChildBounds() {\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping === undefined) {\n        // no choice = no idea about bounds\n        return undefined;\n      }\n\n      if (allowedContent._grouping.hasMultiLevelBounds() === true) {\n        // if our choice has sub-choices, then we have not fucking clue about bounds (or we can not process them)\n        return undefined;\n      }\n\n      return allowedContent._grouping.getBounds();\n    },\n\n    /**\n     * get the bounds for a specific element-name\n     * will go through all of the groupings-tree to find out, just how many elements of this may appear\n     *\n     * @param   childName   string  name of the child-to-be\n     * @return  object              {min: x, max: y}\n     */\n    getBoundsForElementName(childName) {\n      const allowedContent = this.getAllowedContent();\n\n      return allowedContent._grouping.getBoundsForElementName(childName);\n    },\n\n    /**\n     * check if a text-only-node is allowed ...\n     *\n     * @return  boolean\n     */\n    isTextContentAllowed() {\n      if (this.isMixed()) {\n        // mixed means that we allow for text-content\n        return true;\n      }\n\n      // first, get a list of allowed content (don't worry, it's cached)\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._text !== undefined && allowedContent._text !== false) {\n        // if _text is defined and there, we assume that text-content is allowed\n        return true;\n      }\n\n      // had no reason to allow text-content, so gtfoml!\n      return false;\n    },\n\n    isTextContentRequired() {\n      if (this.isTextContentAllowed()) {\n        return !this.isMixed() && !this.getAllowedContent()._text.isValueValid('');\n      }\n      return false;\n    },\n\n    /**\n     * check if an element (specified by its name) is allowed as one of our immediate children\n     * Goes recursive if we have choices.\n     *\n     * @param   child   string  name of the element we want to check\n     * @return  boolean         is this element allowed?\n     */\n    isChildElementAllowed(child) {\n      if (child === '#text' || child === '#cdata-section') {\n        // text-nodes are somewhat special :)\n        return this.isTextContentAllowed();\n      } else if (child === '#comment') {\n        return true;\n      }\n\n      // first, get a list of allowed content (don't worry, it's cached)\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping === undefined) {\n        // when there is no choice, then there is no allowed element\n        return false;\n      }\n      // see, if this child is allowed with our choice\n      return allowedContent._grouping.isElementAllowed(child);\n    },\n\n    /**\n     * get the SchemaElement-object for a certain element-name.\n     * May return undefined if no element is found, so you might be interested in checking isElementAllowed beforehand.\n     *\n     * @param   elementName string  name of the element to find the SchemaElement for\n     * @return  object              SchemaElement-object, or undefined if none is found\n     */\n    getSchemaElementForElementName(elementName) {\n      // first, get a list of allowed content (don't worry, it's cached)\n      const allowedContent = this.getAllowedContent();\n\n      if (elementName === '#text' || elementName === '#cdata-section') {\n        // no special handling for mixed nodes, they do have a #text-SchemaElement already!\n        // text-nodes may be allowed. we will see ...\n        if (this.isTextContentAllowed() === false) {\n          return undefined;\n        }\n\n        if (!this.__textNodeSchemaElement) {\n          const tmpXML = this.getSchema().getSchemaDOM().createElement('element');\n          tmpXML.setAttribute('name', '#text');\n          tmpXML.setAttribute('type', 'xsd:string');\n          this.__textNodeSchemaElement = new cv.ui.manager.model.schema.Element(tmpXML, this.getSchema());\n\n          if (allowedContent._text) {\n            this.__textNodeSchemaElement.getAllowedContent()._text = allowedContent._text;\n          } else if (this.isMixed()) {\n            this.__textNodeSchemaElement.getAllowedContent._text = this.getSchema().getTextNodeSchemaElement();\n          }\n        }\n        return this.__textNodeSchemaElement;\n      } else if (elementName === '#comment') {\n        // comments are always allowed\n        return this.getSchema().getCommentNodeSchemaElement();\n      }\n\n      if (allowedContent._grouping === undefined) {\n        // when there is no choice, then there is no allowed element\n        return undefined;\n      }\n\n      // go over our choice, if the element is allowed with it\n      if (allowedContent._grouping.isElementAllowed(elementName)) {\n        // only look in this tree, if the element is allowed there.\n        return allowedContent._grouping.getSchemaElementForElementName(elementName);\n      }\n\n      return undefined;\n    },\n\n    /**\n     * return the DOM this Schema is based on\n     *\n     * @return  object  DOM of $xsd\n     */\n    getSchemaDOM() {\n      return this.getSchema().getSchemaDOM();\n    },\n\n    /**\n     * check if a given value is valid for this element\n     *\n     * @param   value   string  value to check\n     * @return  boolean         is it valid?\n     */\n    isValueValid(value) {\n      if (this.isTextContentAllowed() === false) {\n        // if no text-content is allowed, then it can not be valid\n        return false;\n      }\n\n      if (this.isMixed()) {\n        // mixed is always good!\n        return true;\n      }\n\n      const allowedContent = this.getAllowedContent();\n\n      return allowedContent._text.isValueValid(value);\n    },\n\n    /**\n     * create and retrieve the part of a regular expression which describes this very element\n     *\n     * @param   separator   string  the string used to separate different elements, e.g. ';'\n     * @param   nocapture   bool    when set to true non capturing groups are used\n     * @return  string\n     */\n    getRegex(separator, nocapture) {\n      if (typeof separator === 'undefined' || separator === undefined) {\n        // default to an empty string\n        separator = '';\n      }\n\n      let regexString = '(';\n      if (nocapture) {\n        regexString += '?:';\n      }\n\n      // start with the name of the element\n      regexString += this.getName() + separator + ')';\n\n      // append bounds\n      let boundsMin = '';\n      let boundsMax = '';\n      const bounds = this.getBounds();\n      if (bounds.min !== undefined) {\n        boundsMin = bounds.min;\n      }\n\n      if (bounds.max !== undefined) {\n        if (bounds.max !== Number.POSITIVE_INFINITY) {\n          boundsMax = bounds.max;\n        }\n      }\n\n      if (boundsMin !== '' || boundsMax !== '') {\n        // append bounds to the regex-string\n        regexString += '{' + boundsMin + ',' + boundsMax + '}';\n      }\n\n      // and thats all\n      return regexString;\n    },\n\n    /**\n     * create a full-blown regular expression that describes this elements immediate children\n     * @param separator   string  the string used to separate different elements, e.g. ';'\n     * @param nocapture\n     * @return  string              the regular expression\n     */\n    getChildrenRegex(separator, nocapture) {\n      if (typeof separator == 'undefined' || separator === undefined) {\n        // default to an empty string\n        separator = '';\n      }\n\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping === undefined) {\n        // not really something to match\n        return '^';\n      }\n\n      return allowedContent._grouping.getRegex(separator, nocapture);\n    }\n  },\n\n  /*\n  ***********************************************\n    DESTRUCTOR\n  ***********************************************\n  */\n  destruct() {\n    this._disposeMap('__allowedAttributes');\n    this._disposeMap('__allowedContent');\n    this._disposeObjects('__textNodeSchemaElement');\n  }\n});\n"
  ],
  "mappings": "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"
}