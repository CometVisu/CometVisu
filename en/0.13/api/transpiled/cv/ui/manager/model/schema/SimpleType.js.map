{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/model/schema/SimpleType.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "cv",
    "ui",
    "manager",
    "model",
    "schema",
    "Base",
    "construct",
    "node",
    "__enumerations",
    "__pattern",
    "__regexCache",
    "__bases",
    "parse",
    "properties",
    "type",
    "refine",
    "init",
    "optional",
    "check",
    "baseType",
    "nullable",
    "members",
    "getNode",
    "setOptional",
    "getAttribute",
    "__fillNodeData",
    "getSchema",
    "hasAttribute",
    "refName",
    "getReferencedNode",
    "Error",
    "match",
    "subnode",
    "setBaseType",
    "subNodes",
    "Array",
    "from",
    "querySelectorAll",
    "forEach",
    "subNode",
    "patternNode",
    "push",
    "enumerationNode",
    "getBaseType",
    "isValueValid",
    "value",
    "isOptional",
    "search",
    "typeNode",
    "getTypeNode",
    "subType",
    "SimpleType",
    "length",
    "includes",
    "boolValid",
    "item",
    "Object",
    "prototype",
    "hasOwnProperty",
    "call",
    "branchIndices",
    "start",
    "i",
    "indexOf",
    "isRootBranch",
    "j",
    "error",
    "branches",
    "map",
    "entry",
    "substr",
    "replace",
    "regexFromString",
    "join",
    "test",
    "getEnumeration",
    "destruct"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* SimpleType.js \n * \n * copyright (c) 2010-2022, Christian Mayer and the CometVisu contributers.\n * \n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n */\n\n\n/**\n * a single SimpleType from the schema.\n * Should be useable for SimpleContent, too.\n * Is usable for attributes, too.\n */\nqx.Class.define('cv.ui.manager.model.schema.SimpleType', {\n  extend: cv.ui.manager.model.schema.Base,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  construct: function (node, schema) {\n    this.base(arguments, node, schema);\n    this.__enumerations = [];\n    this.__pattern = [];\n    this.__regexCache = {};\n    this.__bases = [];\n    this.parse();\n  },\n\n  /*\n  ***********************************************\n    PROPERTIES\n  ***********************************************\n  */\n  properties: {\n    type: {\n      refine: true,\n      init: 'simpleType'\n    },\n    optional: {\n      check: 'Boolean',\n      init: false\n    },\n\n    /**\n     * the baseType of this element, which is one of the xsd-namespaced types (like 'string')\n     * @var string\n     */\n    baseType: {\n      check: 'String',\n      nullable: true\n    }\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n    __pattern: null,\n    __enumerations: null,\n    __bases: null,\n    __regexCache: null,\n\n    parse: function () {\n      const node = this.getNode();\n      this.setOptional(node.getAttribute('use') === 'required');\n      this.__fillNodeData(node);\n    },\n\n    /**\n     * parse a node, find it's data (restrictions, extensions, bases ... whatever)\n     *\n     * @param   node    DOMNode the node to parse\n     */\n    __fillNodeData: function (node) {\n      const schema = this.getSchema();\n\n      if (node.hasAttribute('ref')) {\n        // it's a ref, seek other element!\n        const refName = node.getAttribute('ref');\n        node = schema.getReferencedNode('attribute', refName);\n\n        if (!node) {\n          throw new Error('schema/xsd appears to be invalid, can not find element ' + refName);\n        }\n      }\n\n      if (node.hasAttribute('type')) {\n        // hacked: allow this to be used for attributes\n        const baseType = node.getAttribute('type');\n\n        if (!baseType.match(/^xsd:/)) {\n          // if it's not an xsd-default-basetype, we need to find out what it is\n          const subnode = schema.getReferencedNode('simpleType', baseType);\n          this.__fillNodeData(subnode);\n        } else {\n          this.setBaseType(baseType);\n        }\n        // is this attribute optional?\n        this.setOptional(node.getAttribute('use') !== 'required');\n\n        return;\n      }\n\n      const subNodes = Array.from(node.querySelectorAll(':scope > restriction, :scope > extension, :scope > simpleType > restriction, :scope > simpleType > extension'));\n\n      subNodes.forEach(subNode => {\n        const baseType = subNode.getAttribute('base');\n\n        if (!baseType.match(/^xsd:/)) {\n          // don't dive in for default-types, they simply can not be found\n          const subnode = schema.getReferencedNode('simpleType', baseType);\n          this.__fillNodeData(subnode);\n        } else {\n          this.setBaseType(baseType);\n        }\n        Array.from(subNode.querySelectorAll(':scope > pattern')).forEach(patternNode => {\n          this.__pattern.push(patternNode.getAttribute('value'));\n        });\n\n        Array.from(subNode.querySelectorAll(':scope > enumeration')).forEach(enumerationNode => {\n          this.__enumerations.push(enumerationNode.getAttribute('value'));\n        });\n      });\n\n      if (!this.getBaseType()) {\n        this.setBaseType('xsd:anyType');\n      }\n      this.__bases.push(this.getBaseType());\n    },\n\n    /**\n     * check if a given value is valid for this type\n     *\n     * @param   value   mixed   the value to check\n     * @return  boolean         if the value is valid\n     */\n    isValueValid: function (value) {\n      const baseType = this.getBaseType();\n      const schema = this.getSchema();\n      if (!baseType) {\n        throw new Error('something is wrong, do not have a baseType for type');\n      }\n\n      if (value === '') {\n        // empty values are valid if this node is optional!\n        return this.isOptional();\n      }\n\n      if (baseType.search(/^xsd:/) === -1) {\n        // created our own type, will need to find and use it.\n        const typeNode = schema.getTypeNode('simple', baseType);\n        const subType = new cv.ui.manager.model.schema.SimpleType(typeNode, schema);\n        return subType.isValueValid(value);\n      } \n        // xsd:-namespaces types, those are the originals\n        switch (baseType) {\n          case 'xsd:string':\n          case 'xsd:anyURI':\n          case 'xsd:anyType':\n            if (!(typeof (value) == 'string')) {\n              // it's not a string, but it should be.\n              // pretty much any input a user gives us is string, so this is pretty much moot.\n              return false;\n            }\n            break;\n          case 'xsd:decimal':\n            if (!value.match(/^[-+]?[0-9]*(\\.[0-9]+)?$/)) {\n              return false;\n            }\n            break;\n          case 'xsd:unsignedByte':\n          case 'xsd:nonNegativeInteger':\n            if (!value.match(/^[+]?[0-9]+$/)) {\n              return false;\n            }\n            break;\n          case 'xsd:integer':\n            if (!value.match(/^[-+]?[0-9]+$/)) {\n              return false;\n            }\n            break;\n          case 'xsd:float':\n            if (!value.match(/^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$/)) {\n              return false;\n            }\n            break;\n          case 'xsd:boolean':\n            if (!value.match(/^(true|false|0|1)$/)) {\n              return false;\n            }\n            break;\n          default:\n            throw new Error('not implemented baseType ' + baseType);\n        }\n      \n\n      // check if the value is in our list of valid values, if there is such a list\n      if (this.__enumerations.length > 0) {\n        if (!this.__enumerations.includes(value)) {\n          return false;\n        }\n      }\n\n      // check if the value matches any given pattern\n      if (this.__pattern.length > 0) {\n        // start with assuming it's valid\n        let boolValid = true;\n\n        this.__pattern.forEach(item => {\n          if (!Object.prototype.hasOwnProperty.call(this.__regexCache, item)) {\n            // create a regex from the pattern; mind ^ an $ - XSD has them implicitly (XSD Datatypes, Appendix G)\n            // so for our purpose, we need to add them for every branch (that is not inside [])\n            const branchIndices = [];\n            let start = 0;\n            let i = item.indexOf('|', start);\n            while (i < item.length) {\n              if (i < 0) {\n                break;\n              }\n              // go backwards and look for an [ stop looking on ]\n              let isRootBranch = true;\n              for (let j = i; j >= start; j--) {\n                if (item[j] === ']') {\n                  break;\n                } else if (item[j] === '[') {\n                  isRootBranch = false;\n                }\n              }\n              if (isRootBranch) {\n                branchIndices.push([start, i - start]);\n              }\n              start = i + 1;\n              i = item.indexOf('|', start);\n              if (branchIndices.length > 100) {\n                this.error('too many branchIndices');\n                break;\n              }\n            }\n            if (item.length > start) {\n              // append the rest\n              branchIndices.push([start, item.length - start]);\n            }\n            const branches = branchIndices.map(entry => `^${item.substr(entry[0], entry[1]).replace(/\\\\([\\s\\S])|(\\$)/g, '\\\\$1$2')}$`);\n            this.__regexCache[item] = this.regexFromString(branches.join('|'));\n          }\n\n          if (this.__regexCache[item].test(value) === false) {\n            // regular expression did not match\n            // bad bad value!\n            boolValid = false;\n          }\n        }, this);\n\n        // if the value has been marked invalid by a regex, return invalid.\n        if (boolValid === false) {\n          return false;\n        }\n      }\n\n      // if no check said the value is invalid, then it is not invalid\n      return true;\n    },\n\n    /**\n     * get this elements enumeration (if there is any)\n     *\n     * @return  array   list of allowed values (if there are any)\n     */\n    getEnumeration: function () {\n      if (this.getBaseType() === 'xsd:boolean') {\n        // special handling for boolean, as we KNOW it to be an enumeration\n        return ['true', 'false'];\n      }\n\n      return this.__enumerations;\n    }\n  },\n\n  /*\n  ***********************************************\n    DESTRUCTOR\n  ***********************************************\n  */\n  destruct: function () {\n    this.__regexCache = null;\n  }\n});\n"
  ]
}