{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "cv",
    "ui",
    "manager",
    "model",
    "schema",
    "Base",
    "construct",
    "node",
    "__enumerations",
    "__pattern",
    "__regexCache",
    "__bases",
    "parse",
    "properties",
    "type",
    "refine",
    "init",
    "optional",
    "check",
    "baseType",
    "nullable",
    "members",
    "getNode",
    "setOptional",
    "getAttribute",
    "__fillNodeData",
    "getSchema",
    "hasAttribute",
    "refName",
    "getReferencedNode",
    "Error",
    "match",
    "subnode",
    "setBaseType",
    "subNodes",
    "Array",
    "from",
    "querySelectorAll",
    "forEach",
    "subNode",
    "patternNode",
    "push",
    "enumerationNode",
    "getBaseType",
    "isValueValid",
    "value",
    "isOptional",
    "search",
    "typeNode",
    "getTypeNode",
    "subType",
    "SimpleType",
    "length",
    "includes",
    "boolValid",
    "item",
    "Object",
    "prototype",
    "hasOwnProperty",
    "call",
    "branchIndices",
    "start",
    "i",
    "indexOf",
    "isRootBranch",
    "j",
    "error",
    "branches",
    "map",
    "entry",
    "substr",
    "replace",
    "regexFromString",
    "join",
    "test",
    "getEnumeration",
    "destruct"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/model/schema/SimpleType.js"
  ],
  "sourcesContent": [
    "/* SimpleType.js\n *\n * copyright (c) 2010-2022, Christian Mayer and the CometVisu contributers.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n */\n\n/**\n * a single SimpleType from the schema.\n * Should be useable for SimpleContent, too.\n * Is usable for attributes, too.\n */\nqx.Class.define('cv.ui.manager.model.schema.SimpleType', {\n  extend: cv.ui.manager.model.schema.Base,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  construct(node, schema) {\n    super(node, schema);\n    this.__enumerations = [];\n    this.__pattern = [];\n    this.__regexCache = {};\n    this.__bases = [];\n    this.parse();\n  },\n\n  /*\n  ***********************************************\n    PROPERTIES\n  ***********************************************\n  */\n  properties: {\n    type: {\n      refine: true,\n      init: 'simpleType'\n    },\n\n    optional: {\n      check: 'Boolean',\n      init: false\n    },\n\n    /**\n     * the baseType of this element, which is one of the xsd-namespaced types (like 'string')\n     * @var string\n     */\n    baseType: {\n      check: 'String',\n      nullable: true\n    }\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n    __pattern: null,\n    __enumerations: null,\n    __bases: null,\n    __regexCache: null,\n\n    parse() {\n      const node = this.getNode();\n      this.setOptional(node.getAttribute('use') === 'required');\n      this.__fillNodeData(node);\n    },\n\n    /**\n     * parse a node, find it's data (restrictions, extensions, bases ... whatever)\n     *\n     * @param   node    DOMNode the node to parse\n     */\n    __fillNodeData(node) {\n      const schema = this.getSchema();\n\n      if (node.hasAttribute('ref')) {\n        // it's a ref, seek other element!\n        const refName = node.getAttribute('ref');\n        node = schema.getReferencedNode('attribute', refName);\n\n        if (!node) {\n          throw new Error('schema/xsd appears to be invalid, can not find element ' + refName);\n        }\n      }\n\n      if (node.hasAttribute('type')) {\n        // hacked: allow this to be used for attributes\n        const baseType = node.getAttribute('type');\n\n        if (!baseType.match(/^xsd:/)) {\n          // if it's not an xsd-default-basetype, we need to find out what it is\n          const subnode = schema.getReferencedNode('simpleType', baseType);\n          this.__fillNodeData(subnode);\n        } else {\n          this.setBaseType(baseType);\n        }\n        // is this attribute optional?\n        this.setOptional(node.getAttribute('use') !== 'required');\n\n        return;\n      }\n\n      const subNodes = Array.from(\n        node.querySelectorAll(\n          ':scope > restriction, :scope > extension, :scope > simpleType > restriction, :scope > simpleType > extension'\n        )\n      );\n\n      subNodes.forEach(subNode => {\n        const baseType = subNode.getAttribute('base');\n\n        if (!baseType.match(/^xsd:/)) {\n          // don't dive in for default-types, they simply can not be found\n          const subnode = schema.getReferencedNode('simpleType', baseType);\n          this.__fillNodeData(subnode);\n        } else {\n          this.setBaseType(baseType);\n        }\n        Array.from(subNode.querySelectorAll(':scope > pattern')).forEach(patternNode => {\n          this.__pattern.push(patternNode.getAttribute('value'));\n        });\n\n        Array.from(subNode.querySelectorAll(':scope > enumeration')).forEach(enumerationNode => {\n          this.__enumerations.push(enumerationNode.getAttribute('value'));\n        });\n      });\n\n      if (!this.getBaseType()) {\n        this.setBaseType('xsd:anyType');\n      }\n      this.__bases.push(this.getBaseType());\n    },\n\n    /**\n     * check if a given value is valid for this type\n     *\n     * @param   value   mixed   the value to check\n     * @return  boolean         if the value is valid\n     */\n    isValueValid(value) {\n      const baseType = this.getBaseType();\n      const schema = this.getSchema();\n      if (!baseType) {\n        throw new Error('something is wrong, do not have a baseType for type');\n      }\n\n      if (value === '') {\n        // empty values are valid if this node is optional!\n        return this.isOptional();\n      }\n\n      if (baseType.search(/^xsd:/) === -1) {\n        // created our own type, will need to find and use it.\n        const typeNode = schema.getTypeNode('simple', baseType);\n        const subType = new cv.ui.manager.model.schema.SimpleType(typeNode, schema);\n\n        return subType.isValueValid(value);\n      }\n      // xsd:-namespaces types, those are the originals\n      switch (baseType) {\n        case 'xsd:string':\n        case 'xsd:anyURI':\n        case 'xsd:anyType':\n          if (!(typeof value == 'string')) {\n            // it's not a string, but it should be.\n            // pretty much any input a user gives us is string, so this is pretty much moot.\n            return false;\n          }\n          break;\n        case 'xsd:decimal':\n          if (!value.match(/^[-+]?[0-9]*(\\.[0-9]+)?$/)) {\n            return false;\n          }\n          break;\n        case 'xsd:unsignedByte':\n        case 'xsd:nonNegativeInteger':\n          if (!value.match(/^[+]?[0-9]+$/)) {\n            return false;\n          }\n          break;\n        case 'xsd:integer':\n          if (!value.match(/^[-+]?[0-9]+$/)) {\n            return false;\n          }\n          break;\n        case 'xsd:float':\n          if (!value.match(/^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$/)) {\n            return false;\n          }\n          break;\n        case 'xsd:boolean':\n          if (!value.match(/^(true|false|0|1)$/)) {\n            return false;\n          }\n          break;\n        default:\n          throw new Error('not implemented baseType ' + baseType);\n      }\n\n      // check if the value is in our list of valid values, if there is such a list\n      if (this.__enumerations.length > 0) {\n        if (!this.__enumerations.includes(value)) {\n          return false;\n        }\n      }\n\n      // check if the value matches any given pattern\n      if (this.__pattern.length > 0) {\n        // start with assuming it's valid\n        let boolValid = true;\n\n        this.__pattern.forEach(item => {\n          if (!Object.prototype.hasOwnProperty.call(this.__regexCache, item)) {\n            // create a regex from the pattern; mind ^ an $ - XSD has them implicitly (XSD Datatypes, Appendix G)\n            // so for our purpose, we need to add them for every branch (that is not inside [])\n            const branchIndices = [];\n            let start = 0;\n            let i = item.indexOf('|', start);\n            while (i < item.length) {\n              if (i < 0) {\n                break;\n              }\n              // go backwards and look for an [ stop looking on ]\n              let isRootBranch = true;\n              for (let j = i; j >= start; j--) {\n                if (item[j] === ']') {\n                  break;\n                } else if (item[j] === '[') {\n                  isRootBranch = false;\n                }\n              }\n              if (isRootBranch) {\n                branchIndices.push([start, i - start]);\n              }\n              start = i + 1;\n              i = item.indexOf('|', start);\n              if (branchIndices.length > 100) {\n                this.error('too many branchIndices');\n                break;\n              }\n            }\n            if (item.length > start) {\n              // append the rest\n              branchIndices.push([start, item.length - start]);\n            }\n            const branches = branchIndices.map(\n              entry => `^${item.substr(entry[0], entry[1]).replace(/\\\\([\\s\\S])|(\\$)/g, '\\\\$1$2')}$`\n            );\n\n            this.__regexCache[item] = this.regexFromString(branches.join('|'));\n          }\n\n          if (this.__regexCache[item].test(value) === false) {\n            // regular expression did not match\n            // bad bad value!\n            boolValid = false;\n          }\n        }, this);\n\n        // if the value has been marked invalid by a regex, return invalid.\n        if (boolValid === false) {\n          return false;\n        }\n      }\n\n      // if no check said the value is invalid, then it is not invalid\n      return true;\n    },\n\n    /**\n     * get this elements enumeration (if there is any)\n     *\n     * @return  array   list of allowed values (if there are any)\n     */\n    getEnumeration() {\n      if (this.getBaseType() === 'xsd:boolean') {\n        // special handling for boolean, as we KNOW it to be an enumeration\n        return ['true', 'false'];\n      }\n\n      return this.__enumerations;\n    }\n  },\n\n  /*\n  ***********************************************\n    DESTRUCTOR\n  ***********************************************\n  */\n  destruct() {\n    this.__regexCache = null;\n  }\n});\n"
  ],
  "mappings": "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"
}