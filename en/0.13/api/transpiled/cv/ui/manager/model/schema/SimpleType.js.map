{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "cv",
    "ui",
    "manager",
    "model",
    "schema",
    "Base",
    "construct",
    "node",
    "constructor",
    "call",
    "__enumerations",
    "__pattern",
    "__regexCache",
    "__bases",
    "parse",
    "properties",
    "type",
    "refine",
    "init",
    "optional",
    "check",
    "baseType",
    "nullable",
    "members",
    "getNode",
    "setOptional",
    "getAttribute",
    "__fillNodeData",
    "__P_50_4",
    "_this",
    "getSchema",
    "hasAttribute",
    "refName",
    "getReferencedNode",
    "Error",
    "match",
    "subnode",
    "setBaseType",
    "subNodes",
    "Array",
    "from",
    "querySelectorAll",
    "forEach",
    "subNode",
    "patternNode",
    "push",
    "enumerationNode",
    "getBaseType",
    "isValueValid",
    "value",
    "_this2",
    "isOptional",
    "search",
    "typeNode",
    "getTypeNode",
    "subType",
    "SimpleType",
    "length",
    "includes",
    "boolValid",
    "item",
    "Object",
    "prototype",
    "hasOwnProperty",
    "branchIndices",
    "start",
    "i",
    "indexOf",
    "isRootBranch",
    "j",
    "error",
    "branches",
    "map",
    "entry",
    "concat",
    "substr",
    "replace",
    "regexFromString",
    "join",
    "test",
    "getEnumeration",
    "destruct"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/model/schema/SimpleType.js"
  ],
  "sourcesContent": [
    "/* SimpleType.js\n *\n * copyright (c) 2010-2022, Christian Mayer and the CometVisu contributers.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n */\n\n/**\n * a single SimpleType from the schema.\n * Should be useable for SimpleContent, too.\n * Is usable for attributes, too.\n */\nqx.Class.define('cv.ui.manager.model.schema.SimpleType', {\n  extend: cv.ui.manager.model.schema.Base,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  construct(node, schema) {\n    super(node, schema);\n    this.__enumerations = [];\n    this.__pattern = [];\n    this.__regexCache = {};\n    this.__bases = [];\n    this.parse();\n  },\n\n  /*\n  ***********************************************\n    PROPERTIES\n  ***********************************************\n  */\n  properties: {\n    type: {\n      refine: true,\n      init: 'simpleType'\n    },\n\n    optional: {\n      check: 'Boolean',\n      init: false\n    },\n\n    /**\n     * the baseType of this element, which is one of the xsd-namespaced types (like 'string')\n     * @var string\n     */\n    baseType: {\n      check: 'String',\n      nullable: true\n    }\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n    __pattern: null,\n    __enumerations: null,\n    __bases: null,\n    __regexCache: null,\n\n    parse() {\n      const node = this.getNode();\n      this.setOptional(node.getAttribute('use') === 'required');\n      this.__fillNodeData(node);\n    },\n\n    /**\n     * parse a node, find it's data (restrictions, extensions, bases ... whatever)\n     *\n     * @param   node    DOMNode the node to parse\n     */\n    __fillNodeData(node) {\n      const schema = this.getSchema();\n\n      if (node.hasAttribute('ref')) {\n        // it's a ref, seek other element!\n        const refName = node.getAttribute('ref');\n        node = schema.getReferencedNode('attribute', refName);\n\n        if (!node) {\n          throw new Error('schema/xsd appears to be invalid, can not find element ' + refName);\n        }\n      }\n\n      if (node.hasAttribute('type')) {\n        // hacked: allow this to be used for attributes\n        const baseType = node.getAttribute('type');\n\n        if (!baseType.match(/^xsd:/)) {\n          // if it's not an xsd-default-basetype, we need to find out what it is\n          const subnode = schema.getReferencedNode('simpleType', baseType);\n          this.__fillNodeData(subnode);\n        } else {\n          this.setBaseType(baseType);\n        }\n        // is this attribute optional?\n        this.setOptional(node.getAttribute('use') !== 'required');\n\n        return;\n      }\n\n      const subNodes = Array.from(\n        node.querySelectorAll(\n          ':scope > restriction, :scope > extension, :scope > simpleType > restriction, :scope > simpleType > extension'\n        )\n      );\n\n      subNodes.forEach(subNode => {\n        const baseType = subNode.getAttribute('base');\n\n        if (!baseType.match(/^xsd:/)) {\n          // don't dive in for default-types, they simply can not be found\n          const subnode = schema.getReferencedNode('simpleType', baseType);\n          this.__fillNodeData(subnode);\n        } else {\n          this.setBaseType(baseType);\n        }\n        Array.from(subNode.querySelectorAll(':scope > pattern')).forEach(patternNode => {\n          this.__pattern.push(patternNode.getAttribute('value'));\n        });\n\n        Array.from(subNode.querySelectorAll(':scope > enumeration')).forEach(enumerationNode => {\n          this.__enumerations.push(enumerationNode.getAttribute('value'));\n        });\n      });\n\n      if (!this.getBaseType()) {\n        this.setBaseType('xsd:anyType');\n      }\n      this.__bases.push(this.getBaseType());\n    },\n\n    /**\n     * check if a given value is valid for this type\n     *\n     * @param   value   mixed   the value to check\n     * @return  boolean         if the value is valid\n     */\n    isValueValid(value) {\n      const baseType = this.getBaseType();\n      const schema = this.getSchema();\n      if (!baseType) {\n        throw new Error('something is wrong, do not have a baseType for type');\n      }\n\n      if (value === '') {\n        // empty values are valid if this node is optional!\n        return this.isOptional();\n      }\n\n      if (baseType.search(/^xsd:/) === -1) {\n        // created our own type, will need to find and use it.\n        const typeNode = schema.getTypeNode('simple', baseType);\n        const subType = new cv.ui.manager.model.schema.SimpleType(typeNode, schema);\n\n        return subType.isValueValid(value);\n      }\n      // xsd:-namespaces types, those are the originals\n      switch (baseType) {\n        case 'xsd:string':\n        case 'xsd:anyURI':\n        case 'xsd:anyType':\n          if (!(typeof value == 'string')) {\n            // it's not a string, but it should be.\n            // pretty much any input a user gives us is string, so this is pretty much moot.\n            return false;\n          }\n          break;\n        case 'xsd:decimal':\n          if (!value.match(/^[-+]?[0-9]*(\\.[0-9]+)?$/)) {\n            return false;\n          }\n          break;\n        case 'xsd:unsignedByte':\n        case 'xsd:nonNegativeInteger':\n          if (!value.match(/^[+]?[0-9]+$/)) {\n            return false;\n          }\n          break;\n        case 'xsd:integer':\n          if (!value.match(/^[-+]?[0-9]+$/)) {\n            return false;\n          }\n          break;\n        case 'xsd:float':\n          if (!value.match(/^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$/)) {\n            return false;\n          }\n          break;\n        case 'xsd:boolean':\n          if (!value.match(/^(true|false|0|1)$/)) {\n            return false;\n          }\n          break;\n        default:\n          throw new Error('not implemented baseType ' + baseType);\n      }\n\n      // check if the value is in our list of valid values, if there is such a list\n      if (this.__enumerations.length > 0) {\n        if (!this.__enumerations.includes(value)) {\n          return false;\n        }\n      }\n\n      // check if the value matches any given pattern\n      if (this.__pattern.length > 0) {\n        // start with assuming it's valid\n        let boolValid = true;\n\n        this.__pattern.forEach(item => {\n          if (!Object.prototype.hasOwnProperty.call(this.__regexCache, item)) {\n            // create a regex from the pattern; mind ^ an $ - XSD has them implicitly (XSD Datatypes, Appendix G)\n            // so for our purpose, we need to add them for every branch (that is not inside [])\n            const branchIndices = [];\n            let start = 0;\n            let i = item.indexOf('|', start);\n            while (i < item.length) {\n              if (i < 0) {\n                break;\n              }\n              // go backwards and look for an [ stop looking on ]\n              let isRootBranch = true;\n              for (let j = i; j >= start; j--) {\n                if (item[j] === ']') {\n                  break;\n                } else if (item[j] === '[') {\n                  isRootBranch = false;\n                }\n              }\n              if (isRootBranch) {\n                branchIndices.push([start, i - start]);\n              }\n              start = i + 1;\n              i = item.indexOf('|', start);\n              if (branchIndices.length > 100) {\n                this.error('too many branchIndices');\n                break;\n              }\n            }\n            if (item.length > start) {\n              // append the rest\n              branchIndices.push([start, item.length - start]);\n            }\n            const branches = branchIndices.map(\n              entry => `^${item.substr(entry[0], entry[1]).replace(/\\\\([\\s\\S])|(\\$)/g, '\\\\$1$2')}$`\n            );\n\n            this.__regexCache[item] = this.regexFromString(branches.join('|'));\n          }\n\n          if (this.__regexCache[item].test(value) === false) {\n            // regular expression did not match\n            // bad bad value!\n            boolValid = false;\n          }\n        }, this);\n\n        // if the value has been marked invalid by a regex, return invalid.\n        if (boolValid === false) {\n          return false;\n        }\n      }\n\n      // if no check said the value is invalid, then it is not invalid\n      return true;\n    },\n\n    /**\n     * get this elements enumeration (if there is any)\n     *\n     * @return  array   list of allowed values (if there are any)\n     */\n    getEnumeration() {\n      if (this.getBaseType() === 'xsd:boolean') {\n        // special handling for boolean, as we KNOW it to be an enumeration\n        return ['true', 'false'];\n      }\n\n      return this.__enumerations;\n    }\n  },\n\n  /*\n  ***********************************************\n    DESTRUCTOR\n  ***********************************************\n  */\n  destruct() {\n    this.__regexCache = null;\n  }\n});\n"
  ],
  "mappings": "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"
}