{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "__elementCache",
    "__currentSchemas",
    "_dataProvider",
    "cv",
    "ui",
    "manager",
    "editor",
    "data",
    "Provider",
    "getInstance",
    "properties",
    "currentPath",
    "check",
    "nullable",
    "apply",
    "members",
    "_schemas",
    "__currentSchema",
    "__metaElementCache",
    "__rootTagName",
    "__metaTagName",
    "_getSuggestions",
    "_applyCurrentPath",
    "setStructure",
    "name",
    "loaded",
    "prototype",
    "hasOwnProperty",
    "call",
    "pure",
    "model",
    "Schema",
    "providePureCompletionItems",
    "tile",
    "provideTileCompletionItems",
    "getLastOpenedTag",
    "text",
    "tags",
    "match",
    "closingTags",
    "i",
    "length",
    "indexOf",
    "push",
    "substring",
    "tagPosition",
    "lastIndexOf",
    "tag",
    "closingBracketIdx",
    "openedTag",
    "contentSearch",
    "currentAttribute",
    "attrMatch",
    "exec",
    "filteredElementSearch",
    "test",
    "attributesMatch",
    "matchAll",
    "attributes",
    "tagName",
    "isAttributeSearch",
    "isContentSearch",
    "splice",
    "findElements",
    "parent",
    "elementName",
    "maxDepth",
    "currentDepth",
    "inMeta",
    "cache",
    "getElementNode",
    "undefined",
    "allowedElements",
    "getAllowedElements",
    "element",
    "result",
    "isItemAvailable",
    "itemName",
    "maxOccurs",
    "items",
    "count",
    "parseInt",
    "getElementString",
    "indent",
    "prefix",
    "insertText",
    "getName",
    "allowedAttributes",
    "getAllowedAttributes",
    "getOwnPropertyNames",
    "forEach",
    "attr",
    "attribute",
    "isOptional",
    "getDefaultValue",
    "requiredElements",
    "getRequiredElements",
    "allowedContent",
    "getAllowedContent",
    "isContentAllowed",
    "_text",
    "_grouping",
    "trim",
    "children",
    "elemName",
    "elem",
    "getAvailableElements",
    "usedItems",
    "availableItems",
    "filter",
    "startsWith",
    "childElem",
    "getBounds",
    "max",
    "label",
    "kind",
    "window",
    "monaco",
    "languages",
    "CompletionItemKind",
    "Field",
    "detail",
    "getType",
    "documentation",
    "getDocumentation",
    "join",
    "getAvailableAttributes",
    "usedChildTags",
    "attrs",
    "Property",
    "getTypeString",
    "detectSchema",
    "completeText",
    "endsWith",
    "getProvider",
    "triggerCharacters",
    "provideCompletionItems",
    "position",
    "setCurrentPath",
    "uri",
    "toString",
    "getValue",
    "suggestions",
    "bind",
    "textUntilPosition",
    "getValueInRange",
    "startLineNumber",
    "startColumn",
    "endLineNumber",
    "lineNumber",
    "endColumn",
    "column",
    "metaEndPos",
    "textMeta",
    "mappingNames",
    "stylingNames",
    "templates",
    "map",
    "vmap",
    "regex",
    "templatesStart",
    "templatesString",
    "replace",
    "split",
    "rawTemplate",
    "nameMatch",
    "variables",
    "vregex",
    "lastOpenedTag",
    "openedTags",
    "openedAttributes",
    "parts",
    "shift",
    "cleanedText",
    "xmlDoc",
    "xml",
    "Document",
    "fromString",
    "lastChild",
    "lastElementChild",
    "lastFound",
    "toLowerCase",
    "outerHTML",
    "nodeName",
    "entry",
    "res",
    "searchedElement",
    "getDesigns",
    "then",
    "sugg",
    "getTransforms",
    "getPlugins",
    "getIcons",
    "getInfluxDBs",
    "getInfluxDBFields",
    "includes",
    "influxAttributes",
    "getNamedItem",
    "getInfluxDBTags",
    "value",
    "getInfluxDBValues",
    "keys",
    "EnumMember",
    "templateNames",
    "variableName",
    "locale",
    "Manager",
    "tr",
    "Variable",
    "mappingName",
    "stylingName",
    "backendName",
    "getAddresses",
    "getRrds",
    "typeFilter",
    "getMediaFiles",
    "currentItem",
    "type",
    "getEnumeration",
    "Value",
    "destruct",
    "_schema",
    "completion",
    "Config"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/editor/completion/Config.js"
  ],
  "sourcesContent": [
    "/* Config.js\n *\n * copyright (c) 2010-2022, Christian Mayer and the CometVisu contributers.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n */\n\n/**\n * XSD-based code completion provider for the monaco text editor.\n *\n * @since 0.11.0\n * @author Tobias Br√§utigam\n */\nqx.Class.define('cv.ui.manager.editor.completion.Config', {\n  extend: qx.core.Object,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  /**\n   *\n   */\n  construct() {\n    super();\n    this.__elementCache = {};\n    this.__currentSchemas = {};\n    this._dataProvider = cv.ui.manager.editor.data.Provider.getInstance();\n  },\n\n  /*\n  ***********************************************\n    PROPERTIES\n  ***********************************************\n  */\n  properties: {\n    currentPath: {\n      check: 'String',\n      nullable: true,\n      apply: '_applyCurrentPath'\n    }\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n    _schemas: null,\n    __currentSchema: null,\n    __elementCache: null,\n    __metaElementCache: null,\n    _dataProvider: null,\n    __rootTagName: null,\n    __metaTagName: null,\n    _getSuggestions: null,\n\n    _applyCurrentPath() {\n      this.__currentSchema = null;\n      this.__rootTagName = '';\n    },\n\n    setStructure(name) {\n      const loaded = Object.prototype.hasOwnProperty.call(this.__currentSchemas, name);\n\n      switch (name) {\n        case 'pure':\n          if (!loaded) {\n            this.__currentSchemas.pure = cv.ui.manager.model.Schema.getInstance('visu_config.xsd');\n          }\n          this.__currentSchema = this.__currentSchemas.pure;\n          this.__rootTagName = 'pages';\n          this.__metaTagName = 'meta';\n          this._getSuggestions = this.providePureCompletionItems;\n          break;\n\n        case 'tile':\n          if (!loaded) {\n            this.__currentSchemas.tile = cv.ui.manager.model.Schema.getInstance('visu_config_tile.xsd');\n          }\n          this.__currentSchema = this.__currentSchemas.tile;\n          this.__rootTagName = 'config';\n          this.__metaTagName = 'cv-meta';\n          this._getSuggestions = this.provideTileCompletionItems;\n          break;\n      }\n    },\n\n    getLastOpenedTag(text) {\n      // get all tags inside the content\n      const tags = text.match(/<\\/*(?=\\S*)([a-zA-Z-]+)/g);\n      if (!tags) {\n        return null;\n      }\n      // we need to know which tags are closed\n      const closingTags = [];\n      for (let i = tags.length - 1; i >= 0; i--) {\n        if (tags[i].indexOf('</') === 0) {\n          closingTags.push(tags[i].substring('</'.length));\n        } else {\n          // get the last position of the tag\n          const tagPosition = text.lastIndexOf(tags[i]);\n          const tag = tags[i].substring('<'.length);\n          const closingBracketIdx = text.indexOf('/>', tagPosition);\n          // if the tag wasn't closed\n          if (closingBracketIdx === -1) {\n            // if there are no closing tags or the current tag wasn't closed\n            if (!closingTags.length || closingTags[closingTags.length - 1] !== tag) {\n              // we found our tag, but let's get the information if we are looking for\n              // a child element or an attribute\n              text = text.substring(tagPosition);\n\n              const openedTag = text.indexOf('<') > text.indexOf('>');\n              let contentSearch = false;\n              let currentAttribute = null;\n              if (openedTag) {\n                const attrMatch = /([\\w\\-_\\.\\d]+)=\"[^\"]*$/.exec(text);\n                contentSearch = !!attrMatch;\n                currentAttribute = attrMatch ? attrMatch[1] : null;\n              }\n              const filteredElementSearch = /<[\\w-_\\d]+$/.test(text);\n              const attributesMatch = [...text.matchAll(/\\s([^=]+)=\"([^\"]+)\"/g)];\n              const attributes = {};\n              for (const match of attributesMatch) {\n                attributes[match[1]] = match[2];\n              }\n              return {\n                tagName: tag,\n                currentAttribute: currentAttribute,\n                attributes: attributes,\n                filteredElementSearch: filteredElementSearch,\n                isAttributeSearch: !filteredElementSearch && openedTag && !contentSearch,\n                isContentSearch: contentSearch,\n                text: text\n              };\n            }\n            // remove the last closed tag\n            closingTags.splice(closingTags.length - 1, 1);\n          }\n          // remove the last checked tag and continue processing the rest of the content\n          text = text.substring(0, tagPosition);\n        }\n      }\n      return null;\n    },\n\n    findElements(parent, elementName, maxDepth, currentDepth, inMeta) {\n      const cache = inMeta === true ? this.__metaElementCache : this.__elementCache;\n      if (elementName in cache) {\n        return cache[elementName];\n      }\n      if (maxDepth < currentDepth) {\n        return null;\n      }\n      if (!parent) {\n        parent = this.__currentSchema.getElementNode(this.__rootTagName);\n      }\n      if (currentDepth === undefined) {\n        currentDepth = 1;\n      }\n      const allowedElements = parent.getAllowedElements();\n      // console.log(parent.name+\" looking for \"+elementName+\" in tree level \"+currentDepth+ \"(<\"+maxDepth+\") (\"+Object.getOwnPropertyNames(allowedElements).join(\", \")+\")\");\n      if (elementName in allowedElements) {\n        // console.log(\"found \"+elementName+\" in tree level \"+currentDepth);\n        this.__elementCache[elementName] = allowedElements[elementName];\n        return allowedElements[elementName];\n      }\n      for (let element in allowedElements) {\n        if (inMeta !== true && element === this.__metaTagName) {\n          continue;\n        }\n        if (maxDepth > currentDepth) {\n          const result = this.findElements(allowedElements[element], elementName, maxDepth, currentDepth + 1);\n\n          if (result) {\n            cache[elementName] = result;\n            // console.log(\"found \" + elementName + \" in tree level \" + currentDepth);\n            return result;\n          }\n        }\n      }\n      return null;\n    },\n\n    isItemAvailable(itemName, maxOccurs, items) {\n      // the default for 'maxOccurs' is 1\n      maxOccurs = maxOccurs || '1';\n      // the element can appere infinite times, so it is available\n      if (maxOccurs && maxOccurs === 'unbounded') {\n        return true;\n      }\n      // count how many times the element appeared\n      let count = 0;\n      for (let i = 0; i < items.length; i++) {\n        if (items[i] === itemName) {\n          count++;\n        }\n      }\n      // if it didn't appear yet, or it can appear again, then it\n      // is available, otherwise it't not\n      return count === 0 || parseInt(maxOccurs) > count;\n    },\n\n    getElementString(element, indent, prefix) {\n      let insertText = indent + prefix + element.getName() + ' ';\n      // add all required attributes with default values\n      const allowedAttributes = element.getAllowedAttributes();\n      Object.getOwnPropertyNames(allowedAttributes).forEach(function (attr) {\n        const attribute = allowedAttributes[attr];\n        if (!attribute.isOptional) {\n          insertText += attr + '=\"' + (attribute.getDefaultValue() ? attribute.getDefaultValue() : '') + '\" ';\n        }\n      });\n      // add mandatory children\n      const requiredElements = element.getRequiredElements();\n      const allowedContent = element.getAllowedContent();\n      const isContentAllowed = allowedContent._text || requiredElements.length > 0 || !!allowedContent._grouping;\n      if (!isContentAllowed) {\n        // close tag\n        insertText = insertText.trim() + '/';\n      } else {\n        // close open tag\n        insertText = insertText.trim() + '>';\n\n        // insert required elements\n        let children = 0;\n        requiredElements.forEach(function (elemName) {\n          const elem = this.findElements(element, elemName, 1, 0);\n          if (elem) {\n            insertText += '\\n    ' + this.getElementString(elem, indent + '    ', '<') + '>';\n            children++;\n          }\n        }, this);\n        // add closing tag\n        if (children > 0) {\n          insertText += '\\n' + indent;\n        }\n        insertText += '</' + element.getName();\n      }\n      return insertText;\n    },\n\n    getAvailableElements(element, usedItems) {\n      const availableItems = [];\n      const children = element.getAllowedElements();\n\n      // if there are no such elements, then there are no suggestions\n      if (!children) {\n        return [];\n      }\n      Object.getOwnPropertyNames(children)\n        .filter(name => !name.startsWith('#'))\n        .forEach(function (name) {\n          // get all element attributes\n          const childElem = children[name];\n          // the element is a suggestion if it's available\n          if (this.isItemAvailable(childElem.getName(), childElem.getBounds().max, usedItems)) {\n            // mark it as a 'field', and get the documentation\n            availableItems.push({\n              label: childElem.getName(),\n              insertText: this.getElementString(childElem, '', ''),\n              kind: window.monaco.languages.CompletionItemKind.Field,\n              detail: childElem.getType(),\n              documentation: childElem.getDocumentation().join('\\n')\n            });\n          }\n        }, this);\n      // return the suggestions we found\n      return availableItems;\n    },\n\n    getAvailableAttributes(element, usedChildTags) {\n      const availableItems = [];\n      // get all attributes for the element\n      const attrs = element.getAllowedAttributes();\n      Object.getOwnPropertyNames(attrs).forEach(function (name) {\n        const attr = attrs[name];\n        // accept it in a suggestion list only the attribute is not used yet\n        if (usedChildTags.indexOf(attr.name) === -1) {\n          // mark it as a 'property', and get it's documentation\n          availableItems.push({\n            label: attr.getName(),\n            insertText: attr.getName() + '=\"\"',\n            kind: window.monaco.languages.CompletionItemKind.Property,\n            detail: attr.getTypeString(),\n            documentation: attr.getDocumentation().join('\\n')\n          });\n        }\n      }, this);\n\n      // return the elements we found\n      return availableItems;\n    },\n\n    detectSchema(completeText) {\n      const match = /:noNamespaceSchemaLocation=\"([^\"]+)\"/.exec(completeText.substring(0, 200));\n\n      if (match && match[1].endsWith('visu_config_tile.xsd')) {\n        this.setStructure('tile');\n      } else {\n        this.setStructure('pure');\n      }\n    },\n\n    getProvider() {\n      return {\n        triggerCharacters: ['<', '\"'],\n        provideCompletionItems: function (model, position) {\n          this.setCurrentPath(model.uri.toString());\n          const completeText = model.getValue();\n          if (!this.__currentSchema) {\n            this.detectSchema(completeText);\n          }\n          if (this._getSuggestions) {\n            return this._getSuggestions(model, position);\n          }\n          return { suggestions: [] };\n        }.bind(this)\n      };\n    },\n\n    providePureCompletionItems(model, position) {\n      // get editor content before the pointer\n      const textUntilPosition = model.getValueInRange({\n        startLineNumber: 1,\n        startColumn: 1,\n        endLineNumber: position.lineNumber,\n        endColumn: position.column\n      });\n\n      // parse mappings\n      const completeText = model.getValue();\n      const metaEndPos = completeText.indexOf('</meta>');\n      const textMeta = metaEndPos > 0 ? completeText.substring(0, metaEndPos) : completeText;\n      const mappingNames = [];\n      const stylingNames = [];\n      const templates = {};\n      let map;\n      let vmap;\n      let regex = /<mapping name=\"([^\"]+)\"/gm;\n      while ((map = regex.exec(textMeta)) !== null) {\n        mappingNames.push(map[1]);\n      }\n      regex = /<styling name=\"([^\"]+)\"/gm;\n      while ((map = regex.exec(textMeta)) !== null) {\n        stylingNames.push(map[1]);\n      }\n      const templatesStart = textMeta.indexOf('<templates>');\n      if (templatesStart >= 0) {\n        const templatesString = textMeta\n          .substring(templatesStart + 11, textMeta.indexOf('</templates>') - 12)\n          .replace(/(?:\\r\\n|\\r|\\n)/g, '');\n        templatesString.split('</template>').forEach(function (rawTemplate) {\n          const nameMatch = /<template name=\"([^\"]+)\"/.exec(rawTemplate);\n          // search for variables\n          const variables = [];\n          const vregex = /{{{?\\s*([\\w\\d]+)\\s*}?}}/gm;\n          while ((vmap = vregex.exec(rawTemplate)) !== null) {\n            variables.push(vmap[1]);\n          }\n          templates[nameMatch[1]] = variables;\n        }, this);\n      }\n\n      // if we want suggestions, inside of which tag are we?\n      const lastOpenedTag = this.getLastOpenedTag(textUntilPosition);\n      // console.log(lastOpenedTag);\n      // get opened tags to see what tag we should look for in the XSD schema\n      const openedTags = [];\n      // attrobutes of the ancestors\n      const openedAttributes = [];\n      // get the elements/attributes that are already mentioned in the element we're in\n      const usedItems = [];\n      const isAttributeSearch = lastOpenedTag && lastOpenedTag.isAttributeSearch;\n      const isContentSearch = lastOpenedTag && lastOpenedTag.isContentSearch;\n      const filteredElementSearch = lastOpenedTag && lastOpenedTag.filteredElementSearch;\n      // no need to calculate the position in the XSD schema if we are in the root element\n      let parts;\n      if (lastOpenedTag) {\n        // try to create a valid XML document\n        parts = lastOpenedTag.text.split(' ');\n        parts.shift();\n        let cleanedText = textUntilPosition;\n        if (parts.length) {\n          cleanedText = cleanedText.substring(0, cleanedText.length - parts.join(' ').length) + '>';\n        }\n        // parse the content (not cleared text) into an xml document\n        const xmlDoc = qx.xml.Document.fromString(cleanedText);\n        let lastChild = xmlDoc.lastElementChild;\n        let i;\n        let lastFound = false;\n        while (lastChild && lastChild.tagName.toLowerCase() !== 'parsererror') {\n          openedTags.push(lastChild.tagName);\n          openedAttributes.push(lastChild.attributes);\n          // if we found our last opened tag\n          if (lastChild.tagName === lastOpenedTag.tagName) {\n            lastFound = true;\n            // if we are looking for attributes, then used items should\n            // be the attributes we already used\n            if (lastOpenedTag.isAttributeSearch && lastChild.outerHTML === lastOpenedTag.text) {\n              const attrs = lastChild.attributes;\n              for (i = 0; i < attrs.length; i++) {\n                usedItems.push(attrs[i].nodeName);\n              }\n            } else {\n              // if we are looking for child elements, then used items\n              // should be the elements that were already used\n              const children = lastChild.children;\n              for (i = 0; i < children.length; i++) {\n                if (children[i].tagName.toLowerCase() !== 'parsererror') {\n                  usedItems.push(children[i].tagName);\n                }\n              }\n            }\n            break;\n          }\n          // we haven't found the last opened tag yet, so we move to\n          // the next element\n          lastChild = lastChild.lastElementChild;\n        }\n        if (!lastFound) {\n          // fallback -> parse string\n          if (isAttributeSearch || isContentSearch) {\n            parts = lastOpenedTag.text.split(' ');\n            // skip tag name\n            parts.shift();\n            parts.forEach(function (entry) {\n              usedItems.push(entry.split('=').shift());\n            });\n          }\n        }\n      }\n      let res = [];\n      let match;\n      // find the last opened tag in the schema to see what elements/attributes it can have\n      let searchedElement = openedTags[openedTags.length - 1];\n      if (isContentSearch) {\n        // handle data providers if the is one relevant\n        if (lastOpenedTag.tagName === 'pages' && lastOpenedTag.currentAttribute === 'design') {\n          return this._dataProvider.getDesigns(null, null, 'pure').then(function (sugg) {\n            return { suggestions: sugg };\n          });\n        } else if (lastOpenedTag.tagName === 'address' && lastOpenedTag.currentAttribute === 'transform') {\n          return { suggestions: this._dataProvider.getTransforms() };\n        } else if (lastOpenedTag.tagName === 'plugin' && lastOpenedTag.currentAttribute === 'name') {\n          return { suggestions: this._dataProvider.getPlugins() };\n        } else if (lastOpenedTag.tagName === 'icon' && lastOpenedTag.currentAttribute === 'name') {\n          return {\n            suggestions: this._dataProvider.getIcons('monaco', { cache: false }, completeText)\n          };\n        } else if (lastOpenedTag.tagName === 'influx') {\n          if (lastOpenedTag.currentAttribute === 'measurement') {\n            return this._dataProvider.getInfluxDBs().then(function (suggestions) {\n              return { suggestions: suggestions };\n            });\n          } else if (lastOpenedTag.currentAttribute === 'field') {\n            match = /measurement=\"([^\"]+)\"/.exec(lastOpenedTag.text);\n            if (match) {\n              return this._dataProvider.getInfluxDBFields(match[1]).then(function (suggestions) {\n                return { suggestions: suggestions };\n              });\n            }\n          }\n        } else if (\n          lastOpenedTag.tagName === 'tag' &&\n          (lastOpenedTag.currentAttribute === 'key' || lastOpenedTag.currentAttribute === 'value') &&\n          openedTags.includes('influx')\n        ) {\n          const influxAttributes = openedAttributes[openedTags.indexOf('influx')];\n          const attr = influxAttributes.getNamedItem('measurement');\n          if (attr) {\n            if (lastOpenedTag.currentAttribute === 'key') {\n              return this._dataProvider.getInfluxDBTags(attr.value).then(function (suggestions) {\n                return { suggestions: suggestions };\n              });\n            } else if (lastOpenedTag.currentAttribute === 'value') {\n              match = /key=\"([^\"]+)\"/.exec(lastOpenedTag.text);\n              if (match) {\n                return this._dataProvider.getInfluxDBValues(attr.value, match[1]).then(function (suggestions) {\n                  return { suggestions: suggestions };\n                });\n              }\n            }\n          }\n        } else if (\n          lastOpenedTag.tagName === 'template' &&\n          lastOpenedTag.currentAttribute === 'name' &&\n          openedTags.includes('meta')\n        ) {\n          res = Object.keys(templates).map(function (name) {\n            return {\n              label: name,\n              insertText: name,\n              kind: window.monaco.languages.CompletionItemKind.EnumMember\n            };\n          }, this);\n          return { suggestions: res };\n        } else if (\n          lastOpenedTag.tagName === 'value' &&\n          lastOpenedTag.currentAttribute === 'name' &&\n          !openedTags.includes('meta') &&\n          openedTags.includes('template')\n        ) {\n          // TODO: find out template name\n          const templateNames = Object.keys(templates);\n          templateNames.forEach(function (name) {\n            templates[name].forEach(function (variableName) {\n              res.push({\n                label: variableName,\n                insertText: variableName,\n                detail: qx.locale.Manager.tr('Variable from template %1', name),\n                kind: window.monaco.languages.CompletionItemKind.Variable\n              });\n            }, this);\n          }, this);\n          return { suggestions: res };\n        } else if (lastOpenedTag.currentAttribute === 'mapping') {\n          res = mappingNames.map(function (mappingName) {\n            return {\n              label: mappingName,\n              insertText: mappingName,\n              kind: window.monaco.languages.CompletionItemKind.EnumMember\n            };\n          }, this);\n          return { suggestions: res };\n        } else if (lastOpenedTag.currentAttribute === 'styling') {\n          res = stylingNames.map(function (stylingName) {\n            return {\n              label: stylingName,\n              insertText: stylingName,\n              kind: window.monaco.languages.CompletionItemKind.EnumMember\n            };\n          }, this);\n          return { suggestions: res };\n        }\n\n        // TODO: completions that have to be retrieved from the backend\n        // * rrds\n        // * Influx: dbs, tags fields\n        // * media files\n\n        searchedElement = lastOpenedTag.tagName;\n      } else if (!isAttributeSearch && filteredElementSearch) {\n        searchedElement = openedTags[openedTags.length - 2];\n      } else if (lastOpenedTag.tagName === 'address' && lastOpenedTag.currentAttribute === null) {\n        const backendName = lastOpenedTag.attributes['backend'] || 'main';\n        return this._dataProvider.getAddresses('monaco', null, backendName).then(res => ({ suggestions: res }));\n      }\n      if (searchedElement === 'rrd') {\n        return this._dataProvider.getRrds('monaco').then(res => ({ suggestions: res }));\n      } else if (searchedElement === 'file' && !isAttributeSearch && !isContentSearch && openedTags.includes('files')) {\n        match = /type=\"([^\"]+)\"/.exec(lastOpenedTag.text);\n        const typeFilter = match ? match[1] : null;\n        return this._dataProvider.getMediaFiles(typeFilter).then(function (suggestions) {\n          return { suggestions: suggestions };\n        });\n      }\n      const currentItem = this.findElements(\n        this.__currentSchema.getElementNode('pages'),\n        searchedElement,\n        openedTags.length,\n        openedTags.includes('meta')\n      );\n\n      // return available elements/attributes if the tag exists in the schema, or an empty\n      // array if it doesn't\n      if (isContentSearch) {\n        const currentAttribute = usedItems[usedItems.length - 1];\n\n        if (currentItem && currentAttribute in currentItem.getAllowedAttributes()) {\n          const attribute = currentItem.getAllowedAttributes()[currentAttribute];\n          const type = attribute.getTypeString();\n          attribute.getEnumeration().forEach(function (entry) {\n            res.push({\n              label: entry,\n              insertText: entry,\n              kind: window.monaco.languages.CompletionItemKind.Value,\n              detail: type,\n              documentation: attribute.getDocumentation().join('\\n')\n            });\n          });\n        }\n      } else if (isAttributeSearch) {\n        // get attributes completions\n        res = currentItem ? this.getAvailableAttributes(currentItem, usedItems) : [];\n      } else {\n        // get elements completions\n        // eslint-disable-next-line no-lonely-if\n        if (lastOpenedTag && lastOpenedTag.text.endsWith('</')) {\n          res.push({\n            label: lastOpenedTag.tagName,\n            insertText: lastOpenedTag.tagName,\n            kind: window.monaco.languages.CompletionItemKind.Field\n          });\n        } else {\n          res = currentItem ? this.getAvailableElements(currentItem, usedItems) : [];\n        }\n      }\n      return { suggestions: res };\n    },\n\n    provideTileCompletionItems(model, position) {\n      // get editor content before the pointer\n      const textUntilPosition = model.getValueInRange({\n        startLineNumber: 1,\n        startColumn: 1,\n        endLineNumber: position.lineNumber,\n        endColumn: position.column\n      });\n\n      // parse mappings\n      const completeText = model.getValue();\n      const metaEndPos = completeText.indexOf('</cv-meta>');\n      const textMeta = metaEndPos > 0 ? completeText.substring(0, metaEndPos) : completeText;\n      const mappingNames = [];\n      const stylingNames = [];\n      let map;\n      let regex = /<cv-mapping name=\"([^\"]+)\"/gm;\n      while ((map = regex.exec(textMeta)) !== null) {\n        mappingNames.push(map[1]);\n      }\n      regex = /<cv-styling name=\"([^\"]+)\"/gm;\n      while ((map = regex.exec(textMeta)) !== null) {\n        stylingNames.push(map[1]);\n      }\n\n      // if we want suggestions, inside which tag are we?\n      const lastOpenedTag = this.getLastOpenedTag(textUntilPosition);\n      // console.log(lastOpenedTag);\n      // get opened tags to see what tag we should look for in the XSD schema\n      const openedTags = [];\n      // attributes of the ancestors\n      const openedAttributes = [];\n      // get the elements/attributes that are already mentioned in the element we're in\n      const usedItems = [];\n      const isAttributeSearch = lastOpenedTag && lastOpenedTag.isAttributeSearch;\n      const isContentSearch = lastOpenedTag && lastOpenedTag.isContentSearch;\n      const filteredElementSearch = lastOpenedTag && lastOpenedTag.filteredElementSearch;\n      // no need to calculate the position in the XSD schema if we are in the root element\n      let parts;\n      if (lastOpenedTag) {\n        // try to create a valid XML document\n        parts = lastOpenedTag.text.split(' ');\n        parts.shift();\n        let cleanedText = textUntilPosition;\n        if (parts.length) {\n          cleanedText = cleanedText.substring(0, cleanedText.length - parts.join(' ').length) + '>';\n        }\n        // parse the content (not cleared text) into a xml document\n        const xmlDoc = qx.xml.Document.fromString(cleanedText);\n        let lastChild = xmlDoc.lastElementChild;\n        let i;\n        let lastFound = false;\n        while (lastChild) {\n          openedTags.push(lastChild.tagName);\n          openedAttributes.push(lastChild.attributes);\n          // if we found our last opened tag\n          if (lastChild.tagName === lastOpenedTag.tagName) {\n            lastFound = true;\n            // if we are looking for attributes, then used items should\n            // be the attributes we already used\n            if (lastOpenedTag.isAttributeSearch && lastChild.outerHTML === lastOpenedTag.text) {\n              const attrs = lastChild.attributes;\n              for (i = 0; i < attrs.length; i++) {\n                usedItems.push(attrs[i].nodeName);\n              }\n            } else {\n              // if we are looking for child elements, then used items\n              // should be the elements that were already used\n              const children = lastChild.children;\n              for (i = 0; i < children.length; i++) {\n                if (children[i].tagName.toLowerCase() !== 'parsererror') {\n                  usedItems.push(children[i].tagName);\n                }\n              }\n            }\n            break;\n          }\n          // we haven't found the last opened tag yet, so we move to\n          // the next element\n          lastChild = lastChild.lastElementChild;\n        }\n        if (!lastFound) {\n          // fallback -> parse string\n          if (isAttributeSearch || isContentSearch) {\n            parts = lastOpenedTag.text.split(' ');\n            // skip tag name\n            parts.shift();\n            parts.forEach(entry => {\n              usedItems.push(entry.split('=').shift());\n            });\n          }\n        }\n      }\n      let res = [];\n      let match;\n      // find the last opened tag in the schema to see what elements/attributes it can have\n      let searchedElement = openedTags[openedTags.length - 1];\n      if (isContentSearch) {\n        // handle data providers if the is one relevant\n        if (lastOpenedTag.tagName === 'config' && lastOpenedTag.currentAttribute === 'design') {\n          const suggestions = this._dataProvider.getDesigns(null, null, 'tile');\n          return { suggestions: suggestions };\n        } else if (lastOpenedTag.tagName === 'cv-address' && lastOpenedTag.currentAttribute === 'transform') {\n          return { suggestions: this._dataProvider.getTransforms() };\n        } else if (lastOpenedTag.tagName === 'cv-icon' && lastOpenedTag.currentAttribute === 'name') {\n          return { suggestions: this._dataProvider.getIcons() };\n        } else if (lastOpenedTag.currentAttribute === 'mapping') {\n          res = mappingNames.map(function (mappingName) {\n            return {\n              label: mappingName,\n              insertText: mappingName,\n              kind: window.monaco.languages.CompletionItemKind.EnumMember\n            };\n          }, this);\n          return { suggestions: res };\n        } else if (lastOpenedTag.currentAttribute === 'styling') {\n          res = stylingNames.map(function (stylingName) {\n            return {\n              label: stylingName,\n              insertText: stylingName,\n              kind: window.monaco.languages.CompletionItemKind.EnumMember\n            };\n          }, this);\n          return { suggestions: res };\n        }\n        searchedElement = lastOpenedTag.tagName;\n      } else if (!isAttributeSearch && filteredElementSearch) {\n        searchedElement = openedTags[openedTags.length - 2];\n      } else if (lastOpenedTag.tagName === 'cv-address' && lastOpenedTag.currentAttribute === null) {\n        const backendName = lastOpenedTag.attributes['backend'] || 'main';\n        return this._dataProvider.getAddresses('monaco', null, backendName).then(res => ({ suggestions: res }));\n      } else if (lastOpenedTag.tagName === 'cv-chart' && lastOpenedTag.currentAttribute === 'src') {\n        return this._dataProvider.getRrds('monaco').then(res => ({ suggestions: res }));\n      } else if (lastOpenedTag.tagName === 'cv-loader' && lastOpenedTag.currentAttribute === 'src') {\n        match = /type=\"([^\"]+)\"/.exec(lastOpenedTag.text);\n        const typeFilter = match ? match[1] : null;\n        return this._dataProvider.getMediaFiles(typeFilter).then(function (suggestions) {\n          return { suggestions: suggestions };\n        });\n      }\n      const currentItem = this.findElements(\n        this.__currentSchema.getElementNode('config'),\n        searchedElement,\n        openedTags.length,\n        openedTags.includes('cv-meta')\n      );\n\n      // return available elements/attributes if the tag exists in the schema, or an empty\n      // array if it doesn't\n      if (isContentSearch) {\n        const currentAttribute = lastOpenedTag.currentAttribute;\n\n        if (currentItem && currentAttribute in currentItem.getAllowedAttributes()) {\n          const attribute = currentItem.getAllowedAttributes()[currentAttribute];\n          const type = attribute.getTypeString();\n          attribute.getEnumeration().forEach(function (entry) {\n            res.push({\n              label: entry,\n              insertText: entry,\n              kind: window.monaco.languages.CompletionItemKind.Value,\n              detail: type,\n              documentation: attribute.getDocumentation().join('\\n')\n            });\n          });\n        }\n      } else if (isAttributeSearch) {\n        // get attributes completions\n        res = currentItem ? this.getAvailableAttributes(currentItem, usedItems) : [];\n      } else {\n        // get elements completions\n        // eslint-disable-next-line no-lonely-if\n        if (lastOpenedTag && lastOpenedTag.text.endsWith('</')) {\n          res.push({\n            label: lastOpenedTag.tagName,\n            insertText: lastOpenedTag.tagName,\n            kind: window.monaco.languages.CompletionItemKind.Field\n          });\n        } else {\n          res = currentItem ? this.getAvailableElements(currentItem, usedItems) : [];\n        }\n      }\n      return { suggestions: res };\n    }\n  },\n\n  /*\n  ***********************************************\n    DESTRUCTOR\n  ***********************************************\n  */\n  destruct() {\n    this.__elementCache = null;\n    this._schema = null;\n    this._dataProvider = null;\n  }\n});\n"
  ],
  "mappings": "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"
}