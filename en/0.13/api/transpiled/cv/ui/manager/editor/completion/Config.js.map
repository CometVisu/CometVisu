{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "__elementCache",
    "__currentSchemas",
    "_dataProvider",
    "cv",
    "ui",
    "manager",
    "editor",
    "data",
    "Provider",
    "getInstance",
    "properties",
    "currentPath",
    "check",
    "nullable",
    "apply",
    "members",
    "_schemas",
    "__currentSchema",
    "__metaElementCache",
    "__rootTagName",
    "__metaTagName",
    "_getSuggestions",
    "_applyCurrentPath",
    "setStructure",
    "name",
    "loaded",
    "prototype",
    "hasOwnProperty",
    "call",
    "model",
    "Schema",
    "pure",
    "providePureCompletionItems",
    "tile",
    "provideTileCompletionItems",
    "getLastOpenedTag",
    "text",
    "tags",
    "match",
    "closingTags",
    "i",
    "length",
    "indexOf",
    "push",
    "substring",
    "tagPosition",
    "lastIndexOf",
    "tag",
    "closingBracketIdx",
    "openedTag",
    "contentSearch",
    "currentAttribute",
    "attrMatch",
    "exec",
    "filteredElementSearch",
    "test",
    "attributesMatch",
    "matchAll",
    "attributes",
    "tagName",
    "isAttributeSearch",
    "isContentSearch",
    "splice",
    "findElements",
    "parent",
    "elementName",
    "maxDepth",
    "currentDepth",
    "inMeta",
    "cache",
    "getElementNode",
    "undefined",
    "allowedElements",
    "getAllowedElements",
    "element",
    "result",
    "isItemAvailable",
    "itemName",
    "maxOccurs",
    "items",
    "count",
    "parseInt",
    "getElementString",
    "indent",
    "prefix",
    "insertText",
    "getName",
    "allowedAttributes",
    "getAllowedAttributes",
    "getOwnPropertyNames",
    "forEach",
    "attr",
    "attribute",
    "isOptional",
    "getDefaultValue",
    "requiredElements",
    "getRequiredElements",
    "allowedContent",
    "getAllowedContent",
    "isContentAllowed",
    "_text",
    "_grouping",
    "trim",
    "children",
    "elemName",
    "elem",
    "getAvailableElements",
    "usedItems",
    "availableItems",
    "filter",
    "startsWith",
    "childElem",
    "getBounds",
    "max",
    "label",
    "kind",
    "window",
    "monaco",
    "languages",
    "CompletionItemKind",
    "Field",
    "detail",
    "getType",
    "documentation",
    "getDocumentation",
    "join",
    "getAvailableAttributes",
    "usedChildTags",
    "attrs",
    "Property",
    "getTypeString",
    "detectSchema",
    "completeText",
    "endsWith",
    "getProvider",
    "triggerCharacters",
    "provideCompletionItems",
    "position",
    "setCurrentPath",
    "uri",
    "toString",
    "getValue",
    "suggestions",
    "bind",
    "textUntilPosition",
    "getValueInRange",
    "startLineNumber",
    "startColumn",
    "endLineNumber",
    "lineNumber",
    "endColumn",
    "column",
    "metaEndPos",
    "textMeta",
    "mappingNames",
    "stylingNames",
    "templates",
    "map",
    "vmap",
    "regex",
    "templatesStart",
    "templatesString",
    "replace",
    "split",
    "rawTemplate",
    "nameMatch",
    "variables",
    "vregex",
    "lastOpenedTag",
    "openedTags",
    "openedAttributes",
    "parts",
    "shift",
    "cleanedText",
    "xmlDoc",
    "xml",
    "Document",
    "fromString",
    "lastChild",
    "lastElementChild",
    "lastFound",
    "toLowerCase",
    "outerHTML",
    "nodeName",
    "entry",
    "res",
    "searchedElement",
    "getDesigns",
    "then",
    "sugg",
    "getTransforms",
    "getPlugins",
    "getIcons",
    "getInfluxDBs",
    "getInfluxDBFields",
    "includes",
    "influxAttributes",
    "getNamedItem",
    "getInfluxDBTags",
    "value",
    "getInfluxDBValues",
    "keys",
    "EnumMember",
    "templateNames",
    "variableName",
    "locale",
    "Manager",
    "tr",
    "Variable",
    "mappingName",
    "stylingName",
    "backendName",
    "getAddresses",
    "getRrds",
    "typeFilter",
    "getMediaFiles",
    "currentItem",
    "type",
    "getEnumeration",
    "Value",
    "destruct",
    "_schema",
    "completion",
    "Config"
  ],
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/editor/completion/Config.js"
  ],
  "sourcesContent": [
    "/* Config.js\n *\n * copyright (c) 2010-2022, Christian Mayer and the CometVisu contributers.\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n */\n\n/**\n * XSD-based code completion provider for the monaco text editor.\n *\n * @since 0.11.0\n * @author Tobias Br√§utigam\n */\nqx.Class.define('cv.ui.manager.editor.completion.Config', {\n  extend: qx.core.Object,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  /**\n   *\n   */\n  construct() {\n    super();\n    this.__elementCache = {};\n    this.__currentSchemas = {};\n    this._dataProvider = cv.ui.manager.editor.data.Provider.getInstance();\n  },\n\n  /*\n  ***********************************************\n    PROPERTIES\n  ***********************************************\n  */\n  properties: {\n    currentPath: {\n      check: 'String',\n      nullable: true,\n      apply: '_applyCurrentPath'\n    }\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n    _schemas: null,\n    __currentSchema: null,\n    __elementCache: null,\n    __metaElementCache: null,\n    _dataProvider: null,\n    __rootTagName: null,\n    __metaTagName: null,\n    _getSuggestions: null,\n\n    _applyCurrentPath() {\n      this.__currentSchema = null;\n      this.__rootTagName = '';\n    },\n\n    async setStructure(name) {\n      const loaded = Object.prototype.hasOwnProperty.call(this.__currentSchemas, name);\n\n      switch (name) {\n        case 'pure':\n          if (!loaded) {\n            this.__currentSchemas.pure = await cv.ui.manager.model.Schema.getInstance('visu_config.xsd');\n          }\n          this.__currentSchema = this.__currentSchemas.pure;\n          this.__rootTagName = 'pages';\n          this.__metaTagName = 'meta';\n          this._getSuggestions = this.providePureCompletionItems;\n          break;\n\n        case 'tile':\n          if (!loaded) {\n            this.__currentSchemas.tile = await cv.ui.manager.model.Schema.getInstance('visu_config_tile.xsd');\n          }\n          this.__currentSchema = this.__currentSchemas.tile;\n          this.__rootTagName = 'config';\n          this.__metaTagName = 'cv-meta';\n          this._getSuggestions = this.provideTileCompletionItems;\n          break;\n      }\n    },\n\n    getLastOpenedTag(text) {\n      // get all tags inside the content\n      const tags = text.match(/<\\/*(?=\\S*)([a-zA-Z-]+)/g);\n      if (!tags) {\n        return null;\n      }\n      // we need to know which tags are closed\n      const closingTags = [];\n      for (let i = tags.length - 1; i >= 0; i--) {\n        if (tags[i].indexOf('</') === 0) {\n          closingTags.push(tags[i].substring('</'.length));\n        } else {\n          // get the last position of the tag\n          const tagPosition = text.lastIndexOf(tags[i]);\n          const tag = tags[i].substring('<'.length);\n          const closingBracketIdx = text.indexOf('/>', tagPosition);\n          // if the tag wasn't closed\n          if (closingBracketIdx === -1) {\n            // if there are no closing tags or the current tag wasn't closed\n            if (!closingTags.length || closingTags[closingTags.length - 1] !== tag) {\n              // we found our tag, but let's get the information if we are looking for\n              // a child element or an attribute\n              text = text.substring(tagPosition);\n\n              const openedTag = text.indexOf('<') > text.indexOf('>');\n              let contentSearch = false;\n              let currentAttribute = null;\n              if (openedTag) {\n                const attrMatch = /([\\w\\-_\\.\\d]+)=\"[^\"]*$/.exec(text);\n                contentSearch = !!attrMatch;\n                currentAttribute = attrMatch ? attrMatch[1] : null;\n              }\n              const filteredElementSearch = /<[\\w-_\\d]+$/.test(text);\n              const attributesMatch = [...text.matchAll(/\\s([^=]+)=\"([^\"]+)\"/g)];\n              const attributes = {};\n              for (const match of attributesMatch) {\n                attributes[match[1]] = match[2];\n              }\n              return {\n                tagName: tag,\n                currentAttribute: currentAttribute,\n                attributes: attributes,\n                filteredElementSearch: filteredElementSearch,\n                isAttributeSearch: !filteredElementSearch && openedTag && !contentSearch,\n                isContentSearch: contentSearch,\n                text: text\n              };\n            }\n            // remove the last closed tag\n            closingTags.splice(closingTags.length - 1, 1);\n          }\n          // remove the last checked tag and continue processing the rest of the content\n          text = text.substring(0, tagPosition);\n        }\n      }\n      return null;\n    },\n\n    findElements(parent, elementName, maxDepth, currentDepth, inMeta) {\n      const cache = inMeta === true ? this.__metaElementCache : this.__elementCache;\n      if (elementName in cache) {\n        return cache[elementName];\n      }\n      if (maxDepth < currentDepth) {\n        return null;\n      }\n      if (!parent) {\n        parent = this.__currentSchema.getElementNode(this.__rootTagName);\n      }\n      if (currentDepth === undefined) {\n        currentDepth = 1;\n      }\n      const allowedElements = parent.getAllowedElements();\n      // console.log(parent.name+\" looking for \"+elementName+\" in tree level \"+currentDepth+ \"(<\"+maxDepth+\") (\"+Object.getOwnPropertyNames(allowedElements).join(\", \")+\")\");\n      if (elementName in allowedElements) {\n        // console.log(\"found \"+elementName+\" in tree level \"+currentDepth);\n        this.__elementCache[elementName] = allowedElements[elementName];\n        return allowedElements[elementName];\n      }\n      for (let element in allowedElements) {\n        if (inMeta !== true && element === this.__metaTagName) {\n          continue;\n        }\n        if (maxDepth > currentDepth) {\n          const result = this.findElements(allowedElements[element], elementName, maxDepth, currentDepth + 1);\n\n          if (result) {\n            cache[elementName] = result;\n            // console.log(\"found \" + elementName + \" in tree level \" + currentDepth);\n            return result;\n          }\n        }\n      }\n      return null;\n    },\n\n    isItemAvailable(itemName, maxOccurs, items) {\n      // the default for 'maxOccurs' is 1\n      maxOccurs = maxOccurs || '1';\n      // the element can appere infinite times, so it is available\n      if (maxOccurs && maxOccurs === 'unbounded') {\n        return true;\n      }\n      // count how many times the element appeared\n      let count = 0;\n      for (let i = 0; i < items.length; i++) {\n        if (items[i] === itemName) {\n          count++;\n        }\n      }\n      // if it didn't appear yet, or it can appear again, then it\n      // is available, otherwise it't not\n      return count === 0 || parseInt(maxOccurs) > count;\n    },\n\n    getElementString(element, indent, prefix) {\n      let insertText = indent + prefix + element.getName() + ' ';\n      // add all required attributes with default values\n      const allowedAttributes = element.getAllowedAttributes();\n      Object.getOwnPropertyNames(allowedAttributes).forEach(function (attr) {\n        const attribute = allowedAttributes[attr];\n        if (!attribute.isOptional) {\n          insertText += attr + '=\"' + (attribute.getDefaultValue() ? attribute.getDefaultValue() : '') + '\" ';\n        }\n      });\n      // add mandatory children\n      const requiredElements = element.getRequiredElements();\n      const allowedContent = element.getAllowedContent();\n      const isContentAllowed = allowedContent._text || requiredElements.length > 0 || !!allowedContent._grouping;\n      if (!isContentAllowed) {\n        // close tag\n        insertText = insertText.trim() + '/';\n      } else {\n        // close open tag\n        insertText = insertText.trim() + '>';\n\n        // insert required elements\n        let children = 0;\n        requiredElements.forEach(function (elemName) {\n          const elem = this.findElements(element, elemName, 1, 0);\n          if (elem) {\n            insertText += '\\n    ' + this.getElementString(elem, indent + '    ', '<') + '>';\n            children++;\n          }\n        }, this);\n        // add closing tag\n        if (children > 0) {\n          insertText += '\\n' + indent;\n        }\n        insertText += '</' + element.getName();\n      }\n      return insertText;\n    },\n\n    getAvailableElements(element, usedItems) {\n      const availableItems = [];\n      const children = element.getAllowedElements();\n\n      // if there are no such elements, then there are no suggestions\n      if (!children) {\n        return [];\n      }\n      Object.getOwnPropertyNames(children)\n        .filter(name => !name.startsWith('#'))\n        .forEach(function (name) {\n          // get all element attributes\n          const childElem = children[name];\n          // the element is a suggestion if it's available\n          if (this.isItemAvailable(childElem.getName(), childElem.getBounds().max, usedItems)) {\n            // mark it as a 'field', and get the documentation\n            availableItems.push({\n              label: childElem.getName(),\n              insertText: this.getElementString(childElem, '', ''),\n              kind: window.monaco.languages.CompletionItemKind.Field,\n              detail: childElem.getType(),\n              documentation: childElem.getDocumentation().join('\\n')\n            });\n          }\n        }, this);\n      // return the suggestions we found\n      return availableItems;\n    },\n\n    getAvailableAttributes(element, usedChildTags) {\n      const availableItems = [];\n      // get all attributes for the element\n      const attrs = element.getAllowedAttributes();\n      Object.getOwnPropertyNames(attrs).forEach(function (name) {\n        const attr = attrs[name];\n        // accept it in a suggestion list only the attribute is not used yet\n        if (usedChildTags.indexOf(attr.name) === -1) {\n          // mark it as a 'property', and get it's documentation\n          availableItems.push({\n            label: attr.getName(),\n            insertText: attr.getName() + '=\"\"',\n            kind: window.monaco.languages.CompletionItemKind.Property,\n            detail: attr.getTypeString(),\n            documentation: attr.getDocumentation().join('\\n')\n          });\n        }\n      }, this);\n\n      // return the elements we found\n      return availableItems;\n    },\n\n    async detectSchema(completeText) {\n      const match = /:noNamespaceSchemaLocation=\"([^\"]+)\"/.exec(completeText.substring(0, 200));\n\n      if (match && match[1].endsWith('visu_config_tile.xsd')) {\n        await this.setStructure('tile');\n      } else {\n        await this.setStructure('pure');\n      }\n    },\n\n    getProvider() {\n      return {\n        triggerCharacters: ['<', '\"'],\n        provideCompletionItems: async function (model, position) {\n          this.setCurrentPath(model.uri.toString());\n          const completeText = model.getValue();\n          if (!this.__currentSchema) {\n            await this.detectSchema(completeText);\n          }\n          if (this._getSuggestions) {\n            return this._getSuggestions(model, position);\n          }\n          return { suggestions: [] };\n        }.bind(this)\n      };\n    },\n\n    providePureCompletionItems(model, position) {\n      // get editor content before the pointer\n      const textUntilPosition = model.getValueInRange({\n        startLineNumber: 1,\n        startColumn: 1,\n        endLineNumber: position.lineNumber,\n        endColumn: position.column\n      });\n\n      // parse mappings\n      const completeText = model.getValue();\n      const metaEndPos = completeText.indexOf('</meta>');\n      const textMeta = metaEndPos > 0 ? completeText.substring(0, metaEndPos) : completeText;\n      const mappingNames = [];\n      const stylingNames = [];\n      const templates = {};\n      let map;\n      let vmap;\n      let regex = /<mapping name=\"([^\"]+)\"/gm;\n      while ((map = regex.exec(textMeta)) !== null) {\n        mappingNames.push(map[1]);\n      }\n      regex = /<styling name=\"([^\"]+)\"/gm;\n      while ((map = regex.exec(textMeta)) !== null) {\n        stylingNames.push(map[1]);\n      }\n      const templatesStart = textMeta.indexOf('<templates>');\n      if (templatesStart >= 0) {\n        const templatesString = textMeta\n          .substring(templatesStart + 11, textMeta.indexOf('</templates>') - 12)\n          .replace(/(?:\\r\\n|\\r|\\n)/g, '');\n        templatesString.split('</template>').forEach(function (rawTemplate) {\n          const nameMatch = /<template name=\"([^\"]+)\"/.exec(rawTemplate);\n          // search for variables\n          const variables = [];\n          const vregex = /{{{?\\s*([\\w\\d]+)\\s*}?}}/gm;\n          while ((vmap = vregex.exec(rawTemplate)) !== null) {\n            variables.push(vmap[1]);\n          }\n          templates[nameMatch[1]] = variables;\n        }, this);\n      }\n\n      // if we want suggestions, inside of which tag are we?\n      const lastOpenedTag = this.getLastOpenedTag(textUntilPosition);\n      // console.log(lastOpenedTag);\n      // get opened tags to see what tag we should look for in the XSD schema\n      const openedTags = [];\n      // attrobutes of the ancestors\n      const openedAttributes = [];\n      // get the elements/attributes that are already mentioned in the element we're in\n      const usedItems = [];\n      const isAttributeSearch = lastOpenedTag && lastOpenedTag.isAttributeSearch;\n      const isContentSearch = lastOpenedTag && lastOpenedTag.isContentSearch;\n      const filteredElementSearch = lastOpenedTag && lastOpenedTag.filteredElementSearch;\n      // no need to calculate the position in the XSD schema if we are in the root element\n      let parts;\n      if (lastOpenedTag) {\n        // try to create a valid XML document\n        parts = lastOpenedTag.text.split(' ');\n        parts.shift();\n        let cleanedText = textUntilPosition;\n        if (parts.length) {\n          cleanedText = cleanedText.substring(0, cleanedText.length - parts.join(' ').length) + '>';\n        }\n        // parse the content (not cleared text) into an xml document\n        const xmlDoc = qx.xml.Document.fromString(cleanedText);\n        let lastChild = xmlDoc.lastElementChild;\n        let i;\n        let lastFound = false;\n        while (lastChild && lastChild.tagName.toLowerCase() !== 'parsererror') {\n          openedTags.push(lastChild.tagName);\n          openedAttributes.push(lastChild.attributes);\n          // if we found our last opened tag\n          if (lastChild.tagName === lastOpenedTag.tagName) {\n            lastFound = true;\n            // if we are looking for attributes, then used items should\n            // be the attributes we already used\n            if (lastOpenedTag.isAttributeSearch && lastChild.outerHTML === lastOpenedTag.text) {\n              const attrs = lastChild.attributes;\n              for (i = 0; i < attrs.length; i++) {\n                usedItems.push(attrs[i].nodeName);\n              }\n            } else {\n              // if we are looking for child elements, then used items\n              // should be the elements that were already used\n              const children = lastChild.children;\n              for (i = 0; i < children.length; i++) {\n                if (children[i].tagName.toLowerCase() !== 'parsererror') {\n                  usedItems.push(children[i].tagName);\n                }\n              }\n            }\n            break;\n          }\n          // we haven't found the last opened tag yet, so we move to\n          // the next element\n          lastChild = lastChild.lastElementChild;\n        }\n        if (!lastFound) {\n          // fallback -> parse string\n          if (isAttributeSearch || isContentSearch) {\n            parts = lastOpenedTag.text.split(' ');\n            // skip tag name\n            parts.shift();\n            parts.forEach(function (entry) {\n              usedItems.push(entry.split('=').shift());\n            });\n          }\n        }\n      }\n      let res = [];\n      let match;\n      // find the last opened tag in the schema to see what elements/attributes it can have\n      let searchedElement = openedTags[openedTags.length - 1];\n      if (isContentSearch) {\n        // handle data providers if the is one relevant\n        if (lastOpenedTag.tagName === 'pages' && lastOpenedTag.currentAttribute === 'design') {\n          return this._dataProvider.getDesigns(null, null, 'pure').then(function (sugg) {\n            return { suggestions: sugg };\n          });\n        } else if (lastOpenedTag.tagName === 'address' && lastOpenedTag.currentAttribute === 'transform') {\n          return { suggestions: this._dataProvider.getTransforms() };\n        } else if (lastOpenedTag.tagName === 'plugin' && lastOpenedTag.currentAttribute === 'name') {\n          return { suggestions: this._dataProvider.getPlugins() };\n        } else if (lastOpenedTag.tagName === 'icon' && lastOpenedTag.currentAttribute === 'name') {\n          return {\n            suggestions: this._dataProvider.getIcons('monaco', { cache: false }, completeText)\n          };\n        } else if (lastOpenedTag.tagName === 'influx') {\n          if (lastOpenedTag.currentAttribute === 'measurement') {\n            return this._dataProvider.getInfluxDBs().then(function (suggestions) {\n              return { suggestions: suggestions };\n            });\n          } else if (lastOpenedTag.currentAttribute === 'field') {\n            match = /measurement=\"([^\"]+)\"/.exec(lastOpenedTag.text);\n            if (match) {\n              return this._dataProvider.getInfluxDBFields(match[1]).then(function (suggestions) {\n                return { suggestions: suggestions };\n              });\n            }\n          }\n        } else if (\n          lastOpenedTag.tagName === 'tag' &&\n          (lastOpenedTag.currentAttribute === 'key' || lastOpenedTag.currentAttribute === 'value') &&\n          openedTags.includes('influx')\n        ) {\n          const influxAttributes = openedAttributes[openedTags.indexOf('influx')];\n          const attr = influxAttributes.getNamedItem('measurement');\n          if (attr) {\n            if (lastOpenedTag.currentAttribute === 'key') {\n              return this._dataProvider.getInfluxDBTags(attr.value).then(function (suggestions) {\n                return { suggestions: suggestions };\n              });\n            } else if (lastOpenedTag.currentAttribute === 'value') {\n              match = /key=\"([^\"]+)\"/.exec(lastOpenedTag.text);\n              if (match) {\n                return this._dataProvider.getInfluxDBValues(attr.value, match[1]).then(function (suggestions) {\n                  return { suggestions: suggestions };\n                });\n              }\n            }\n          }\n        } else if (\n          lastOpenedTag.tagName === 'template' &&\n          lastOpenedTag.currentAttribute === 'name' &&\n          openedTags.includes('meta')\n        ) {\n          res = Object.keys(templates).map(function (name) {\n            return {\n              label: name,\n              insertText: name,\n              kind: window.monaco.languages.CompletionItemKind.EnumMember\n            };\n          }, this);\n          return { suggestions: res };\n        } else if (\n          lastOpenedTag.tagName === 'value' &&\n          lastOpenedTag.currentAttribute === 'name' &&\n          !openedTags.includes('meta') &&\n          openedTags.includes('template')\n        ) {\n          // TODO: find out template name\n          const templateNames = Object.keys(templates);\n          templateNames.forEach(function (name) {\n            templates[name].forEach(function (variableName) {\n              res.push({\n                label: variableName,\n                insertText: variableName,\n                detail: qx.locale.Manager.tr('Variable from template %1', name),\n                kind: window.monaco.languages.CompletionItemKind.Variable\n              });\n            }, this);\n          }, this);\n          return { suggestions: res };\n        } else if (lastOpenedTag.currentAttribute === 'mapping') {\n          res = mappingNames.map(function (mappingName) {\n            return {\n              label: mappingName,\n              insertText: mappingName,\n              kind: window.monaco.languages.CompletionItemKind.EnumMember\n            };\n          }, this);\n          return { suggestions: res };\n        } else if (lastOpenedTag.currentAttribute === 'styling') {\n          res = stylingNames.map(function (stylingName) {\n            return {\n              label: stylingName,\n              insertText: stylingName,\n              kind: window.monaco.languages.CompletionItemKind.EnumMember\n            };\n          }, this);\n          return { suggestions: res };\n        }\n\n        // TODO: completions that have to be retrieved from the backend\n        // * rrds\n        // * Influx: dbs, tags fields\n        // * media files\n\n        searchedElement = lastOpenedTag.tagName;\n      } else if (!isAttributeSearch && filteredElementSearch) {\n        searchedElement = openedTags[openedTags.length - 2];\n      } else if (lastOpenedTag.tagName === 'address' && lastOpenedTag.currentAttribute === null) {\n        const backendName = lastOpenedTag.attributes['backend'] || 'main';\n        return this._dataProvider.getAddresses('monaco', null, backendName).then(res => ({ suggestions: res }));\n      }\n      if (searchedElement === 'rrd') {\n        return this._dataProvider.getRrds('monaco').then(res => ({ suggestions: res }));\n      } else if (searchedElement === 'file' && !isAttributeSearch && !isContentSearch && openedTags.includes('files')) {\n        match = /type=\"([^\"]+)\"/.exec(lastOpenedTag.text);\n        const typeFilter = match ? match[1] : null;\n        return this._dataProvider.getMediaFiles(typeFilter).then(function (suggestions) {\n          return { suggestions: suggestions };\n        });\n      }\n      const currentItem = this.findElements(\n        this.__currentSchema.getElementNode('pages'),\n        searchedElement,\n        openedTags.length,\n        openedTags.includes('meta')\n      );\n\n      // return available elements/attributes if the tag exists in the schema, or an empty\n      // array if it doesn't\n      if (isContentSearch) {\n        const currentAttribute = usedItems[usedItems.length - 1];\n\n        if (currentItem && currentAttribute in currentItem.getAllowedAttributes()) {\n          const attribute = currentItem.getAllowedAttributes()[currentAttribute];\n          const type = attribute.getTypeString();\n          attribute.getEnumeration().forEach(function (entry) {\n            res.push({\n              label: entry,\n              insertText: entry,\n              kind: window.monaco.languages.CompletionItemKind.Value,\n              detail: type,\n              documentation: attribute.getDocumentation().join('\\n')\n            });\n          });\n        }\n      } else if (isAttributeSearch) {\n        // get attributes completions\n        res = currentItem ? this.getAvailableAttributes(currentItem, usedItems) : [];\n      } else {\n        // get elements completions\n        // eslint-disable-next-line no-lonely-if\n        if (lastOpenedTag && lastOpenedTag.text.endsWith('</')) {\n          res.push({\n            label: lastOpenedTag.tagName,\n            insertText: lastOpenedTag.tagName,\n            kind: window.monaco.languages.CompletionItemKind.Field\n          });\n        } else {\n          res = currentItem ? this.getAvailableElements(currentItem, usedItems) : [];\n        }\n      }\n      return { suggestions: res };\n    },\n\n    provideTileCompletionItems(model, position) {\n      // get editor content before the pointer\n      const textUntilPosition = model.getValueInRange({\n        startLineNumber: 1,\n        startColumn: 1,\n        endLineNumber: position.lineNumber,\n        endColumn: position.column\n      });\n\n      // parse mappings\n      const completeText = model.getValue();\n      const metaEndPos = completeText.indexOf('</cv-meta>');\n      const textMeta = metaEndPos > 0 ? completeText.substring(0, metaEndPos) : completeText;\n      const mappingNames = [];\n      const stylingNames = [];\n      let map;\n      let regex = /<cv-mapping name=\"([^\"]+)\"/gm;\n      while ((map = regex.exec(textMeta)) !== null) {\n        mappingNames.push(map[1]);\n      }\n      regex = /<cv-styling name=\"([^\"]+)\"/gm;\n      while ((map = regex.exec(textMeta)) !== null) {\n        stylingNames.push(map[1]);\n      }\n\n      // if we want suggestions, inside which tag are we?\n      const lastOpenedTag = this.getLastOpenedTag(textUntilPosition);\n      // console.log(lastOpenedTag);\n      // get opened tags to see what tag we should look for in the XSD schema\n      const openedTags = [];\n      // attributes of the ancestors\n      const openedAttributes = [];\n      // get the elements/attributes that are already mentioned in the element we're in\n      const usedItems = [];\n      const isAttributeSearch = lastOpenedTag && lastOpenedTag.isAttributeSearch;\n      const isContentSearch = lastOpenedTag && lastOpenedTag.isContentSearch;\n      const filteredElementSearch = lastOpenedTag && lastOpenedTag.filteredElementSearch;\n      // no need to calculate the position in the XSD schema if we are in the root element\n      let parts;\n      if (lastOpenedTag) {\n        // try to create a valid XML document\n        parts = lastOpenedTag.text.split(' ');\n        parts.shift();\n        let cleanedText = textUntilPosition;\n        if (parts.length) {\n          cleanedText = cleanedText.substring(0, cleanedText.length - parts.join(' ').length) + '>';\n        }\n        // parse the content (not cleared text) into a xml document\n        const xmlDoc = qx.xml.Document.fromString(cleanedText);\n        let lastChild = xmlDoc.lastElementChild;\n        let i;\n        let lastFound = false;\n        while (lastChild) {\n          openedTags.push(lastChild.tagName);\n          openedAttributes.push(lastChild.attributes);\n          // if we found our last opened tag\n          if (lastChild.tagName === lastOpenedTag.tagName) {\n            lastFound = true;\n            // if we are looking for attributes, then used items should\n            // be the attributes we already used\n            if (lastOpenedTag.isAttributeSearch && lastChild.outerHTML === lastOpenedTag.text) {\n              const attrs = lastChild.attributes;\n              for (i = 0; i < attrs.length; i++) {\n                usedItems.push(attrs[i].nodeName);\n              }\n            } else {\n              // if we are looking for child elements, then used items\n              // should be the elements that were already used\n              const children = lastChild.children;\n              for (i = 0; i < children.length; i++) {\n                if (children[i].tagName.toLowerCase() !== 'parsererror') {\n                  usedItems.push(children[i].tagName);\n                }\n              }\n            }\n            break;\n          }\n          // we haven't found the last opened tag yet, so we move to\n          // the next element\n          lastChild = lastChild.lastElementChild;\n        }\n        if (!lastFound) {\n          // fallback -> parse string\n          if (isAttributeSearch || isContentSearch) {\n            parts = lastOpenedTag.text.split(' ');\n            // skip tag name\n            parts.shift();\n            parts.forEach(entry => {\n              usedItems.push(entry.split('=').shift());\n            });\n          }\n        }\n      }\n      let res = [];\n      let match;\n      // find the last opened tag in the schema to see what elements/attributes it can have\n      let searchedElement = openedTags[openedTags.length - 1];\n      if (isContentSearch) {\n        // handle data providers if the is one relevant\n        if (lastOpenedTag.tagName === 'config' && lastOpenedTag.currentAttribute === 'design') {\n          const suggestions = this._dataProvider.getDesigns(null, null, 'tile');\n          return { suggestions: suggestions };\n        } else if (lastOpenedTag.tagName === 'cv-address' && lastOpenedTag.currentAttribute === 'transform') {\n          return { suggestions: this._dataProvider.getTransforms() };\n        } else if (lastOpenedTag.tagName === 'cv-icon' && lastOpenedTag.currentAttribute === 'name') {\n          return { suggestions: this._dataProvider.getIcons() };\n        } else if (lastOpenedTag.currentAttribute === 'mapping') {\n          res = mappingNames.map(function (mappingName) {\n            return {\n              label: mappingName,\n              insertText: mappingName,\n              kind: window.monaco.languages.CompletionItemKind.EnumMember\n            };\n          }, this);\n          return { suggestions: res };\n        } else if (lastOpenedTag.currentAttribute === 'styling') {\n          res = stylingNames.map(function (stylingName) {\n            return {\n              label: stylingName,\n              insertText: stylingName,\n              kind: window.monaco.languages.CompletionItemKind.EnumMember\n            };\n          }, this);\n          return { suggestions: res };\n        }\n        searchedElement = lastOpenedTag.tagName;\n      } else if (!isAttributeSearch && filteredElementSearch) {\n        searchedElement = openedTags[openedTags.length - 2];\n      } else if (lastOpenedTag.tagName === 'cv-address' && lastOpenedTag.currentAttribute === null) {\n        const backendName = lastOpenedTag.attributes['backend'] || 'main';\n        return this._dataProvider.getAddresses('monaco', null, backendName).then(res => ({ suggestions: res }));\n      } else if (lastOpenedTag.tagName === 'cv-chart' && lastOpenedTag.currentAttribute === 'src') {\n        return this._dataProvider.getRrds('monaco').then(res => ({ suggestions: res }));\n      } else if (lastOpenedTag.tagName === 'cv-loader' && lastOpenedTag.currentAttribute === 'src') {\n        match = /type=\"([^\"]+)\"/.exec(lastOpenedTag.text);\n        const typeFilter = match ? match[1] : null;\n        return this._dataProvider.getMediaFiles(typeFilter).then(function (suggestions) {\n          return { suggestions: suggestions };\n        });\n      }\n      const currentItem = this.findElements(\n        this.__currentSchema.getElementNode('config'),\n        searchedElement,\n        openedTags.length,\n        openedTags.includes('cv-meta')\n      );\n\n      // return available elements/attributes if the tag exists in the schema, or an empty\n      // array if it doesn't\n      if (isContentSearch) {\n        const currentAttribute = lastOpenedTag.currentAttribute;\n\n        if (currentItem && currentAttribute in currentItem.getAllowedAttributes()) {\n          const attribute = currentItem.getAllowedAttributes()[currentAttribute];\n          const type = attribute.getTypeString();\n          attribute.getEnumeration().forEach(function (entry) {\n            res.push({\n              label: entry,\n              insertText: entry,\n              kind: window.monaco.languages.CompletionItemKind.Value,\n              detail: type,\n              documentation: attribute.getDocumentation().join('\\n')\n            });\n          });\n        }\n      } else if (isAttributeSearch) {\n        // get attributes completions\n        res = currentItem ? this.getAvailableAttributes(currentItem, usedItems) : [];\n      } else {\n        // get elements completions\n        // eslint-disable-next-line no-lonely-if\n        if (lastOpenedTag && lastOpenedTag.text.endsWith('</')) {\n          res.push({\n            label: lastOpenedTag.tagName,\n            insertText: lastOpenedTag.tagName,\n            kind: window.monaco.languages.CompletionItemKind.Field\n          });\n        } else {\n          res = currentItem ? this.getAvailableElements(currentItem, usedItems) : [];\n        }\n      }\n      return { suggestions: res };\n    }\n  },\n\n  /*\n  ***********************************************\n    DESTRUCTOR\n  ***********************************************\n  */\n  destruct() {\n    this.__elementCache = null;\n    this._schema = null;\n    this._dataProvider = null;\n  }\n});\n"
  ],
  "mappings": "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"
}