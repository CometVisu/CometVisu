{
  "version": 0.3,
  "lastModified": 1722153602031,
  "lastModifiedIso": "2024-07-28T08:00:02.031Z",
  "classFilename": "../../node_modules/@qooxdoo/framework/source/class/qx/io/request/Xhr.js",
  "type": "class",
  "location": {
    "start": {
      "line": 64,
      "column": 0,
      "index": 2012
    },
    "end": {
      "line": 336,
      "column": 3,
      "index": 9960
    }
  },
  "className": "qx.io.request.Xhr",
  "jsdoc": {
    "raw": [
      "*",
      " * Send HTTP requests and handle responses using the HTTP client API.",
      " *",
      " * Configuration of the request is done with properties. Events are fired for",
      " * various states in the life cycle of a request, such as \"success\". Request",
      " * data is transparently processed.",
      " *",
      " * Here is how to request a JSON file and listen to the \"success\" event:",
      " *",
      " * <pre class=\"javascript\">",
      " * var req = new qx.io.request.Xhr(\"/some/path/file.json\");",
      " *",
      " * req.addListener(\"success\", function(e) {",
      " *   var req = e.getTarget();",
      " *",
      " *   // Response parsed according to the server's",
      " *   // response content type, e.g. JSON",
      " *   req.getResponse();",
      " * }, this);",
      " *",
      " * // Send request",
      " * req.send();",
      " * </pre>",
      " *",
      " * Some noteable features:",
      " *",
      " * * Abstraction of low-level request",
      " * * Convenient setup using properties",
      " * * Fine-grained events",
      " * * Symbolic phases",
      " * * Transparent processing of request data",
      " * * Stream-lined authentication",
      " * * Automagic parsing of response based on content type",
      " *",
      " * Cross-origin requests are supported, but require browser support",
      " * (see <a href=\"http://caniuse.com/#search=CORS\">caniuse.com</a>) and backend configuration",
      " * (see <a href=\"https://developer.mozilla.org/en-US/docs/docs/HTTP/Access_control_CORS>MDN</a>).",
      " * Note that IE's <code>XDomainRequest</code> is not currently supported.",
      " * For a cross-browser alternative, consider {@link qx.io.request.Jsonp}.",
      " *",
      " * In order to debug requests, set the environment flag",
      " * <code>qx.debug.io</code>.",
      " *",
      " * Internally uses {@link qx.bom.request.Xhr}.",
      " "
    ],
    "@description": [
      {
        "name": "@description",
        "body": "<p>Send HTTP requests and handle responses using the HTTP client API.\n Configuration of the request is done with properties. Events are fired for\n various states in the life cycle of a request, such as \"success\". Request\n data is transparently processed.\n Here is how to request a JSON file and listen to the \"success\" event:\n </p>\n<pre class=\"javascript\">\n var req = new qx.io.request.Xhr(\"/some/path/file.json\");\n req.addListener(\"success\", function(e) {\n   var req = e.getTarget();\n\n\n   req.getResponse();\n }, this);\n\n req.send();\n </pre>\n<p>Some noteable features:</p>\n<ul>\n<li>Abstraction of low-level request</li>\n<li>Convenient setup using properties</li>\n<li>Fine-grained events</li>\n<li>Symbolic phases</li>\n<li>Transparent processing of request data</li>\n<li>Stream-lined authentication</li>\n<li>Automagic parsing of response based on content type\nCross-origin requests are supported, but require browser support\n(see <a href=\"http://caniuse.com/#search=CORS\">caniuse.com</a>) and backend configuration\n(see <a href=\"https://developer.mozilla.org/en-US/docs/docs/HTTP/Access_control_CORS>MDN</a>).\nNote that IE's <code>XDomainRequest</code> is not currently supported.\nFor a cross-browser alternative, consider {@link qx.io.request.Jsonp}.\nIn order to debug requests, set the environment flag\n<code>qx.debug.io</code>.\nInternally uses {@link qx.bom.request.Xhr}.</li>\n</ul>"
      }
    ]
  },
  "superClass": "qx.io.request.AbstractRequest",
  "construct": {
    "type": "function",
    "params": [
      {
        "name": "url"
      },
      {
        "name": "method"
      }
    ],
    "location": {
      "start": {
        "line": 71,
        "column": 2,
        "index": 2215
      },
      "end": {
        "line": 78,
        "column": 3,
        "index": 2377
      }
    }
  },
  "events": {
    "readyStateChange": {
      "type": "qx.event.type.Event",
      "jsdoc": {
        "raw": [
          "*",
          "     * Fired on every change of the transport’s readyState.",
          "     *",
          "     * See {@link qx.bom.request.Xhr} for available readyStates.",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": "<p>Fired on every change of the transport’s readyState.\n See {@link qx.bom.request.Xhr} for available readyStates.</p>"
          }
        ]
      },
      "location": {
        "start": {
          "line": 89,
          "column": 4,
          "index": 2666
        },
        "end": {
          "line": 89,
          "column": 43,
          "index": 2705
        }
      }
    },
    "success": {
      "type": "qx.event.type.Event",
      "jsdoc": {
        "raw": [
          "*",
          "     * Fired when request completes without error and transport status",
          "     * indicates success.",
          "     *",
          "     * Refer to {@link qx.util.Request#isSuccessful} for a list of HTTP",
          "     * status considered successful.",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": "<p>Fired when request completes without error and transport status\n indicates success.\n Refer to {@link qx.util.Request#isSuccessful} for a list of HTTP\n status considered successful.</p>"
          }
        ]
      },
      "location": {
        "start": {
          "line": 98,
          "column": 4,
          "index": 2941
        },
        "end": {
          "line": 98,
          "column": 34,
          "index": 2971
        }
      }
    },
    "load": {
      "type": "qx.event.type.Event",
      "jsdoc": {
        "raw": [
          "*",
          "     * Fired when request completes without error.",
          "     *",
          "     * Every request not canceled or aborted completes. This means that",
          "     * even requests receiving a response with erroneous HTTP status",
          "     * fire a \"load\" event. If you are only interested in successful",
          "     * responses, listen to the {@link #success} event instead.",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": "<p>Fired when request completes without error.\n Every request not canceled or aborted completes. This means that\n even requests receiving a response with erroneous HTTP status\n fire a \"load\" event. If you are only interested in successful\n responses, listen to the {@link #success} event instead.</p>"
          }
        ]
      },
      "location": {
        "start": {
          "line": 108,
          "column": 4,
          "index": 3326
        },
        "end": {
          "line": 108,
          "column": 31,
          "index": 3353
        }
      }
    },
    "statusError": {
      "type": "qx.event.type.Event",
      "jsdoc": {
        "raw": [
          "*",
          "     * Fired when request completes without error but erroneous HTTP status.",
          "     *",
          "     * Refer to {@link qx.util.Request#isSuccessful} for a list of HTTP",
          "     * status considered successful.",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": "<p>Fired when request completes without error but erroneous HTTP status.\n Refer to {@link qx.util.Request#isSuccessful} for a list of HTTP\n status considered successful.</p>"
          }
        ]
      },
      "location": {
        "start": {
          "line": 116,
          "column": 4,
          "index": 3569
        },
        "end": {
          "line": 116,
          "column": 38,
          "index": 3603
        }
      }
    }
  },
  "properties": {
    "method": {
      "location": {
        "start": {
          "line": 123,
          "column": 4,
          "index": 3670
        },
        "end": {
          "line": 125,
          "column": 5,
          "index": 3703
        }
      },
      "json": {
        "init": "GET"
      },
      "jsdoc": {
        "raw": [
          "*",
          "     * The HTTP method.",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": "<p>The HTTP method.</p>"
          }
        ]
      },
      "appearsIn": []
    },
    "async": {
      "location": {
        "start": {
          "line": 130,
          "column": 4,
          "index": 3788
        },
        "end": {
          "line": 133,
          "column": 5,
          "index": 3843
        }
      },
      "json": {
        "check": "Boolean",
        "init": true
      },
      "jsdoc": {
        "raw": [
          "*",
          "     * Whether the request should be executed asynchronously.",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": "<p>Whether the request should be executed asynchronously.</p>"
          }
        ]
      },
      "appearsIn": []
    },
    "accept": {
      "location": {
        "start": {
          "line": 145,
          "column": 4,
          "index": 4257
        },
        "end": {
          "line": 148,
          "column": 5,
          "index": 4316
        }
      },
      "json": {
        "check": "String",
        "nullable": true
      },
      "jsdoc": {
        "raw": [
          "*",
          "     * The content type to accept. By default, every content type",
          "     * is accepted.",
          "     *",
          "     * Note: Some backends send distinct representations of the same",
          "     * resource depending on the content type accepted. For instance,",
          "     * a backend may respond with either a JSON (the accept header",
          "     * indicates so) or a HTML representation (the default, no accept",
          "     * header given).",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": "<p>The content type to accept. By default, every content type\n is accepted.\n Note: Some backends send distinct representations of the same\n resource depending on the content type accepted. For instance,\n a backend may respond with either a JSON (the accept header\n indicates so) or a HTML representation (the default, no accept\n header given).</p>"
          }
        ]
      },
      "appearsIn": []
    },
    "cache": {
      "location": {
        "start": {
          "line": 181,
          "column": 4,
          "index": 5849
        },
        "end": {
          "line": 186,
          "column": 5,
          "index": 5988
        }
      },
      "json": {
        "check": "[[ ObjectMethod Function ]]",
        "init": true
      },
      "jsdoc": {
        "raw": [
          "*",
          "     * Whether to allow request to be answered from cache.",
          "     *",
          "     * Allowed values:",
          "     *",
          "     * * <code>true</code>: Allow caching (Default)",
          "     * * <code>false</code>: Prohibit caching. Appends nocache parameter to URL.",
          "     * * <code>String</code>: Any Cache-Control request directive",
          "     *",
          "     * If a string is given, it is inserted in the request's Cache-Control",
          "     * header. A request’s Cache-Control header may contain a number of directives",
          "     * controlling the behavior of any caches in between client and origin",
          "     * server.",
          "     *",
          "     * * <code>\"no-cache\"</code>: Force caches to submit request in order to",
          "     *   validate the freshness of the representation. Note that the requested",
          "     *   resource may still be served from cache if the representation is",
          "     *   considered fresh. Use this directive to ensure freshness but save",
          "     *   bandwidth when possible.",
          "     * * <code>\"no-store\"</code>: Do not keep a copy of the representation under",
          "     *   any conditions.",
          "     *",
          "     * See <a href=\"http://www.mnot.net/cache_docs/#CACHE-CONTROL\">",
          "     * Caching tutorial</a> for an excellent introduction to Caching in general.",
          "     * Refer to the corresponding section in the",
          "     * <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9\">",
          "     * HTTP 1.1 specification</a> for more details and advanced directives.",
          "     *",
          "     * It is recommended to choose an appropriate Cache-Control directive rather",
          "     * than prohibit caching using the nocache parameter.",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": "<p>Whether to allow request to be answered from cache.\n Allowed values:</p>\n<ul>\n<li><code>true</code>: Allow caching (Default)</li>\n<li><code>false</code>: Prohibit caching. Appends nocache parameter to URL.</li>\n<li><code>String</code>: Any Cache-Control request directive\nIf a string is given, it is inserted in the request's Cache-Control\nheader. A request’s Cache-Control header may contain a number of directives\ncontrolling the behavior of any caches in between client and origin\nserver.</li>\n<li><code>\"no-cache\"</code>: Force caches to submit request in order to\nvalidate the freshness of the representation. Note that the requested\nresource may still be served from cache if the representation is\nconsidered fresh. Use this directive to ensure freshness but save\nbandwidth when possible.</li>\n<li><code>\"no-store\"</code>: Do not keep a copy of the representation under\nany conditions.\nSee <a href=\"http://www.mnot.net/cache_docs/#CACHE-CONTROL\">\nCaching tutorial</a> for an excellent introduction to Caching in general.\nRefer to the corresponding section in the\n<a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9\">\nHTTP 1.1 specification</a> for more details and advanced directives.\nIt is recommended to choose an appropriate Cache-Control directive rather\nthan prohibit caching using the nocache parameter.</li>\n</ul>"
          }
        ]
      },
      "appearsIn": []
    }
  },
  "members": {
    "_parser": {
      "jsdoc": {
        "raw": [
          "*",
          "     * @type {Function} Parser.",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": ""
          }
        ],
        "@type": [
          {
            "name": "@type",
            "body": "{Function} Parser."
          }
        ]
      },
      "access": "protected",
      "location": {
        "start": {
          "line": 193,
          "column": 4,
          "index": 6060
        },
        "end": {
          "line": 193,
          "column": 17,
          "index": 6073
        }
      },
      "appearsIn": []
    },
    "_createTransport": {
      "jsdoc": {
        "raw": [
          "*",
          "     * Create XHR transport.",
          "     *",
          "     * @return {qx.bom.request.Xhr} Transport.",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": "<p>Create XHR transport.</p>"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.bom.request.Xhr} Transport.",
            "type": "qx.bom.request.Xhr",
            "description": "Transport."
          }
        ]
      },
      "access": "protected",
      "location": {
        "start": {
          "line": 206,
          "column": 4,
          "index": 6380
        },
        "end": {
          "line": 208,
          "column": 5,
          "index": 6445
        }
      },
      "type": "function",
      "params": [],
      "returnType": {
        "type": "qx.bom.request.Xhr"
      },
      "overriddenFrom": "qx.io.request.AbstractRequest",
      "appearsIn": [
        "qx.io.request.AbstractRequest"
      ]
    },
    "_getConfiguredUrl": {
      "jsdoc": {
        "raw": [
          "*",
          "     * Get configured URL.",
          "     *",
          "     * Append request data to URL if HTTP method is GET. Append random",
          "     * string to URL if required by value of {@link #cache}.",
          "     *",
          "     * @return {String} The configured URL.",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": "<p>Get configured URL.\n Append request data to URL if HTTP method is GET. Append random\n string to URL if required by value of {@link #cache}.</p>"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{String} The configured URL.",
            "type": "string",
            "description": "The configured URL."
          }
        ]
      },
      "access": "protected",
      "location": {
        "start": {
          "line": 218,
          "column": 4,
          "index": 6685
        },
        "end": {
          "line": 235,
          "column": 5,
          "index": 7223
        }
      },
      "type": "function",
      "params": [],
      "returnType": {
        "type": "string"
      },
      "overriddenFrom": "qx.io.request.AbstractRequest",
      "appearsIn": [
        "qx.io.request.AbstractRequest"
      ]
    },
    "_getConfiguredRequestHeaders": {
      "jsdoc": {
        "raw": [
          " overridden"
        ]
      },
      "access": "protected",
      "location": {
        "start": {
          "line": 238,
          "column": 4,
          "index": 7248
        },
        "end": {
          "line": 269,
          "column": 5,
          "index": 8354
        }
      },
      "type": "function",
      "params": [],
      "overriddenFrom": "qx.io.request.AbstractRequest",
      "appearsIn": [
        "qx.io.request.AbstractRequest"
      ]
    },
    "_getMethod": {
      "jsdoc": {
        "raw": [
          " overridden"
        ]
      },
      "access": "protected",
      "location": {
        "start": {
          "line": 272,
          "column": 4,
          "index": 8379
        },
        "end": {
          "line": 274,
          "column": 5,
          "index": 8430
        }
      },
      "type": "function",
      "params": [],
      "overriddenFrom": "qx.io.request.AbstractRequest",
      "appearsIn": [
        "qx.io.request.AbstractRequest"
      ]
    },
    "_isAsync": {
      "jsdoc": {
        "raw": [
          " overridden"
        ]
      },
      "access": "protected",
      "location": {
        "start": {
          "line": 277,
          "column": 4,
          "index": 8455
        },
        "end": {
          "line": 279,
          "column": 5,
          "index": 8502
        }
      },
      "type": "function",
      "params": [],
      "overriddenFrom": "qx.io.request.AbstractRequest",
      "appearsIn": [
        "qx.io.request.AbstractRequest"
      ]
    },
    "_createResponseParser": {
      "jsdoc": {
        "raw": [
          "*",
          "     * Create response parser.",
          "     *",
          "     * @return {qx.util.ResponseParser} parser.",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": "<p>Create response parser.</p>"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.util.ResponseParser} parser.",
            "type": "qx.util.ResponseParser",
            "description": "parser."
          }
        ]
      },
      "access": "protected",
      "location": {
        "start": {
          "line": 292,
          "column": 4,
          "index": 8800
        },
        "end": {
          "line": 294,
          "column": 5,
          "index": 8874
        }
      },
      "type": "function",
      "params": [],
      "returnType": {
        "type": "qx.util.ResponseParser"
      },
      "appearsIn": []
    },
    "_getParsedResponse": {
      "jsdoc": {
        "raw": [
          "*",
          "     * Returns response parsed with parser determined by content type.",
          "     *",
          "     * @return {String|Object} The parsed response of the request.",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns response parsed with parser determined by content type.</p>"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{String|Object} The parsed response of the request.",
            "type": "String|Object",
            "description": "The parsed response of the request."
          }
        ]
      },
      "access": "protected",
      "location": {
        "start": {
          "line": 301,
          "column": 4,
          "index": 9042
        },
        "end": {
          "line": 321,
          "column": 5,
          "index": 9626
        }
      },
      "type": "function",
      "params": [],
      "returnType": {
        "type": "String|Object"
      },
      "overriddenFrom": "qx.io.request.AbstractRequest",
      "appearsIn": [
        "qx.io.request.AbstractRequest"
      ]
    },
    "setParser": {
      "jsdoc": {
        "raw": [
          "*",
          "     * Set parser used to parse response once request has",
          "     * completed successfully.",
          "     *",
          "     * @see qx.util.ResponseParser#setParser",
          "     *",
          "     * @param parser {String|Function}",
          "     * @return {Function} The parser function",
          "     "
        ],
        "@description": [
          {
            "name": "@description",
            "body": "<p>Set parser used to parse response once request has\n completed successfully.</p>"
          }
        ],
        "@see": [
          {
            "name": "@see",
            "body": "qx.util.ResponseParser#setParser"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "parser {String|Function}",
            "paramName": "parser",
            "type": [
              "String",
              "Function"
            ]
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Function} The parser function",
            "type": "((...args: any[]) => any)",
            "description": "The parser function"
          }
        ]
      },
      "access": "public",
      "location": {
        "start": {
          "line": 332,
          "column": 4,
          "index": 9882
        },
        "end": {
          "line": 334,
          "column": 5,
          "index": 9952
        }
      },
      "type": "function",
      "params": [
        {
          "name": "parser",
          "type": [
            "String",
            "Function"
          ]
        }
      ],
      "returnType": {
        "type": "((...args: any[]) => any)"
      },
      "appearsIn": []
    }
  },
  "statics": {}
}