{
  "className": "qx.Promise",
  "packageName": "qx",
  "name": "Promise",
  "superClass": "qx.core.Object",
  "interfaces": [],
  "mixins": [],
  "functionName": null,
  "clazz": {
    "location": {
      "start": {
        "line": 69,
        "column": 0,
        "index": 2191
      },
      "end": {
        "line": 1063,
        "column": 3,
        "index": 40673
      }
    },
    "jsdoc": {
      "@description": [
        {
          "name": "@description",
          "body": "<p>This class adds Promise/A+ support to Qooxdoo, as specified at\n https://github.com/promises-aplus/promises-spec and using the Bluebird Promise\n library (http://bluebirdjs.com/) to implement it.  The official Promise/A+ API)\n is mirrored exactly, and a number of extension methods are added with the BluebirdJS\n API for inspiration (many/most of the extension functions are taken verbatim).\n There are two ways to bind a 'this' value to callbacks - the first is to\n append a context method to methods like then(), and the second is to specify\n the context as the second parameter to the constructor and all callbacks will\n be bound to that value.\n For example:\n </p>\n<pre class=\"javascript\">\n   var promise = new qx.Promise(myAsyncFunction, this);\n   promise.then(function() {\n\n   });\n\n   var promise = new qx.Promise(myAsyncFunction);\n   promise.then(function() {\n\n   }, this);\n </pre>\n<p>If you have an existing qx.Promise and want to bind all callbacks, use the\n bind() method - but note that it returns a new promise:\n  </p>\n<pre class=\"javascript\">\n    var promise = someMethodThatReturnsAPromise();\n    var boundPromise = promise.bind(this);\n    boundPromise.then(function() {\n\n    }, this);\n  </pre>"
        },
        {
          "name": "@description",
          "body": ""
        }
      ],
      "@ignore": [
        {
          "name": "@ignore",
          "body": "process.*"
        },
        {
          "name": "@ignore",
          "body": "global.*"
        },
        {
          "name": "@ignore",
          "body": "Symbol.*"
        },
        {
          "name": "@ignore",
          "body": "chrome.*"
        }
      ]
    }
  },
  "type": "class",
  "construct": {
    "location": {
      "start": {
        "line": 83,
        "column": 2,
        "index": 2770
      },
      "end": {
        "line": 120,
        "column": 3,
        "index": 4052
      }
    },
    "jsdoc": {
      "@description": [
        {
          "name": "@description",
          "body": "<p>Constructor.\n The promise function is called with two parameters, functions which are to be called\n when the promise is fulfilled or rejected respectively.  If you do not provide any\n parameters, the promise can be externally resolved or rejected by calling the\n <code>resolve()</code> or <code>reject()</code> methods.</p>"
        }
      ],
      "@param": [
        {
          "name": "@param",
          "body": "fn {Function} the promise function called with <code>(resolve, reject)</code>",
          "paramName": "fn",
          "description": " the promise function called with <code>(resolve, reject)</code>",
          "type": "Function"
        },
        {
          "name": "@param",
          "body": "context {Object?} optional context for all callbacks",
          "paramName": "context",
          "description": " optional context for all callbacks",
          "optional": true,
          "type": "Object"
        }
      ]
    }
  },
  "destruct": {
    "location": {
      "start": {
        "line": 125,
        "column": 2,
        "index": 4085
      },
      "end": {
        "line": 128,
        "column": 3,
        "index": 4155
      }
    },
    "jsdoc": {
      "@description": [
        {
          "name": "@description",
          "body": "<p>Destructor</p>"
        }
      ]
    }
  },
  "members": {
    "__p": {
      "location": {
        "start": {
          "line": 132,
          "column": 4,
          "index": 4198
        },
        "end": {
          "line": 132,
          "column": 13,
          "index": 4207
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>The Promise</p>"
          }
        ]
      },
      "type": "variable",
      "access": "private"
    },
    "__external": {
      "location": {
        "start": {
          "line": 135,
          "column": 4,
          "index": 4275
        },
        "end": {
          "line": 135,
          "column": 20,
          "index": 4291
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Stores data for completing the promise externally</p>"
          }
        ]
      },
      "type": "variable",
      "access": "private"
    },
    "then": {
      "location": {
        "start": {
          "line": 153,
          "column": 4,
          "index": 4885
        },
        "end": {
          "line": 155,
          "column": 5,
          "index": 4972
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns a promise which is determined by the functions <code>onFulfilled</code>\n and <code>onRejected</code>.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "onFulfilled {Function} called when the Promise is fulfilled. This function\n  has one argument, the fulfillment value.",
            "paramName": "onFulfilled",
            "description": " called when the Promise is fulfilled. This function\n  has one argument, the fulfillment value.",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "onRejected {Function?} called when the Promise is rejected. This function\n  has one argument, the rejection reason.",
            "paramName": "onRejected",
            "description": " called when the Promise is rejected. This function\n  has one argument, the rejection reason.",
            "optional": true,
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "catch": {
      "location": {
        "start": {
          "line": 167,
          "column": 4,
          "index": 5540
        },
        "end": {
          "line": 169,
          "column": 5,
          "index": 5616
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Appends a rejection handler callback to the promise, and returns a new promise\n resolving to the return value of the callback if it is called, or to its original\n fulfillment value if the promise is instead fulfilled.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "onRejected {Function?} called when the Promise is rejected. This function\n  has one argument, the rejection reason.",
            "paramName": "onRejected",
            "description": " called when the Promise is rejected. This function\n  has one argument, the rejection reason.",
            "optional": true,
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise} a qx.Promise is rejected if onRejected throws an error or\n  returns a Promise which is itself rejected; otherwise, it is resolved.",
            "type": "qx.Promise",
            "description": " a qx.Promise is rejected if onRejected throws an error or\n  returns a Promise which is itself rejected; otherwise, it is resolved."
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "bind": {
      "location": {
        "start": {
          "line": 183,
          "column": 4,
          "index": 5980
        },
        "end": {
          "line": 185,
          "column": 5,
          "index": 6057
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Creates a new qx.Promise with the 'this' set to a different context</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "context {Object} the 'this' context for the new Promise",
            "paramName": "context",
            "description": " the 'this' context for the new Promise",
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise} the new promise",
            "type": "qx.Promise",
            "description": " the new promise"
          }
        ]
      },
      "type": "function",
      "access": "public",
      "overriddenFrom": "qx.data.MBinding",
      "appearsIn": [
        "qx.data.MBinding"
      ]
    },
    "spread": {
      "location": {
        "start": {
          "line": 209,
          "column": 4,
          "index": 6746
        },
        "end": {
          "line": 211,
          "column": 5,
          "index": 6830
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Like calling <code>.then</code>, but the fulfillment value must be an array, which is flattened\n to the formal parameters of the fulfillment handler.\n For example:\n </p>\n<pre>\n qx.Promise.all([\n   fs.readFileAsync(\"file1.txt\"),\n   fs.readFileAsync(\"file2.txt\")\n ]).spread(function(file1text, file2text) {\n   if (file1text === file2text) {\n     console.log(\"files are equal\");\n   }\n   else {\n     console.log(\"files are not equal\");\n   }\n });\n </pre>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "fulfilledHandler {Function} called when the Promises are fulfilled.",
            "paramName": "fulfilledHandler",
            "description": " called when the Promises are fulfilled.",
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "finally": {
      "location": {
        "start": {
          "line": 221,
          "column": 4,
          "index": 7225
        },
        "end": {
          "line": 223,
          "column": 5,
          "index": 7305
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Appends a handler that will be called regardless of this promise's fate. The handler\n is not allowed to modify the value of the promise</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "handler {Function?} called when the Promise is fulfilled or rejected. This function\n  has no arguments, but can return a promise",
            "paramName": "handler",
            "description": " called when the Promise is fulfilled or rejected. This function\n  has no arguments, but can return a promise",
            "optional": true,
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise} a qx.Promise chained from this promise",
            "type": "qx.Promise",
            "description": " a qx.Promise chained from this promise"
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "cancel": {
      "location": {
        "start": {
          "line": 228,
          "column": 4,
          "index": 7413
        },
        "end": {
          "line": 230,
          "column": 5,
          "index": 7481
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Cancel this promise. Will not do anything if this promise is already settled.</p>"
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "all": {
      "location": {
        "start": {
          "line": 240,
          "column": 4,
          "index": 7897
        },
        "end": {
          "line": 242,
          "column": 5,
          "index": 7967
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Same as {@link qx.Promise.all} except that it iterates over the value of this promise, when\n it is fulfilled; for example, if this Promise resolves to an Iterable (eg an Array),\n <code>.all</code> will return a Promise that waits for all promises in that Iterable to be\n fullfilled.  The Iterable can be a mix of values and Promises</p>"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "race": {
      "location": {
        "start": {
          "line": 252,
          "column": 4,
          "index": 8395
        },
        "end": {
          "line": 254,
          "column": 5,
          "index": 8475
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Same as {@link qx.Promise.race} except that it iterates over the value of this promise, when\n it is fulfilled; for example, if this Promise resolves to an Iterable (eg an Array),\n <code>.race</code> will return a Promise that waits until the first promise in that Iterable\n has been fullfilled.  The Iterable can be a mix of values and Promises</p>"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "any": {
      "location": {
        "start": {
          "line": 263,
          "column": 4,
          "index": 8807
        },
        "end": {
          "line": 265,
          "column": 5,
          "index": 8885
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Same as {@link qx.Promise.some} except that it iterates over the value of this promise, when\n it is fulfilled.  Like <code>some</code>, with 1 as count. However, if the promise fulfills,\n the fulfillment value is not an array of 1 but the value directly.</p>"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "some": {
      "location": {
        "start": {
          "line": 276,
          "column": 4,
          "index": 9350
        },
        "end": {
          "line": 278,
          "column": 5,
          "index": 9437
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Same as {@link qx.Promise.some} except that it iterates over the value of this promise, when\n it is fulfilled; return a promise that is fulfilled as soon as count promises are fulfilled\n in the array. The fulfillment value is an array with count values in the order they were fulfilled.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "count {Integer}"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "forEach": {
      "location": {
        "start": {
          "line": 294,
          "column": 4,
          "index": 10328
        },
        "end": {
          "line": 296,
          "column": 5,
          "index": 10421
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Same as {@link qx.Promise.forEach} except that it iterates over the value of this promise, when\n it is fulfilled; iterates over the values with the given <code>iterator</code> function with the signature\n <code>(value, index, length)</code> where <code>value</code> is the resolved value. Iteration happens\n serially. If any promise is rejected the returned promise is rejected as well.\n Resolves to the original array unmodified, this method is meant to be used for side effects. If the iterator\n function returns a promise or a thenable, then the result of the promise is awaited, before continuing with\n next iteration.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "iterator {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "iterator",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "filter": {
      "location": {
        "start": {
          "line": 308,
          "column": 4,
          "index": 11025
        },
        "end": {
          "line": 310,
          "column": 5,
          "index": 11128
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Same as {@link qx.Promise.filter} except that it iterates over the value of this promise, when it is fulfilled;\n iterates over all the values into an array and filter the array to another using the given filterer function.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "iterator {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "iterator",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "options {Object?} options; can be:\n  <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>",
            "paramName": "options",
            "description": " options; can be:\n  <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>",
            "optional": true,
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "map": {
      "location": {
        "start": {
          "line": 331,
          "column": 4,
          "index": 12367
        },
        "end": {
          "line": 333,
          "column": 5,
          "index": 12464
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Same as {@link qx.Promise.map} except that it iterates over the value of this promise, when it is fulfilled;\n iterates over all the values into an array and map the array to another using the given mapper function.\n Promises returned by the mapper function are awaited for and the returned promise doesn't fulfill\n until all mapped promises have fulfilled as well. If any promise in the array is rejected, or\n any promise returned by the mapper function is rejected, the returned promise is rejected as well.\n The mapper function for a given item is called as soon as possible, that is, when the promise\n for that item's index in the input array is fulfilled. This doesn't mean that the result array\n has items in random order, it means that .map can be used for concurrency coordination unlike\n .all.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "iterator {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "iterator",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "options {Object?} options; can be:\n  <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>",
            "paramName": "options",
            "description": " options; can be:\n  <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>",
            "optional": true,
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "mapSeries": {
      "location": {
        "start": {
          "line": 352,
          "column": 4,
          "index": 13493
        },
        "end": {
          "line": 354,
          "column": 5,
          "index": 13593
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Same as {@link qx.Promise.mapSeries} except that it iterates over the value of this promise, when\n it is fulfilled; iterates over all the values into an array and iterate over the array serially,\n in-order.\n Returns a promise for an array that contains the values returned by the iterator function in their\n respective positions. The iterator won't be called for an item until its previous item, and the\n promise returned by the iterator for that item are fulfilled. This results in a mapSeries kind of\n utility but it can also be used simply as a side effect iterator similar to Array#forEach.\n If any promise in the input array is rejected or any promise returned by the iterator function is\n rejected, the result will be rejected as well.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "iterator {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "iterator",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "reduce": {
      "location": {
        "start": {
          "line": 378,
          "column": 4,
          "index": 14983
        },
        "end": {
          "line": 380,
          "column": 5,
          "index": 15090
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Same as {@link qx.Promise.reduce} except that it iterates over the value of this promise, when\n it is fulfilled; iterates over all the values in the <code>Iterable</code> into an array and\n reduce the array to a value using the given reducer function.\n If the reducer function returns a promise, then the result of the promise is awaited, before\n continuing with next iteration. If any promise in the array is rejected or a promise returned\n by the reducer function is rejected, the result is rejected as well.\n If initialValue is undefined (or a promise that resolves to undefined) and the iterable contains\n only 1 item, the callback will not be called and the iterable's single item is returned. If the\n iterable is empty, the callback will not be called and initialValue is returned (which may be\n undefined).\n qx.Promise.reduce will start calling the reducer as soon as possible, this is why you might want to\n use it over qx.Promise.all (which awaits for the entire array before you can call Array#reduce on it).</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "reducer {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "reducer",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "initialValue {Object?} optional initial value",
            "paramName": "initialValue",
            "description": " optional initial value",
            "optional": true,
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "__externalPromise": {
      "location": {
        "start": {
          "line": 385,
          "column": 4,
          "index": 15145
        },
        "end": {
          "line": 387,
          "column": 5,
          "index": 15266
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>External promise handler</p>"
          }
        ]
      },
      "type": "function",
      "access": "private"
    },
    "__getPendingExternal": {
      "location": {
        "start": {
          "line": 392,
          "column": 4,
          "index": 15377
        },
        "end": {
          "line": 401,
          "column": 5,
          "index": 15700
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns the data stored by __externalPromise, throws an exception once processed</p>"
          }
        ]
      },
      "type": "function",
      "access": "private"
    },
    "resolve": {
      "location": {
        "start": {
          "line": 406,
          "column": 4,
          "index": 15759
        },
        "end": {
          "line": 408,
          "column": 5,
          "index": 15831
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Resolves an external promise</p>"
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "reject": {
      "location": {
        "start": {
          "line": 413,
          "column": 4,
          "index": 15889
        },
        "end": {
          "line": 415,
          "column": 5,
          "index": 15961
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Rejects an external promise</p>"
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "_callIterableMethod": {
      "location": {
        "start": {
          "line": 426,
          "column": 4,
          "index": 16197
        },
        "end": {
          "line": 437,
          "column": 5,
          "index": 16582
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Helper method used to call Promise methods which iterate over an array</p>"
          }
        ]
      },
      "type": "function",
      "access": "protected"
    },
    "_callMethod": {
      "location": {
        "start": {
          "line": 442,
          "column": 4,
          "index": 16656
        },
        "end": {
          "line": 445,
          "column": 5,
          "index": 16811
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Helper method used to call a Promise method</p>"
          }
        ]
      },
      "type": "function",
      "access": "protected"
    },
    "toPromise": {
      "location": {
        "start": {
          "line": 457,
          "column": 4,
          "index": 17306
        },
        "end": {
          "line": 459,
          "column": 5,
          "index": 17348
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns the actual Promise implementation.\n Note that Bluebird is the current implementation, and may change without\n notice in the future; if you use this API you accept that this is a private\n implementation detail exposed for debugging or diagnosis purposes only.  For\n this reason, the toPromise() method is listed as deprecated starting from the\n first release</p>"
          }
        ],
        "@deprecated": [
          {
            "name": "@deprecated",
            "body": "{6.0} this API method is subject to change"
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "removeBinding": {
      "type": "function",
      "name": "removeBinding",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.data.MBinding",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Removes the binding with the given id from the current object. The\n id has to be the id returned by any of the bind functions.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "id {var} The id of the binding.",
            "paramName": "id",
            "description": " The id of the binding.",
            "type": "var"
          }
        ],
        "@throws": [
          {
            "name": "@throws",
            "body": "{Error} If the binding could not be found.",
            "type": "Error",
            "description": " If the binding could not be found."
          }
        ]
      }
    },
    "removeRelatedBindings": {
      "type": "function",
      "name": "removeRelatedBindings",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.data.MBinding",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Removes all bindings between the object and the related one.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "relatedObject {qx.core.Object} The object of which related\n   bindings should be removed.",
            "paramName": "relatedObject",
            "description": " The object of which related\n   bindings should be removed.",
            "type": "qx.core.Object"
          }
        ],
        "@throws": [
          {
            "name": "@throws",
            "body": "{Error} If one of the bindings listed internally can not be\n   removed.",
            "type": "Error",
            "description": " If one of the bindings listed internally can not be\n   removed."
          }
        ]
      }
    },
    "removeAllBindings": {
      "type": "function",
      "name": "removeAllBindings",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.data.MBinding",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Removes all bindings from the object.</p>"
          }
        ],
        "@throws": [
          {
            "name": "@throws",
            "body": "{qx.core.AssertionError} If the object is not in the internal\n   registry of the bindings.",
            "type": "qx.core.AssertionError",
            "description": " If the object is not in the internal\n   registry of the bindings."
          },
          {
            "name": "@throws",
            "body": "{Error} If one of the bindings listed internally can not be\n   removed.",
            "type": "Error",
            "description": " If one of the bindings listed internally can not be\n   removed."
          }
        ]
      }
    },
    "getBindings": {
      "type": "function",
      "name": "getBindings",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.data.MBinding",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns an array which lists all bindings for the object.</p>"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Array} An array of binding informations. Every binding\n   information is an array itself containing id, sourceObject, sourceEvent,\n   targetObject and targetProperty in that order.",
            "type": "qx.data.Array",
            "description": " An array of binding informations. Every binding\n   information is an array itself containing id, sourceObject, sourceEvent,\n   targetObject and targetProperty in that order."
          }
        ]
      }
    },
    "debug": {
      "type": "function",
      "name": "debug",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MLogging",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Logs a debug message.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "varargs {var} The item(s) to log. Any number of arguments is\n supported. If an argument is not a string, the object dump will be\n logged.",
            "paramName": "varargs",
            "description": " The item(s) to log. Any number of arguments is\n supported. If an argument is not a string, the object dump will be\n logged.",
            "type": "var"
          }
        ]
      }
    },
    "info": {
      "type": "function",
      "name": "info",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MLogging",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Logs an info message.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "varargs {var} The item(s) to log. Any number of arguments is\n supported. If an argument is not a string, the object dump will be\n logged.",
            "paramName": "varargs",
            "description": " The item(s) to log. Any number of arguments is\n supported. If an argument is not a string, the object dump will be\n logged.",
            "type": "var"
          }
        ]
      }
    },
    "warn": {
      "type": "function",
      "name": "warn",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MLogging",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Logs a warning message.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "varargs {var} The item(s) to log. Any number of arguments is\n supported. If an argument is not a string, the object dump will be\n logged.",
            "paramName": "varargs",
            "description": " The item(s) to log. Any number of arguments is\n supported. If an argument is not a string, the object dump will be\n logged.",
            "type": "var"
          }
        ]
      }
    },
    "error": {
      "type": "function",
      "name": "error",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MLogging",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Logs an error message.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "varargs {var} The item(s) to log. Any number of arguments is\n supported. If an argument is not a string, the object dump will be\n logged.",
            "paramName": "varargs",
            "description": " The item(s) to log. Any number of arguments is\n supported. If an argument is not a string, the object dump will be\n logged.",
            "type": "var"
          }
        ]
      }
    },
    "trace": {
      "type": "function",
      "name": "trace",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MLogging",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Logs an error message with the current stack trace</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "varargs {var} The item(s) to log. Any number of arguments is\n supported. If an argument is not a string, the object dump will be\n logged.",
            "paramName": "varargs",
            "description": " The item(s) to log. Any number of arguments is\n supported. If an argument is not a string, the object dump will be\n logged.",
            "type": "var"
          }
        ]
      }
    },
    "__logMessage": {
      "type": "function",
      "name": "__logMessage",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "private",
      "overriddenFrom": "qx.core.MLogging",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Helper that calls the appropriate logger function with the current object\n and any number of items.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "level {String} The log level of the message",
            "paramName": "level",
            "description": " The log level of the message",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "varargs {arguments} Arguments list to be logged",
            "paramName": "varargs",
            "description": " Arguments list to be logged",
            "type": "arguments"
          }
        ]
      }
    },
    "addListener": {
      "type": "function",
      "name": "addListener",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Add event listener to this object.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "type {String} name of the event type",
            "paramName": "type",
            "description": " name of the event type",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "listener {Function} event callback function",
            "paramName": "listener",
            "description": " event callback function",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "self {Object ? null} Reference to the 'this' variable inside\n         the event listener. When not given, the corresponding dispatcher\n         usually falls back to a default, which is the target\n         by convention. Note this is not a strict requirement, i.e.\n         custom dispatchers can follow a different strategy.",
            "paramName": "self",
            "description": " Reference to the 'this' variable inside\n         the event listener. When not given, the corresponding dispatcher\n         usually falls back to a default, which is the target\n         by convention. Note this is not a strict requirement, i.e.\n         custom dispatchers can follow a different strategy.",
            "optional": true,
            "defaultValue": "null",
            "type": "Object"
          },
          {
            "name": "@param",
            "body": "capture {Boolean ? false} Whether to attach the event to the\n         capturing phase or the bubbling phase of the event. The default is\n         to attach the event handler to the bubbling phase.",
            "paramName": "capture",
            "description": " Whether to attach the event to the\n         capturing phase or the bubbling phase of the event. The default is\n         to attach the event handler to the bubbling phase.",
            "optional": true,
            "defaultValue": "false",
            "type": "Boolean"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{String} An opaque id, which can be used to remove the event listener\n         using the {@link #removeListenerById} method.",
            "type": "String",
            "description": " An opaque id, which can be used to remove the event listener\n         using the {@link #removeListenerById} method."
          }
        ]
      }
    },
    "addListenerOnce": {
      "type": "function",
      "name": "addListenerOnce",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Add event listener to this object, which is only called once. After the\n listener is called the event listener gets removed.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "type {String} name of the event type",
            "paramName": "type",
            "description": " name of the event type",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "listener {Function} event callback function",
            "paramName": "listener",
            "description": " event callback function",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "context {Object ? window} reference to the 'this' variable inside the callback",
            "paramName": "context",
            "description": " reference to the 'this' variable inside the callback",
            "optional": true,
            "defaultValue": "window",
            "type": "Object"
          },
          {
            "name": "@param",
            "body": "capture {Boolean ? false} Whether to attach the event to the\n         capturing phase or the bubbling phase of the event. The default is\n         to attach the event handler to the bubbling phase.",
            "paramName": "capture",
            "description": " Whether to attach the event to the\n         capturing phase or the bubbling phase of the event. The default is\n         to attach the event handler to the bubbling phase.",
            "optional": true,
            "defaultValue": "false",
            "type": "Boolean"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{String} An opaque id, which can be used to remove the event listener\n         using the {@link #removeListenerById} method.",
            "type": "String",
            "description": " An opaque id, which can be used to remove the event listener\n         using the {@link #removeListenerById} method."
          }
        ]
      }
    },
    "removeListener": {
      "type": "function",
      "name": "removeListener",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Remove event listener from this object</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "type {String} name of the event type",
            "paramName": "type",
            "description": " name of the event type",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "listener {Function} event callback function",
            "paramName": "listener",
            "description": " event callback function",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "self {Object ? null} reference to the 'this' variable inside the callback",
            "paramName": "self",
            "description": " reference to the 'this' variable inside the callback",
            "optional": true,
            "defaultValue": "null",
            "type": "Object"
          },
          {
            "name": "@param",
            "body": "capture {Boolean} Whether to remove the event listener of\n   the bubbling or of the capturing phase.",
            "paramName": "capture",
            "description": " Whether to remove the event listener of\n   the bubbling or of the capturing phase.",
            "type": "Boolean"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Boolean} Whether the event was removed successfully (has existed)",
            "type": "Boolean",
            "description": " Whether the event was removed successfully (has existed)"
          }
        ]
      }
    },
    "removeListenerById": {
      "type": "function",
      "name": "removeListenerById",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Removes an event listener from an event target by an id returned by\n {@link #addListener}</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "id {String} The id returned by {@link #addListener}",
            "paramName": "id",
            "description": " The id returned by {@link #addListener}",
            "type": "String"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Boolean} Whether the event was removed successfully (has existed)",
            "type": "Boolean",
            "description": " Whether the event was removed successfully (has existed)"
          }
        ]
      }
    },
    "hasListener": {
      "type": "function",
      "name": "hasListener",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Check if there are one or more listeners for an event type.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "type {String} name of the event type",
            "paramName": "type",
            "description": " name of the event type",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "capture {Boolean ? false} Whether to check for listeners of\n         the bubbling or of the capturing phase.",
            "paramName": "capture",
            "description": " Whether to check for listeners of\n         the bubbling or of the capturing phase.",
            "optional": true,
            "defaultValue": "false",
            "type": "Boolean"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Boolean} Whether the object has a listener of the given type.",
            "type": "Boolean",
            "description": " Whether the object has a listener of the given type."
          }
        ]
      }
    },
    "dispatchEvent": {
      "type": "function",
      "name": "dispatchEvent",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Dispatch an event on this object</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "evt {qx.event.type.Event} event to dispatch",
            "paramName": "evt",
            "description": " event to dispatch",
            "type": "qx.event.type.Event"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Boolean} Whether the event default was prevented or not.\n     Returns true, when the event was NOT prevented.",
            "type": "Boolean",
            "description": " Whether the event default was prevented or not.\n     Returns true, when the event was NOT prevented."
          }
        ]
      }
    },
    "__trackPendingEvent": {
      "type": "function",
      "name": "__trackPendingEvent",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "private",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Internal helper method to track promises returned from event handlers</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "{var} result the result from the event handler",
            "paramName": "result",
            "description": "the result from the event handler",
            "type": "var"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise|var} the value to return",
            "type": "qx.Promise|var",
            "description": " the value to return"
          }
        ]
      }
    },
    "waitForPendingEvents": {
      "type": "function",
      "name": "waitForPendingEvents",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Waits for all pending events to be resolved</p>"
          }
        ]
      }
    },
    "fireEvent": {
      "type": "function",
      "name": "fireEvent",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Creates and dispatches an event on this object.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "type {String} Event type to fire",
            "paramName": "type",
            "description": " Event type to fire",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "clazz {Class?qx.event.type.Event} The event class",
            "paramName": "clazz",
            "description": " The event class",
            "optional": true,
            "defaultValue": "qx.event.type.Event",
            "type": "Class"
          },
          {
            "name": "@param",
            "body": "args {Array?null} Arguments, which will be passed to\n       the event's init method.",
            "paramName": "args",
            "description": " Arguments, which will be passed to\n       the event's init method.",
            "optional": true,
            "defaultValue": "null",
            "type": "Array"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Boolean|qx.Promise} whether the event default was prevented or not.\n     Returns true, when the event was NOT prevented.",
            "type": "Boolean|qx.Promise",
            "description": " whether the event default was prevented or not.\n     Returns true, when the event was NOT prevented."
          }
        ]
      }
    },
    "fireEventAsync": {
      "type": "function",
      "name": "fireEventAsync",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Creates and dispatches an event on this object; equivalent to fireEvent, except that it\n always returns a promise</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "type {String} Event type to fire",
            "paramName": "type",
            "description": " Event type to fire",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "clazz {Class?qx.event.type.Event} The event class",
            "paramName": "clazz",
            "description": " The event class",
            "optional": true,
            "defaultValue": "qx.event.type.Event",
            "type": "Class"
          },
          {
            "name": "@param",
            "body": "args {Array?null} Arguments, which will be passed to\n       the event's init method.",
            "paramName": "args",
            "description": " Arguments, which will be passed to\n       the event's init method.",
            "optional": true,
            "defaultValue": "null",
            "type": "Array"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise} a promise aggregated from the event handlers;\n  if the default was prevented, the promise is rejected",
            "type": "qx.Promise",
            "description": " a promise aggregated from the event handlers;\n  if the default was prevented, the promise is rejected"
          }
        ]
      }
    },
    "fireNonBubblingEvent": {
      "type": "function",
      "name": "fireNonBubblingEvent",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Create an event object and dispatch it on this object.\n The event dispatched with this method does never bubble! Use only if you\n are sure that bubbling is not required.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "type {String} Event type to fire",
            "paramName": "type",
            "description": " Event type to fire",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "clazz {Class?qx.event.type.Event} The event class",
            "paramName": "clazz",
            "description": " The event class",
            "optional": true,
            "defaultValue": "qx.event.type.Event",
            "type": "Class"
          },
          {
            "name": "@param",
            "body": "args {Array?null} Arguments, which will be passed to\n       the event's init method.",
            "paramName": "args",
            "description": " Arguments, which will be passed to\n       the event's init method.",
            "optional": true,
            "defaultValue": "null",
            "type": "Array"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Boolean} Whether the event default was prevented or not.\n     Returns true, when the event was NOT prevented.",
            "type": "Boolean",
            "description": " Whether the event default was prevented or not.\n     Returns true, when the event was NOT prevented."
          }
        ]
      }
    },
    "fireNonBubblingEventAsync": {
      "type": "function",
      "name": "fireNonBubblingEventAsync",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Create an event object and dispatch it on this object; equivalent to fireNonBubblingEvent,\n except that it always returns a promise.\n The event dispatched with this method does never bubble! Use only if you\n are sure that bubbling is not required.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "type {String} Event type to fire",
            "paramName": "type",
            "description": " Event type to fire",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "clazz {Class?qx.event.type.Event} The event class",
            "paramName": "clazz",
            "description": " The event class",
            "optional": true,
            "defaultValue": "qx.event.type.Event",
            "type": "Class"
          },
          {
            "name": "@param",
            "body": "args {Array?null} Arguments, which will be passed to\n       the event's init method.",
            "paramName": "args",
            "description": " Arguments, which will be passed to\n       the event's init method.",
            "optional": true,
            "defaultValue": "null",
            "type": "Array"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise} a promise aggregated from the event handlers;\n  if the default was prevented, the promise is rejected",
            "type": "qx.Promise",
            "description": " a promise aggregated from the event handlers;\n  if the default was prevented, the promise is rejected"
          }
        ]
      }
    },
    "fireDataEvent": {
      "type": "function",
      "name": "fireDataEvent",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Creates and dispatches an non-bubbling data event on this object.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "type {String} Event type to fire",
            "paramName": "type",
            "description": " Event type to fire",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "data {var} User defined data attached to the event object",
            "paramName": "data",
            "description": " User defined data attached to the event object",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "oldData {var?null} The event's old data (optional)",
            "paramName": "oldData",
            "description": " The event's old data (optional)",
            "optional": true,
            "defaultValue": "null",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "cancelable {Boolean?false} Whether or not an event can have its default\n     action prevented. The default action can either be the browser's\n     default action of a native event (e.g. open the context menu on a\n     right click) or the default action of a qooxdoo class (e.g. close\n     the window widget). The default action can be prevented by calling\n     {@link qx.event.type.Event#preventDefault}",
            "paramName": "cancelable",
            "description": " Whether or not an event can have its default\n     action prevented. The default action can either be the browser's\n     default action of a native event (e.g. open the context menu on a\n     right click) or the default action of a qooxdoo class (e.g. close\n     the window widget). The default action can be prevented by calling\n     {@link qx.event.type.Event#preventDefault}",
            "optional": true,
            "defaultValue": "false",
            "type": "Boolean"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Boolean|qx.Promise} whether the event default was prevented or not.\n     Returns true, when the event was NOT prevented.",
            "type": "Boolean|qx.Promise",
            "description": " whether the event default was prevented or not.\n     Returns true, when the event was NOT prevented."
          }
        ]
      }
    },
    "fireDataEventAsync": {
      "type": "function",
      "name": "fireDataEventAsync",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MEvent",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Creates and dispatches an non-bubbling data event on this object; equivalent to\n fireEvent, except that it always returns a promise.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "type {String} Event type to fire",
            "paramName": "type",
            "description": " Event type to fire",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "data {var} User defined data attached to the event object",
            "paramName": "data",
            "description": " User defined data attached to the event object",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "oldData {var?null} The event's old data (optional)",
            "paramName": "oldData",
            "description": " The event's old data (optional)",
            "optional": true,
            "defaultValue": "null",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "cancelable {Boolean?false} Whether or not an event can have its default\n     action prevented. The default action can either be the browser's\n     default action of a native event (e.g. open the context menu on a\n     right click) or the default action of a qooxdoo class (e.g. close\n     the window widget). The default action can be prevented by calling\n     {@link qx.event.type.Event#preventDefault}",
            "paramName": "cancelable",
            "description": " Whether or not an event can have its default\n     action prevented. The default action can either be the browser's\n     default action of a native event (e.g. open the context menu on a\n     right click) or the default action of a qooxdoo class (e.g. close\n     the window widget). The default action can be prevented by calling\n     {@link qx.event.type.Event#preventDefault}",
            "optional": true,
            "defaultValue": "false",
            "type": "Boolean"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise} a promise aggregated from the event handlers;\n  if the default was prevented, the promise is rejected",
            "type": "qx.Promise",
            "description": " a promise aggregated from the event handlers;\n  if the default was prevented, the promise is rejected"
          }
        ]
      }
    },
    "set": {
      "type": "function",
      "name": "set",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MProperty",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Sets either multiple properties at once by using a property list or\n sets one property and its value by the first and second argument.\n As a fallback, if no generated property setter could be found, a\n handwritten setter will be searched and invoked if available.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "data {Object | String} a map of property values. The key is the name of the property.",
            "paramName": "data",
            "description": " a map of property values. The key is the name of the property.",
            "type": [
              "Object",
              "String"
            ]
          },
          {
            "name": "@param",
            "body": "value {var?} the value, only used when <code>data</code> is a string.",
            "paramName": "value",
            "description": " the value, only used when <code>data</code> is a string.",
            "optional": true,
            "type": "var"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Object} Returns this instance if <code>data</code> is a map\n   or a non-generated setter is called; otherwise returns <code>value</code>.",
            "type": "qx.core.Object",
            "description": " Returns this instance if <code>data</code> is a map\n   or a non-generated setter is called; otherwise returns <code>value</code>."
          }
        ],
        "@throws": [
          {
            "name": "@throws",
            "body": "{Error} if a property defined does not exist",
            "type": "Error",
            "description": " if a property defined does not exist"
          }
        ]
      }
    },
    "get": {
      "type": "function",
      "name": "get",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MProperty",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns the value of the given property. If no generated getter could be\n found, a fallback tries to access a handwritten getter.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "prop {String} Name of the property.",
            "paramName": "prop",
            "description": " Name of the property.",
            "type": "String"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{var} The value of the value",
            "type": "var",
            "description": " The value of the value"
          }
        ],
        "@throws": [
          {
            "name": "@throws",
            "body": "{Error} if a property defined does not exist",
            "type": "Error",
            "description": " if a property defined does not exist"
          }
        ]
      }
    },
    "reset": {
      "type": "function",
      "name": "reset",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MProperty",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Resets the value of the given property. If no generated resetter could be\n found, a handwritten resetter will be invoked, if available.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "prop {String} Name of the property.",
            "paramName": "prop",
            "description": " Name of the property.",
            "type": "String"
          }
        ],
        "@throws": [
          {
            "name": "@throws",
            "body": "{Error} if a property defined does not exist",
            "type": "Error",
            "description": " if a property defined does not exist"
          }
        ]
      }
    },
    "isPropertyInitialized": {
      "type": "function",
      "name": "isPropertyInitialized",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MProperty",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Checks if the property is initialized, i.e. has a defined init value or\n has got a value by a setter method.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "prop {String} Name of the property",
            "paramName": "prop",
            "description": " Name of the property",
            "type": "String"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Boolean} If the property is initialized",
            "type": "Boolean",
            "description": " If the property is initialized"
          }
        ],
        "@throws": [
          {
            "name": "@throws",
            "body": "{Error} If the property defined does not exist",
            "type": "Error",
            "description": " If the property defined does not exist"
          }
        ]
      }
    },
    "_applyQxOwner": {
      "type": "function",
      "name": "_applyQxOwner",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "protected",
      "overriddenFrom": "qx.core.MObjectId",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Apply owner</p>"
          }
        ]
      }
    },
    "_applyQxObjectId": {
      "type": "function",
      "name": "_applyQxObjectId",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "protected",
      "overriddenFrom": "qx.core.MObjectId",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Apply objectId</p>"
          }
        ]
      }
    },
    "__onOwnedObjectIdChange": {
      "type": "function",
      "name": "__onOwnedObjectIdChange",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "private",
      "overriddenFrom": "qx.core.MObjectId",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Called when a child's objectId changes</p>"
          }
        ]
      }
    },
    "_cascadeQxObjectIdChanges": {
      "type": "function",
      "name": "_cascadeQxObjectIdChanges",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "protected",
      "overriddenFrom": "qx.core.MObjectId",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Reflect changes to IDs or owners</p>"
          }
        ]
      }
    },
    "getQxObject": {
      "type": "function",
      "name": "getQxObject",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MObjectId",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns the object with the specified ID</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "id\n          {String} ID of the object",
            "paramName": "id",
            "description": " ID of the object",
            "type": "String"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.core.Object?} the found object",
            "type": "qx.core.Object?",
            "description": " the found object"
          }
        ]
      }
    },
    "_createQxObject": {
      "type": "function",
      "name": "_createQxObject",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "protected",
      "overriddenFrom": "qx.core.MObjectId",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Creates the object and adds it to a list; most classes are expected to\n override <code>_createQxObjectImpl</code> NOT this method.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "id {String} ID of the object",
            "paramName": "id",
            "description": " ID of the object",
            "type": "String"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.core.Object?} the created object",
            "type": "qx.core.Object?",
            "description": " the created object"
          }
        ]
      }
    },
    "_createQxObjectImpl": {
      "type": "function",
      "name": "_createQxObjectImpl",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "protected",
      "overriddenFrom": "qx.core.MObjectId",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Creates the object, intended to be overridden. Null is a valid return\n value and will be cached by <code>getQxObject</code>, however <code>undefined</code> is NOT a\n valid value and so will not be cached meaning that <code>_createQxObjectImpl</code>\n will be called multiple times until a valid value is returned.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "id {String} ID of the object",
            "paramName": "id",
            "description": " ID of the object",
            "type": "String"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.core.Object?} the created object",
            "type": "qx.core.Object?",
            "description": " the created object"
          }
        ]
      }
    },
    "addOwnedQxObject": {
      "type": "function",
      "name": "addOwnedQxObject",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MObjectId",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Adds an object as owned by this object</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "obj {qx.core.Object} the object to register",
            "paramName": "obj",
            "description": " the object to register",
            "type": "qx.core.Object"
          },
          {
            "name": "@param",
            "body": "id {String?} the id to set when registering the object",
            "paramName": "id",
            "description": " the id to set when registering the object",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "removeOwnedQxObject": {
      "type": "function",
      "name": "removeOwnedQxObject",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MObjectId",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Discards an object from the list of owned objects; note that this does\n not dispose of the object, simply forgets it if it exists.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "args {String|Object} the ID of the object to discard, or the object itself",
            "paramName": "args",
            "description": " the ID of the object to discard, or the object itself",
            "type": [
              "String",
              "Object"
            ]
          }
        ]
      }
    },
    "__removeOwnedQxObjectImpl": {
      "type": "function",
      "name": "__removeOwnedQxObjectImpl",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "private",
      "overriddenFrom": "qx.core.MObjectId",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Removes an owned object</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "obj {qx.core.Object} the object",
            "paramName": "obj",
            "description": " the object",
            "type": "qx.core.Object"
          }
        ]
      }
    },
    "getOwnedQxObjects": {
      "type": "function",
      "name": "getOwnedQxObjects",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MObjectId",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns an array of objects that are owned by this object, or an empty\n array if none exists.</p>"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Array}",
            "type": "Array",
            "description": ""
          }
        ]
      }
    },
    "getQxOwner": {
      "type": "function",
      "name": "getQxOwner",
      "abstract": false,
      "mixin": false,
      "inherited": true,
      "access": "public",
      "property": "get",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Gets the (computed) value of the property <code>qxOwner</code>.\n\nFor further details take a look at the property definition: {@link #qxOwner}."
          }
        ],
        "@return": [
          {
            "name": "@return",
            "type": "qx.core.Object",
            "desc": "Returns the value for qxOwner"
          }
        ]
      }
    },
    "setQxOwner": {
      "type": "function",
      "name": "setQxOwner",
      "abstract": false,
      "mixin": false,
      "inherited": true,
      "access": "public",
      "property": "set",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Sets the user value of the property <code>qxOwner</code>.\n\nFor further details take a look at the property definition: {@link #qxOwner}."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "type": "qx.core.Object",
            "paramName": "value",
            "desc": "Value for qxOwner"
          }
        ]
      }
    },
    "resetQxOwner": {
      "type": "function",
      "name": "resetQxOwner",
      "abstract": false,
      "mixin": false,
      "inherited": true,
      "access": "public",
      "property": "reset",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Resets the user value of the property <code>qxOwner</code>.\n\nThe computed value falls back to the next available value e.g. appearance, init or inheritance value depending on the property configuration and value availability.\n\nFor further details take a look at the property definition: {@link #qxOwner}."
          }
        ]
      }
    },
    "getQxObjectId": {
      "type": "function",
      "name": "getQxObjectId",
      "abstract": false,
      "mixin": false,
      "inherited": true,
      "access": "public",
      "property": "get",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Gets the (computed) value of the property <code>qxObjectId</code>.\n\nFor further details take a look at the property definition: {@link #qxObjectId}."
          }
        ],
        "@return": [
          {
            "name": "@return",
            "type": "[[ ObjectMethod Function ]]",
            "desc": "Returns the value for qxObjectId"
          }
        ]
      }
    },
    "setQxObjectId": {
      "type": "function",
      "name": "setQxObjectId",
      "abstract": false,
      "mixin": false,
      "inherited": true,
      "access": "public",
      "property": "set",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Sets the user value of the property <code>qxObjectId</code>.\n\nFor further details take a look at the property definition: {@link #qxObjectId}."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "type": "[[ ObjectMethod Function ]]",
            "paramName": "value",
            "desc": "Value for qxObjectId"
          }
        ]
      }
    },
    "resetQxObjectId": {
      "type": "function",
      "name": "resetQxObjectId",
      "abstract": false,
      "mixin": false,
      "inherited": true,
      "access": "public",
      "property": "reset",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Resets the user value of the property <code>qxObjectId</code>.\n\nThe computed value falls back to the next available value e.g. appearance, init or inheritance value depending on the property configuration and value availability.\n\nFor further details take a look at the property definition: {@link #qxObjectId}."
          }
        ]
      }
    },
    "assert": {
      "type": "function",
      "name": "assert",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the condition evaluates to <code>true</code>.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "condition {var} Condition to check for. Must evaluate to\n    <code>true</code>.",
            "paramName": "condition",
            "description": " Condition to check for. Must evaluate to\n    <code>true</code>.",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "fail": {
      "type": "function",
      "name": "fail",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Raise an {@link AssertionError}</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "msg {String} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "compact {Boolean?false} Show less verbose message. Default: false.",
            "paramName": "compact",
            "description": " Show less verbose message. Default: false.",
            "optional": true,
            "defaultValue": "false",
            "type": "Boolean"
          }
        ]
      }
    },
    "assertTrue": {
      "type": "function",
      "name": "assertTrue",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is <code>true</code> (Identity check).</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {Boolean} Condition to check for. Must be identical to\n    <code>true</code>.",
            "paramName": "value",
            "description": " Condition to check for. Must be identical to\n    <code>true</code>.",
            "type": "Boolean"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertFalse": {
      "type": "function",
      "name": "assertFalse",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is <code>false</code> (Identity check).</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {Boolean} Condition to check for. Must be identical to\n    <code>false</code>.",
            "paramName": "value",
            "description": " Condition to check for. Must be identical to\n    <code>false</code>.",
            "type": "Boolean"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertEquals": {
      "type": "function",
      "name": "assertEquals",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that both values are equal. (Uses the equality operator\n <code>==</code>.)</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "expected {var} Reference value",
            "paramName": "expected",
            "description": " Reference value",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "found {var} found value",
            "paramName": "found",
            "description": " found value",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertNotEquals": {
      "type": "function",
      "name": "assertNotEquals",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that both values are not equal. (Uses the not equality operator\n <code>!=</code>.)</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "expected {var} Reference value",
            "paramName": "expected",
            "description": " Reference value",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "found {var} found value",
            "paramName": "found",
            "description": " found value",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertEqualsFloat": {
      "type": "function",
      "name": "assertEqualsFloat",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that both float values are equal. This might be needed because\n of the natural floating point inaccuracy of computers.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "expected {Float} Reference value",
            "paramName": "expected",
            "description": " Reference value",
            "type": "Float"
          },
          {
            "name": "@param",
            "body": "found {Float} Found value",
            "paramName": "found",
            "description": " Found value",
            "type": "Float"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertNotEqualsFloat": {
      "type": "function",
      "name": "assertNotEqualsFloat",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that both float values are not equal. This might be needed\n because of the natural floating point inaccuracy of computers.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "expected {Float} Reference value",
            "paramName": "expected",
            "description": " Reference value",
            "type": "Float"
          },
          {
            "name": "@param",
            "body": "found {Float} Found value",
            "paramName": "found",
            "description": " Found value",
            "type": "Float"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertIdentical": {
      "type": "function",
      "name": "assertIdentical",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that both values are identical. (Uses the identity operator\n <code>===</code>.)</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "expected {var} Reference value",
            "paramName": "expected",
            "description": " Reference value",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "found {var} found value",
            "paramName": "found",
            "description": " found value",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertNotIdentical": {
      "type": "function",
      "name": "assertNotIdentical",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that both values are not identical. (Uses the not identity operator\n <code>!==</code>.)</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "expected {var} Reference value",
            "paramName": "expected",
            "description": " Reference value",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "found {var} found value",
            "paramName": "found",
            "description": " found value",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertNotUndefined": {
      "type": "function",
      "name": "assertNotUndefined",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is not <code>undefined</code>.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertUndefined": {
      "type": "function",
      "name": "assertUndefined",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is <code>undefined</code>.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertNotNull": {
      "type": "function",
      "name": "assertNotNull",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is not <code>null</code>.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertNull": {
      "type": "function",
      "name": "assertNull",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is <code>null</code>.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertJsonEquals": {
      "type": "function",
      "name": "assertJsonEquals",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the first two arguments are equal, when serialized into\n JSON.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "expected {var} The expected value",
            "paramName": "expected",
            "description": " The expected value",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "found {var} The found value",
            "paramName": "found",
            "description": " The found value",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertMatch": {
      "type": "function",
      "name": "assertMatch",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the given string matches the regular expression</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "str {String} String, which should match the regular expression",
            "paramName": "str",
            "description": " String, which should match the regular expression",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "re {RegExp} Regular expression to match",
            "paramName": "re",
            "description": " Regular expression to match",
            "type": "RegExp"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertArgumentsCount": {
      "type": "function",
      "name": "assertArgumentsCount",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the number of arguments is within the given range</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "args {arguments} The <code>arguments<code> variable of a function",
            "paramName": "args",
            "description": " The <code>arguments<code> variable of a function",
            "type": "arguments"
          },
          {
            "name": "@param",
            "body": "minCount {Integer} Minimal number of arguments",
            "paramName": "minCount",
            "description": " Minimal number of arguments",
            "type": "Integer"
          },
          {
            "name": "@param",
            "body": "maxCount {Integer} Maximum number of arguments",
            "paramName": "maxCount",
            "description": " Maximum number of arguments",
            "type": "Integer"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertEventFired": {
      "type": "function",
      "name": "assertEventFired",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that an event is fired.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "obj {Object} The object on which the event should be fired.",
            "paramName": "obj",
            "description": " The object on which the event should be fired.",
            "type": "qx.core.Object"
          },
          {
            "name": "@param",
            "body": "event {String} The event which should be fired.",
            "paramName": "event",
            "description": " The event which should be fired.",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "invokeFunc {Function} The function which will be invoked and which\n   fires the event.",
            "paramName": "invokeFunc",
            "description": " The function which will be invoked and which\n   fires the event.",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "listener {Function?null} The function which will be invoked in the\n   listener. The function has one parameter called e which is the event.",
            "paramName": "listener",
            "description": " The function which will be invoked in the\n   listener. The function has one parameter called e which is the event.",
            "optional": true,
            "defaultValue": "null",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "msg {String?\"\"} Message to be shows if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shows if the assertion fails.",
            "optional": true,
            "defaultValue": "\"\"",
            "type": "String"
          }
        ]
      }
    },
    "assertEventNotFired": {
      "type": "function",
      "name": "assertEventNotFired",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that an event is not fired.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "obj {Object} The object on which the event should be fired.",
            "paramName": "obj",
            "description": " The object on which the event should be fired.",
            "type": "qx.core.Object"
          },
          {
            "name": "@param",
            "body": "event {String} The event which should be fired.",
            "paramName": "event",
            "description": " The event which should be fired.",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "invokeFunc {Function} The function which will be invoked and which\n   should not fire the event.",
            "paramName": "invokeFunc",
            "description": " The function which will be invoked and which\n   should not fire the event.",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shows if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shows if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertException": {
      "type": "function",
      "name": "assertException",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Asserts that the callback raises a matching exception.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "callback {Function} function to check",
            "paramName": "callback",
            "description": " function to check",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "exception {Error?Error} Expected constructor of the exception.\n   The assertion fails if the raised exception is not an instance of the\n   parameter.",
            "paramName": "exception",
            "description": " Expected constructor of the exception.\n   The assertion fails if the raised exception is not an instance of the\n   parameter.",
            "optional": true,
            "defaultValue": "Error",
            "type": "Error"
          },
          {
            "name": "@param",
            "body": "re {String|RegExp} The assertion fails if the error message does\n   not match this parameter",
            "paramName": "re",
            "description": " The assertion fails if the error message does\n   not match this parameter",
            "type": [
              "String",
              "RegExp"
            ]
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertInArray": {
      "type": "function",
      "name": "assertInArray",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is an item in the given array.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "array {Array} List of valid values",
            "paramName": "array",
            "description": " List of valid values",
            "type": "Array"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertNotInArray": {
      "type": "function",
      "name": "assertNotInArray",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is NOT an item in the given array</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "array {Array} List of values",
            "paramName": "array",
            "description": " List of values",
            "type": "Array"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertArrayEquals": {
      "type": "function",
      "name": "assertArrayEquals",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that both array have identical array items.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "expected {Array} The expected array",
            "paramName": "expected",
            "description": " The expected array",
            "type": "Array"
          },
          {
            "name": "@param",
            "body": "found {Array} The found array",
            "paramName": "found",
            "description": " The found array",
            "type": "Array"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertKeyInMap": {
      "type": "function",
      "name": "assertKeyInMap",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is a key in the given map.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "map {Map} Map, where the keys represent the valid values",
            "paramName": "map",
            "description": " Map, where the keys represent the valid values",
            "type": "Map"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertFunction": {
      "type": "function",
      "name": "assertFunction",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is a function.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertString": {
      "type": "function",
      "name": "assertString",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is a string.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertBoolean": {
      "type": "function",
      "name": "assertBoolean",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is a boolean.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertNumber": {
      "type": "function",
      "name": "assertNumber",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is a number.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertPositiveNumber": {
      "type": "function",
      "name": "assertPositiveNumber",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is a number &gt;= 0.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertInteger": {
      "type": "function",
      "name": "assertInteger",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is an integer.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertPositiveInteger": {
      "type": "function",
      "name": "assertPositiveInteger",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is an integer &gt;= 0.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertInRange": {
      "type": "function",
      "name": "assertInRange",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is inside the given range.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "min {Number} lower bound",
            "paramName": "min",
            "description": " lower bound",
            "type": "Number"
          },
          {
            "name": "@param",
            "body": "max {Number} upper bound",
            "paramName": "max",
            "description": " upper bound",
            "type": "Number"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertObject": {
      "type": "function",
      "name": "assertObject",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is an object.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertArray": {
      "type": "function",
      "name": "assertArray",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is an array.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertMap": {
      "type": "function",
      "name": "assertMap",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is a map either created using <code>new Object</code>\n or by using the object literal notation <code>{ ... }</code>.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertRegExp": {
      "type": "function",
      "name": "assertRegExp",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is a regular expression.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertType": {
      "type": "function",
      "name": "assertType",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value has the given type using the <code>typeof</code>\n operator. Because the type is not always what it is supposed to be it is\n better to use more explicit checks like {@link #assertString} or\n {@link #assertArray}.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "type {String} expected type of the value",
            "paramName": "type",
            "description": " expected type of the value",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertInstance": {
      "type": "function",
      "name": "assertInstance",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is an instance of the given class.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "clazz {Class} The value must be an instance of this class",
            "paramName": "clazz",
            "description": " The value must be an instance of this class",
            "type": "Class"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertInterface": {
      "type": "function",
      "name": "assertInterface",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value implements the given interface.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "iface {Class} The value must implement this interface",
            "paramName": "iface",
            "description": " The value must implement this interface",
            "type": "Class"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertCssColor": {
      "type": "function",
      "name": "assertCssColor",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value represents the given CSS color value. This method\n parses the color strings and compares the RGB values. It is able to\n parse values supported by {@link qx.util.ColorUtil#stringToRgb}.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "expected {String} The expected color",
            "paramName": "expected",
            "description": " The expected color",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "value {String} The value to check",
            "paramName": "value",
            "description": " The value to check",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertElement": {
      "type": "function",
      "name": "assertElement",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is a DOM element.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertQxObject": {
      "type": "function",
      "name": "assertQxObject",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is an instance of {@link qx.core.Object}.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    },
    "assertQxWidget": {
      "type": "function",
      "name": "assertQxWidget",
      "abstract": false,
      "mixin": true,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.MAssert",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Assert that the value is an instance of {@link qx.ui.core.Widget}.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} Value to check",
            "paramName": "value",
            "description": " Value to check",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "msg {String?} Message to be shown if the assertion fails.",
            "paramName": "msg",
            "description": " Message to be shown if the assertion fails.",
            "optional": true,
            "type": "String"
          }
        ]
      }
    }
  },
  "statics": {
    "Bluebird": {
      "location": {
        "start": {
          "line": 464,
          "column": 4,
          "index": 17426
        },
        "end": {
          "line": 464,
          "column": 18,
          "index": 17440
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Bluebird Promise library; always available</p>"
          }
        ]
      },
      "type": "variable",
      "access": "public"
    },
    "Native": {
      "location": {
        "start": {
          "line": 467,
          "column": 4,
          "index": 17524
        },
        "end": {
          "line": 467,
          "column": 16,
          "index": 17536
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Native Promise library; only available if the browser supports it</p>"
          }
        ]
      },
      "type": "variable",
      "access": "public"
    },
    "Promise": {
      "location": {
        "start": {
          "line": 470,
          "column": 4,
          "index": 17644
        },
        "end": {
          "line": 470,
          "column": 17,
          "index": 17657
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Promise library, either the Native one or a Polyfill; reliable choice for native Promises</p>"
          }
        ]
      },
      "type": "variable",
      "access": "public"
    },
    "__DEFAULT_ERROR": {
      "location": {
        "start": {
          "line": 475,
          "column": 4,
          "index": 17800
        },
        "end": {
          "line": 475,
          "column": 47,
          "index": 17843
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>This is used to suppress warnings about rejections without an Error object, only used if\n the reason is undefined</p>"
          }
        ]
      },
      "type": "variable",
      "access": "private"
    },
    "isPromise": {
      "location": {
        "start": {
          "line": 499,
          "column": 4,
          "index": 18812
        },
        "end": {
          "line": 515,
          "column": 5,
          "index": 19297
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Detects whether the value is a promise.\n Note that this is not an <code>instanceof</code> check and while it may look odd to just test whether\n there is a property called <code>then</code> which is a Function, that's the actual spec -</p>"
          }
        ],
        "@see": [
          {
            "name": "@see",
            "body": "https://promisesaplus.com/\n The difficulty is that it also needs to have a <code>.finally</code> and <code>.catch</code> methods in order to\n always be routinely useful; it's debatable what we can do about that here - if the calling code\n definitely requires a promise then it can use <code>.resolve</code> to upgrade it or make sure that it is\n a fully featured promise.  In this function, we detect that it is thenable, and then give a warning\n if it is not catchable."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "{*} value"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Boolean} true if it is a promise",
            "type": "Boolean",
            "description": " true if it is a promise"
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "resolve": {
      "location": {
        "start": {
          "line": 528,
          "column": 4,
          "index": 19898
        },
        "end": {
          "line": 539,
          "column": 5,
          "index": 20216
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns a Promise object that is resolved with the given value. If the value is a thenable (i.e.\n has a then method), the returned promise will \"follow\" that thenable, adopting its eventual\n state; otherwise the returned promise will be fulfilled with the value. Generally, if you\n don't know if a value is a promise or not, Promise.resolve(value) it instead and work with\n the return value as a promise.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {Object}"
          },
          {
            "name": "@param",
            "body": "context {Object?} optional context for callbacks to be bound to",
            "paramName": "context",
            "description": " optional context for callbacks to be bound to",
            "optional": true,
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "reject": {
      "location": {
        "start": {
          "line": 547,
          "column": 4,
          "index": 20569
        },
        "end": {
          "line": 560,
          "column": 5,
          "index": 21068
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns a Promise object that is rejected with the given reason.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "reason {Object?} Reason why this Promise rejected. A warning is generated if not instanceof Error. If undefined, a default Error is used.",
            "paramName": "reason",
            "description": " Reason why this Promise rejected. A warning is generated if not instanceof Error. If undefined, a default Error is used.",
            "optional": true,
            "type": "Object"
          },
          {
            "name": "@param",
            "body": "context {Object?} optional context for callbacks to be bound to",
            "paramName": "context",
            "description": " optional context for callbacks to be bound to",
            "optional": true,
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "allOf": {
      "location": {
        "start": {
          "line": 570,
          "column": 4,
          "index": 21476
        },
        "end": {
          "line": 588,
          "column": 5,
          "index": 22056
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns a promise that resolves when all of the promises in the object properties have resolved,\n or rejects with the reason of the first passed promise that rejects.  The result of each property\n is placed back in the object, replacing the promise.  Note that non-promise values are untouched.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {var} An object",
            "paramName": "value",
            "description": " An object",
            "type": "var"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "all": {
      "location": {
        "start": {
          "line": 598,
          "column": 4,
          "index": 22417
        },
        "end": {
          "line": 600,
          "column": 5,
          "index": 22500
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns a promise that resolves when all of the promises in the iterable argument have resolved,\n or rejects with the reason of the first passed promise that rejects.  Note that non-promise values\n are untouched.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "race": {
      "location": {
        "start": {
          "line": 608,
          "column": 4,
          "index": 22791
        },
        "end": {
          "line": 610,
          "column": 5,
          "index": 22876
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns a promise that resolves or rejects as soon as one of the promises in the iterable resolves\n or rejects, with the value or reason from that promise.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "any": {
      "location": {
        "start": {
          "line": 625,
          "column": 4,
          "index": 23297
        },
        "end": {
          "line": 627,
          "column": 5,
          "index": 23380
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Like Promise.some, with 1 as count. However, if the promise fulfills, the fulfillment value is not an\n array of 1 but the value directly.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "some": {
      "location": {
        "start": {
          "line": 639,
          "column": 4,
          "index": 23933
        },
        "end": {
          "line": 641,
          "column": 5,
          "index": 24025
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Given an Iterable (arrays are Iterable), or a promise of an Iterable, which produces promises (or a mix\n of promises and values), iterate over all the values in the Iterable into an array and return a promise\n that is fulfilled as soon as count promises are fulfilled in the array. The fulfillment value is an\n array with count values in the order they were fulfilled.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "count {Integer}"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "forEach": {
      "location": {
        "start": {
          "line": 657,
          "column": 4,
          "index": 24947
        },
        "end": {
          "line": 659,
          "column": 5,
          "index": 25045
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values)\n with the given <code>iterator</code> function with the signature <code>(value, index, length)</code> where\n <code>value</code> is the resolved value of a respective promise in the input array. Iteration happens\n serially. If any promise in the input array is rejected the returned promise is rejected as well.\n Resolves to the original array unmodified, this method is meant to be used for side effects. If the iterator\n function returns a promise or a thenable, then the result of the promise is awaited, before continuing with\n next iteration.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "iterator {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "iterator",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "filter": {
      "location": {
        "start": {
          "line": 685,
          "column": 4,
          "index": 26190
        },
        "end": {
          "line": 687,
          "column": 5,
          "index": 26298
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Given an Iterable(arrays are Iterable), or a promise of an Iterable, which produces promises (or a mix of\n promises and values), iterate over all the values in the Iterable into an array and filter the array to\n another using the given filterer function.\n It is essentially an efficient shortcut for doing a .map and then Array#filter:\n </p>\n<pre>\n   qx.Promise.map(valuesToBeFiltered, function(value, index, length) {\n       return Promise.all([filterer(value, index, length), value]);\n   }).then(function(values) {\n       return values.filter(function(stuff) {\n           return stuff[0] == true\n       }).map(function(stuff) {\n           return stuff[1];\n       });\n   });\n </pre>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "iterator {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "iterator",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "options {Object?} options; can be:\n  <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>",
            "paramName": "options",
            "description": " options; can be:\n  <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>",
            "optional": true,
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "map": {
      "location": {
        "start": {
          "line": 730,
          "column": 4,
          "index": 28300
        },
        "end": {
          "line": 732,
          "column": 5,
          "index": 28402
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Given an <code>Iterable</code> (arrays are <code>Iterable</code>), or a promise of an\n <code>Iterable</code>, which produces promises (or a mix of promises and values), iterate over\n all the values in the <code>Iterable</code> into an array and map the array to another using\n the given mapper function.\n Promises returned by the mapper function are awaited for and the returned promise doesn't fulfill\n until all mapped promises have fulfilled as well. If any promise in the array is rejected, or\n any promise returned by the mapper function is rejected, the returned promise is rejected as well.\n The mapper function for a given item is called as soon as possible, that is, when the promise\n for that item's index in the input array is fulfilled. This doesn't mean that the result array\n has items in random order, it means that .map can be used for concurrency coordination unlike\n .all.\n A common use of Promise.map is to replace the .push+Promise.all boilerplate:\n </p>\n<pre>\n   var promises = [];\n   for (var i = 0; i < fileNames.length; ++i) {\n       promises.push(fs.readFileAsync(fileNames[i]));\n   }\n   qx.Promise.all(promises).then(function() {\n       console.log(\"done\");\n   });\n\n   qx.Promise.map(fileNames, function(fileName) {\n\n       return fs.readFileAsync(fileName);\n   }).then(function() {\n       console.log(\"done\");\n   });\n </pre>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "iterator {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "iterator",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "options {Object?} options; can be:\n  <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>",
            "paramName": "options",
            "description": " options; can be:\n  <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>",
            "optional": true,
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "mapSeries": {
      "location": {
        "start": {
          "line": 769,
          "column": 4,
          "index": 30254
        },
        "end": {
          "line": 771,
          "column": 5,
          "index": 30359
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Given an <code>Iterable</code>(arrays are <code>Iterable</code>), or a promise of an\n <code>Iterable</code>, which produces promises (or a mix of promises and values), iterate over\n all the values in the <code>Iterable</code> into an array and iterate over the array serially,\n in-order.\n Returns a promise for an array that contains the values returned by the iterator function in their\n respective positions. The iterator won't be called for an item until its previous item, and the\n promise returned by the iterator for that item are fulfilled. This results in a mapSeries kind of\n utility but it can also be used simply as a side effect iterator similar to Array#forEach.\n If any promise in the input array is rejected or any promise returned by the iterator function is\n rejected, the result will be rejected as well.\n Example where .mapSeries(the instance method) is used for iterating with side effects:\n </p>\n<pre>\n\n function loadStory() {\n   return getJSON('story.json')\n     .then(function(story) {\n       addHtmlToPage(story.heading);\n       return story.chapterURLs.map(getJSON);\n     })\n     .mapSeries(function(chapter) { addHtmlToPage(chapter.html); })\n     .then(function() { addTextToPage(\"All done\"); })\n     .catch(function(err) { addTextToPage(\"Argh, broken: \" + err.message); })\n     .then(function() { document.querySelector('.spinner').style.display = 'none'; });\n }\n </pre>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "iterator {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "iterator",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "reduce": {
      "location": {
        "start": {
          "line": 809,
          "column": 4,
          "index": 32299
        },
        "end": {
          "line": 811,
          "column": 5,
          "index": 32411
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Given an <code>Iterable</code> (arrays are <code>Iterable</code>), or a promise of an\n <code>Iterable</code>, which produces promises (or a mix of promises and values), iterate\n over all the values in the <code>Iterable</code> into an array and reduce the array to a\n value using the given reducer function.\n If the reducer function returns a promise, then the result of the promise is awaited, before\n continuing with next iteration. If any promise in the array is rejected or a promise returned\n by the reducer function is rejected, the result is rejected as well.\n Read given files sequentially while summing their contents as an integer. Each file contains\n just the text 10.\n </p>\n<pre>\n   qx.Promise.reduce([\"file1.txt\", \"file2.txt\", \"file3.txt\"], function(total, fileName) {\n       return fs.readFileAsync(fileName, \"utf8\").then(function(contents) {\n           return total + parseInt(contents, 10);\n       });\n   }, 0).then(function(total) {\n\n   });\n </pre>\n<p>If initialValue is undefined (or a promise that resolves to undefined) and the iterable contains\n only 1 item, the callback will not be called and the iterable's single item is returned. If the\n iterable is empty, the callback will not be called and initialValue is returned (which may be\n undefined).\n Promise.reduce will start calling the reducer as soon as possible, this is why you might want to\n use it over Promise.all (which awaits for the entire array before you can call Array#reduce on it).</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "iterable {Iterable} An iterable object, such as an Array",
            "paramName": "iterable",
            "description": " An iterable object, such as an Array",
            "type": "Iterable"
          },
          {
            "name": "@param",
            "body": "reducer {Function} the callback, with <code>(value, index, length)</code>",
            "paramName": "reducer",
            "description": " the callback, with <code>(value, index, length)</code>",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "initialValue {Object?} optional initial value",
            "paramName": "initialValue",
            "description": " optional initial value",
            "optional": true,
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "method": {
      "location": {
        "start": {
          "line": 819,
          "column": 4,
          "index": 32728
        },
        "end": {
          "line": 824,
          "column": 5,
          "index": 32904
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns a new function that wraps the given function fn. The new function will always return a promise that is\n fulfilled with the original functions return values or rejected with thrown exceptions from the original function.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "cb {Function}"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Function}",
            "type": "Function",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "props": {
      "location": {
        "start": {
          "line": 840,
          "column": 4,
          "index": 33741
        },
        "end": {
          "line": 842,
          "column": 5,
          "index": 33825
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Like .all but for object properties or Maps* entries instead of iterated values. Returns a promise that\n is fulfilled when all the properties of the object or the Map's' values** are fulfilled. The promise's\n fulfillment value is an object or a Map with fulfillment values at respective keys to the original object\n or a Map. If any promise in the object or Map rejects, the returned promise is rejected with the rejection\n reason.\n If object is a trusted Promise, then it will be treated as a promise for object rather than for its\n properties. All other objects (except Maps) are treated for their properties as is returned by\n Object.keys - the object's own enumerable properties.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "input {Object} An Object",
            "paramName": "input",
            "description": " An Object",
            "type": "Object"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "promisify": {
      "location": {
        "start": {
          "line": 897,
          "column": 4,
          "index": 35679
        },
        "end": {
          "line": 899,
          "column": 5,
          "index": 35776
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns a new function that wraps a function that is in node.js\n style. The resulting function returns a promise instead of taking a\n callback function as an argument. The promise is resolved or rejected\n by the action of the callback function. The provided function must\n accept a callback as its last argument, and that callback function must\n expect its first argument to be an error if non-null. If the first\n argument is null, the second argument (optional) will be the success\n value.\n Example:\n Assume there is a member method in myApp.Application such as the\n following:</p>\n <pre><code>\n   issueRpc : function(method, params, callback)\n   {\n     ...\n   }\n </code></pre>\n<p>where the signature of <code>callback</code> is:</p>\n <pre><code>\n   function callback(e, result)\n </code></pre>\n<p>The <code>issueRpc</code>method could be converted to be called using\n promises instead of callbacks, as shown here:</p>\n <pre><code>\n   var app = qx.core.Init.getApplication();\n   var rpc = qx.Promise.promisify(app.issueRpc, { context : app });\n   rpc(\"ping\", [ \"hello world\" ])\n     .then(\n       function(pongValue)\n       {\n\n       })\n     .catch(\n       function(e)\n       {\n         throw e;\n       });\n </code></pre>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "f {Function} The node.js-style function to be promisified",
            "paramName": "f",
            "description": " The node.js-style function to be promisified",
            "type": "Function"
          },
          {
            "name": "@param",
            "body": "options {Map?}\n   The sole user option in this map is <code>context</code>, which may\n   be specified to arrange for the provided callback function to be\n   called in the specified context.",
            "paramName": "options",
            "description": "\n   The sole user option in this map is <code>context</code>, which may\n   be specified to arrange for the provided callback function to be\n   called in the specified context.",
            "optional": true,
            "type": "Map"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{qx.Promise}",
            "type": "qx.Promise",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "__attachBluebird": {
      "location": {
        "start": {
          "line": 911,
          "column": 4,
          "index": 36043
        },
        "end": {
          "line": 918,
          "column": 5,
          "index": 36319
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Called when the Bluebird Promise class is loaded</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "Promise {Class} the Promise class",
            "paramName": "Promise",
            "description": " the Promise class",
            "type": "qx.Class"
          }
        ]
      },
      "type": "function",
      "access": "private"
    },
    "__initialized": {
      "location": {
        "start": {
          "line": 921,
          "column": 4,
          "index": 36381
        },
        "end": {
          "line": 921,
          "column": 24,
          "index": 36401
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Whether one-time initialisaton has happened</p>"
          }
        ]
      },
      "type": "variable",
      "access": "private"
    },
    "__initialize": {
      "location": {
        "start": {
          "line": 926,
          "column": 4,
          "index": 36452
        },
        "end": {
          "line": 950,
          "column": 5,
          "index": 37202
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>One-time initializer</p>"
          }
        ]
      },
      "type": "function",
      "access": "private"
    },
    "__onUnhandledRejection": {
      "location": {
        "start": {
          "line": 956,
          "column": 4,
          "index": 37345
        },
        "end": {
          "line": 975,
          "column": 5,
          "index": 37926
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Handles unhandled errors and passes them through to Qooxdoo's global error handler</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "e {NativeEvent}"
          }
        ]
      },
      "type": "function",
      "access": "private"
    },
    "__wrap": {
      "location": {
        "start": {
          "line": 982,
          "column": 4,
          "index": 38058
        },
        "end": {
          "line": 991,
          "column": 5,
          "index": 38295
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Wraps values, converting Promise into qx.Promise</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "value {Object}"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Object}",
            "type": "Object",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "private"
    },
    "__bindArgs": {
      "location": {
        "start": {
          "line": 1002,
          "column": 4,
          "index": 38814
        },
        "end": {
          "line": 1019,
          "column": 5,
          "index": 39347
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Binds all functions in the array to the context at the end of the array;\n the last value must be a qx.core.Object to distinguish itself from configuration\n objects passed to some methods.</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "args {arguments}"
          },
          {
            "name": "@param",
            "body": "minArgs {Integer?} minimum number of arguments expected for the method call;\n \tthis is used to determine whether the last value is for binding (default is 1)",
            "paramName": "minArgs",
            "description": " minimum number of arguments expected for the method call;\n \tthis is used to determine whether the last value is for binding (default is 1)",
            "optional": true,
            "type": "Integer"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Array} array of new arguments with functions bound as necessary",
            "type": "Array",
            "description": " array of new arguments with functions bound as necessary"
          }
        ]
      },
      "type": "function",
      "access": "private"
    },
    "__callStaticMethod": {
      "location": {
        "start": {
          "line": 1028,
          "column": 4,
          "index": 39605
        },
        "end": {
          "line": 1036,
          "column": 5,
          "index": 39875
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Helper method used to call a Bluebird Promise method</p>"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "methodName {String} method name to call",
            "paramName": "methodName",
            "description": " method name to call",
            "type": "String"
          },
          {
            "name": "@param",
            "body": "args {Array} arguments to pass",
            "paramName": "args",
            "description": " arguments to pass",
            "type": "Array"
          },
          {
            "name": "@param",
            "body": "minArgs {Integer?} {@see __bindArgs}",
            "paramName": "minArgs",
            "description": " {@see __bindArgs}",
            "optional": true,
            "type": "Integer"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Object?}",
            "type": "Object?",
            "description": ""
          }
        ]
      },
      "type": "function",
      "access": "private"
    },
    "__mapArgs": {
      "location": {
        "start": {
          "line": 1042,
          "column": 4,
          "index": 40070
        },
        "end": {
          "line": 1054,
          "column": 5,
          "index": 40398
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Maps all arguments ready for passing to a Bluebird function; qx.data.Array are\n translated to native arrays and qx.Promise to Promise.  This is not recursive.</p>"
          }
        ]
      },
      "type": "function",
      "access": "private"
    }
  },
  "defer": {
    "location": {
      "start": {
        "line": 1057,
        "column": 2,
        "index": 40407
      },
      "end": {
        "line": 1062,
        "column": 3,
        "index": 40669
      }
    }
  },
  "descendants": []
}