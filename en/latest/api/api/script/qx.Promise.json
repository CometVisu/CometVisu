{"attributes": {"name": "Promise", "hasWarning": true, "packageName": "qx", "superClass": "qx.core.Object", "fullName": "qx.Promise", "type": "class"}, "type": "class", "children": [{"attributes": {"text": "<p>This class adds Promise/A+ support to Qooxdoo, as specified at \n<a href=\"https://github.com/promises-aplus/promises-spec\">https://github.com/promises-aplus/promises-spec</a> and using the Bluebird Promise\nlibrary (<a href=\"http://bluebirdjs.com/\">http://bluebirdjs.com/</a>) to implement it.  The official Promise/A+ <span class=\"caps\">API</span>) \nis mirrored exactly, and a number of extension methods are added with the BluebirdJS \n<span class=\"caps\">API</span> for inspiration (many/most of the extension functions are taken verbatim).</p>\n\n<p>There are two ways to bind a &#8216;this&#8217; value to callbacks &#8211; the first is to\nappend a context method to methods like then(), and the second is to specify\nthe context as the second parameter to the constructor and all callbacks will\nbe bound to that value.</p>\n\n<p>For example:</p>\n\n<pre class=\"javascript\">\n  var promise = new qx.Promise(myAsyncFunction, this);\n  promise.then(function() {\n    // 'this' is preserved from the outer scope\n  });\n  \n  // ... is the same as: ...\n  var promise = new qx.Promise(myAsyncFunction);\n  promise.then(function() {\n    // 'this' is preserved from the outer scope\n  }, this);\n</pre>\n\n<p>If you have an existing qx.Promise and want to bind all callbacks, use the\nbind() method &#8211; but note that it returns a new promise:</p>\n\n<pre class=\"javascript\">\n   var promise = someMethodThatReturnsAPromise();\n   var boundPromise = promise.bind(this);\n   boundPromise.then(function() {\n     // 'this' is preserved from the outer scope\n   }, this);\n </pre>"}, "type": "desc"}, {"attributes": {}, "type": "constructor", "children": [{"attributes": {"line": 73, "isCtor": true, "overriddenFrom": "qx.core.Object", "name": "ctor"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "fn"}, "type": "param", "children": [{"attributes": {"text": "<p>the promise function called with <code>(resolve, reject)</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "context"}, "type": "param", "children": [{"attributes": {"text": "<p>optional context for all callbacks</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Constructor.</p>\n\n<p>The promise function is called with two parameters, functions which are to be called\nwhen the promise is fulfilled or rejected respectively.  If you do not provide any\nparameters, the promise can be externally resolved or rejected by calling the\n<code>resolve()</code> or <code>reject()</code> methods.</p>"}, "type": "desc"}]}]}, {"attributes": {}, "type": "methods", "children": [{"attributes": {"access": "private", "line": 360, "hasError": true, "name": "__externalPromise"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "resolve"}, "type": "param"}, {"attributes": {"name": "reject"}, "type": "param"}]}, {"attributes": {"text": "<p>External promise handler</p>"}, "type": "desc"}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Parameter is not documented: 'resolve'", "column": 24, "line": 360}, "type": "error"}, {"attributes": {"msg": "Parameter is not documented: 'reject'", "column": 24, "line": 360}, "type": "error"}]}]}, {"attributes": {"access": "private", "line": 367, "hasError": true, "name": "__getPendingExternal"}, "type": "method", "children": [{"attributes": {"text": "<p>Returns the data stored by __externalPromise, throws an exception once processed</p>"}, "type": "desc"}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Missing documentation for return value.", "column": 27, "line": 367}, "type": "error"}]}]}, {"attributes": {"access": "protected", "line": 405, "hasError": true, "name": "_callIterableMethod"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "methodName"}, "type": "param"}, {"attributes": {"name": "args"}, "type": "param"}]}, {"attributes": {"text": "<p>Helper method used to call Promise methods which iterate over an array</p>"}, "type": "desc"}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Parameter is not documented: 'methodName'", "column": 26, "line": 405}, "type": "error"}, {"attributes": {"msg": "Parameter is not documented: 'args'", "column": 26, "line": 405}, "type": "error"}, {"attributes": {"msg": "Missing documentation for return value.", "column": 26, "line": 405}, "type": "error"}]}]}, {"attributes": {"access": "protected", "line": 416, "hasError": true, "name": "_callMethod"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "methodName"}, "type": "param"}, {"attributes": {"name": "args"}, "type": "param"}]}, {"attributes": {"text": "<p>Helper method used to call a Promise method</p>"}, "type": "desc"}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Parameter is not documented: 'methodName'", "column": 18, "line": 416}, "type": "error"}, {"attributes": {"msg": "Parameter is not documented: 'args'", "column": 18, "line": 416}, "type": "error"}, {"attributes": {"msg": "Missing documentation for return value.", "column": 18, "line": 416}, "type": "error"}]}]}, {"attributes": {"line": 215, "name": "all"}, "type": "method", "children": [{"attributes": {"text": "<p>Same as {@link qx.Promise.all} except that it iterates over the value of this promise, when\nit is fulfilled; for example, if this Promise resolves to an Iterable (eg an Array), \n<code>.all</code> will return a Promise that waits for all promises in that Iterable to be \nfullfilled.  The Iterable can be a mix of values and Promises</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 238, "hasError": true, "name": "any"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param"}]}, {"attributes": {"text": "<p>Same as {@link qx.Promise.some} except that it iterates over the value of this promise, when\nit is fulfilled.  Like <code>some</code>, with 1 as count. However, if the promise fulfills, \nthe fulfillment value is not an array of 1 but the value directly.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Parameter is not documented: 'iterable'", "column": 10, "line": 238}, "type": "error"}]}]}, {"attributes": {"line": 158, "name": "bind"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "context"}, "type": "param", "children": [{"attributes": {"text": "<p>the &#8216;this&#8217; context for the new Promise</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Creates a new qx.Promise with the &#8216;this&#8217; set to a different context</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": "<p>the new promise</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 203, "hasError": true, "name": "cancel"}, "type": "method", "children": [{"attributes": {"text": "<p>Cancel this promise. Will not do anything if this promise is already settled.</p>"}, "type": "desc"}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Missing documentation for return value.", "column": 13, "line": 203}, "type": "error"}]}]}, {"attributes": {"line": 140, "name": "catch"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"optional": true, "name": "onRejected"}, "type": "param", "children": [{"attributes": {"text": "<p>called when the Promise is rejected. This function  has one argument, the rejection reason.</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Appends a rejection handler callback to the promise, and returns a new promise \nresolving to the return value of the callback if it is called, or to its original \nfulfillment value if the promise is instead fulfilled.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": "<p>a qx.Promise is rejected if onRejected throws an error or  returns a Promise which is itself rejected; otherwise, it is resolved.</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 283, "name": "filter"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}, {"attributes": {"name": "iterator"}, "type": "param", "children": [{"attributes": {"text": "<p>the callback, with <code>(value, index, length)</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "options"}, "type": "param", "children": [{"attributes": {"text": "<p>options; can be: <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Same as {@link qx.Promise.filter} except that it iterates over the value of this promise, when it is fulfilled; \niterates over all the values into an array and filter the array to another using the given filterer function.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 196, "hasError": true, "name": "finally"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "onRejected"}, "type": "param"}]}, {"attributes": {"text": "<p>Appends a handler that will be called regardless of this promise&#8217;s fate. The handler\nis not allowed to modify the value of the promise</p>"}, "type": "desc"}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Contains information for non-existing parameter: 'handler'.", "column": 16, "line": 196}, "type": "error"}, {"attributes": {"msg": "Parameter is not documented: 'onRejected'", "column": 16, "line": 196}, "type": "error"}]}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": "<p>a qx.Promise chained from this promise</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 269, "name": "forEach"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}, {"attributes": {"name": "iterator"}, "type": "param", "children": [{"attributes": {"text": "<p>the callback, with <code>(value, index, length)</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Same as {@link qx.Promise.forEach} except that it iterates over the value of this promise, when\nit is fulfilled; iterates over the values with the given <code>iterator</code> function with the signature \n<code>(value, index, length)</code> where <code>value</code> is the resolved value. Iteration happens \nserially. If any promise is rejected the returned promise is rejected as well.</p>\n\n<p>Resolves to the original array unmodified, this method is meant to be used for side effects. If the iterator \nfunction returns a promise or a thenable, then the result of the promise is awaited, before continuing with \nnext iteration.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 306, "name": "map"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}, {"attributes": {"name": "iterator"}, "type": "param", "children": [{"attributes": {"text": "<p>the callback, with <code>(value, index, length)</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "options"}, "type": "param", "children": [{"attributes": {"text": "<p>options; can be: <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Same as {@link qx.Promise.map} except that it iterates over the value of this promise, when it is fulfilled; \niterates over all the values into an array and map the array to another using the given mapper function.</p>\n\n<p>Promises returned by the mapper function are awaited for and the returned promise doesn&#8217;t fulfill \nuntil all mapped promises have fulfilled as well. If any promise in the array is rejected, or \nany promise returned by the mapper function is rejected, the returned promise is rejected as well.</p>\n\n<p>The mapper function for a given item is called as soon as possible, that is, when the promise \nfor that item&#8217;s index in the input array is fulfilled. This doesn&#8217;t mean that the result array \nhas items in random order, it means that .map can be used for concurrency coordination unlike \n.all.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 327, "name": "mapSeries"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}, {"attributes": {"name": "iterator"}, "type": "param", "children": [{"attributes": {"text": "<p>the callback, with <code>(value, index, length)</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Same as {@link qx.Promise.mapSeries} except that it iterates over the value of this promise, when\nit is fulfilled; iterates over all the values into an array and iterate over the array serially, \nin-order.</p>\n\n<p>Returns a promise for an array that contains the values returned by the iterator function in their \nrespective positions. The iterator won&#8217;t be called for an item until its previous item, and the \npromise returned by the iterator for that item are fulfilled. This results in a mapSeries kind of \nutility but it can also be used simply as a side effect iterator similar to Array#forEach.</p>\n\n<p>If any promise in the input array is rejected or any promise returned by the iterator function is \nrejected, the result will be rejected as well.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 227, "hasError": true, "name": "race"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param"}]}, {"attributes": {"text": "<p>Same as {@link qx.Promise.race} except that it iterates over the value of this promise, when\nit is fulfilled; for example, if this Promise resolves to an Iterable (eg an Array), \n<code>.race</code> will return a Promise that waits until the first promise in that Iterable \nhas been fullfilled.  The Iterable can be a mix of values and Promises</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Parameter is not documented: 'iterable'", "column": 11, "line": 227}, "type": "error"}]}]}, {"attributes": {"line": 353, "name": "reduce"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}, {"attributes": {"name": "reducer"}, "type": "param", "children": [{"attributes": {"text": "<p>the callback, with <code>(value, index, length)</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "initialValue"}, "type": "param", "children": [{"attributes": {"text": "<p>optional initial value</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Same as {@link qx.Promise.reduce} except that it iterates over the value of this promise, when\nit is fulfilled; iterates over all the values in the <code>Iterable</code> into an array and \nreduce the array to a value using the given reducer function.</p>\n\n<p>If the reducer function returns a promise, then the result of the promise is awaited, before \ncontinuing with next iteration. If any promise in the array is rejected or a promise returned \nby the reducer function is rejected, the result is rejected as well.</p>\n\n<p>If initialValue is undefined (or a promise that resolves to undefined) and the iterable contains \nonly 1 item, the callback will not be called and the iterable&#8217;s single item is returned. If the \niterable is empty, the callback will not be called and initialValue is returned (which may be \nundefined).</p>\n\n<p>qx.Promise.reduce will start calling the reducer as soon as possible, this is why you might want to \nuse it over qx.Promise.all (which awaits for the entire array before you can call Array#reduce on it).</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 388, "hasError": true, "name": "reject"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "reason"}, "type": "param"}]}, {"attributes": {"text": "<p>Rejects an external promise</p>"}, "type": "desc"}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Parameter is not documented: 'reason'", "column": 13, "line": 388}, "type": "error"}]}]}, {"attributes": {"line": 381, "hasError": true, "name": "resolve"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "value"}, "type": "param"}]}, {"attributes": {"text": "<p>Resolves an external promise</p>"}, "type": "desc"}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Parameter is not documented: 'value'", "column": 14, "line": 381}, "type": "error"}]}]}, {"attributes": {"line": 251, "name": "some"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}, {"attributes": {"name": "count"}, "type": "param", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Integer"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Same as {@link qx.Promise.some} except that it iterates over the value of this promise, when\nit is fulfilled; return a promise that is fulfilled as soon as count promises are fulfilled \nin the array. The fulfillment value is an array with count values in the order they were fulfilled.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 184, "name": "spread"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "fulfilledHandler"}, "type": "param", "children": [{"attributes": {"text": "<p>called when the Promises are fulfilled.</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Like calling <code>.then</code>, but the fulfillment value must be an array, which is flattened \nto the formal parameters of the fulfillment handler.</p>\n\n<p>For example:</p>\n\n<pre>\nqx.Promise.all([\n  fs.readFileAsync(\"file1.txt\"),\n  fs.readFileAsync(\"file2.txt\")\n]).spread(function(file1text, file2text) {\n  if (file1text === file2text) {\n    console.log(\"files are equal\");\n  }\n  else {\n    console.log(\"files are not equal\");\n  }\n});\n</pre>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 126, "name": "then"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "onFulfilled"}, "type": "param", "children": [{"attributes": {"text": "<p>called when the Promise is fulfilled. This function  has one argument, the fulfillment value.</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "onRejected"}, "type": "param", "children": [{"attributes": {"text": "<p>called when the Promise is rejected. This function  has one argument, the rejection reason.</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Returns a promise which is determined by the functions <code>onFulfilled</code>\nand <code>onRejected</code>.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 431, "hasError": true, "name": "toPromise"}, "type": "method", "children": [{"attributes": {}, "type": "deprecated", "children": [{"attributes": {"text": "<p>this <span class=\"caps\">API</span> method is subject to change</p>"}, "type": "desc"}]}, {"attributes": {"text": "<p>Returns the actual Promise implementation.</p>\n\n<p>Note that Bluebird is the current implementation, and may change without \nnotice in the future; if you use this <span class=\"caps\">API</span> you accept that this is a private \nimplementation detail exposed for debugging or diagnosis purposes only.  For\nthis reason, the toPromise() method is listed as deprecated starting from the\nfirst release</p>"}, "type": "desc"}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Missing documentation for return value.", "column": 16, "line": 431}, "type": "error"}]}]}]}, {"attributes": {}, "type": "methods-static", "children": [{"attributes": {"access": "private", "line": 758, "isStatic": true, "name": "__attachBluebird"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "Promise"}, "type": "param", "children": [{"attributes": {"text": "<p>the Promise class</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Class"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Called when the Bluebird Promise class is loaded</p>"}, "type": "desc"}]}, {"attributes": {"access": "private", "line": 827, "isStatic": true, "name": "__bindArgs"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "args"}, "type": "param", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "arguments"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "minArgs"}, "type": "param", "children": [{"attributes": {"text": "<p>minimum number of arguments expected for the method call; this is used to determine whether the last value is for binding (default is 1)</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Integer"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Binds all functions in the array to the context at the end of the array;\nthe last value must be a qx.core.Object to distinguish itself from configuration\nobjects passed to some methods.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": "<p>array of new arguments with functions bound as necessary</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Array"}, "type": "entry"}]}]}]}, {"attributes": {"access": "private", "line": 853, "isStatic": true, "name": "__callStaticMethod"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "methodName"}, "type": "param", "children": [{"attributes": {"text": "<p>method name to call</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "String"}, "type": "entry"}]}]}, {"attributes": {"name": "args"}, "type": "param", "children": [{"attributes": {"text": "<p>arguments to pass</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Array"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "minArgs"}, "type": "param", "children": [{"attributes": {"text": "<p>{@see __bindArgs}</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Integer"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Helper method used to call a Bluebird Promise method</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"access": "private", "line": 773, "isStatic": true, "name": "__initialize"}, "type": "method", "children": [{"attributes": {"text": "<p>One-time initializer</p>"}, "type": "desc"}]}, {"attributes": {"access": "private", "isStatic": true, "hasError": true, "line": 862, "name": "__mapArgs"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "args"}, "type": "param"}]}, {"attributes": {"text": "<p>Maps all arguments ready for passing to a Bluebird function; qx.data.Array are\ntranslated to native arrays and qx.Promise to Promise.  This is not recursive.</p>"}, "type": "desc"}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Parameter is not documented: 'args'", "column": 16, "line": 862}, "type": "error"}, {"attributes": {"msg": "Missing documentation for return value.", "column": 16, "line": 862}, "type": "error"}]}]}, {"attributes": {"access": "private", "line": 788, "isStatic": true, "name": "__onUnhandledRejection"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "e"}, "type": "param", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "NativeEvent"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Handles unhandled errors and passes them through to Qooxdoo&#8217;s global error handler</p>"}, "type": "desc"}]}, {"attributes": {"access": "private", "line": 807, "isStatic": true, "name": "__wrap"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "value"}, "type": "param", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Wraps values, converting Promise into qx.Promise</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"line": 498, "isStatic": true, "name": "all"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Returns a promise that resolves when all of the promises in the iterable argument have resolved, \nor rejects with the reason of the first passed promise that rejects.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 527, "isStatic": true, "name": "any"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Like Promise.some, with 1 as count. However, if the promise fulfills, the fulfillment value is not an \narray of 1 but the value directly.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 587, "isStatic": true, "name": "filter"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}, {"attributes": {"name": "iterator"}, "type": "param", "children": [{"attributes": {"text": "<p>the callback, with <code>(value, index, length)</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "options"}, "type": "param", "children": [{"attributes": {"text": "<p>options; can be: <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Given an <acronym title=\"arrays are Iterable\">Iterable</acronym>, or a promise of an Iterable, which produces promises (or a mix of \npromises and values), iterate over all the values in the Iterable into an array and filter the array to \nanother using the given filterer function.</p>\n\n<p>It is essentially an efficient shortcut for doing a .map and then Array#filter:</p>\n\n<pre>\n  qx.Promise.map(valuesToBeFiltered, function(value, index, length) {\n      return Promise.all([filterer(value, index, length), value]);\n  }).then(function(values) {\n      return values.filter(function(stuff) {\n          return stuff[0] == true\n      }).map(function(stuff) {\n          return stuff[1];\n      });\n  });\n</pre>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 559, "isStatic": true, "name": "forEach"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}, {"attributes": {"name": "iterator"}, "type": "param", "children": [{"attributes": {"text": "<p>the callback, with <code>(value, index, length)</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) \nwith the given <code>iterator</code> function with the signature <code>(value, index, length)</code> where \n<code>value</code> is the resolved value of a respective promise in the input array. Iteration happens \nserially. If any promise in the input array is rejected the returned promise is rejected as well.</p>\n\n<p>Resolves to the original array unmodified, this method is meant to be used for side effects. If the iterator \nfunction returns a promise or a thenable, then the result of the promise is awaited, before continuing with \nnext iteration.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 632, "isStatic": true, "name": "map"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}, {"attributes": {"name": "iterator"}, "type": "param", "children": [{"attributes": {"text": "<p>the callback, with <code>(value, index, length)</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "options"}, "type": "param", "children": [{"attributes": {"text": "<p>options; can be: <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Given an <code>Iterable</code> (arrays are <code>Iterable</code>), or a promise of an \n<code>Iterable</code>, which produces promises (or a mix of promises and values), iterate over \nall the values in the <code>Iterable</code> into an array and map the array to another using \nthe given mapper function.</p>\n\n<p>Promises returned by the mapper function are awaited for and the returned promise doesn&#8217;t fulfill \nuntil all mapped promises have fulfilled as well. If any promise in the array is rejected, or \nany promise returned by the mapper function is rejected, the returned promise is rejected as well.</p>\n\n<p>The mapper function for a given item is called as soon as possible, that is, when the promise \nfor that item&#8217;s index in the input array is fulfilled. This doesn&#8217;t mean that the result array \nhas items in random order, it means that .map can be used for concurrency coordination unlike \n.all.</p>\n\n<p>A common use of Promise.map is to replace the .push+Promise.all boilerplate:</p>\n\n<pre>\n  var promises = [];\n  for (var i = 0; i < fileNames.length; ++i) {\n      promises.push(fs.readFileAsync(fileNames[i]));\n  }\n  qx.Promise.all(promises).then(function() {\n      console.log(\"done\");\n  });\n  \n  // Using Promise.map:\n  qx.Promise.map(fileNames, function(fileName) {\n      // Promise.map awaits for returned promises as well.\n      return fs.readFileAsync(fileName);\n  }).then(function() {\n      console.log(\"done\");\n  });\n</pre>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 671, "isStatic": true, "name": "mapSeries"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}, {"attributes": {"name": "iterator"}, "type": "param", "children": [{"attributes": {"text": "<p>the callback, with <code>(value, index, length)</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Given an <code>Iterable</code>(arrays are <code>Iterable</code>), or a promise of an \n<code>Iterable</code>, which produces promises (or a mix of promises and values), iterate over \nall the values in the <code>Iterable</code> into an array and iterate over the array serially, \nin-order.</p>\n\n<p>Returns a promise for an array that contains the values returned by the iterator function in their \nrespective positions. The iterator won&#8217;t be called for an item until its previous item, and the \npromise returned by the iterator for that item are fulfilled. This results in a mapSeries kind of \nutility but it can also be used simply as a side effect iterator similar to Array#forEach.</p>\n\n<p>If any promise in the input array is rejected or any promise returned by the iterator function is \nrejected, the result will be rejected as well.</p>\n\n<p>Example where .mapSeries(the instance method) is used for iterating with side effects:</p>\n\n<pre>\n// Source: http://jakearchibald.com/2014/es7-async-functions/\nfunction loadStory() {\n  return getJSON('story.json')\n    .then(function(story) {\n      addHtmlToPage(story.heading);\n      return story.chapterURLs.map(getJSON);\n    })\n    .mapSeries(function(chapter) { addHtmlToPage(chapter.html); })\n    .then(function() { addTextToPage(\"All done\"); })\n    .catch(function(err) { addTextToPage(\"Argh, broken: \" + err.message); })\n    .then(function() { document.querySelector('.spinner').style.display = 'none'; });\n}\n</pre>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 721, "isStatic": true, "name": "method"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "cb"}, "type": "param", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Returns a new function that wraps the given function fn. The new function will always return a promise that is \nfulfilled with the original functions return values or rejected with thrown exceptions from the original function.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}]}, {"attributes": {"line": 742, "isStatic": true, "name": "props"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "input"}, "type": "param", "children": [{"attributes": {"text": "<p>An Object</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Like .all but for object properties or Maps* entries instead of iterated values. Returns a promise that \nis fulfilled when all the properties of the object or the Map&#8217;s&#8217; values** are fulfilled. The promise&#8217;s \nfulfillment value is an object or a Map with fulfillment values at respective keys to the original object \nor a Map. If any promise in the object or Map rejects, the returned promise is rejected with the rejection \nreason.</p>\n\n<p>If object is a trusted Promise, then it will be treated as a promise for object rather than for its \nproperties. All other objects (except Maps) are treated for their properties as is returned by \nObject.keys &#8211; the object&#8217;s own enumerable properties.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 508, "isStatic": true, "name": "race"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Returns a promise that resolves or rejects as soon as one of the promises in the iterable resolves \nor rejects, with the value or reason from that promise.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 711, "isStatic": true, "name": "reduce"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}, {"attributes": {"name": "reducer"}, "type": "param", "children": [{"attributes": {"text": "<p>the callback, with <code>(value, index, length)</code></p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "initialValue"}, "type": "param", "children": [{"attributes": {"text": "<p>optional initial value</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Given an <code>Iterable</code> (arrays are <code>Iterable</code>), or a promise of an \n<code>Iterable</code>, which produces promises (or a mix of promises and values), iterate \nover all the values in the <code>Iterable</code> into an array and reduce the array to a \nvalue using the given reducer function.</p>\n\n<p>If the reducer function returns a promise, then the result of the promise is awaited, before \ncontinuing with next iteration. If any promise in the array is rejected or a promise returned \nby the reducer function is rejected, the result is rejected as well.</p>\n\n<p>Read given files sequentially while summing their contents as an integer. Each file contains \njust the text 10.</p>\n\n<pre>\n  qx.Promise.reduce([\"file1.txt\", \"file2.txt\", \"file3.txt\"], function(total, fileName) {\n      return fs.readFileAsync(fileName, \"utf8\").then(function(contents) {\n          return total + parseInt(contents, 10);\n      });\n  }, 0).then(function(total) {\n      //Total is 30\n  });\n</pre>\n\n<p>If initialValue is undefined (or a promise that resolves to undefined) and the iterable contains \nonly 1 item, the callback will not be called and the iterable&#8217;s single item is returned. If the \niterable is empty, the callback will not be called and initialValue is returned (which may be \nundefined).</p>\n\n<p>Promise.reduce will start calling the reducer as soon as possible, this is why you might want to \nuse it over Promise.all (which awaits for the entire array before you can call Array#reduce on it).</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 484, "isStatic": true, "name": "reject"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "reason"}, "type": "param", "children": [{"attributes": {"text": "<p>Reason why this Promise rejected.</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "context"}, "type": "param", "children": [{"attributes": {"text": "<p>optional context for callbacks to be bound to</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Returns a Promise object that is rejected with the given reason.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 465, "isStatic": true, "name": "resolve"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "value"}, "type": "param", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "context"}, "type": "param", "children": [{"attributes": {"text": "<p>optional context for callbacks to be bound to</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Returns a Promise object that is resolved with the given value. If the value is a thenable (i.e. \nhas a then method), the returned promise will &#8220;follow&#8221; that thenable, adopting its eventual \nstate; otherwise the returned promise will be fulfilled with the value. Generally, if you \ndon&#8217;t know if a value is a promise or not, Promise.resolve(value) it instead and work with \nthe return value as a promise.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"line": 541, "isStatic": true, "name": "some"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "iterable"}, "type": "param", "children": [{"attributes": {"text": "<p>An iterable object, such as an Array</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Iterable"}, "type": "entry"}]}]}, {"attributes": {"name": "count"}, "type": "param", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Integer"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Given an Iterable (arrays are Iterable), or a promise of an Iterable, which produces promises (or a mix \nof promises and values), iterate over all the values in the Iterable into an array and return a promise \nthat is fulfilled as soon as count promises are fulfilled in the array. The fulfillment value is an \narray with count values in the order they were fulfilled.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": ""}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}]}, {"attributes": {}, "type": "constants", "children": [{"attributes": {"access": "private", "type": "Boolean", "name": "__initialized", "value": "false"}, "type": "constant", "children": [{"attributes": {"text": "<p>Whether one-time initialisaton has happened</p>"}, "type": "desc"}]}, {"attributes": {"type": "Null", "name": "Bluebird", "value": "null"}, "type": "constant", "children": [{"attributes": {"text": "<p>Bluebird Promise library; always available</p>"}, "type": "desc"}]}, {"attributes": {"type": "Null", "name": "Promise", "value": "null"}, "type": "constant", "children": [{"attributes": {"text": "<p>Promise library, either the Native one or a Polyfill; reliable choice for native Promises</p>"}, "type": "desc"}]}, {"attributes": {"type": "Null", "name": "Native", "value": "null"}, "type": "constant", "children": [{"attributes": {"text": "<p>Native Promise library; only available if the browser supports it</p>"}, "type": "desc"}]}]}]}