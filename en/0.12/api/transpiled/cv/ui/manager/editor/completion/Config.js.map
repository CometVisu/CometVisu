{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/editor/completion/Config.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "schema",
    "__elementCache",
    "_schema",
    "_dataProvider",
    "cv",
    "ui",
    "manager",
    "editor",
    "data",
    "Provider",
    "getInstance",
    "members",
    "__metaElementCache",
    "getLastOpenedTag",
    "text",
    "tags",
    "match",
    "closingTags",
    "i",
    "length",
    "indexOf",
    "push",
    "substring",
    "tagPosition",
    "lastIndexOf",
    "tag",
    "closingBracketIdx",
    "openedTag",
    "contentSearch",
    "currentAttribute",
    "attrMatch",
    "exec",
    "filteredElementSearch",
    "test",
    "tagName",
    "isAttributeSearch",
    "isContentSearch",
    "splice",
    "findElements",
    "parent",
    "elementName",
    "maxDepth",
    "currentDepth",
    "inMeta",
    "cache",
    "getElementNode",
    "undefined",
    "allowedElements",
    "getAllowedElements",
    "element",
    "result",
    "isItemAvailable",
    "itemName",
    "maxOccurs",
    "items",
    "count",
    "parseInt",
    "getElementString",
    "indent",
    "prefix",
    "insertText",
    "getName",
    "allowedAttributes",
    "getAllowedAttributes",
    "getOwnPropertyNames",
    "forEach",
    "attr",
    "attribute",
    "isOptional",
    "getDefaultValue",
    "requiredElements",
    "getRequiredElements",
    "allowedContent",
    "getAllowedContent",
    "isContentAllowed",
    "_text",
    "_grouping",
    "trim",
    "children",
    "elemName",
    "elem",
    "getAvailableElements",
    "usedItems",
    "availableItems",
    "filter",
    "name",
    "startsWith",
    "childElem",
    "getBounds",
    "max",
    "label",
    "kind",
    "window",
    "monaco",
    "languages",
    "CompletionItemKind",
    "Field",
    "detail",
    "getType",
    "documentation",
    "getDocumentation",
    "join",
    "getAvailableAttributes",
    "usedChildTags",
    "attrs",
    "Property",
    "getTypeString",
    "getProvider",
    "triggerCharacters",
    "provideCompletionItems",
    "model",
    "position",
    "textUntilPosition",
    "getValueInRange",
    "startLineNumber",
    "startColumn",
    "endLineNumber",
    "lineNumber",
    "endColumn",
    "column",
    "completeText",
    "getValue",
    "metaEndPos",
    "textMeta",
    "mappingNames",
    "stylingNames",
    "templates",
    "map",
    "vmap",
    "regex",
    "templatesStart",
    "templatesString",
    "replace",
    "split",
    "rawTemplate",
    "nameMatch",
    "variables",
    "vregex",
    "lastOpenedTag",
    "openedTags",
    "openedAttributes",
    "parts",
    "shift",
    "cleanedText",
    "xmlDoc",
    "xml",
    "Document",
    "fromString",
    "lastChild",
    "lastElementChild",
    "lastFound",
    "toLowerCase",
    "attributes",
    "outerHTML",
    "nodeName",
    "entry",
    "res",
    "searchedElement",
    "getDesigns",
    "then",
    "sugg",
    "suggestions",
    "getTransforms",
    "getPlugins",
    "getIcons",
    "getInfluxDBs",
    "getInfluxDBFields",
    "includes",
    "influxAttributes",
    "getNamedItem",
    "getInfluxDBTags",
    "value",
    "getInfluxDBValues",
    "keys",
    "EnumMember",
    "templateNames",
    "variableName",
    "locale",
    "Manager",
    "tr",
    "Variable",
    "mappingName",
    "stylingName",
    "getAddresses",
    "getRrds",
    "typeFilter",
    "getMediaFiles",
    "currentItem",
    "type",
    "getEnumeration",
    "Value",
    "endsWith",
    "bind",
    "destruct",
    "completion",
    "Config"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* Config.js \n * \n * copyright (c) 2010-2022, Christian Mayer and the CometVisu contributers.\n * \n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n */\n\n\n/**\n * XSD-based code completion provider for the monaco text editor.\n *\n * @since 0.11.0\n * @author Tobias Bräutigam\n */\nqx.Class.define('cv.ui.manager.editor.completion.Config', {\n  extend: qx.core.Object,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  /**\n   *\n   * @param schema {cv.ui.manager.model.Schema}\n   */\n  construct: function (schema) {\n    this.base(arguments);\n    this.__elementCache = {};\n    this._schema = schema;\n    this._dataProvider = cv.ui.manager.editor.data.Provider.getInstance();\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n    __elementCache: null,\n    __metaElementCache: null,\n    _dataProvider: null,\n\n    getLastOpenedTag: function (text) {\n      // get all tags inside of the content\n      const tags = text.match(/<\\/*(?=\\S*)([a-zA-Z-]+)/g);\n      if (!tags) {\n        return null;\n      }\n      // we need to know which tags are closed\n      const closingTags = [];\n      for (let i = tags.length - 1; i >= 0; i--) {\n        if (tags[i].indexOf('</') === 0) {\n          closingTags.push(tags[i].substring('</'.length));\n        } else {\n          // get the last position of the tag\n          const tagPosition = text.lastIndexOf(tags[i]);\n          const tag = tags[i].substring('<'.length);\n          const closingBracketIdx = text.indexOf('/>', tagPosition);\n          // if the tag wasn't closed\n          if (closingBracketIdx === -1) {\n            // if there are no closing tags or the current tag wasn't closed\n            if (!closingTags.length || closingTags[closingTags.length - 1] !== tag) {\n              // we found our tag, but let's get the information if we are looking for\n              // a child element or an attribute\n              text = text.substring(tagPosition);\n\n              const openedTag = text.indexOf('<') > text.indexOf('>');\n              let contentSearch = false;\n              let currentAttribute = null;\n              if (openedTag) {\n                const attrMatch = /([\\w\\-_\\.\\d]+)=\"[^\"]*$/.exec(text);\n                contentSearch = !!attrMatch;\n                currentAttribute = attrMatch ? attrMatch[1] : null;\n              }\n              const filteredElementSearch = /<[\\w-_\\d]+$/.test(text);\n              return {\n                tagName: tag,\n                currentAttribute: currentAttribute,\n                filteredElementSearch: filteredElementSearch,\n                isAttributeSearch: !filteredElementSearch && openedTag && !contentSearch,\n                isContentSearch: contentSearch,\n                text: text\n              };\n            }\n            // remove the last closed tag\n            closingTags.splice(closingTags.length - 1, 1);\n          }\n          // remove the last checked tag and continue processing the rest of the content\n          text = text.substring(0, tagPosition);\n        }\n      }\n      return null;\n    },\n\n    findElements: function (parent, elementName, maxDepth, currentDepth, inMeta) {\n      const cache = inMeta === true ? this.__metaElementCache : this.__elementCache;\n      if (elementName in cache) {\n        return cache[elementName];\n      }\n      if (maxDepth < currentDepth) {\n        return null;\n      }\n      if (!parent) {\n        parent = this._schema.getElementNode('pages');\n      }\n      if (currentDepth === undefined) {\n        currentDepth = 1;\n      }\n      const allowedElements = parent.getAllowedElements();\n      // console.log(parent.name+\" looking for \"+elementName+\" in tree level \"+currentDepth+ \"(<\"+maxDepth+\") (\"+Object.getOwnPropertyNames(allowedElements).join(\", \")+\")\");\n      if (elementName in allowedElements) {\n        // console.log(\"found \"+elementName+\" in tree level \"+currentDepth);\n        this.__elementCache[elementName] = allowedElements[elementName];\n        return allowedElements[elementName];\n      }\n      for (let element in allowedElements) {\n        if (inMeta !== true && element === 'meta') {\n          continue;\n        }\n        if (maxDepth > currentDepth) {\n          const result = this.findElements(allowedElements[element], elementName, maxDepth, currentDepth + 1);\n          if (result) {\n            cache[elementName] = result;\n            // console.log(\"found \" + elementName + \" in tree level \" + currentDepth);\n            return result;\n          }\n        }\n      }\n      return null;\n    },\n\n    isItemAvailable: function (itemName, maxOccurs, items) {\n      // the default for 'maxOccurs' is 1\n      maxOccurs = maxOccurs || '1';\n      // the element can appere infinite times, so it is available\n      if (maxOccurs && maxOccurs === 'unbounded') {\n        return true;\n      }\n      // count how many times the element appeared\n      let count = 0;\n      for (let i = 0; i < items.length; i++) {\n        if (items[i] === itemName) {\n          count++;\n        }\n      }\n      // if it didn't appear yet, or it can appear again, then it\n      // is available, otherwise it't not\n      return count === 0 || parseInt(maxOccurs) > count;\n    },\n\n    getElementString: function (element, indent, prefix) {\n      let insertText = indent + prefix + element.getName() + ' ';\n      // add all required attributes with default values\n      const allowedAttributes = element.getAllowedAttributes();\n      Object.getOwnPropertyNames(allowedAttributes).forEach(function(attr) {\n        const attribute = allowedAttributes[attr];\n        if (!attribute.isOptional) {\n          insertText += attr+'=\"'+(attribute.getDefaultValue() ? attribute.getDefaultValue() : '')+'\" ';\n        }\n      });\n      // add mandatory children\n      const requiredElements = element.getRequiredElements();\n      const allowedContent = element.getAllowedContent();\n      const isContentAllowed = allowedContent._text || requiredElements.length > 0 || !!allowedContent._grouping;\n      if (!isContentAllowed) {\n        // close tag\n        insertText = insertText.trim()+'/';\n      } else {\n        // close open tag\n        insertText = insertText.trim()+'>';\n\n        // insert required elements\n        let children = 0;\n        requiredElements.forEach(function(elemName) {\n          const elem = this.findElements(element, elemName, 1, 0);\n          if (elem) {\n            insertText += '\\n    ' + this.getElementString(elem, indent + '    ', '<') + '>';\n            children++;\n          }\n        }, this);\n        // add closing tag\n        if (children > 0) {\n          insertText += '\\n'+indent;\n        }\n        insertText += '</'+element.getName();\n      }\n      return insertText;\n    },\n\n    getAvailableElements: function (element, usedItems) {\n      const availableItems = [];\n      const children = element.getAllowedElements();\n\n      // if there are no such elements, then there are no suggestions\n      if (!children) {\n        return [];\n      }\n      Object.getOwnPropertyNames(children).filter(name => !name.startsWith('#')).forEach(function(name) {\n        // get all element attributes\n        const childElem = children[name];\n        // the element is a suggestion if it's available\n        if (this.isItemAvailable(childElem.getName(), childElem.getBounds().max, usedItems)) {\n          // mark it as a 'field', and get the documentation\n          availableItems.push({\n            label: childElem.getName(),\n            insertText: this.getElementString(childElem, '', ''),\n            kind: window.monaco.languages.CompletionItemKind.Field,\n            detail: childElem.getType(),\n            documentation: childElem.getDocumentation().join('\\n')\n          });\n        }\n      }, this);\n      // return the suggestions we found\n      return availableItems;\n    },\n\n    getAvailableAttributes: function (element, usedChildTags) {\n      const availableItems = [];\n      // get all attributes for the element\n      const attrs = element.getAllowedAttributes();\n      Object.getOwnPropertyNames(attrs).forEach(function(name) { // jshint ignore:line\n        const attr = attrs[name];\n        // accept it in a suggestion list only the attribute is not used yet\n        if (usedChildTags.indexOf(attr.name) === -1) {\n          // mark it as a 'property', and get it's documentation\n          availableItems.push({\n            label: attr.getName(),\n            insertText: attr.getName()+'=\"\"',\n            kind: window.monaco.languages.CompletionItemKind.Property,\n            detail: attr.getTypeString(),\n            documentation: attr.getDocumentation().join('\\n')\n          });\n        }\n      }, this);\n\n      // return the elements we found\n      return availableItems;\n    },\n\n    getProvider: function () {\n      return {\n        triggerCharacters: ['<', '\"'],\n        provideCompletionItems: function (model, position) {\n          // get editor content before the pointer\n          const textUntilPosition = model.getValueInRange({\n            startLineNumber: 1,\n            startColumn: 1,\n            endLineNumber: position.lineNumber,\n            endColumn: position.column\n          });\n          // parse mappings\n          const completeText = model.getValue();\n          const metaEndPos = completeText.indexOf('</meta>');\n          const textMeta = metaEndPos > 0 ? completeText.substring(0, metaEndPos) : completeText;\n          const mappingNames = [];\n          const stylingNames = [];\n          const templates = {};\n          let map;\n          let vmap;\n          let regex = /<mapping name=\"([^\"]+)\"/gm;\n          while ((map = regex.exec(textMeta)) !== null) {\n            mappingNames.push(map[1]);\n          }\n          regex = /<styling name=\"([^\"]+)\"/gm;\n          while ((map = regex.exec(textMeta)) !== null) {\n            stylingNames.push(map[1]);\n          }\n          const templatesStart = textMeta.indexOf('<templates>');\n          if (templatesStart >= 0) {\n            const templatesString = textMeta.substring(templatesStart + 11, textMeta.indexOf('</templates>') - 12).replace(/(?:\\r\\n|\\r|\\n)/g, '');\n            templatesString.split('</template>').forEach(function (rawTemplate) {\n              const nameMatch = /<template name=\"([^\"]+)\"/.exec(rawTemplate);\n              if (nameMatch) {\n                // search for variables\n                const variables = [];\n                const vregex = /{{{?\\s*([\\w\\d]+)\\s*}?}}/gm;\n                while ((vmap = vregex.exec(rawTemplate)) !== null) {\n                  variables.push(vmap[1]);\n                }\n                templates[nameMatch[1]] = variables;\n              }\n            }, this);\n          }\n\n          // if we want suggestions, inside of which tag are we?\n          const lastOpenedTag = this.getLastOpenedTag(textUntilPosition);\n          // console.log(lastOpenedTag);\n          // get opened tags to see what tag we should look for in the XSD schema\n          const openedTags = [];\n          // attributes of the ancestors\n          const openedAttributes = [];\n          // get the elements/attributes that are already mentioned in the element we're in\n          const usedItems = [];\n          const isAttributeSearch = lastOpenedTag && lastOpenedTag.isAttributeSearch;\n          const isContentSearch = lastOpenedTag && lastOpenedTag.isContentSearch;\n          const filteredElementSearch = lastOpenedTag && lastOpenedTag.filteredElementSearch;\n          // no need to calculate the position in the XSD schema if we are in the root element\n          let parts;\n          if (lastOpenedTag) {\n            // try to create a valid XML document\n            parts = lastOpenedTag.text.split(' ');\n            parts.shift();\n            let cleanedText = textUntilPosition;\n            if (parts.length) {\n              cleanedText = cleanedText.substring(0, cleanedText.length-parts.join(' ').length)+'>';\n            }\n            // parse the content (not cleared text) into an xml document\n            const xmlDoc = qx.xml.Document.fromString(cleanedText);\n            let lastChild = xmlDoc.lastElementChild;\n            let i;\n            let lastFound = false;\n            while (lastChild && lastChild.tagName.toLowerCase() !== 'parsererror') {\n              openedTags.push(lastChild.tagName);\n              openedAttributes.push(lastChild.attributes);\n              // if we found our last opened tag\n              if (lastChild.tagName === lastOpenedTag.tagName) {\n                lastFound = true;\n                // if we are looking for attributes, then used items should\n                // be the attributes we already used\n                if (lastOpenedTag.isAttributeSearch && lastChild.outerHTML === lastOpenedTag.text) {\n                  const attrs = lastChild.attributes;\n                  for (i = 0; i < attrs.length; i++) {\n                    usedItems.push(attrs[i].nodeName);\n                  }\n                } else {\n                  // if we are looking for child elements, then used items\n                  // should be the elements that were already used\n                  const children = lastChild.children;\n                  for (i = 0; i < children.length; i++) {\n                    if (children[i].tagName.toLowerCase() !== 'parsererror') {\n                      usedItems.push(children[i].tagName);\n                    }\n                  }\n                }\n                break;\n              }\n              // we haven't found the last opened tag yet, so we move to\n              // the next element\n              lastChild = lastChild.lastElementChild;\n            }\n            if (!lastFound) {\n              // fallback -> parse string\n              if (isAttributeSearch || isContentSearch) {\n                parts = lastOpenedTag.text.split(' ');\n                // skip tag name\n                parts.shift();\n                parts.forEach(function(entry) {\n                  usedItems.push(entry.split('=').shift());\n                });\n              }\n            }\n          }\n          let res = [];\n          let match;\n          // find the last opened tag in the schema to see what elements/attributes it can have\n          let searchedElement = openedTags[openedTags.length - 1];\n          if (isContentSearch) {\n            // handle data providers if the is one relevant\n            if (lastOpenedTag.tagName === 'pages' && lastOpenedTag.currentAttribute === 'design') {\n              return this._dataProvider.getDesigns().then(function (sugg) {\n                return {suggestions: sugg};\n              });\n            } else if (lastOpenedTag.tagName === 'address' && lastOpenedTag.currentAttribute === 'transform') {\n              return {suggestions: this._dataProvider.getTransforms()};\n            } else if (lastOpenedTag.tagName === 'plugin' && lastOpenedTag.currentAttribute === 'name') {\n              return {suggestions: this._dataProvider.getPlugins()};\n            } else if (lastOpenedTag.tagName === 'icon' && lastOpenedTag.currentAttribute === 'name') {\n              return {suggestions: this._dataProvider.getIcons('monaco', {cache: false}, completeText)};\n            } else if (lastOpenedTag.tagName === 'influx') {\n              if (lastOpenedTag.currentAttribute === 'measurement') {\n                return this._dataProvider.getInfluxDBs().then(function (suggestions) {\n                  return {suggestions: suggestions};\n                });\n              } else if (lastOpenedTag.currentAttribute === 'field') {\n                match = /measurement=\"([^\"]+)\"/.exec(lastOpenedTag.text);\n                if (match) {\n                  return this._dataProvider.getInfluxDBFields(match[1]).then(function (suggestions) {\n                    return {suggestions: suggestions};\n                  });\n                }\n              }\n            } else if (lastOpenedTag.tagName === 'tag' && (lastOpenedTag.currentAttribute === 'key' || lastOpenedTag.currentAttribute === 'value') && openedTags.includes('influx')) {\n              const influxAttributes = openedAttributes[openedTags.indexOf('influx')];\n              const attr = influxAttributes.getNamedItem('measurement');\n              if (attr) {\n                if (lastOpenedTag.currentAttribute === 'key') {\n                  return this._dataProvider.getInfluxDBTags(attr.value).then(function (suggestions) {\n                    return {suggestions: suggestions};\n                  });\n                } else if (lastOpenedTag.currentAttribute === 'value') {\n                  match = /key=\"([^\"]+)\"/.exec(lastOpenedTag.text);\n                  if (match) {\n                    return this._dataProvider.getInfluxDBValues(attr.value, match[1]).then(function (suggestions) {\n                      return {suggestions: suggestions};\n                    });\n                  }\n                }\n              }\n            } else if (lastOpenedTag.tagName === 'template' && lastOpenedTag.currentAttribute === 'name' && openedTags.includes('meta')) {\n              res = Object.keys(templates).map(function (name) {\n                return {\n                  label: name,\n                  insertText: name,\n                  kind: window.monaco.languages.CompletionItemKind.EnumMember\n                };\n              }, this);\n              return {suggestions: res};\n            } else if (lastOpenedTag.tagName === 'value' &&\n              lastOpenedTag.currentAttribute === 'name' &&\n              !openedTags.includes('meta') &&\n              openedTags.includes('template')) {\n              // TODO: find out template name\n              const templateNames = Object.keys(templates);\n              templateNames.forEach(function (name) {\n                templates[name].forEach(function (variableName) {\n                  res.push({\n                    label: variableName,\n                    insertText: variableName,\n                    detail: qx.locale.Manager.tr('Variable from template %1', name),\n                    kind: window.monaco.languages.CompletionItemKind.Variable\n                  });\n                }, this);\n              }, this);\n              return {suggestions: res};\n            } else if (lastOpenedTag.currentAttribute === 'mapping') {\n              res = mappingNames.map(function (mappingName) {\n                return {\n                  label: mappingName,\n                  insertText: mappingName,\n                  kind: window.monaco.languages.CompletionItemKind.EnumMember\n                };\n              }, this);\n              return {suggestions: res};\n            } else if (lastOpenedTag.currentAttribute === 'styling') {\n              res = stylingNames.map(function (stylingName) {\n                return {\n                  label: stylingName,\n                  insertText: stylingName,\n                  kind: window.monaco.languages.CompletionItemKind.EnumMember\n                };\n              }, this);\n              return {suggestions: res};\n            }\n\n            // TODO: completions that have to be retrieved from the backend\n            // * rrds\n            // * Influx: dbs, tags fields\n            // * media files\n\n            searchedElement = lastOpenedTag.tagName;\n          } else if (!isAttributeSearch && filteredElementSearch) {\n            searchedElement = openedTags[openedTags.length-2];\n          } else if (lastOpenedTag.tagName === 'address' && lastOpenedTag.currentAttribute === null) {\n            return this._dataProvider.getAddresses('monaco').then(res => ({suggestions: res}));\n          }\n          if (searchedElement === 'rrd') {\n            return this._dataProvider.getRrds('monaco').then(res => ({suggestions: res}));\n          } else if (searchedElement === 'file' && !isAttributeSearch && !isContentSearch && openedTags.includes('files')) {\n            match = /type=\"([^\"]+)\"/.exec(lastOpenedTag.text);\n            const typeFilter = match ? match[1] : null;\n            return this._dataProvider.getMediaFiles(typeFilter).then(function (suggestions) {\n              return {suggestions: suggestions};\n            });\n          }\n          const currentItem = this.findElements(this._schema.getElementNode('pages'), searchedElement, openedTags.length, openedTags.includes('meta'));\n\n          // return available elements/attributes if the tag exists in the schema, or an empty\n          // array if it doesn't\n          if (isContentSearch) {\n            const currentAttribute = usedItems[usedItems.length - 1];\n\n            if (currentItem && currentAttribute in currentItem.getAllowedAttributes()) {\n              const attribute = currentItem.getAllowedAttributes()[currentAttribute];\n              const type = attribute.getTypeString();\n              attribute.getEnumeration().forEach(function(entry) {\n                res.push({\n                  label: entry,\n                  kind: window.monaco.languages.CompletionItemKind.Value,\n                  detail: type,\n                  documentation: attribute.getDocumentation().join('\\n')\n                });\n              });\n            }\n          } else if (isAttributeSearch) {\n            // get attributes completions\n            res = currentItem ? this.getAvailableAttributes(currentItem, usedItems) : [];\n          } else {\n            // get elements completions\n            // eslint-disable-next-line no-lonely-if\n            if (lastOpenedTag && lastOpenedTag.text.endsWith('</')) {\n              res.push({\n                label: lastOpenedTag.tagName,\n                kind: window.monaco.languages.CompletionItemKind.Field\n              });\n            } else {\n              res = currentItem ? this.getAvailableElements(currentItem, usedItems) : [];\n            }\n          }\n          return {suggestions: res};\n        }.bind(this)\n      };\n    }\n  },\n\n  /*\n  ***********************************************\n    DESTRUCTOR\n  ***********************************************\n  */\n  destruct: function () {\n    this.__elementCache = null;\n    this._schema = null;\n    this._dataProvider = null;\n  }\n});\n"
  ]
}