{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/model/schema/Group.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "cv",
    "ui",
    "manager",
    "model",
    "schema",
    "Base",
    "construct",
    "node",
    "parse",
    "properties",
    "type",
    "refine",
    "init",
    "members",
    "getSchema",
    "group",
    "getNode",
    "hasAttribute",
    "getReferencedNode",
    "getAttribute",
    "grouping",
    "querySelector",
    "_subGroupings",
    "push",
    "Choice",
    "Sequence",
    "getAllowedElements",
    "getAllowedElementsSorting",
    "sortNumber",
    "namesWithSorting",
    "allowedElements",
    "Object",
    "keys",
    "forEach",
    "name",
    "item",
    "mySortNumber",
    "undefined",
    "getType",
    "getName",
    "subSortedElements",
    "assign",
    "getRegex",
    "separator",
    "nocapture",
    "_regexCache",
    "regexString",
    "bounds",
    "getBounds",
    "min",
    "max",
    "Number",
    "POSITIVE_INFINITY",
    "getBoundsForElementName",
    "childName",
    "Group"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* Group.js \n * \n * copyright (c) 2010-2022, Christian Mayer and the CometVisu contributers.\n * \n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n */\n\n\n/**\n * a single group.\n * may be recursive\n */\nqx.Class.define('cv.ui.manager.model.schema.Group', {\n  extend: cv.ui.manager.model.schema.Base,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  construct: function (node, schema) {\n    this.base(arguments, node, schema);\n    this.parse();\n  },\n\n  /*\n  ***********************************************\n    PROPERTIES\n  ***********************************************\n  */\n  properties: {\n    type: {\n      refine: true,\n      init: 'group'\n    }\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n    /**\n     * parse a list of elements in this group.\n     * Group is allowed (all|choice|sequence)? as per the definition.\n     * We do all of those (except for 'all')\n     */\n    parse: function () {\n      this.base(arguments);\n      const schema = this.getSchema();\n\n      let group = this.getNode();\n      if (group.hasAttribute('ref')) {\n        // if this is a reference, unravel it.\n        group = schema.getReferencedNode('group', group.getAttribute('ref'));\n      }\n\n      // we are allowed choice and sequence, but only ONE AT ALL is allowed\n      let grouping = group.querySelector(':scope > choice');\n      if (grouping) {\n        this._subGroupings.push(new cv.ui.manager.model.schema.Choice(grouping, schema));\n      } else {\n        grouping = group.querySelector(':scope > sequence');\n        if (grouping) {\n          this._subGroupings.push(new cv.ui.manager.model.schema.Sequence(grouping, schema));\n        }\n      }\n    },\n\n    /**\n     * get the elements allowed for this group\n     *\n     * @return  object      list of allowed elements, key is the name\n     */\n    getAllowedElements: function () {\n      // we have non of ourselves, so we return what the child says\n      return this._subGroupings[0].getAllowedElements();\n    },\n\n    /**\n     * get the sorting of the allowed elements.\n     * For a group, all elements have the same sorting, so they will all have the\n     * same sort number\n     *\n     * Warning: this only works if any element can have only ONE position in the parent.\n     *\n     * @param   sortNumber  integer the sort number of a parent (only used when recursive)\n     * @return  object              list of allowed elements, with their sort-number as value\n     */\n    getAllowedElementsSorting: function (sortNumber) {\n      const namesWithSorting = {};\n      const allowedElements = this.getAllowedElements();\n      Object.keys(allowedElements).forEach(name => {\n        const item = allowedElements[name];\n        let mySortNumber = 'x'; // for a group, sortNumber is always the same\n        if (sortNumber !== undefined) {\n          mySortNumber = sortNumber + '.' + mySortNumber;\n        }\n\n        if (item.getType() === 'element') {\n          namesWithSorting[item.getName()] = mySortNumber;\n        } else {\n          // go recursive\n          const subSortedElements = item.getAllowedElementsSorting(mySortNumber);\n          Object.assign(namesWithSorting, subSortedElements);\n        }\n      }, this);\n      return namesWithSorting;\n    },\n\n    /**\n     * get a regex (string) describing this choice\n     *\n     * @param   separator   string  the string used to separate different elements, e.g. ';'\n     * @param   nocapture   bool    when set to true non capturing groups are used\n     * @return  string  regex\n     */\n    getRegex: function (separator, nocapture) {\n      if (this._regexCache !== null) {\n        // use the cache if primed\n        return this._regexCache;\n      }\n\n      let regexString = '(';\n\n      // collect the regex for each and every grouping we might have;\n      // 'each and every' means 'the only ONE'\n      this._subGroupings.forEach(grouping => {\n        regexString = '(';\n        if (nocapture) {\n regexString += '?:'; \n}\n        regexString += grouping.getRegex(separator, nocapture) + ')';\n      });\n\n      // append bounds to regex\n      regexString += '{';\n      const bounds = this.getBounds();\n      regexString += bounds.min === undefined ? 1 : bounds.min;\n      regexString += ',';\n      if (bounds.max !== Number.POSITIVE_INFINITY) {\n        regexString += bounds.max === undefined ? 1 : bounds.max;\n      }\n      regexString += '}';\n\n      // fill the cache\n      this._regexCache = regexString;\n\n      // thats about it.\n      return regexString;\n    },\n\n    getBoundsForElementName: function (childName) {\n      // we are a group. we have no saying of ourselves\n      // (@FIXME: by definition we do, but we do not take that into account)\n      return this._subGroupings[0].getBoundsForElementName(childName);\n    }\n  }\n});\n"
  ]
}