{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/model/schema/Sequence.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "cv",
    "ui",
    "manager",
    "model",
    "schema",
    "Base",
    "construct",
    "node",
    "parse",
    "properties",
    "type",
    "refine",
    "init",
    "elementsHaveOrder",
    "members",
    "getSchema",
    "subNodes",
    "Array",
    "from",
    "getNode",
    "children",
    "forEach",
    "subNode",
    "subObject",
    "undefined",
    "nodeName",
    "Element",
    "setSortable",
    "_allowedElements",
    "getName",
    "Choice",
    "_subGroupings",
    "push",
    "Sequence",
    "Group",
    "Any",
    "_sortedContent",
    "getCommentNodeSchemaElement",
    "getRegex",
    "separator",
    "nocapture",
    "_regexCache",
    "regexString",
    "elementRegexes",
    "element",
    "join",
    "bounds",
    "getBounds",
    "min",
    "max",
    "Number",
    "POSITIVE_INFINITY",
    "getBoundsForElementName",
    "childName",
    "elementBounds",
    "sequenceBounds",
    "resultBounds",
    "hasOwnProperty",
    "isNaN",
    "childBounds",
    "tmpBounds",
    "i",
    "length",
    "getAllowedElementsSorting",
    "sortNumber",
    "namesWithSorting",
    "item",
    "mySortNumber",
    "getType",
    "subSortedElements",
    "Object",
    "assign"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/**\n * a single sequence.\n * may be recursive\n */\nqx.Class.define('cv.ui.manager.model.schema.Sequence', {\n  extend: cv.ui.manager.model.schema.Base,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  construct: function (node, schema) {\n    this.base(arguments, node, schema);\n    this.parse();\n  },\n\n  /*\n  ***********************************************\n    PROPERTIES\n  ***********************************************\n  */\n  properties: {\n    type: {\n      refine: true,\n      init: 'sequence'\n    },\n    elementsHaveOrder: {\n      refine: true,\n      init: true\n    }\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n\n    /**\n     * parse a list of elements in this group.\n     * Group is allowed (all|choice|sequence)? as per the definition.\n     * We do all of those (except for 'all')\n     */\n    parse: function () {\n      this.base(arguments);\n      const schema = this.getSchema();\n\n      // for a sequence, we need to keep the order of the elements\n      // so we have to use a 'mixed' approach in reading them\n      const subNodes = Array.from(this.getNode().children);\n\n      subNodes.forEach((subNode) => {\n        let subObject = undefined;\n\n        switch (subNode.nodeName) {\n          case 'xsd:element':\n          case 'element':\n            subObject = new cv.ui.manager.model.schema.Element(subNode, schema);\n            // sequences' children are non-sortable\n            subObject.setSortable(false);\n            this._allowedElements[subObject.getName()] = subObject;\n            break;\n          case 'xsd:choice':\n          case 'choice':\n            subObject = new cv.ui.manager.model.schema.Choice(subNode, schema)\n            this._subGroupings.push(subObject);\n            break;\n          case 'xsd:sequence':\n          case 'sequence':\n            subObject = new cv.ui.manager.model.schema.Sequence(subNode, schema)\n            this._subGroupings.push(subObject);\n            break;\n          case 'xsd:group':\n          case 'group':\n            subObject = new cv.ui.manager.model.schema.Group(subNode, schema)\n            this._subGroupings.push(subObject);\n            break;\n          case 'xsd:any':\n          case 'any':\n            subObject = new cv.ui.manager.model.schema.Any(subNode, schema)\n            this._subGroupings.push(subObject);\n            break;\n        }\n\n        this._sortedContent.push(subObject);\n      });\n      this._allowedElements['#comment'] = this.getSchema().getCommentNodeSchemaElement();\n    },\n\n    /**\n     * get a regex (string) describing this choice\n     *\n     * @param   separator   string  the string used to separate different elements, e.g. ';'\n     * @param   nocapture   bool    when set to true non capturing groups are used\n     * @return  string  regex\n     */\n    getRegex: function (separator, nocapture) {\n      if (this._regexCache !== null) {\n        // use the cache if primed\n        return this._regexCache;\n      }\n\n      let regexString = '(';\n\n      // create list of allowed elements\n      if (nocapture) {\n        regexString += '?:';\n      }\n\n      const elementRegexes = [];\n\n      // this goes over ALL elements AND sub-groupings\n      this._sortedContent.forEach((element) => {\n        elementRegexes.push(element.getRegex(separator, nocapture));\n      });\n\n      regexString += elementRegexes.join('');\n\n      regexString += ')';\n\n\n      // append bounds to regex\n      regexString += '{';\n      const bounds = this.getBounds();\n      regexString += bounds.min === undefined ? 1 : bounds.min;\n      regexString += ',';\n      if (bounds.max !== Number.POSITIVE_INFINITY) {\n        regexString += bounds.max === undefined ? 1 : bounds.max;\n      }\n      regexString += '}';\n\n      // fill the cache\n      this._regexCache = regexString;\n\n      // thats about it.\n      return regexString;\n    },\n\n    getBoundsForElementName: function (childName) {\n      // we are a sequence-element; there is actually a lot of sayings ...\n      if (typeof this._allowedElements[childName] !== 'undefined') {\n        const elementBounds = this._allowedElements[childName].getBounds();\n        const sequenceBounds = this.getBounds();\n\n        const resultBounds = {\n          min: 1,\n          max: 1\n        };\n\n        // if it is bounded, we must duplicate element and sequence bounds\n        // (an element may appear as often as the number of sequences times the number of elements\n        // in each sequence - roughly)\n        if (elementBounds.hasOwnProperty(\"min\")) {\n          resultBounds.min = elementBounds.min;\n        }\n\n        if (sequenceBounds.hasOwnProperty(\"min\") && !isNaN(sequenceBounds.min)) {\n          resultBounds.min = resultBounds.min * sequenceBounds.min;\n        }\n\n        if (elementBounds.max === Number.POSITIVE_INFINITY || sequenceBounds.max === Number.POSITIVE_INFINITY) {\n          resultBounds.max = Number.POSITIVE_INFINITY;\n        } else {\n          if (elementBounds.hasOwnProperty(\"max\")) {\n            resultBounds.max = elementBounds.max;\n          }\n\n          if (sequenceBounds.hasOwnProperty(\"max\") && !isNaN(sequenceBounds.max)) {\n            resultBounds.max = resultBounds.max * sequenceBounds.max;\n          }\n        }\n\n        return resultBounds;\n      }\n\n      let childBounds = undefined;\n\n      let tmpBounds;\n\n      for (let i = 0; i < this._subGroupings.length; ++i) {\n        tmpBounds = this._subGroupings[i].getBoundsForElementName(childName);\n\n        if (undefined !== tmpBounds) {\n          // once we find the first set of bounds, we return that\n          childBounds = tmpBounds;\n          break;\n        }\n      }\n\n      return childBounds;\n    },\n\n    /**\n     * get the sorting of the allowed elements\n     *\n     * Warning: this only works if any element can have only ONE position in the parent.\n     *\n     * @param   sortnumber  integer the sortnumber of a parent (only used when recursive)\n     * @return  object              list of allowed elements, with their sort-number as value\n     */\n    getAllowedElementsSorting: function (sortNumber) {\n      const namesWithSorting = {};\n\n      this._sortedContent.forEach( (item, i) => {\n        let mySortNumber = i;\n        if (sortNumber !== undefined) {\n          mySortNumber = sortNumber + '.' + i;\n        }\n\n        if (item.getType() === 'element') {\n          namesWithSorting[item.getName()] = mySortNumber;\n        } else {\n          // go recursive\n          const subSortedElements = item.getAllowedElementsSorting(mySortNumber);\n          Object.assign(namesWithSorting, subSortedElements);\n        }\n      });\n\n      return namesWithSorting;\n    }\n  }\n});\n"
  ]
}