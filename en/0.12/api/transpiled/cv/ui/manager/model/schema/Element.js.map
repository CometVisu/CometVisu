{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/model/schema/Element.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "cv",
    "ui",
    "manager",
    "model",
    "schema",
    "Base",
    "include",
    "MAnnotation",
    "construct",
    "node",
    "parse",
    "statics",
    "getElementName",
    "e",
    "hasAttribute",
    "getAttribute",
    "refName",
    "ref",
    "getReferencedNode",
    "length",
    "Error",
    "getTypeNode",
    "type",
    "match",
    "querySelector",
    "sortChildNodes",
    "sorting",
    "a",
    "b",
    "aSortvalue",
    "name",
    "bSortvalue",
    "undefined",
    "toString",
    "aSortvaluesList",
    "split",
    "bSortvaluesList",
    "i",
    "properties",
    "refine",
    "init",
    "check",
    "defaultValue",
    "nullable",
    "sortable",
    "event",
    "mixed",
    "members",
    "__allowedContentLoaded",
    "__allowedContent",
    "__allowedAttributes",
    "__textNodeSchemaElement",
    "_type",
    "getNode",
    "getSchema",
    "Element",
    "setName",
    "setDefaultValue",
    "setMixed",
    "getAllowedContent",
    "allowedContent",
    "_grouping",
    "_text",
    "querySelectorAll",
    "SimpleType",
    "tmpDOMGrouping",
    "nodeName",
    "Choice",
    "Sequence",
    "Group",
    "Any",
    "children",
    "Array",
    "from",
    "forEach",
    "sub",
    "subElement",
    "getName",
    "getAllowedAttributes",
    "allowedAttributes",
    "attributes",
    "attributeGroups",
    "aGroup",
    "attributeGroup",
    "child",
    "push",
    "attr",
    "attribute",
    "Attribute",
    "areChildrenSortable",
    "getElementsHaveOrder",
    "getRequiredElements",
    "getAllowedElements",
    "excludeComment",
    "allowedElements",
    "Object",
    "assign",
    "textOnly",
    "isMixed",
    "getTextNodeSchemaElement",
    "getCommentNodeSchemaElement",
    "getAllowedElementsSorting",
    "getFirstLevelElementSorting",
    "allowedSorting",
    "keys",
    "sort",
    "parseInt",
    "getChildBounds",
    "hasMultiLevelBounds",
    "getBounds",
    "getBoundsForElementName",
    "childName",
    "isTextContentAllowed",
    "isTextContentRequired",
    "isValueValid",
    "isChildElementAllowed",
    "isElementAllowed",
    "getSchemaElementForElementName",
    "elementName",
    "tmpXML",
    "getSchemaDOM",
    "createElement",
    "setAttribute",
    "value",
    "getRegex",
    "separator",
    "nocapture",
    "regexString",
    "boundsMin",
    "boundsMax",
    "bounds",
    "min",
    "max",
    "Number",
    "POSITIVE_INFINITY",
    "getChildrenRegex",
    "destruct",
    "_disposeMap",
    "_disposeObjects"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* Element.js \n * \n * copyright (c) 2010-2022, Christian Mayer and the CometVisu contributers.\n * \n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n */\n\n\n/**\n * a single element from the schema\n */\nqx.Class.define('cv.ui.manager.model.schema.Element', {\n  extend: cv.ui.manager.model.schema.Base,\n  include: cv.ui.manager.model.schema.MAnnotation,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  construct: function (node, schema) {\n    this.base(arguments, node, schema);\n    this.parse();\n  },\n\n  /*\n  ***********************************************\n    STATICS\n  ***********************************************\n  */\n  statics: {\n    /**\n     * Get the name of a schema-element\n     * @param e object  element to find the name of\n     * @param schema\n     * @return  string          name of the element\n     * @throws  if the name can not be found\n     */\n    getElementName: function(e, schema) {\n      if (e.hasAttribute('name')) {\n        return e.getAttribute('name');\n      }\n\n      if (e.hasAttribute('ref')) {\n        // it's a ref, seek other element!\n        const refName = e.getAttribute('ref');\n        const ref = schema.getReferencedNode('element', refName);\n\n        if (ref.length !== 1) {\n          throw new Error('schema/xsd appears to be invalid, can not find element ' + refName);\n        }\n\n        return ref.getAttribute('name');\n      }\n\n      return 'unknown';\n    },\n\n    /**\n     * find the type-node for this element\n     * @param node\n     * @param schema\n     * @return  object  object of the type-Node\n     */\n    getTypeNode: function (node, schema) {\n      let type;\n\n      if (node.hasAttribute('type')) {\n        if (node.getAttribute('type').match(/^xsd:/)) {\n          // if it starts with xsd:, it's actually a simple type\n          // does not start with\n          type = node;\n        } else {\n          // otherwise, the element is linked to a complexType\n          type = schema.getTypeNode('complex', node.getAttribute('type'));\n        }\n      } else if (node.hasAttribute('ref')) {\n        // the link is a reference to another element, which means it does not even have it's own name.\n        // this one is most certainly deprecated, as we do not have many root-level-elements, and only those can\n        // be ref'ed\n      } else {\n        // the element is it's own type\n        type = node.querySelector(':scope > complexType');\n      }\n\n      return type;\n    },\n\n    sortChildNodes: function (sorting) {\n      /**\n       * the comparison-function that helps the sorting\n       *\n       * @param   a   mixed   whatever sort gives us\n       * @param   b   mixed   whatever sort gives us\n       * @return  integer     -1, 0, 1 - depending on sort-order\n       */\n      return function (a, b) {\n        let aSortvalue = sorting[a.name];\n        let bSortvalue = sorting[b.name];\n\n        if (aSortvalue === undefined || bSortvalue === undefined) {\n          // undefined means: no sorting available\n          return 0;\n        }\n\n        if (aSortvalue === bSortvalue) {\n          // identical means 'no sorting necessary'\n          return 0;\n        }\n\n        // we need to go through the complete list of values the sorting is composed of,\n        // to find the first one that distinguishes a from b\n\n        // first, typecast to string!\n        if (typeof aSortvalue !== 'string') {\n          aSortvalue = aSortvalue.toString();\n        }\n        if (typeof bSortvalue !== 'string') {\n          bSortvalue = bSortvalue.toString();\n        }\n\n        let aSortvaluesList = aSortvalue.split('.');\n        let bSortvaluesList = bSortvalue.split('.');\n\n        for (let i = 0; i < aSortvaluesList.length; ++i) {\n          if (aSortvaluesList[i] < bSortvaluesList[i]) {\n            return -1;\n          } else if (aSortvaluesList[i] > bSortvaluesList[i]) {\n            return 1;\n          }\n        }\n\n        // if nothing else matched, then they are treated equal\n        return 0;\n      };\n    }\n  },\n\n  /*\n  ***********************************************\n    PROPERTIES\n  ***********************************************\n  */\n  properties: {\n    type: {\n      refine: true,\n      init: 'element'\n    },\n\n    name: {\n      check: 'String',\n      init: ''\n    },\n\n    defaultValue: {\n      check: 'String',\n      nullable: true\n    },\n\n    sortable: {\n      check: 'Boolean',\n      init: false,\n      event: 'changeSortable'\n    },\n\n    mixed: {\n      check: 'Boolean',\n      init: false\n    }\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n    __allowedContentLoaded: false,\n    __allowedContent: null,\n    __allowedAttributes: null,\n    __textNodeSchemaElement: null,\n\n    /**\n     * get and set the type-node for the element\n     * @var object  Type-Node (most certainly a complexType)\n     */\n    _type: null,\n\n    parse: function () {\n      this.base(arguments);\n      const node = this.getNode();\n      const schema = this.getSchema();\n\n      this._type = cv.ui.manager.model.schema.Element.getTypeNode(node, schema);\n      this.setName(cv.ui.manager.model.schema.Element.getElementName(node, schema));\n      if (node.hasAttribute('default')) {\n        this.setDefaultValue(node.getAttribute('default'));\n      }\n      this.setMixed(this._type.hasAttribute('mixed') && this._type.getAttribute('mixed') === 'true');\n    },\n\n    /**\n     * get a list of allowed elements for this element\n     *\n     * @return  object  object of SchemaElement-elements, key is the name\n     */\n    getAllowedContent: function () {\n      if (this.__allowedContent !== null) {\n        // if we have parsed this already, we can simply return the 'cache'\n        return this.__allowedContent;\n      }\n      const schema = this.getSchema();\n\n      const allowedContent = {\n        _grouping: undefined,\n        _text: false\n      };\n\n      // allowed sub-elements\n      // can be either simpleContent, or (choice|sequence|group|all)?\n      // 'all' is not supported yet.\n\n      if (this._type.querySelectorAll(':scope > simpleContent').length > 0) {\n        // it's simpleContent? Then it's either extension or restriction\n        // anyways, we will handle it, as if it were a simpleType\n        allowedContent._text = new cv.ui.manager.model.schema.SimpleType(this._type.querySelector(':scope > simpleContent'), schema);\n      } else if (this._type.querySelectorAll('complexType > choice, complexType> sequence, complexType > group').length > 0) {\n        // we have a choice, group or sequence. great\n        // as per the W3C, only one of these may appear per element/type\n\n        let tmpDOMGrouping = this._type.querySelector('complexType > choice, complexType > sequence, complexType > group');\n\n        // create the appropriate Schema*-object and append it to this very element\n        switch (tmpDOMGrouping.nodeName) {\n          case 'xsd:choice':\n          case 'choice':\n            allowedContent._grouping = new cv.ui.manager.model.schema.Choice(tmpDOMGrouping, schema);\n            break;\n          case 'xsd:sequence':\n          case 'sequence':\n            allowedContent._grouping = new cv.ui.manager.model.schema.Sequence(tmpDOMGrouping, schema);\n            break;\n          case 'xsd:group':\n          case 'group':\n            allowedContent._grouping = new cv.ui.manager.model.schema.Group(tmpDOMGrouping, schema);\n            break;\n          case 'xsd:any':\n          case 'any':\n            allowedContent._grouping = new cv.ui.manager.model.schema.Any(tmpDOMGrouping, schema);\n            break;\n        }\n      } else if (this._type.hasAttribute('type') && this._type.getAttribute('type').match(/^xsd:/)) {\n        // this is a really simple node that defines its own baseType\n        allowedContent._text = new cv.ui.manager.model.schema.SimpleType(this._type, schema);\n      } else {\n        // no type, no children, no choice - this is an element with NO allowed content/children\n        this.__allowedContent = allowedContent;\n        return allowedContent;\n      }\n\n\n      const children = Array.from(this._type.querySelectorAll(':scope > element'));\n      children.forEach(sub => {\n        const subElement = new cv.ui.manager.model.schema.Element(sub, schema);\n        allowedContent[subElement.getName()] = subElement;\n      });\n\n      // fill the cache\n      this.__allowedContent = allowedContent;\n\n      return allowedContent;\n    },\n\n    /**\n     * get and set the list of allowed attributes\n     * @var array   List of SchemaAttribute-objects\n     */\n    getAllowedAttributes: function () {\n      if (this.__allowedAttributes === null) {\n        const allowedAttributes = {};\n\n        // allowed attributes\n        const attributes = Array.from(this._type.querySelectorAll(':scope > attribute, :scope > simpleContent > extension > attribute'));\n\n        // now add any attribute that comes from an attribute-group\n        const attributeGroups = Array.from(this._type.querySelectorAll(':scope > attributeGroup, :scope > simpleContent > extension > attributeGroup'));\n\n        attributeGroups.forEach(aGroup => {\n          // get get group itself, by reference if necessary\n          // then extract all attributes, and add them to the list of already know attributes\n\n          let attributeGroup = {};\n          if (aGroup.hasAttribute('ref')) {\n            // we do have a reffed group\n            attributeGroup = this.getSchema().getReferencedNode('attributeGroup', aGroup.getAttribute('ref'));\n          } else {\n            attributeGroup = aGroup;\n          }\n\n          Array.from(attributeGroup.querySelectorAll(':scope > attribute')).forEach(child => {\n            attributes.push(child);\n          });\n        });\n\n        // convert all allowed attributes to a more object-oriented approach\n        attributes.forEach(attr => {\n          const attribute = new cv.ui.manager.model.schema.Attribute(attr, this.getSchema());\n          allowedAttributes[attribute.getName()] = attribute;\n        });\n\n        this.__allowedAttributes = allowedAttributes;\n      }\n      return this.__allowedAttributes;\n    },\n\n    /**\n     * are this elements children sortable? this is not the case if a sequence is used, e.g.\n     *\n     * @return  boolean     are children sortable?\n     */\n    areChildrenSortable: function () {\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping === undefined) {\n        return true;\n      }\n\n      // the inverse of \"do the elements have a given order?\"\n      return !allowedContent._grouping.getElementsHaveOrder();\n    },\n\n    /**\n     * get a list of required elements.\n     * if an element is required multiple times, it is listed multiple times\n     *\n     * @return  array   list of required elements\n     */\n    getRequiredElements: function () {\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping !== undefined) {\n        // we do have a grouping as a child\n        return allowedContent._grouping.getRequiredElements();\n      }\n\n      // there is no grouping, hence no elements defined as children\n      return [];\n    },\n\n    /**\n     * get a list of all allowed elements for this element\n     * @param excludeComment\n     * @return  object  list of SchemaElement-elements, key is the name\n     */\n    getAllowedElements: function (excludeComment) {\n      const allowedContent = this.getAllowedContent();\n\n      const allowedElements = {};\n      if (allowedContent._grouping !== undefined) {\n        Object.assign(allowedElements, allowedContent._grouping.getAllowedElements());\n      }\n\n      let textOnly = false;\n      if (this.isMixed()) {\n        // mixed elements are allowed to have #text-nodes\n        allowedElements['#text'] = this.getSchema().getTextNodeSchemaElement();\n      } else if (allowedContent._text && allowedContent._grouping === undefined) {\n        // text only\n        allowedElements['#text'] = allowedContent._text;\n        textOnly = true;\n      }\n\n      if (!textOnly && !excludeComment) {\n        // although its basically allowed to add comments in a text-only content, we do not allow it\n        allowedElements['#comment'] = this.getSchema().getCommentNodeSchemaElement();\n      }\n\n      return allowedElements;\n    },\n\n    /**\n     * get the sorting of the allowed elements.\n     *\n     * @return  object              list of allowed elements, with their sort-number as value\n     */\n    getAllowedElementsSorting: function () {\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping !== undefined) {\n        return allowedContent._grouping.getAllowedElementsSorting();\n      }\n\n      return undefined;\n    },\n\n    getFirstLevelElementSorting: function () {\n      const allowedSorting = this.getAllowedElementsSorting();\n      if (allowedSorting) {\n        // we only care about the first level here\n        Object.keys(allowedSorting).forEach(name => {\n          let sort = allowedSorting[name];\n          if (typeof sort === 'string') {\n            sort = parseInt(sort.split('.')[0]);\n          }\n          allowedSorting[name] = sort;\n        });\n      }\n      return allowedSorting;\n    },\n\n    /**\n     * get the bounds for this elements children (as defined by a choice)\n     *\n     * @return  object  bounds ({min: x, max: y})\n     */\n    getChildBounds: function () {\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping === undefined) {\n        // no choice = no idea about bounds\n        return undefined;\n      }\n\n      if (allowedContent._grouping.hasMultiLevelBounds() === true) {\n        // if our choice has sub-choices, then we have not fucking clue about bounds (or we can not process them)\n        return undefined;\n      }\n\n      return allowedContent._grouping.getBounds();\n    },\n\n    /**\n     * get the bounds for a specific element-name\n     * will go through all of the groupings-tree to find out, just how many elements of this may appear\n     *\n     * @param   childName   string  name of the child-to-be\n     * @return  object              {min: x, max: y}\n     */\n    getBoundsForElementName: function (childName) {\n      const allowedContent = this.getAllowedContent();\n\n      return allowedContent._grouping.getBoundsForElementName(childName);\n    },\n\n    /**\n     * check if a text-only-node is allowed ...\n     *\n     * @return  boolean\n     */\n    isTextContentAllowed: function () {\n      if (this.isMixed()) {\n        // mixed means that we allow for text-content\n        return true;\n      }\n\n      // first, get a list of allowed content (don't worry, it's cached)\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._text !== undefined && allowedContent._text !== false) {\n        // if _text is defined and there, we assume that text-content is allowed\n        return true;\n      }\n\n      // had no reason to allow text-content, so gtfoml!\n      return false;\n    },\n\n    isTextContentRequired: function () {\n      if (this.isTextContentAllowed()) {\n        return !this.isMixed() && !this.getAllowedContent()._text.isValueValid('');\n      }\n      return false;\n    },\n\n    /**\n     * check if an element (specified by its name) is allowed as one of our immediate children\n     * Goes recursive if we have choices.\n     *\n     * @param   child   string  name of the element we want to check\n     * @return  boolean         is this element allowed?\n     */\n    isChildElementAllowed: function (child) {\n      if (child === '#text' || child === '#cdata-section') {\n        // text-nodes are somewhat special :)\n        return this.isTextContentAllowed();\n      } else if (child === '#comment') {\n        return true;\n      }\n\n      // first, get a list of allowed content (don't worry, it's cached)\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping === undefined) {\n        // when there is no choice, then there is no allowed element\n        return false;\n      } \n        // see, if this child is allowed with our choice\n        return allowedContent._grouping.isElementAllowed(child);\n    },\n\n\n    /**\n     * get the SchemaElement-object for a certain element-name.\n     * May return undefined if no element is found, so you might be interested in checking isElementAllowed beforehand.\n     *\n     * @param   elementName string  name of the element to find the SchemaElement for\n     * @return  object              SchemaElement-object, or undefined if none is found\n     */\n    getSchemaElementForElementName: function (elementName) {\n      // first, get a list of allowed content (don't worry, it's cached)\n      const allowedContent = this.getAllowedContent();\n\n      if (elementName === '#text' || elementName === '#cdata-section') {\n        // no special handling for mixed nodes, they do have a #text-SchemaElement already!\n        // text-nodes may be allowed. we will see ...\n        if (this.isTextContentAllowed() === false) {\n          return undefined;\n        }\n\n        if (!this.__textNodeSchemaElement) {\n          const tmpXML = this.getSchema().getSchemaDOM().createElement('element');\n          tmpXML.setAttribute('name', '#text');\n          tmpXML.setAttribute('type', 'xsd:string');\n          this.__textNodeSchemaElement = new cv.ui.manager.model.schema.Element(tmpXML, this.getSchema());\n          if (allowedContent._text) {\n            this.__textNodeSchemaElement.getAllowedContent()._text = allowedContent._text;\n          } else if (this.isMixed()) {\n            this.__textNodeSchemaElement.getAllowedContent._text = this.getSchema().getTextNodeSchemaElement();\n          }\n        }\n        return this.__textNodeSchemaElement;\n      } else if (elementName === '#comment') {\n        // comments are always allowed\n        return this.getSchema().getCommentNodeSchemaElement();\n      }\n\n      if (allowedContent._grouping === undefined) {\n        // when there is no choice, then there is no allowed element\n        return undefined;\n      }\n\n      // go over our choice, if the element is allowed with it\n      if (allowedContent._grouping.isElementAllowed(elementName)) {\n        // only look in this tree, if the element is allowed there.\n        return allowedContent._grouping.getSchemaElementForElementName(elementName);\n      }\n\n      return undefined;\n    },\n\n    /**\n     * return the DOM this Schema is based on\n     *\n     * @return  object  DOM of $xsd\n     */\n    getSchemaDOM: function () {\n      return this.getSchema().getSchemaDOM();\n    },\n\n    /**\n     * check if a given value is valid for this element\n     *\n     * @param   value   string  value to check\n     * @return  boolean         is it valid?\n     */\n    isValueValid: function (value) {\n      if (this.isTextContentAllowed() === false) {\n        // if no text-content is allowed, then it can not be valid\n        return false;\n      }\n\n      if (this.isMixed()) {\n        // mixed is always good!\n        return true;\n      }\n\n      const allowedContent = this.getAllowedContent();\n\n      return allowedContent._text.isValueValid(value);\n    },\n\n    /**\n     * create and retrieve the part of a regular expression which describes this very element\n     *\n     * @param   separator   string  the string used to separate different elements, e.g. ';'\n     * @param   nocapture   bool    when set to true non capturing groups are used\n     * @return  string\n     */\n    getRegex: function (separator, nocapture) {\n      if (typeof separator === 'undefined' || separator === undefined) {\n        // default to an empty string\n        separator = '';\n      }\n\n      let regexString = '(';\n      if (nocapture) {\n        regexString += '?:';\n      }\n\n      // start with the name of the element\n      regexString += this.getName() + separator + ')';\n\n      // append bounds\n      let boundsMin = '';\n      let boundsMax = '';\n      const bounds = this.getBounds();\n      if (bounds.min !== undefined) {\n        boundsMin = bounds.min;\n      }\n\n      if (bounds.max !== undefined) {\n        if (bounds.max !== Number.POSITIVE_INFINITY) {\n          boundsMax = bounds.max;\n        }\n      }\n\n      if (boundsMin !== '' || boundsMax !== '') {\n        // append bounds to the regex-string\n        regexString += '{' + boundsMin + ',' + boundsMax + '}';\n      }\n\n      // and thats all\n      return regexString;\n    },\n\n    /**\n     * create a full-blown regular expression that describes this elements immediate children\n     * @param separator   string  the string used to separate different elements, e.g. ';'\n     * @param nocapture\n     * @return  string              the regular expression\n     */\n    getChildrenRegex: function(separator, nocapture) {\n      if (typeof separator == 'undefined' || separator === undefined) {\n        // default to an empty string\n        separator = '';\n      }\n\n      const allowedContent = this.getAllowedContent();\n\n      if (allowedContent._grouping === undefined) {\n        // not really something to match\n        return '^';\n      }\n\n      return allowedContent._grouping.getRegex(separator, nocapture);\n    }\n  },\n\n  /*\n  ***********************************************\n    DESTRUCTOR\n  ***********************************************\n  */\n  destruct: function () {\n    this._disposeMap('__allowedAttributes');\n    this._disposeMap('__allowedContent');\n    this._disposeObjects('__textNodeSchemaElement');\n  }\n});\n"
  ]
}