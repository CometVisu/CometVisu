{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/core/Assert.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__logError",
    "__fail",
    "comment",
    "msgvarargs",
    "msg",
    "i",
    "l",
    "arguments",
    "length",
    "__toString",
    "undefined",
    "fullComment",
    "errorMsg",
    "Class",
    "isDefined",
    "err",
    "core",
    "AssertionError",
    "error",
    "getStackTrace",
    "Error",
    "value",
    "stringValue",
    "lang",
    "Type",
    "isArray",
    "Object",
    "toString",
    "Json",
    "stringify",
    "e",
    "assert",
    "condition",
    "fail",
    "compact",
    "assertTrue",
    "assertFalse",
    "assertEquals",
    "expected",
    "found",
    "assertNotEquals",
    "assertEqualsFloat",
    "assertNumber",
    "Number",
    "equals",
    "assertNotEqualsFloat",
    "assertIdentical",
    "assertNotIdentical",
    "assertNotUndefined",
    "assertUndefined",
    "assertNotNull",
    "assertNull",
    "assertJsonEquals",
    "assertMatch",
    "str",
    "re",
    "assertString",
    "isRegExp",
    "isString",
    "search",
    "assertArgumentsCount",
    "args",
    "minCount",
    "maxCount",
    "argCount",
    "assertEventFired",
    "obj",
    "event",
    "invokeFunc",
    "listenerFunc",
    "called",
    "listener",
    "call",
    "id",
    "addListener",
    "ex",
    "removeListenerById",
    "assertEventNotFired",
    "assertException",
    "callback",
    "exception",
    "assertInArray",
    "array",
    "indexOf",
    "assertNotInArray",
    "String",
    "format",
    "assertArrayEquals",
    "assertArray",
    "join",
    "assertKeyInMap",
    "map",
    "assertFunction",
    "isFunction",
    "assertFunctionOrAsyncFunction",
    "isFunctionOrAsyncFunction",
    "assertBoolean",
    "isBoolean",
    "isNumber",
    "isFinite",
    "assertPositiveNumber",
    "assertInteger",
    "assertPositiveInteger",
    "assertInRange",
    "min",
    "max",
    "assertObject",
    "isObject",
    "assertMap",
    "assertRegExp",
    "assertType",
    "type",
    "assertInstance",
    "clazz",
    "className",
    "classname",
    "assertInterface",
    "iface",
    "implementsInterface",
    "assertCssColor",
    "ColorUtil",
    "getByName",
    "expectedRgb",
    "stringToRgb",
    "valueRgb",
    "assertElement",
    "nodeType",
    "assertQxObject",
    "__isQxInstance",
    "assertQxWidget",
    "object",
    "constructor",
    "superclass",
    "Assert"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * A collection of assertions.\n *\n * These methods can be used to assert incoming parameters, return values, ...\n * If an assertion fails an {@link AssertionError} is thrown.\n *\n * Assertions are used in unit tests as well.\n *\n * @require(qx.lang.Type)\n * @ignore(qx.Class.*)\n */\nqx.Bootstrap.define(\"qx.core.Assert\",\n{\n  statics :\n  {\n    __logError : true,\n\n    /**\n     * Assert that the condition evaluates to <code>true</code>. An\n     * {@link AssertionError} is thrown if otherwise.\n     *\n     * @param comment {String} Message to be shown if the assertion fails. This\n     *    message is provided by the user.\n     * @param msgvarargs {var} any number of parts of a message to show if assertion\n     *                         triggers. Each will be converted to a string and all\n     *                         parts will be concatenated. E. g. instead of\n     *                         \"Got invalid value \" + this.__toString(val) + \"!!!!!\"\n     *                         use\n     *                         \"Got invalid value \", val, \"!!!!!\"\n     *                         (much better performance)\n     *\n     */\n    __fail : function(comment, msgvarargs)\n    {\n      // Build up message from message varargs. It's not really important\n      // how long this takes as it is done only when assertion is triggered\n      var msg = \"\";\n      for (var i=1, l=arguments.length; i<l; i++)\n      {\n        msg = msg + this.__toString(arguments[i] === undefined ? \"'undefined'\" : arguments[i]);\n      }\n\n      var fullComment = \"\";\n      if (msg) {\n        fullComment = comment + \": \" + msg;\n      } else {\n        fullComment = comment;\n      }\n      var errorMsg = \"Assertion error! \" + fullComment;\n\n      if (qx.Class && qx.Class.isDefined(\"qx.core.AssertionError\"))\n      {\n        var err = new qx.core.AssertionError(comment, msg);\n        if (this.__logError) {\n          qx.Bootstrap.error(errorMsg + \"\\n Stack trace: \\n\" + err.getStackTrace());\n        }\n        throw err;\n      }\n      else\n      {\n        if (this.__logError) {\n          qx.Bootstrap.error(errorMsg);\n        }\n        throw new Error(errorMsg);\n      }\n    },\n\n\n    /**\n     * Convert an unknown value to a string to display in error messages\n     *\n     * @param value {var} any value\n     * @return {String} a string representation of the value\n     */\n    __toString : function(value)\n    {\n      var stringValue;\n\n      if (value === null)\n      {\n        stringValue = \"null\";\n      }\n      else if (qx.lang.Type.isArray(value) && value.length > 10)\n      {\n        stringValue = \"Array[\" + value.length + \"]\";\n      } else if ((value instanceof Object) && (value.toString == null))\n      {\n        stringValue = qx.lang.Json.stringify(value, null, 2);\n      } else\n      {\n        try {\n          stringValue = value.toString();\n        } catch(e) {\n          stringValue = \"\";\n        }\n      }\n      return stringValue;\n    },\n\n\n    /**\n     * Assert that the condition evaluates to <code>true</code>.\n     *\n     * @param condition {var} Condition to check for. Must evaluate to\n     *    <code>true</code>.\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assert : function(condition, msg) {\n      condition == true || this.__fail(msg || \"\", \"Called assert with 'false'\");\n    },\n\n\n    /**\n     * Raise an {@link AssertionError}.\n     *\n     * @param msg {String} Message to be shown if the assertion fails.\n     * @param compact {Boolean?false} Show less verbose message. Default: false.\n     */\n    fail : function(msg, compact) {\n      var msgvarargs = compact ? \"\" : \"Called fail().\";\n      this.__fail(msg || \"\", msgvarargs);\n    },\n\n\n    /**\n     * Assert that the value is <code>true</code> (Identity check).\n     *\n     * @param value {Boolean} Condition to check for. Must be identical to\n     *    <code>true</code>.\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertTrue : function(value, msg) {\n      (value === true) || this.__fail(msg || \"\", \"Called assertTrue with '\", value, \"'\");\n    },\n\n\n    /**\n     * Assert that the value is <code>false</code> (Identity check).\n     *\n     * @param value {Boolean} Condition to check for. Must be identical to\n     *    <code>false</code>.\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertFalse : function(value, msg) {\n      (value === false) || this.__fail(msg || \"\", \"Called assertFalse with '\", value, \"'\");\n    },\n\n\n    /**\n     * Assert that both values are equal. (Uses the equality operator\n     * <code>==</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertEquals : function(expected, found, msg)\n    {\n      expected == found || this.__fail(\n        msg || \"\",\n        \"Expected '\", expected,\n        \"' but found '\", found, \"'!\"\n      );\n    },\n\n    /**\n     * Assert that both values are not equal. (Uses the not equality operator\n     * <code>!=</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotEquals : function(expected, found, msg)\n    {\n        expected != found || this.__fail(\n        msg || \"\",\n        \"Expected '\",expected,\n        \"' to be not equal with '\", found, \"'!\"\n      );\n    },\n\n    /**\n     * Assert that both float values are equal. This might be needed because\n     * of the natural floating point inaccuracy of computers.\n     *\n     * @param expected {Float} Reference value\n     * @param found {Float} Found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertEqualsFloat : function(expected, found, msg)\n    {\n      this.assertNumber(expected);\n      this.assertNumber(found);\n\n      qx.lang.Number.equals(expected, found) ||\n        this.__fail(msg || \"\", \"Expected '\", expected, \"' to be equal with '\",\n        found, \"'!\"\n      );\n    },\n\n    /**\n     * Assert that both float values are not equal. This might be needed\n     * because of the natural floating point inaccuracy of computers.\n     *\n     * @param expected {Float} Reference value\n     * @param found {Float} Found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotEqualsFloat : function(expected, found, msg)\n    {\n      this.assertNumber(expected);\n      this.assertNumber(found);\n\n      !qx.lang.Number.equals(expected, found) ||\n        this.__fail(msg || \"\", \"Expected '\", expected,\n        \"' to be not equal with '\", found, \"'!\"\n      );\n    },\n\n    /**\n     * Assert that both values are identical. (Uses the identity operator\n     * <code>===</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertIdentical : function(expected, found, msg)\n    {\n      expected === found || this.__fail(\n        msg || \"\",\n        \"Expected '\", expected,\n        \"' (identical) but found '\", found, \"'!\"\n      );\n    },\n\n\n    /**\n     * Assert that both values are not identical. (Uses the not identity operator\n     * <code>!==</code>.)\n     *\n     * @param expected {var} Reference value\n     * @param found {var} found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotIdentical : function(expected, found, msg)\n    {\n      expected !== found || this.__fail(\n        msg || \"\",\n        \"Expected '\", expected,\n        \"' to be not identical with '\", found, \"'!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is not <code>undefined</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotUndefined : function(value, msg)\n    {\n      value !== undefined || this.__fail(\n        msg || \"\",\n        \"Expected value not to be undefined but found undefined!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is <code>undefined</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertUndefined : function(value, msg)\n    {\n      value === undefined || this.__fail(\n        msg || \"\",\n        \"Expected value to be undefined but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is not <code>null</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNotNull : function(value, msg)\n    {\n      value !== null || this.__fail(\n        msg || \"\",\n        \"Expected value not to be null but found null!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is <code>null</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNull : function(value, msg)\n    {\n      value === null || this.__fail(\n        msg || \"\",\n        \"Expected value to be null but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n     * Assert that the first two arguments are equal, when serialized into\n     * JSON.\n     *\n     * @param expected {var} The the expected value\n     * @param found {var} The found value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertJsonEquals : function(expected, found, msg) {\n      this.assertEquals(\n        qx.lang.Json.stringify(expected),\n        qx.lang.Json.stringify(found),\n        msg\n      );\n    },\n\n\n    /**\n     * Assert that the given string matches the regular expression\n     *\n     * @param str {String} String, which should match the regular expression\n     * @param re {String|RegExp} Regular expression to match\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertMatch : function(str, re, msg)\n    {\n      this.assertString(str);\n      this.assert(\n        qx.lang.Type.isRegExp(re) || qx.lang.Type.isString(re),\n        \"The parameter 're' must be a string or a regular expression.\"\n      );\n      str.search(re) >= 0 || this.__fail(\n        msg || \"\",\n        \"The String '\", str, \"' does not match the regular expression '\", re.toString(), \"'!\"\n      );\n    },\n\n\n    /**\n     * Assert that the number of arguments is within the given range\n     *\n     * @param args {arguments} The <code>arguments<code> variable of a function\n     * @param minCount {Integer} Minimal number of arguments\n     * @param maxCount {Integer} Maximum number of arguments\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertArgumentsCount : function(args, minCount, maxCount, msg)\n    {\n      var argCount = args.length;\n      (argCount >= minCount && argCount <= maxCount) || this.__fail(\n        msg || \"\",\n        \"Wrong number of arguments given. Expected '\", minCount, \"' to '\",\n        maxCount, \"' arguments but found '\", argCount, \"' arguments.\"\n      );\n    },\n\n\n    /**\n     * Assert that an event is fired.\n     *\n     * @param obj {Object} The object on which the event should be fired.\n     * @param event {String} The event which should be fired.\n     * @param invokeFunc {Function} The function which will be invoked and which\n     *   fires the event.\n     * @param listenerFunc {Function?null} The function which will be invoked in the\n     *   listener. The function receives one parameter which is the event.\n     * @param msg {String?\"\"} Message to be shows if the assertion fails.\n     */\n    assertEventFired : function(obj, event, invokeFunc, listenerFunc, msg)\n    {\n      var called = false;\n      var listener = function(e)\n      {\n        if (listenerFunc) {\n          listenerFunc.call(obj, e);\n        }\n        called = true;\n      };\n\n      var id;\n      try {\n        id = obj.addListener(event, listener, obj);\n        invokeFunc.call(obj);\n      } catch (ex) {\n        throw ex;\n      } finally {\n        try {\n          obj.removeListenerById(id);\n        } catch (ex) { /* ignore */ }\n      }\n\n      called === true || this.__fail(msg || \"\", \"Event (\", event, \") not fired.\");\n    },\n\n\n    /**\n     * Assert that an event is not fired.\n     *\n     * @param obj {Object} The object on which the event should be fired.\n     * @param event {String} The event which should be fired.\n     * @param invokeFunc {Function} The function which will be invoked and which\n     *   should not fire the event.\n     * @param msg {String?} Message to be shows if the assertion fails.\n     */\n    assertEventNotFired : function(obj, event, invokeFunc, msg)\n    {\n      var called = false;\n      var listener = function(e) {\n        called = true;\n      };\n      var id = obj.addListener(event, listener, obj);\n\n      invokeFunc.call();\n      called === false || this.__fail(msg || \"\", \"Event (\", event, \") was fired.\");\n\n      obj.removeListenerById(id);\n    },\n\n\n    /**\n     * Asserts that the callback raises a matching exception.\n     *\n     * @param callback {Function} function to check\n     * @param exception {Error?Error} Expected constructor of the exception.\n     *   The assertion fails if the raised exception is not an instance of the\n     *   parameter.\n     * @param re {String|RegExp} The assertion fails if the error message does\n     *   not match this parameter\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertException : function(callback, exception, re, msg)\n    {\n      var exception = exception || Error;\n      var error;\n\n      try {\n        this.__logError = false;\n        callback();\n      } catch(ex) {\n        error = ex;\n      } finally {\n        this.__logError = true;\n      }\n\n      if (error == null) {\n        this.__fail(msg || \"\", \"The function did not raise an exception!\");\n      }\n\n      error instanceof exception || this.__fail(msg || \"\",\n        \"The raised exception does not have the expected type! \",\n        exception , \" != \", error);\n\n      if (re) {\n        this.assertMatch(error.toString(), re, msg);\n      }\n    },\n\n\n    /**\n     * Assert that the value is an item in the given array.\n     *\n     * @param value {var} Value to check\n     * @param array {Array} List of valid values\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInArray : function(value, array, msg)\n    {\n      array.indexOf(value) !== -1 || this.__fail(\n        msg || \"\",\n        \"The value '\", value,\n        \"' must have any of the values defined in the array '\",\n        array, \"'\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is NOT an item in the given array\n     *\n     * @param value {var} Value to check\n     * @param array {Array} List of values\n     * @param msg {String?} Message to be shown if the assertion fails\n     */\n    assertNotInArray : function(value, array, msg) {\n      array.indexOf(value) === -1 || this.__fail(\n          msg || \"\",\n          qx.lang.String.format(\n            \"The value '%1' must not have any of the values defined in the array '%2'\",\n            [value, array]\n          )\n        );\n    },\n\n\n    /**\n     * Assert that both array have identical array items.\n     *\n     * @param expected {Array} The expected array\n     * @param found {Array} The found array\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertArrayEquals : function(expected, found, msg)\n    {\n      this.assertArray(expected, msg);\n      this.assertArray(found, msg);\n\n      msg = msg ||\n        \"Expected [\" + expected.join(\", \") +\n        \"], but found [\" + found.join(\", \") + \"]\";\n\n      if (expected.length !== found.length) {\n        this.fail(msg, true);\n      }\n\n      for (var i=0; i<expected.length; i++) {\n        if (expected[i] !== found[i]) {\n          this.fail(msg, true);\n        }\n      }\n    },\n\n\n    /**\n     * Assert that the value is a key in the given map.\n     *\n     * @param value {var} Value to check\n     * @param map {Map} Map, where the keys represent the valid values\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertKeyInMap : function(value, map, msg)\n    {\n      map[value] !== undefined || this.__fail(\n        msg || \"\",\n        \"The value '\", value, \"' must must be a key of the map '\",\n        map, \"'\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is a function.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertFunction : function(value, msg)\n    {\n      qx.lang.Type.isFunction(value) || this.__fail(\n        msg || \"\",\n        \"Expected value to be typeof function but found \", value, \"!\"\n      );\n    },\n\n    /**\n     * Assert that the value is a function or an async function.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertFunctionOrAsyncFunction : function(value, msg)\n    {\n      qx.lang.Type.isFunctionOrAsyncFunction(value) || this.__fail(\n        msg || \"\",\n        \"Expected value to be typeof function or typeof async function but found \", value, \"!\"\n      );\n    },\n\n    /**\n     * Assert that the value is a string.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertString : function(value, msg) {\n      qx.lang.Type.isString(value) || this.__fail(\n        msg || \"\",\n        \"Expected value to be a string but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is a boolean.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertBoolean : function(value, msg)\n    {\n      qx.lang.Type.isBoolean(value) || this.__fail(\n        msg || \"\",\n        \"Expected value to be a boolean but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is a number.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertNumber : function(value, msg)\n    {\n      (qx.lang.Type.isNumber(value) && isFinite(value)) || this.__fail(\n        msg || \"\",\n        \"Expected value to be a number but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is a number >= 0.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertPositiveNumber : function(value, msg)\n    {\n      (qx.lang.Type.isNumber(value) && isFinite(value) && value >= 0) || this.__fail(\n        msg || \"\",\n        \"Expected value to be a number >= 0 but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is an integer.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInteger : function(value, msg)\n    {\n      (qx.lang.Type.isNumber(value) && isFinite(value) && value % 1 === 0) || this.__fail(\n        msg || \"\",\n        \"Expected value to be an integer but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is an integer >= 0.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertPositiveInteger : function(value, msg)\n    {\n      var condition = (\n        qx.lang.Type.isNumber(value) &&\n        isFinite(value) &&\n        value % 1 === 0 &&\n        value >= 0\n      );\n      condition || this.__fail(\n        msg || \"\",\n        \"Expected value to be an integer >= 0 but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is inside the given range.\n     *\n     * @param value {var} Value to check\n     * @param min {Number} lower bound\n     * @param max {Number} upper bound\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInRange : function(value, min, max, msg)\n    {\n      (value >= min && value <= max) || this.__fail(\n        msg || \"\",\n        qx.lang.String.format(\"Expected value '%1' to be in the range '%2'..'%3'!\", [value, min, max])\n      );\n    },\n\n\n    /**\n     * Assert that the value is an object.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertObject : function(value, msg)\n    {\n      var condition = value !== null &&\n        (qx.lang.Type.isObject(value) || typeof value === \"object\");\n      condition || this.__fail(\n        msg || \"\",\n        \"Expected value to be typeof object but found \", (value), \"!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is an array.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertArray : function(value, msg)\n    {\n      qx.lang.Type.isArray(value) || this.__fail(\n        msg || \"\",\n        \"Expected value to be an array but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is a map either created using <code>new Object</code>\n     * or by using the object literal notation <code>{ ... }</code>.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertMap : function(value, msg)\n    {\n      qx.lang.Type.isObject(value) || this.__fail(\n        msg || \"\",\n        \"Expected value to be a map but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n    * Assert that the value is a regular expression.\n    *\n    * @param value {var} Value to check\n    * @param msg {String?} Message to be shown if the assertion fails.\n    */\n   assertRegExp : function(value, msg)\n   {\n     qx.lang.Type.isRegExp(value) || this.__fail(\n       msg || \"\",\n       \"Expected value to be a regular expression but found \", value, \"!\"\n     );\n   },\n\n\n    /**\n     * Assert that the value has the given type using the <code>typeof</code>\n     * operator. Because the type is not always what it is supposed to be it is\n     * better to use more explicit checks like {@link #assertString} or\n     * {@link #assertArray}.\n     *\n     * @param value {var} Value to check\n     * @param type {String} expected type of the value\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertType : function(value, type, msg)\n    {\n      this.assertString(type, \"Invalid argument 'type'\");\n\n      typeof(value) === type || this.__fail(\n        msg || \"\",\n        \"Expected value to be typeof '\", type, \"' but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is an instance of the given class.\n     *\n     * @param value {var} Value to check\n     * @param clazz {Class} The value must be an instance of this class\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInstance : function(value, clazz, msg)\n    {\n      var className = clazz.classname || clazz + \"\";\n\n      value instanceof clazz || this.__fail(\n        msg || \"\",\n        \"Expected value to be instanceof '\", className, \"' but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value implements the given interface.\n     *\n     * @param value {var} Value to check\n     * @param iface {Class} The value must implement this interface\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertInterface : function(value, iface, msg) {\n      qx.Class && qx.Class.implementsInterface(value, iface) || this.__fail(\n        msg || \"\",\n        \"Expected object '\", value, \"' to implement the interface '\", iface, \"'!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value represents the given CSS color value. This method\n     * parses the color strings and compares the RGB values. It is able to\n     * parse values supported by {@link qx.util.ColorUtil#stringToRgb}.\n     *\n     *  @param expected {String} The expected color\n     *  @param value {String} The value to check\n     *  @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertCssColor : function(expected, value, msg)\n    {\n      var ColorUtil = qx.Class ? qx.Class.getByName(\"qx.util.ColorUtil\") : null;\n      if (!ColorUtil) {\n        throw new Error(\"qx.util.ColorUtil not available! Your code must have a dependency on 'qx.util.ColorUtil'\");\n      }\n\n      var expectedRgb = ColorUtil.stringToRgb(expected);\n      try\n      {\n        var valueRgb = ColorUtil.stringToRgb(value);\n      }\n      catch (ex)\n      {\n        this.__fail(\n          msg || \"\",\n          \"Expected value to be the CSS color '\", expected,\n          \"' (rgb(\", expectedRgb.join(\",\"),\n          \")), but found value '\", value, \"', which cannot be converted to a CSS color!\"\n        );\n      }\n\n      var condition = expectedRgb[0] == valueRgb[0] && expectedRgb[1] == valueRgb[1] && expectedRgb[2] == valueRgb[2];\n      condition || this.__fail(\n        msg || \"\",\n          \"Expected value to be the CSS color '\", expectedRgb,\n          \"' (rgb(\", expectedRgb.join(\",\"),\n          \")), but found value '\", value,\n          \"' (rgb(\", valueRgb.join(\",\"), \"))!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is a DOM element.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertElement : function(value, msg)\n    {\n      // see qx.dom.Node.isElement\n      !!(value && value.nodeType === 1) || this.__fail(\n        msg || \"\",\n        \"Expected value to be a DOM element but found  '\", value, \"'!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is an instance of {@link qx.core.Object}.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertQxObject : function(value, msg)\n    {\n      this.__isQxInstance(value, \"qx.core.Object\") || this.__fail(\n        msg || \"\",\n        \"Expected value to be a qooxdoo object but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n     * Assert that the value is an instance of {@link qx.ui.core.Widget}.\n     *\n     * @param value {var} Value to check\n     * @param msg {String?} Message to be shown if the assertion fails.\n     */\n    assertQxWidget : function(value, msg)\n    {\n      this.__isQxInstance(value, \"qx.ui.core.Widget\") || this.__fail(\n        msg || \"\",\n        \"Expected value to be a qooxdoo widget but found \", value, \"!\"\n      );\n    },\n\n\n    /**\n     * Internal helper for checking the instance of a qooxdoo object using the\n     * classname.\n     *\n     * @param object {var} The object to check.\n     * @param classname {String} The classname of the class as string.\n     * @return {Boolean} <code>true</code> if the object is an instance of the\n     * class\n     */\n    __isQxInstance : function(object, classname)\n    {\n      if (!object) {\n        return false;\n      }\n      var clazz = object.constructor;\n      while(clazz) {\n        if (clazz.classname === classname) {\n          return true;\n        }\n        clazz = clazz.superclass;\n      }\n      return false;\n    }\n  }\n});\n"
  ]
}