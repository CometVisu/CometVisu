{
  "version": 3,
  "sources": [
    "/home/travis/build/CometVisu/CometVisu/node_modules/@qooxdoo/compiler/node_modules/@qooxdoo/framework/source/class/qx/util/TimerManager.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "type",
    "statics",
    "__timerQueue",
    "__timerData",
    "__timerId",
    "members",
    "__timerListenerActive",
    "start",
    "callback",
    "recurTime",
    "context",
    "userData",
    "initialTime",
    "expireAt",
    "Date",
    "getTime",
    "__insertNewTimer",
    "stop",
    "timerId",
    "timerQueue",
    "length",
    "i",
    "splice",
    "event",
    "Idle",
    "getInstance",
    "removeListener",
    "__processQueue",
    "timerData",
    "push",
    "addListener",
    "timeNow",
    "expiredTimerId",
    "shift",
    "expiredTimerData",
    "call",
    "now",
    "util",
    "TimerManager"
  ],
  "mappings": ";;;;;;;;;;;;;AAAAA,EAAAA,EAAE,CAACC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,EAAAA,EAAE,CAACI,KAAH,CAASC,MAAT,CAAgB,sBAAhB,EACA;AACEC,IAAAA,MAAM,EAAGN,EAAE,CAACO,IAAH,CAAQC,MADnB;AAEEC,IAAAA,IAAI,EAAK,WAFX;AAIEC,IAAAA,OAAO,EACP;AACE;AACAC,MAAAA,SAAY,EAAG,EAFjB;;AAIE;AACAC,MAAAA,SAAW,EAAI,EALjB;;AAOE;AACAC,MAAAA,SAAS,EAAM;AARjB,KALF;AAgBEC,IAAAA,OAAO,EACP;AACE;AACAC,MAAAA,SAAqB,EAAG,KAF1B;;AAIE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,MAAAA,KAAK,EAAG,eAASC,QAAT,EAAmBC,SAAnB,EAA8BC,OAA9B,EAAuCC,QAAvC,EAAiDC,WAAjD,EACR;AACE;AACA,YAAI,OAAOA,WAAP,IAAsB,QAA1B,EACA;AACEA,UAAAA,WAAW,GAAGH,SAAS,IAAI,CAA3B;AACD;;AAED,YAAII,QAAQ,GAAI,IAAIC,IAAJ,EAAD,CAAaC,OAAb,KAAyBH,WAAxC,CAPF,CASE;AACA;;AACA,6BAAqBT,SAArB,CA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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2008 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * Timer manipulation for handling multiple timed callbacks with the use of\n * only a single native timer object.\n *\n * Use of these timers is via the methods start() and stop().  Examples:\n * <pre class='javascript'>\n * var timer = qx.util.TimerManager.getInstance();\n *\n * // Start a 5-second recurrent timer.\n * // Note that the first expiration is after 3 seconds\n * // (last parameter is 3000) but each subsequent expiration is\n * // at 5 second intervals.\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"Recurrent 5-second timer: \" + timerId);\n *             },\n *             5000,\n *             this,\n *             null,\n *             3000);\n *\n * // Start a 1-second one-shot timer\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"One-shot 1-second timer: \" + timerId);\n *             },\n *             0,\n *             this,\n *             null,\n *             1000);\n *\n * // Start a 2-second recurrent timer that stops itself after\n * // three iterations\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"Recurrent 2-second timer with limit 3:\" +\n *                          timerId);\n *               if (++userData.count == 3)\n *               {\n *                 this.debug(\"Stopping recurrent 2-second timer\");\n *                 timer.stop(timerId);\n *               }\n *             },\n *             2000,\n *             this,\n *             { count : 0 });\n *\n * // Start an immediate one-shot timer\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"Immediate one-shot timer: \" + timerId);\n *             });\n * </pre>\n */\nqx.Class.define(\"qx.util.TimerManager\",\n{\n  extend : qx.core.Object,\n  type   : \"singleton\",\n\n  statics :\n  {\n    /** Time-ordered queue of timers */\n    __timerQueue : [],\n\n    /** Saved data for each timer */\n    __timerData  : {},\n\n    /** Next timer id value is determined by incrementing this */\n    __timerId    : 0\n  },\n\n  members :\n  {\n    /** Whether we're currently listening on the interval timer event */\n    __timerListenerActive : false,\n\n    /**\n     * Start a new timer\n     *\n     * @param callback {Function}\n     *   Function to be called upon expiration of the timer.  The function is\n     *   passed these parameters:\n     *   <dl>\n     *     <dt>userData</dt>\n     *       <dd>The user data provided to the start() method</dd>\n     *     <dt>timerId</dt>\n     *       <dd>The timer id, as was returned by the start() method</dd>\n     *   </dl>\n     *\n     * @param recurTime {Integer|null}\n     *   If null, the timer will not recur.  Once the callback function\n     *   returns the first time, the timer will be removed from the timer\n     *   queue.  If non-null, upon return from the callback function, the\n     *   timer will be reset to this number of milliseconds.\n     *\n     * @param context {qx.core.Object|null}\n     *   Context (this) the callback function is called with.  If not\n     *   provided, this Timer singleton object is used.\n     *\n     * @param userData {var}\n     *   Data which is passed to the callback function upon timer expiry\n     *\n     * @param initialTime {Integer|null}\n     *   Milliseconds before the callback function is called the very first\n     *   time.  If not specified and recurTime is specified, then recurTime\n     *   will be used as initialTime; otherwise initialTime will default\n     *   to zero.\n     *\n     * @return {Integer}\n     *   The timer id of this unique timer.  It may be provided to the stop()\n     *   method to cancel a timer before expiration.\n     */\n    start : function(callback, recurTime, context, userData, initialTime)\n    {\n      // Get the expiration time for this timer\n      if (typeof initialTime != \"number\")\n      {\n        initialTime = recurTime || 0;\n      }\n\n      var expireAt = (new Date()).getTime() + initialTime;\n\n      // Save the callback, user data, and requested recurrency time as well\n      // as the current expiry time\n      this.self(arguments).__timerData[++this.self(arguments).__timerId] =\n        {\n          callback  : callback,\n          userData  : userData || null,\n          expireAt  : expireAt,\n          recurTime : recurTime,\n          context   : context || this\n        };\n\n      // Insert this new timer on the time-ordered timer queue\n      this.__insertNewTimer(expireAt, this.self(arguments).__timerId);\n\n      // Give 'em the timer id\n      return this.self(arguments).__timerId;\n    },\n\n    /**\n     * Stop a running timer\n     *\n     * @param timerId {Integer}\n     *   A timer id previously returned by start()\n     */\n    stop : function(timerId)\n    {\n      // Find this timer id in the time-ordered list\n      var timerQueue = this.self(arguments).__timerQueue;\n      var length = timerQueue.length;\n      for (var i = 0; i < length; i++)\n      {\n        // Is this the one we're looking for?\n        if (timerQueue[i] == timerId)\n        {\n          // Yup.  Remove it.\n          timerQueue.splice(i, 1);\n\n          // We found it so no need to continue looping through the queue\n          break;\n        }\n      }\n\n      // Ensure it's gone from the timer data map as well\n      delete this.self(arguments).__timerData[timerId];\n\n      // If there are no more timers pending...\n      if (timerQueue.length == 0 && this.__timerListenerActive)\n      {\n        // ... then stop listening for the periodic timer\n        qx.event.Idle.getInstance().removeListener(\"interval\",\n                                                   this.__processQueue,\n                                                   this);\n        this.__timerListenerActive = false;\n      }\n    },\n\n    /**\n     * Insert a timer on the time-ordered list of active timers.\n     *\n     * @param expireAt {Integer}\n     *   Milliseconds from now when this timer should expire\n     *\n     * @param timerId {Integer}\n     *   Id of the timer to be time-ordered\n     *\n     */\n    __insertNewTimer : function(expireAt, timerId)\n    {\n      // The timer queue is time-ordered so that processing timers need not\n      // search the queue; rather, it can simply look at the first element\n      // and if not yet ready to fire, be done.  Search the queue for the\n      // appropriate place to insert this timer.\n      var timerQueue = this.self(arguments).__timerQueue;\n      var timerData = this.self(arguments).__timerData;\n      var length = timerQueue.length;\n      for (var i = 0; i < length; i++)\n      {\n        // Have we reached a later time?\n        if (timerData[timerQueue[i]].expireAt > expireAt)\n        {\n          // Yup.  Insert our new timer id before this element.\n          timerQueue.splice(i, 0, timerId);\n\n          // No need to loop through the queue further\n          break;\n        }\n      }\n\n      // Did we find someplace in the middle of the queue for it?\n      if (timerQueue.length == length)\n      {\n        // Nope.  Insert it at the end.\n        timerQueue.push(timerId);\n      }\n\n      // If this is the first element on the queue...\n      if (! this.__timerListenerActive)\n      {\n        // ... then start listening for the periodic timer.\n        qx.event.Idle.getInstance().addListener(\"interval\",\n                                                this.__processQueue,\n                                                this);\n        this.__timerListenerActive = true;\n      }\n\n    },\n\n    /**\n     * Process the queue of timers.  Call the registered callback function for\n     * any timer which has expired.  If the timer is marked as recurrent, the\n     * timer is restarted with the recurrent timeout following completion of\n     * the callback function.\n     *\n     */\n    __processQueue : function()\n    {\n      // Get the current time\n      var timeNow = (new Date()).getTime();\n\n      // While there are timer elements that need processing...\n      var timerQueue = this.self(arguments).__timerQueue;\n      var timerData = this.self(arguments).__timerData;\n\n      // Is it time to process the first timer element yet?\n      while (timerQueue.length > 0 &&\n             timerData[timerQueue[0]].expireAt <= timeNow)\n      {\n        // Yup.  Do it.  First, remove element from the queue.\n        var expiredTimerId = timerQueue.shift();\n\n        // Call the handler function for this timer\n        var expiredTimerData = timerData[expiredTimerId];\n        expiredTimerData.callback.call(expiredTimerData.context,\n                                       expiredTimerData.userData,\n                                       expiredTimerId);\n\n        // If this is a recurrent timer which wasn't stopped by the callback...\n        if (expiredTimerData.recurTime && timerData[expiredTimerId])\n        {\n          // ... then restart it.\n          var now = (new Date()).getTime();\n          expiredTimerData.expireAt = now + expiredTimerData.recurTime;\n\n          // Insert this timer back on the time-ordered timer queue\n          this.__insertNewTimer(expiredTimerData.expireAt, expiredTimerId);\n        }\n        else\n        {\n          // If it's not a recurrent timer, we can purge its data too.\n          delete timerData[expiredTimerId];\n        }\n      }\n\n      // If there are no more timers pending...\n      if (timerQueue.length == 0 && this.__timerListenerActive)\n      {\n        // ... then stop listening for the periodic timer\n        qx.event.Idle.getInstance().removeListener(\"interval\",\n                                                   this.__processQueue,\n                                                   this);\n        this.__timerListenerActive = false;\n      }\n    }\n  }\n});\n"
  ]
}