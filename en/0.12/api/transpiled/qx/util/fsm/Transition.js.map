{
  "version": 3,
  "sources": [
    "/home/travis/build/CometVisu/CometVisu/node_modules/@qooxdoo/compiler/node_modules/@qooxdoo/framework/source/class/qx/util/fsm/Transition.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "transitionName",
    "transitionInfo",
    "context",
    "setName",
    "window",
    "setUserData",
    "field",
    "setPredicate",
    "__bindIfFunction",
    "setNextState",
    "setAutoActionsBeforeOntransition",
    "setAutoActionsAfterOntransition",
    "setOntransition",
    "debug",
    "properties",
    "name",
    "check",
    "nullable",
    "predicate",
    "init",
    "fsm",
    "event",
    "transform",
    "nextState",
    "util",
    "FiniteStateMachine",
    "StateChange",
    "CURRENT_STATE",
    "autoActionsBeforeOntransition",
    "autoActionsAfterOntransition",
    "ontransition",
    "members",
    "__transformPredicate",
    "value",
    "lang",
    "Function",
    "bind",
    "getUserData",
    "Error",
    "__transformNextState",
    "POP_STATE_STACK",
    "TERMINATE",
    "__transformAutoActionsBeforeOntransition",
    "State",
    "_commonTransformAutoActions",
    "__transformAutoActionsAfterOntransition",
    "__transformOntransition",
    "f",
    "Transition"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2006, 2007, 2011 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * Create a new possible transition from one state to another.\n */\nqx.Class.define(\"qx.util.fsm.Transition\",\n{\n  extend : qx.core.Object,\n\n\n  /**\n   * @param transitionName {String}\n   *   The name of this transition, used in debug messages.\n   *\n   * @param transitionInfo {Object}\n   *   <pre>\n   *   An object optionally containing any of the following properties:\n   *\n   *     context -\n   *       A context in which all of the following functions should be run.\n   *\n   *     predicate -\n   *       A function which is called to determine whether this transition is\n   *       acceptable.  An acceptable transition will cause the transition's\n   *       \"ontransition\" function to be run, the current state's \"onexit\"\n   *       function to be run, and the new state's \"onentry\" function to be\n   *       run.\n   *\n   *       The predicate function's signature is function(fsm, event) and it\n   *       is saved in the predicate property of the transition object.  In\n   *       the predicate function:\n   *\n   *         fsm -\n   *           The finite state machine object to which this state is\n   *           attached.\n   *\n   *         event -\n   *           The event that caused a run of the finite state machine\n   *\n   *       The predicate function should return one of the following three\n   *       values:\n   *\n   *         - true means the transition is acceptable\n   *\n   *         - false means the transition is not acceptable, and the next\n   *           transition (if one exists) should be tried to determine if it\n   *           is acceptable\n   *\n   *         - null means that the transition determined that no further\n   *           transitions should be tried.  This might be used when the\n   *           transition ascertained that the event is for a target that is\n   *           not available in the current state, and the event has called\n   *           fsm.queueEvent() to have the event delivered upon state\n   *           transition.\n   *\n   *       It is possible to create a default predicate -- one that will cause\n   *       a transition to be acceptable always -- by either not providing a\n   *       predicate property, or by explicitly either setting the predicate\n   *       property to 'true' or setting it to a function that unconditionally\n   *       returns 'true'.  This default transition should, of course, always\n   *       be the last transition added to a state, since no transition added\n   *       after it will ever be tried.\n   *\n   *     nextState -\n   *       The state to which we transition, if the predicate returns true\n   *       (meaning the transition is acceptable).  The value of nextState may\n   *       be:\n   *\n   *         - a string, the state name of the state to transition to\n   *\n   *         - One of the constants:\n   *           - qx.util.fsm.FiniteStateMachine.StateChange.CURRENT_STATE:\n   *               Remain in whatever is the current state\n   *           - qx.util.fsm.FiniteStateMachine.StateChange.POP_STATE_STACK:\n   *               Transition to the state at the top of the saved-state\n   *               stack, and remove the top element from the saved-state\n   *               stack.  Elements are added to the saved-state stack using\n   *               fsm.pushState().  It is an error if no state exists on the\n   *               saved-state stack.\n   *           - qx.util.fsm.FiniteStateMachine.StateChange.TERMINATE:\n   *               TBD\n   *\n   *     autoActionsBeforeOntransition -\n   *     autoActionsAfterOntransition -\n   *       Automatic actions which take place at the time specified by the\n   *       property name.  In all cases, the action takes place immediately\n   *       before or after the specified function.\n   *\n   *       The property value for each of these properties is an object which\n   *       describes some number of functions to invoke on a set of specified\n   *       objects (typically widgets).\n   *\n   *       See {@link qx.util.fsm.State} for an example of autoActions.\n   *\n   *     ontransition -\n   *       A function which is called if the predicate function for this\n   *       transition returns true.  Its signature is function(fsm, event) and\n   *       it is saved in the ontransition property of the transition object.\n   *       In the ontransition function:\n   *\n   *         fsm -\n   *           The finite state machine object to which this state is\n   *           attached.\n   *\n   *         event -\n   *           The event that caused a run of the finite state machine\n   *\n   *     Additional properties may be provided in transInfo.  They will not be\n   *     used by the finite state machine, but will be available via\n   *     this.getUserData(\"<propertyName>\") during the transition's predicate\n   *     and ontransition functions.\n   *   </pre>\n   */\n  construct : function(transitionName, transitionInfo)\n  {\n    var context;\n\n    // Call our superclass' constructor\n    this.base(arguments);\n\n    // Save the state name\n    this.setName(transitionName);\n\n    // If a context was specified, retrieve it.\n    context = transitionInfo.context || window;\n\n    // Save it for future use\n    this.setUserData(\"context\", context);\n\n    // Save data from the transitionInfo object\n    for (var field in transitionInfo)\n    {\n      // If we find one of our properties, call its setter.\n      switch(field)\n      {\n      case \"predicate\":\n        this.setPredicate(\n          this.__bindIfFunction(transitionInfo[field], context));\n        break;\n\n      case \"nextState\":\n        this.setNextState(transitionInfo[field]);\n        break;\n\n      case \"autoActionsBeforeOntransition\":\n        this.setAutoActionsBeforeOntransition(\n          this.__bindIfFunction(transitionInfo[field], context));\n        break;\n\n      case \"autoActionsAfterOntransition\":\n        this.setAutoActionsAfterOntransition(\n          this.__bindIfFunction(transitionInfo[field], context));\n        break;\n\n      case \"ontransition\":\n        this.setOntransition(\n          this.__bindIfFunction(transitionInfo[field], context));\n        break;\n\n      case \"context\":\n        // already handled\n        break;\n\n      default:\n        // Anything else is user-provided data for their own use.  Save it.\n        this.setUserData(field, transitionInfo[field]);\n\n        // Log it in case it was a typo and they intended a built-in field\n        this.debug(\"Transition \" + transitionName + \": \" +\n                   \"Adding user-provided field to transition: \" + field);\n\n        break;\n      }\n    }\n  },\n\n\n  properties :\n  {\n    /**\n     * The name of this transition\n     */\n    name :\n    {\n      check : \"String\",\n      nullable : true\n    },\n\n\n    /**\n     * The predicate function for this transition.  This is documented in the\n     * constructor, and is typically provided through the constructor's\n     * transitionInfo object, but it is also possible (but highly NOT\n     * recommended) to change this dynamically.\n     */\n    predicate :\n    {\n      init : function(fsm, event)\n      {\n        return true;\n      },\n\n      transform : \"__transformPredicate\"\n    },\n\n\n    /**\n     * The state to transition to, if the predicate determines that this\n     * transition is acceptable.  This is documented in the constructor, and\n     * is typically provided through the constructor's transitionInfo object,\n     * but it is also possible (but highly NOT recommended) to change this\n     * dynamically.\n     */\n    nextState :\n    {\n      init : qx.util.fsm.FiniteStateMachine.StateChange.CURRENT_STATE,\n      transform : \"__transformNextState\"\n    },\n\n\n    /**\n     * Automatic actions to take prior to calling the transition's\n     * ontransition function.  This is documented in the constructor, and is\n     * typically provided through the constructor's transitionInfo object, but\n     * it is also possible (but highly NOT recommended) to change this\n     * dynamically.\n     */\n    autoActionsBeforeOntransition :\n    {\n      init : function(fsm, event) {},\n      transform : \"__transformAutoActionsBeforeOntransition\"\n    },\n\n\n    /**\n     * Automatic actions to take immediately after calling the transition's\n     * ontransition function.  This is documented in the constructor, and is\n     * typically provided through the constructor's transitionInfo object, but\n     * it is also possible (but highly NOT recommended) to change this\n     * dynamically.\n     */\n    autoActionsAfterOntransition :\n    {\n      init : function(fsm, event) {},\n      transform : \"__transformAutoActionsAfterOntransition\"\n    },\n\n\n    /**\n     * The function run when the transition is accepted.  This is documented\n     * in the constructor, and is typically provided through the constructor's\n     * transitionInfo object, but it is also possible (but highly NOT\n     * recommended) to change this dynamically.\n     */\n    ontransition :\n    {\n      init : function(fsm, event) {},\n      transform : \"__transformOntransition\"\n    }\n  },\n\n\n  members:\n  {\n    /**\n     * Validate the predicate. Converts all incoming values to functions.\n     *\n     * @param value {var} incoming value\n     * @return {Function} predicate function\n     */\n    __transformPredicate : function(value)\n    {\n      // Validate the predicate.  Convert all valid types to function.\n      switch(typeof (value))\n      {\n      case \"undefined\":\n        // No predicate means predicate passes\n        return function(fsm, event)\n        {\n          return true;\n        };\n\n      case \"boolean\":\n        // Convert boolean predicate to a function which returns that value\n        return function(fsm, event)\n        {\n          return value;\n        };\n\n      case \"function\":\n        // Use user-provided function.\n        return qx.lang.Function.bind(value, this.getUserData(\"context\"));\n\n      default:\n        throw new Error(\"Invalid transition predicate type: \" +\n                        typeof (value));\n      }\n    },\n\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {Function} the final value\n     */\n    __transformNextState : function(value)\n    {\n      // Validate nextState.  It must be a string or a number.\n      switch(typeof (value))\n      {\n      case \"string\":\n        return value;\n\n      case \"number\":\n        // Ensure that it's one of the possible state-change constants\n        switch(value)\n        {\n        case qx.util.fsm.FiniteStateMachine.StateChange.CURRENT_STATE:\n        case qx.util.fsm.FiniteStateMachine.StateChange.POP_STATE_STACK:\n        case qx.util.fsm.FiniteStateMachine.StateChange.TERMINATE:\n          return value;\n\n        default:\n          throw new Error(\"Invalid transition nextState value: \" +\n                          value + \": \" +\n                          \"nextState must be an explicit state name, \" +\n                          \"or one of the Fsm.StateChange constants\");\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Invalid transition nextState type: \" +\n                        typeof (value));\n      }\n    },\n\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {Function} the final value\n     */\n    __transformAutoActionsBeforeOntransition : function(value)\n    {\n      return qx.util.fsm.State._commonTransformAutoActions(\n        \"autoActionsBeforeOntransition\",\n        value,\n        this.getUserData(\"context\"));\n\n    },\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {Function} the final value\n     */\n    __transformAutoActionsAfterOntransition : function(value)\n    {\n      return qx.util.fsm.State._commonTransformAutoActions(\n        \"autoActionsAfterOntransition\",\n        value,\n        this.getUserData(\"context\"));\n\n    },\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {Function} the final value\n     */\n    __transformOntransition : function(value)\n    {\n      // Validate the ontransition function.  Convert undefined to function.\n      switch(typeof (value))\n      {\n      case \"undefined\":\n        // No provided function just means do nothing.  Use a null\n        // function.\n        return function(fsm, event) {};\n\n      case \"function\":\n        // Use user-provided function.\n        return qx.lang.Function.bind(value, this.getUserData(\"context\"));\n\n      default:\n        throw new Error(\"Invalid ontransition type: \" + typeof (value));\n      }\n    },\n\n    /**\n     * If given a function, bind it to a specified context.\n     *\n     * @param f {Function|var}\n     *   The (possibly) function to be bound to the specified context.\n     *\n     * @param context {Object}\n     *   The context to bind the function to.\n     *\n     * @return {Function}\n     *   If f was a function, the return value is f wrapped such that it will\n     *   be called in the specified context. Otherwise, f is returned\n     *   unaltered.\n     */\n    __bindIfFunction : function(f, context)\n    {\n      // Is the first parameter a function?\n      if (typeof(f) == \"function\")\n      {\n        // Yup. Bind it to the specified context.\n        f = qx.lang.Function.bind(f, context);\n      }\n\n      return f;\n    }\n  }\n});\n"
  ]
}