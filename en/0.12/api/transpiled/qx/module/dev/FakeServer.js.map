{
  "version": 3,
  "sources": [
    "/home/travis/build/CometVisu/CometVisu/node_modules/@qooxdoo/compiler/node_modules/@qooxdoo/framework/source/class/qx/module/dev/FakeServer.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "configure",
    "responseData",
    "dev",
    "FakeServer",
    "getInstance",
    "removeResponse",
    "method",
    "url",
    "addFilter",
    "filter",
    "removeFilter",
    "respondWith",
    "urlRegExp",
    "response",
    "getFakeServer",
    "restore",
    "defer",
    "qxWeb",
    "$attachStatic",
    "module"
  ],
  "mappings": ";;;;;;;;;;;;;AAAAA,EAAAA,EAAE,CAACC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC;;AAAA;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;AAUAH,EAAAA,EAAE,CAACC,SAAH,CAAaG,MAAb,CAAoB,0BAApB,EAAgD;AAC9CC,IAAAA,OAAO,EACP;AACE;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BAC,MAAAA,SAAS,EAAG,mBAASC,YAAT,EAAuB;AACjCP,QAAAA,EAAE,CAACQ,GAAH,CAAOC,UAAP,CAAkBC,WAAlB,GAAgCJ,SAAhC,CAA0CC,YAA1C;AACD,OA7BH;;AAgCE;;;;;;;AAOAI,MAAAA,cAAc,EAAG,wBAASC,MAAT,EAAiBC,GAAjB,EAAsB;AACrCb,QAAAA,EAAE,CAACQ,GAAH,CAAOC,UAAP,CAAkBC,WAAlB,GAAgCC,cAAhC,CAA+CC,MAA/C,EAAuDC,GAAvD;AACD,OAzCH;;AA2CE;;;;;;;;;;;;AAYAC,MAAAA,SAAS,EAAG,mBAASC,MAAT,EAAiB;AAC3Bf,QAAAA,EAAE,CAACQ,GAAH,CAAOC,UAAP,CAAkBC,WAAlB,GAAgCI,SAAhC,CAA0CC,MAA1C;AACD,OAzDH;;AA4DE;;;;;;AAMAC,MAAAA,YAAY,EAAG,sBAASD,MAAT,EAAiB;AAC9Bf,QAAAA,EAAE,CAACQ,GAAH,CAAOC,UAAP,CAAkBC,WAAlB,GAAgCM,YAAhC,CAA6CD,MAA7C;AACD,OApEH;;AAuEE;;;;;;;;;AASAE,MAAAA,WAAW,EAAG,qBAASL,MAAT,EAAiBM,SAAjB,EAA4BC,QAA5B,EAAsC;AAClDnB,QAAAA,EAAE,CAACQ,GAAH,CAAOC,UAAP,CAAkBC,WAAlB,GAAgCO,WAAhC,CAA4CL,MAA5C,EAAoDM,SAApD,EAA+DC,QAA/D;AACD,OAlFH;;AAqFE;;;;;;AAMAC,MAAAA,aAAa,EAAG,yBAAW;AACzB,eAAOpB,EAAE,CAACQ,GAAH,CAAOC,UAAP,CAAkBC,WAAlB,GAAgCU,aAAhC,EAAP;AACD,OA7FH;;AAgGE;;;;AAKAC,MAAAA,OAAO,EAAE,mBAAW;AAClBrB,QAAAA,EAAE,CAACQ,GAAH,CAAOC,UAAP,CAAkBC,WAAlB,GAAgCW,OAAhC;AACD;AAvGH,KAF8C;AA4G9CC,IAAAA,KAAK,EAAG,eAASjB,OAAT,EAAkB;AACxBkB,MAAAA,KAAK,CAACC,aAAN,CAAoB;AAClB,eAAO;AACL,wBAAe;AACb,yBAAcnB,OAAO,CAACC,SADT;AAEb,8BAAmBD,OAAO,CAACM,cAFd;AAGb,yBAAcN,OAAO,CAACS,SAHT;AAIb,4BAAiBT,OAAO,CAACW,YAJZ;AAKb,2BAAgBX,OAAO,CAACY,WALX;AAMb,6BAAkBZ,OAAO,CAACe,aANb;AAOb,uBAAYf,OAAO,CAACgB;AAPP;AADV;AADW,OAApB;AAaD;AA1H6C,GAAhD;AA3BArB,EAAAA,EAAE,CAACyB,MAAH,CAAUjB,GAAV,CAAcC,UAAd,CAAyBN,aAAzB,GAAyCA,aAAzC",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2013 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Richard Sternagel (rsternagel)\n\n************************************************************************ */\n/**\n * A wrapper around Sinon.JS's FakeXMLHttpRequest and FakeServer features that\n * allows quick and simple configuration of mock HTTP backends for testing and\n * development.\n * Automatically creates URL filtering rules to ensure that only configured\n * requests are faked while others will be processed normally by the browser's\n * XHR implementation.\n *\n * @group (IO)\n */\nqx.Bootstrap.define(\"qx.module.dev.FakeServer\", {\n  statics :\n  {\n    /**\n     * Configures a set of fake HTTP responses. Each response is defined as a map\n     * that must provide the following keys:\n     * <ul>\n     *   <li><code>method</code> HTTP method to respond to, e.g. <code>PUT</code></li>\n     *   <li><code>url</code> URL used to match requests to fake responses. Can be\n     *   a RegExp or a String. REST-style parameter placeholders in curly braces\n     *   will be replaced with wildcards, e.g. the string \"/resource/{resourceId}\"\n     *   is interpreted as the RegExp <code>/\\/resource\\/\\{.*?\\}/</code>\n     *   <li><code>response</code> This can be either:\n     *     <ul>\n     *       <li>a string: This will be the response body, status code will be 200</li>\n     *       <li>an array containing the status code, a map of response headers and\n     *         the response text, e.g. <code>[200, { \"Content-Type\": \"text/html\" }, \"OK\"]</code>\n     *       </li>\n     *       <li>a function: This will be called with a FakeXMLHttpRequest object as\n     *       the only argument. Its <code>respond</code> method must be called to send a response.\n     *       See <a href=\"http://sinonjs.org/docs/#respond\">Sinon.JS: Respond</a> for details.\n     *       </li>\n     *     </ul>\n     *   </li>\n     * </ul>\n     *\n     * @attachStatic {qxWeb, dev.fakeServer.configure}\n     * @param responseData {Map[]} An array of response description maps.\n     */\n    configure : function(responseData) {\n      qx.dev.FakeServer.getInstance().configure(responseData);\n    },\n\n\n    /**\n     * Removes a response that was configured with {@link #configure}\n     * @param method {String} HTTP method of the response\n     * @param url {String|RegExp} URL of the response\n     *\n     * @attachStatic {qxWeb, dev.fakeServer.removeResponse}\n     */\n    removeResponse : function(method, url) {\n      qx.dev.FakeServer.getInstance().removeResponse(method, url);\n    },\n\n    /**\n     * Adds a URL filtering function to decide whether a request should be handled\n     * by the FakeServer or passed to the regular XMLHttp implementation.\n     * See <a href=\"http://sinonjs.org/docs/#filtered-requests\">Sinon.JS: Filtered Requests</a>\n     * for details.\n     *\n     * @attachStatic {qxWeb, dev.fakeServer.addFilter}\n     * @param filter {Function} URL filter function. Will be called with the\n     * following arguments: <code>method</code>, <code>url</code>, <code>async</code>,\n     * <code>username</code>, <code>password</code>. Must return <code>true</code>\n     * if the request should not be faked.\n     */\n    addFilter : function(filter) {\n      qx.dev.FakeServer.getInstance().addFilter(filter);\n    },\n\n\n    /**\n     * Remove a filter that was added with {@link #addFilter}\n     * @param filter {Function} filter function to remove\n     *\n     * @attachStatic {qxWeb, dev.fakeServer.removeFilter}\n     */\n    removeFilter : function(filter) {\n      qx.dev.FakeServer.getInstance().removeFilter(filter);\n    },\n\n\n    /**\n     * Defines a fake XHR response to a matching request.\n     *\n     * @attachStatic {qxWeb, dev.fakeServer.respondWith}\n     * @param method {String} HTTP method to respond to, e.g. \"GET\"\n     * @param urlRegExp {RegExp} Request URL must match match this expression\n     * @param response {Function|Array|String} Response to send. See\n     * <a href=\"http://sinonjs.org/docs/#fakeServer\">Sinon.JS: Fake Server</a> for details.\n     */\n    respondWith : function(method, urlRegExp, response) {\n      qx.dev.FakeServer.getInstance().respondWith(method, urlRegExp, response);\n    },\n\n\n    /**\n     * Creates and configures a FakeServer if necessary and returns it.\n     *\n     * @attachStatic {qxWeb, dev.fakeServer.getFakeServer}\n     * @return {Object} FakeServer object\n     */\n    getFakeServer : function() {\n      return qx.dev.FakeServer.getInstance().getFakeServer();\n    },\n\n\n    /**\n     * Stops the FakeServer and removes all configured responses and/or filters.\n\n     * @attachStatic {qxWeb, dev.fakeServer.restore}\n     */\n    restore: function() {\n      qx.dev.FakeServer.getInstance().restore();\n    }\n  },\n\n  defer : function(statics) {\n    qxWeb.$attachStatic({\n      \"dev\": {\n        \"fakeServer\" : {\n          \"configure\" : statics.configure,\n          \"removeResponse\" : statics.removeResponse,\n          \"addFilter\" : statics.addFilter,\n          \"removeFilter\" : statics.removeFilter,\n          \"respondWith\" : statics.respondWith,\n          \"getFakeServer\" : statics.getFakeServer,\n          \"restore\" : statics.restore\n        }\n      }\n    });\n  }\n});\n"
  ]
}