{
  "version": 3,
  "sources": [
    "/home/travis/build/CometVisu/CometVisu/node_modules/@qooxdoo/compiler/node_modules/@qooxdoo/framework/source/class/qx/module/Event.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__normalizations",
    "__hooks",
    "on",
    "off",
    "__isReady",
    "ready",
    "callback",
    "document",
    "readyState",
    "window",
    "setTimeout",
    "onWindowLoad",
    "module",
    "Event",
    "qxWeb",
    "wrappedCallback",
    "env",
    "get",
    "bom",
    "addNativeListener",
    "timer",
    "documentElement",
    "doScroll",
    "body",
    "error",
    "$registerEventNormalization",
    "types",
    "normalizer",
    "lang",
    "Type",
    "isArray",
    "registry",
    "i",
    "l",
    "length",
    "type",
    "isFunction",
    "push",
    "$unregisterEventNormalization",
    "Array",
    "remove",
    "$getEventNormalizationRegistry",
    "$registerEventHook",
    "registerHook",
    "unregisterHook",
    "onHooks",
    "offHooks",
    "$unregisterEventHook",
    "$getEventHookRegistry",
    "members",
    "listener",
    "context",
    "useCapture",
    "el",
    "ctx",
    "hooks",
    "typeHooks",
    "concat",
    "j",
    "m",
    "bound",
    "event",
    "normalizations",
    "x",
    "y",
    "apply",
    "bind",
    "original",
    "$$emitter",
    "Emitter",
    "$$lastlistenerId",
    "getEntryById",
    "__listener",
    "__ctx",
    "removeAll",
    "listenerType",
    "id",
    "storedListener",
    "hasStoredContext",
    "storedContext",
    "result",
    "removeNativeListener",
    "k",
    "allOff",
    "offById",
    "entry",
    "name",
    "emit",
    "data",
    "once",
    "self",
    "wrappedListener",
    "call",
    "hasListener",
    "getListeners",
    "attachedListeners",
    "undefined",
    "copyEventsTo",
    "target",
    "source",
    "targetCopy",
    "descendants",
    "getElementsByTagName",
    "forEach",
    "storage",
    "hover",
    "callbackIn",
    "callbackOut",
    "onMatchTarget",
    "eventType",
    "e",
    "eventTarget",
    "getTarget",
    "is",
    "object",
    "clone",
    "targetToMatch",
    "find",
    "isChildOf",
    "matchTarget",
    "$$matchTargetInfo",
    "offMatchTarget",
    "infos",
    "splice",
    "defer",
    "$attachAll",
    "$attachStatic"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2011-2012 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (wittemann)\n     * Daniel Wagner (danielwagner)\n\n************************************************************************ */\n\n/**\n * Support for native and custom events.\n *\n * @require(qx.module.Polyfill)\n * @require(qx.module.Environment)\n * @use(qx.module.event.PointerHandler)\n * @group (Core)\n */\nqx.Bootstrap.define(\"qx.module.Event\", {\n  statics :\n  {\n    /**\n     * Event normalization registry\n     *\n     * @internal\n     */\n    __normalizations : {},\n\n    /**\n     * Registry of event hooks\n     * @internal\n     */\n    __hooks : {\n      on : {},\n      off : {}\n    },\n\n\n\n    __isReady : false,\n\n\n    /**\n     * Executes the given function once the document is ready.\n     *\n     * @attachStatic {qxWeb}\n     * @param callback {Function} callback function\n     */\n    ready : function(callback) {\n      // DOM is already ready\n      if (document.readyState === \"complete\") {\n        window.setTimeout(callback, 1);\n        return;\n      }\n\n      // listen for the load event so the callback is executed no matter what\n      var onWindowLoad = function()\n      {\n        qx.module.Event.__isReady = true;\n        callback();\n      };\n\n      qxWeb(window).on(\"load\", onWindowLoad);\n\n      var wrappedCallback = function() {\n        qxWeb(window).off(\"load\", onWindowLoad);\n        callback();\n      };\n\n      // Listen for DOMContentLoaded event if available (no way to reliably detect\n      // support)\n      if (qxWeb.env.get(\"engine.name\") !== \"mshtml\" || qxWeb.env.get(\"browser.documentmode\") > 8) {\n        qx.bom.Event.addNativeListener(document, \"DOMContentLoaded\", wrappedCallback);\n      }\n      else {\n        // Continually check to see if the document is ready\n        var timer = function() {\n          // onWindowLoad already executed\n          if (qx.module.Event.__isReady) {\n            return;\n          }\n          try {\n            // If DOMContentLoaded is unavailable, use the trick by Diego Perini\n            // http://javascript.nwbox.com/IEContentLoaded/\n            document.documentElement.doScroll(\"left\");\n            if (document.body) {\n              wrappedCallback();\n            }\n          }\n          catch(error) {\n            window.setTimeout(timer, 100);\n          }\n        };\n\n        timer();\n      }\n    },\n\n\n    /**\n     * Registers a normalization function for the given event types. Listener\n     * callbacks for these types will be called with the return value of the\n     * normalization function instead of the regular event object.\n     *\n     * The normalizer will be called with two arguments: The original event\n     * object and the element on which the event was triggered\n     *\n     * @attachStatic {qxWeb, $registerEventNormalization}\n     * @param types {String[]} List of event types to be normalized. Use an\n     * asterisk (<code>*</code>) to normalize all event types\n     * @param normalizer {Function} Normalizer function\n     */\n    $registerEventNormalization : function(types, normalizer)\n    {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var registry = qx.module.Event.__normalizations;\n      for (var i=0,l=types.length; i<l; i++) {\n        var type = types[i];\n        if (qx.lang.Type.isFunction(normalizer)) {\n          if (!registry[type]) {\n            registry[type] = [];\n          }\n          registry[type].push(normalizer);\n        }\n      }\n    },\n\n\n    /**\n     * Unregisters a normalization function from the given event types.\n     *\n     * @attachStatic {qxWeb, $unregisterEventNormalization}\n     * @param types {String[]} List of event types\n     * @param normalizer {Function} Normalizer function\n     */\n    $unregisterEventNormalization : function(types, normalizer)\n    {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var registry = qx.module.Event.__normalizations;\n      for (var i=0,l=types.length; i<l; i++) {\n        var type = types[i];\n        if (registry[type]) {\n          qx.lang.Array.remove(registry[type], normalizer);\n        }\n      }\n    },\n\n\n    /**\n     * Returns all registered event normalizers\n     *\n     * @attachStatic {qxWeb, $getEventNormalizationRegistry}\n     * @return {Map} Map of event types/normalizer functions\n     */\n    $getEventNormalizationRegistry : function()\n    {\n      return qx.module.Event.__normalizations;\n    },\n\n\n    /**\n     * Registers an event hook for the given event types.\n     *\n     * @attachStatic {qxWeb, $registerEventHook}\n     * @param types {String[]} List of event types\n     * @param registerHook {Function} Hook function to be called on event registration\n     * @param unregisterHook {Function?} Hook function to be called on event deregistration\n     * @internal\n     */\n    $registerEventHook : function(types, registerHook, unregisterHook)\n    {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var onHooks = qx.module.Event.__hooks.on;\n      for (var i=0,l=types.length; i<l; i++) {\n        var type = types[i];\n        if (qx.lang.Type.isFunction(registerHook)) {\n          if (!onHooks[type]) {\n            onHooks[type] = [];\n          }\n          onHooks[type].push(registerHook);\n        }\n      }\n      if (!unregisterHook) {\n        return;\n      }\n      var offHooks = qx.module.Event.__hooks.off;\n      for (var i=0,l=types.length; i<l; i++) {\n        var type = types[i];\n        if (qx.lang.Type.isFunction(unregisterHook)) {\n          if (!offHooks[type]) {\n            offHooks[type] = [];\n          }\n          offHooks[type].push(unregisterHook);\n        }\n      }\n    },\n\n\n    /**\n     * Unregisters a hook from the given event types.\n     *\n     * @attachStatic {qxWeb, $unregisterEventHooks}\n     * @param types {String[]} List of event types\n     * @param registerHook {Function} Hook function to be called on event registration\n     * @param unregisterHook {Function?} Hook function to be called on event deregistration\n     * @internal\n     */\n    $unregisterEventHook : function(types, registerHook, unregisterHook)\n    {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var onHooks = qx.module.Event.__hooks.on;\n      for (var i=0,l=types.length; i<l; i++) {\n        var type = types[i];\n        if (onHooks[type]) {\n          qx.lang.Array.remove(onHooks[type], registerHook);\n        }\n      }\n      if (!unregisterHook) {\n        return;\n      }\n      var offHooks = qx.module.Event.__hooks.off;\n      for (var i=0,l=types.length; i<l; i++) {\n        var type = types[i];\n        if (offHooks[type]) {\n          qx.lang.Array.remove(offHooks[type], unregisterHook);\n        }\n      }\n    },\n\n\n    /**\n     * Returns all registered event hooks\n     *\n     * @attachStatic {qxWeb, $getEventHookRegistry}\n     * @return {Map} Map of event types/registration hook functions\n     * @internal\n     */\n    $getEventHookRegistry : function()\n    {\n      return qx.module.Event.__hooks;\n    }\n  },\n\n\n  members :\n  {\n    /**\n     * Registers a listener for the given event type on each item in the\n     * collection. This can be either native or custom events.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Type of the event to listen for\n     * @param listener {Function} Listener callback\n     * @param context {Object?} Context the callback function will be executed in.\n     * Default: The element on which the listener was registered\n     * @param useCapture {Boolean?} Attach the listener to the capturing\n     * phase if true\n     * @return {qxWeb} The collection for chaining\n     */\n    on : function(type, listener, context, useCapture) {\n      for (var i=0; i < this.length; i++) {\n        var el = this[i];\n        var ctx = context || qxWeb(el);\n\n        // call hooks\n        var hooks = qx.module.Event.__hooks.on;\n        // generic\n        var typeHooks = hooks[\"*\"] || [];\n        // type specific\n        if (hooks[type]) {\n          typeHooks = typeHooks.concat(hooks[type]);\n        }\n        for (var j=0, m=typeHooks.length; j<m; j++) {\n          typeHooks[j](el, type, listener, context);\n        }\n\n        var bound = function(el, event) {\n          // apply normalizations\n          var registry = qx.module.Event.__normalizations;\n          // generic\n          var normalizations = registry[\"*\"] || [];\n          // type specific\n          if (registry[type]) {\n            normalizations = normalizations.concat(registry[type]);\n          }\n\n          for (var x=0, y=normalizations.length; x<y; x++) {\n            event = normalizations[x](event, el, type);\n          }\n          // call original listener with normalized event\n          listener.apply(this, [event]);\n        }.bind(ctx, el);\n        bound.original = listener;\n\n        // add native listener\n        qx.bom.Event.addNativeListener(el, type, bound, useCapture);\n\n        // create an emitter if necessary\n        if (!el.$$emitter) {\n          el.$$emitter = new qx.event.Emitter();\n        }\n\n        el.$$lastlistenerId = el.$$emitter.on(type, bound, ctx);\n        // save the useCapture for removing\n        el.$$emitter.getEntryById(el.$$lastlistenerId).useCapture = !!useCapture;\n\n        if (!el.__listener) {\n          el.__listener = {};\n        }\n        if (!el.__listener[type]) {\n          el.__listener[type] = {};\n        }\n        el.__listener[type][el.$$lastlistenerId] = bound;\n\n        if (!context) {\n          // store a reference to the dynamically created context so we know\n          // what to check for when removing the listener\n          if (!el.__ctx) {\n            el.__ctx = {};\n          }\n          el.__ctx[el.$$lastlistenerId] = ctx;\n        }\n      }\n      return this;\n    },\n\n\n    /**\n     * Unregisters event listeners for the given type from each element in the\n     * collection.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Type of the event\n     * @param listener {Function} Listener callback\n     * @param context {Object?} Listener callback context\n     * @param useCapture {Boolean?} Attach the listener to the capturing\n     * phase if true\n     * @return {qxWeb} The collection for chaining\n     */\n    off : function(type, listener, context, useCapture) {\n      var removeAll = (listener === null && context === null);\n\n      for (var j=0; j < this.length; j++) {\n        var el = this[j];\n\n        // continue if no listeners are available\n        if (!el.__listener) {\n          continue;\n        }\n\n        var types = [];\n        if (type !== null) {\n          types.push(type);\n        } else {\n          // no type specified, remove all listeners\n          for (var listenerType in el.__listener) {\n            types.push(listenerType);\n          }\n        }\n\n        for (var i=0, l=types.length; i<l; i++) {\n          for (var id in el.__listener[types[i]]) {\n            var storedListener = el.__listener[types[i]][id];\n            if (removeAll || storedListener == listener || storedListener.original == listener) {\n              // get the stored context\n              var hasStoredContext = typeof el.__ctx !== \"undefined\" && el.__ctx[id];\n              var storedContext;\n              if (!context && hasStoredContext) {\n                storedContext = el.__ctx[id];\n              }\n              // remove the listener from the emitter\n              var result = el.$$emitter.off(types[i], storedListener, storedContext || context);\n\n              // check if it's a bound listener which means it was a native event\n              if (removeAll || storedListener.original == listener) {\n                // remove the native listener\n                qx.bom.Event.removeNativeListener(el, types[i], storedListener, useCapture);\n              }\n\n              // BUG #9184\n              // only if the emitter was successfully removed also delete the key in the data structure\n              if (result !== null) {\n                delete el.__listener[types[i]][id];\n              }\n\n              if (hasStoredContext) {\n                delete el.__ctx[id];\n              }\n            }\n          }\n\n          // call hooks\n          var hooks = qx.module.Event.__hooks.off;\n          // generic\n          var typeHooks = hooks[\"*\"] || [];\n          // type specific\n          if (hooks[type]) {\n            typeHooks = typeHooks.concat(hooks[type]);\n          }\n          for (var k=0, m=typeHooks.length; k<m; k++) {\n            typeHooks[k](el, type, listener, context);\n          }\n        }\n\n      }\n\n      return this;\n    },\n\n    /**\n     * Removes all event listeners (or all listeners for a given type) from the\n     * collection.\n     *\n     * @attach {qxWeb}\n     * @param type {String?} Event type. All listeners will be removed if this is undefined.\n     * @return {qxWeb} The collection for chaining\n     */\n    allOff : function(type) {\n      return this.off(type || null, null, null);\n    },\n\n    /**\n     * Removes the listener with the given id.\n     * @param id {Number} The id of the listener to remove\n     * @return {qxWeb} The collection for chaining.\n     */\n    offById : function(id) {\n      var entry = this[0].$$emitter.getEntryById(id);\n      return this.off(entry.name, entry.listener.original, entry.ctx, entry.useCapture);\n    },\n\n    /**\n     * Fire an event of the given type.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Event type\n     * @param data {var?} Optional data that will be passed to the listener\n     * callback function.\n     * @return {qxWeb} The collection for chaining\n     */\n    emit : function(type, data) {\n      for (var j=0; j < this.length; j++) {\n        var el = this[j];\n        if (el.$$emitter) {\n          el.$$emitter.emit(type, data);\n        }\n      }\n      return this;\n    },\n\n\n    /**\n     * Attaches a listener for the given event that will be executed only once.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Type of the event to listen for\n     * @param listener {Function} Listener callback\n     * @param context {Object?} Context the callback function will be executed in.\n     * Default: The element on which the listener was registered\n     * @return {qxWeb} The collection for chaining\n     */\n    once : function(type, listener, context) {\n      var self = this;\n      var wrappedListener = function(data) {\n        self.off(type, wrappedListener, context);\n        listener.call(this, data);\n      };\n      this.on(type, wrappedListener, context);\n      return this;\n    },\n\n\n    /**\n     * Checks if one or more listeners for the given event type are attached to\n     * the first element in the collection.\n     *\n     * *Important:* Make sure you are handing in the *identical* context object to get\n     * the correct result. Especially when using a collection instance this is a common pitfall.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Event type, e.g. <code>mousedown</code>\n     * @param listener {Function?} Event listener to check for.\n     * @param context {Object?} Context object listener to check for.\n     * @return {Boolean} <code>true</code> if one or more listeners are attached\n     */\n    hasListener : function(type, listener, context) {\n      if (!this[0] || !this[0].$$emitter ||\n        !this[0].$$emitter.getListeners()[type])\n      {\n        return false;\n      }\n\n      if (listener) {\n        var attachedListeners = this[0].$$emitter.getListeners()[type];\n        for (var i = 0; i < attachedListeners.length; i++) {\n          var hasListener = false;\n          if (attachedListeners[i].listener == listener) {\n            hasListener = true;\n          }\n          if (attachedListeners[i].listener.original &&\n              attachedListeners[i].listener.original == listener) {\n            hasListener =  true;\n          }\n\n          if (hasListener) {\n            if (context !== undefined) {\n              if (attachedListeners[i].ctx === context) {\n                return true;\n              }\n            } else {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n      return this[0].$$emitter.getListeners()[type].length > 0;\n    },\n\n\n    /**\n     * Copies any event listeners that are attached to the elements in the\n     * collection to the provided target element\n     *\n     * @internal\n     * @param target {Element} Element to attach the copied listeners to\n     */\n    copyEventsTo : function(target) {\n      // Copy both arrays to make sure the original collections are not manipulated.\n      // If e.g. the 'target' array contains a DOM node with child nodes we run into\n      // problems because the 'target' array is flattened within this method.\n      var source = this.concat();\n      var targetCopy = target.concat();\n\n      // get all children of source and target\n      for (var i = source.length - 1; i >= 0; i--) {\n        var descendants = source[i].getElementsByTagName(\"*\");\n        for (var j=0; j < descendants.length; j++) {\n          source.push(descendants[j]);\n        }\n      }\n\n      for (var i = targetCopy.length -1; i >= 0; i--) {\n        var descendants = targetCopy[i].getElementsByTagName(\"*\");\n        for (var j=0; j < descendants.length; j++) {\n          targetCopy.push(descendants[j]);\n        }\n      }\n      // make sure no emitter object has been copied\n      targetCopy.forEach(function(el) {\n        el.$$emitter = null;\n      });\n\n      for (var i=0; i < source.length; i++) {\n        var el = source[i];\n        if (!el.$$emitter) {\n          continue;\n        }\n        var storage = el.$$emitter.getListeners();\n        for (var name in storage) {\n          for (var j = storage[name].length - 1; j >= 0; j--) {\n            var listener = storage[name][j].listener;\n            if (listener.original) {\n              listener = listener.original;\n            }\n            qxWeb(targetCopy[i]).on(name, listener, storage[name][j].ctx);\n          }\n        }\n      }\n    },\n\n\n\n    /**\n     * Bind one or two callbacks to the collection.\n     * If only the first callback is defined the collection\n     * does react on 'pointerover' only.\n     *\n     * @attach {qxWeb}\n     *\n     * @param callbackIn {Function} callback when hovering over\n     * @param callbackOut {Function?} callback when hovering out\n     * @return {qxWeb} The collection for chaining\n     */\n    hover : function(callbackIn, callbackOut) {\n\n      this.on(\"pointerover\", callbackIn, this);\n\n      if (qx.lang.Type.isFunction(callbackOut)) {\n        this.on(\"pointerout\", callbackOut, this);\n      }\n\n      return this;\n    },\n\n\n    /**\n     * Adds a listener for the given type and checks if the target fulfills the selector check.\n     * If the check is successful the callback is executed with the target and event as arguments.\n     *\n     * @attach{qxWeb}\n     *\n     * @param eventType {String} name of the event to watch out for (attached to the document object)\n     * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,\n     * Array of DOM elements or collection\n     * @param callback {Function} function to call if the selector matches.\n     * The callback will get the target as qxWeb collection and the event as arguments\n     * @param context {Object?} optional context object to call the callback\n     * @return {qxWeb} The collection for chaining\n     */\n    onMatchTarget : function(eventType, target, callback, context) {\n\n      context = context !== undefined ? context : this;\n\n      var listener = function(e){\n\n        var eventTarget = qxWeb(e.getTarget());\n        if (eventTarget.is(target)) {\n          callback.call(context, eventTarget, qxWeb.object.clone(e));\n        } else {\n          var targetToMatch = typeof target == \"string\" ? this.find(target) : qxWeb(target);\n          for(var i = 0, l = targetToMatch.length; i < l; i++) {\n            if(eventTarget.isChildOf(qxWeb(targetToMatch[i]))) {\n              callback.call(context, eventTarget, qxWeb.object.clone(e));\n              break;\n            }\n          }\n        }\n      };\n\n      // make sure to store the infos for 'offMatchTarget' at each element of the collection\n      // to be able to remove the listener separately\n      this.forEach(function(el) {\n        var matchTarget = {\n          type : eventType,\n          listener : listener,\n          callback : callback,\n          context : context\n        };\n\n        if (!el.$$matchTargetInfo) {\n          el.$$matchTargetInfo = [];\n        }\n        el.$$matchTargetInfo.push(matchTarget);\n      });\n\n      this.on(eventType, listener);\n\n      return this;\n    },\n\n\n    /**\n     * Removes a listener for the given type and selector check.\n     *\n     * @attach{qxWeb}\n     *\n     * @param eventType {String} name of the event to remove for\n     * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,\n     * Array of DOM elements or collection\n     * @param callback {Function} function to remove\n     * @param context {Object?} optional context object to remove\n     * @return {qxWeb} The collection for chaining\n     */\n    offMatchTarget : function(eventType, target, callback, context) {\n\n      context = context !== undefined ? context : this;\n\n      this.forEach(function(el) {\n\n        if (el.$$matchTargetInfo && qxWeb.type.get(el.$$matchTargetInfo) == \"Array\") {\n\n          var infos = el.$$matchTargetInfo;\n\n          for (var i=infos.length - 1; i>=0; i--) {\n\n            var entry = infos[i];\n            if (entry.type == eventType &&\n                entry.callback == callback &&\n                entry.context == context) {\n\n              this.off(eventType, entry.listener);\n              infos.splice(i, 1);\n            }\n\n          }\n\n          if (infos.length === 0) {\n            el.$$matchTargetInfo = null;\n          }\n        }\n      }, this);\n\n      return this;\n    }\n  },\n\n\n  defer : function(statics) {\n    qxWeb.$attachAll(this);\n    // manually attach internal $-methods as they are ignored by the previous method-call\n    qxWeb.$attachStatic({\n      \"$registerEventNormalization\" : statics.$registerEventNormalization,\n      \"$unregisterEventNormalization\" : statics.$unregisterEventNormalization,\n      \"$getEventNormalizationRegistry\" : statics.$getEventNormalizationRegistry,\n      \"$registerEventHook\" : statics.$registerEventHook,\n      \"$unregisterEventHook\" : statics.$unregisterEventHook,\n      \"$getEventHookRegistry\" : statics.$getEventHookRegistry\n    });\n  }\n});\n"
  ]
}