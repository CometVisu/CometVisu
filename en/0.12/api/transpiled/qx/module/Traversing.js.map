{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/module/Traversing.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "EQUALITY_ATTRIBUTES",
    "__getAncestors",
    "selector",
    "filter",
    "ancestors",
    "i",
    "length",
    "parent",
    "dom",
    "Element",
    "getParentElement",
    "found",
    "bom",
    "Selector",
    "matches",
    "concat",
    "qxWeb",
    "$init",
    "__getElementFromArgument",
    "arg",
    "isString",
    "__getNodeFromArgument",
    "Array",
    "isNode",
    "__getAttributes",
    "node",
    "attributes",
    "attr",
    "name",
    "value",
    "__hierarchyHelper",
    "collection",
    "method",
    "all",
    "Hierarchy",
    "l",
    "push",
    "apply",
    "ret",
    "lang",
    "unique",
    "isElement",
    "Node",
    "module",
    "Traversing",
    "isNodeName",
    "nodeName",
    "isDocument",
    "isDocumentFragment",
    "getWindow",
    "isTextNode",
    "obj",
    "isText",
    "isWindow",
    "getDocument",
    "getNodeName",
    "getName",
    "getNodeText",
    "getText",
    "isBlockNode",
    "equalNodes",
    "node1",
    "node2",
    "core",
    "Environment",
    "get",
    "isEqualNode",
    "hasAttributes",
    "hasChildNodes",
    "childNodes",
    "domAttributes",
    "domAttrib",
    "node1Attributes",
    "node2Attributes",
    "j",
    "m",
    "child1",
    "child2",
    "members",
    "add",
    "el",
    "getChildren",
    "children",
    "getChildElements",
    "forEach",
    "fn",
    "ctx",
    "call",
    "getParents",
    "parents",
    "isChildOf",
    "parentCollection",
    "getAncestors",
    "len",
    "indexOf",
    "getAncestorsUntil",
    "getClosest",
    "closest",
    "findClosest",
    "current",
    "parentNode",
    "find",
    "query",
    "getContents",
    "_forEachElement",
    "item",
    "fromCollection",
    "is",
    "Type",
    "isFunction",
    "eq",
    "index",
    "slice",
    "getFirst",
    "getLast",
    "has",
    "descendants",
    "constructor",
    "contains",
    "element",
    "document",
    "getNext",
    "map",
    "getNextElementSibling",
    "getNextAll",
    "getNextUntil",
    "nextSiblings",
    "getNextSiblings",
    "getPrev",
    "getPreviousElementSibling",
    "getPrevAll",
    "getPrevUntil",
    "previousSiblings",
    "getPreviousSiblings",
    "getSiblings",
    "not",
    "res",
    "getOffsetParent",
    "Location",
    "isRendered",
    "defer",
    "$attachAll",
    "$attach"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2011-2012 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (wittemann)\n     * Daniel Wagner (danielwagner)\n\n************************************************************************ */\n\n/**\n * DOM traversal module\n *\n * @require(qx.dom.Hierarchy#getSiblings)\n * @require(qx.dom.Hierarchy#getNextSiblings)\n * @require(qx.dom.Hierarchy#getPreviousSiblings)\n * @require(qx.dom.Hierarchy#contains)\n *\n * @group (Core)\n */\nqx.Bootstrap.define(\"qx.module.Traversing\", {\n  statics :\n  {\n    /**\n     * String attributes used to determine if two DOM nodes are equal\n     * as defined in <a href=\"http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode\">\n     * DOM Level 3</a>\n     */\n    EQUALITY_ATTRIBUTES : [\n      \"nodeType\",\n      \"nodeName\",\n      \"localName\",\n      \"namespaceURI\",\n      \"prefix\",\n      \"nodeValue\"\n    ],\n\n\n    /**\n     * Internal helper for getAncestors and getAncestorsUntil\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector that indicates where to stop including\n     * ancestor elements\n     * @param filter {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the ancestor elements\n     * @internal\n     */\n    __getAncestors : function(selector, filter) {\n      var ancestors = [];\n      for (var i=0; i < this.length; i++) {\n        var parent = qx.dom.Element.getParentElement(this[i]);\n        while (parent) {\n          var found = [parent];\n          if (selector && qx.bom.Selector.matches(selector, found).length > 0) {\n            break;\n          }\n          if (filter) {\n            found = qx.bom.Selector.matches(filter, found);\n          }\n          ancestors = ancestors.concat(found);\n          parent = qx.dom.Element.getParentElement(parent);\n        }\n      }\n      return qxWeb.$init(ancestors, qxWeb);\n    },\n\n\n\n    /**\n     * Helper which returns the element from the given argument. If it's a collection,\n     * it returns it's first child. If it's a string, it tries to use the string\n     * as selector and returns the first child of the new collection.\n     * @param arg {Node|String|qxWeb} The element.\n     * @return {Node|var} If a node can be extracted, the node element will be return.\n     *   If not, at given argument will be returned.\n     */\n    __getElementFromArgument : function(arg) {\n      if (arg instanceof qxWeb) {\n        return arg[0];\n      } else if (qx.Bootstrap.isString(arg)) {\n        return qxWeb(arg)[0];\n      }\n      return arg;\n    },\n\n\n\n    /**\n     * Helper that attempts to convert the given argument into a DOM node\n     * @param arg {var} object to convert\n     * @return {Node|null} DOM node or null if the conversion failed\n     */\n    __getNodeFromArgument : function(arg) {\n      if (typeof arg == \"string\") {\n        arg = qxWeb(arg);\n      }\n\n      if (arg instanceof Array || arg instanceof qxWeb) {\n        arg = arg[0];\n      }\n\n      return qxWeb.isNode(arg) ? arg : null;\n    },\n\n\n    /**\n     * Returns a map containing the given DOM node's attribute names\n     * and values\n     *\n     * @param node {Node} DOM node\n     * @return {Map} Map of attribute names/values\n     */\n    __getAttributes : function(node) {\n      var attributes = {};\n\n      for (var attr in node.attributes) {\n        if (attr == \"length\") {\n          continue;\n        }\n        var name = node.attributes[attr].name;\n        var value = node.attributes[attr].value;\n        attributes[name] = value;\n      }\n\n      return attributes;\n    },\n\n\n    /**\n     * Helper function that iterates over a set of items and applies the given\n     * qx.dom.Hierarchy method to each entry, storing the results in a new Array.\n     * Duplicates are removed and the items are filtered if a selector is\n     * provided.\n     *\n     * @attach{qxWeb}\n     * @param collection {Array} Collection to iterate over (any Array-like object)\n     * @param method {String} Name of the qx.dom.Hierarchy method to apply\n     * @param selector {String?} Optional selector that elements to be included\n     * must match\n     * @return {Array} Result array\n     * @internal\n     */\n    __hierarchyHelper : function(collection, method, selector)\n    {\n      // Iterate ourself, as we want to directly combine the result\n      var all = [];\n      var Hierarchy = qx.dom.Hierarchy;\n      for (var i=0, l=collection.length; i<l; i++) {\n        all.push.apply(all, Hierarchy[method](collection[i]));\n      }\n\n      // Remove duplicates\n      var ret = qx.lang.Array.unique(all);\n\n      // Post reduce result by selector\n      if (selector) {\n        ret = qx.bom.Selector.matches(selector, ret);\n      }\n\n      return ret;\n    },\n\n\n    /**\n     * Checks if the given object is a DOM element\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Object|String|qxWeb} Object to check\n     * @return {Boolean} <code>true</code> if the object is a DOM element\n     */\n    isElement : function(selector) {\n      return qx.dom.Node.isElement(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n\n    /**\n     * Checks if the given object is a DOM node\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} Object to check\n     * @return {Boolean} <code>true</code> if the object is a DOM node\n     */\n    isNode : function(selector) {\n      return qx.dom.Node.isNode(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n\n    /**\n     * Whether the node has the given node name\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} the node to check\n     * @param  nodeName {String} the node name to check for\n     * @return {Boolean} <code>true</code> if the node has the given name\n     */\n    isNodeName : function(selector, nodeName) {\n      return qx.dom.Node.isNodeName(qx.module.Traversing.__getElementFromArgument(selector), nodeName);\n    },\n\n\n    /**\n     * Checks if the given object is a DOM document object\n     *\n     * @attachStatic{qxWeb}\n     * @param node {Object|qxWeb} Object to check. If the value is a qxWeb\n     * collection, isDocument will check the first item.\n     * @return {Boolean} <code>true</code> if the object is a DOM document\n     */\n    isDocument : function(node) {\n      if (node instanceof qxWeb) {\n        node = node[0];\n      }\n      return qx.dom.Node.isDocument(node);\n    },\n\n\n    /**\n     * Checks if the given object is a DOM document fragment object\n     *\n     * @attachStatic{qxWeb}\n     * @param node {Object|qxWeb} Object to check. If the value is a qxWeb\n     * collection, isDocumentFragment will check the first item.\n     * @return {Boolean} <code>true</code> if the object is a DOM document fragment\n     */\n    isDocumentFragment : function(node) {\n      if (node instanceof qxWeb) {\n        node = node[0];\n      }\n      return qx.dom.Node.isDocumentFragment(node);\n    },\n\n\n    /**\n     * Returns the DOM2 <code>defaultView</code> (window) for the given node.\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|Document|Window|String|qxWeb} Node to inspect\n     * @return {Window} the <code>defaultView</code> for the given node\n     */\n    getWindow : function(selector) {\n      return qx.dom.Node.getWindow(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n    /**\n     * Checks whether the given object is a DOM text node\n     *\n     * @attachStatic{qxWeb}\n     * @param obj {Object} the object to be tested\n     * @return {Boolean} <code>true</code> if the object is a textNode\n     */\n    isTextNode : function(obj) {\n      return qx.dom.Node.isText(obj);\n    },\n\n\n    /**\n     * Check whether the given object is a browser window object.\n     *\n     * @attachStatic{qxWeb}\n     * @param obj {Object|qxWeb} the object to be tested. If the value\n     * is a qxWeb collection, isDocument will check the first item.\n     * @return {Boolean} <code>true</code> if the object is a window object\n     */\n    isWindow : function(obj) {\n      if (obj instanceof qxWeb) {\n        obj = obj[0];\n      }\n      return qx.dom.Node.isWindow(obj);\n    },\n\n\n    /**\n     * Returns the owner document of the given node\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} Node to get the document for\n     * @return {Document|null} The document of the given DOM node\n     */\n    getDocument : function(selector) {\n      return qx.dom.Node.getDocument(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n    /**\n     * Get the DOM node's name as a lowercase string\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} DOM Node\n     * @return {String} node name\n     */\n    getNodeName : function(selector) {\n      return qx.dom.Node.getName(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n    /**\n     * Returns the text content of a node where the node type may be one of\n     * NODE_ELEMENT, NODE_ATTRIBUTE, NODE_TEXT, NODE_CDATA\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} the node from where the search should start. If the\n     * node has subnodes the text contents are recursively retrieved and joined\n     * @return {String} the joined text content of the given node or null if not\n     * appropriate.\n     */\n    getNodeText : function(selector) {\n      return qx.dom.Node.getText(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n    /**\n     * Checks if the given node is a block node\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} the node to check\n     * @return {Boolean} <code>true</code> if the node is a block node\n     */\n    isBlockNode : function(selector) {\n      return qx.dom.Node.isBlockNode(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n\n    /**\n     * Determines if two DOM nodes are equal as defined in the\n     * <a href=\"http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode\">DOM Level 3 isEqualNode spec</a>.\n     * Also works in legacy browsers without native <em>isEqualNode</em> support.\n     *\n     * @attachStatic{qxWeb}\n     * @param node1 {String|Element|Element[]|qxWeb} first object to compare\n     * @param node2 {String|Element|Element[]|qxWeb} second object to compare\n     * @return {Boolean} <code>true</code> if the nodes are equal\n     */\n    equalNodes : function(node1, node2) {\n      node1 = qx.module.Traversing.__getNodeFromArgument(node1);\n      node2 = qx.module.Traversing.__getNodeFromArgument(node2);\n\n      if (!node1 || !node2) {\n        return false;\n      }\n\n      if (qx.core.Environment.get(\"html.node.isequalnode\")) {\n        return node1.isEqualNode(node2);\n      } else {\n        if (node1 === node2) {\n          return true;\n        }\n\n        // quick attributes length check\n        var hasAttributes = node1.attributes && node2.attributes;\n        if (hasAttributes &&\n            node1.attributes.length !== node2.attributes.length) {\n          return false;\n        }\n\n        var hasChildNodes = node1.childNodes && node2.childNodes;\n        // quick childNodes length check\n        if (hasChildNodes &&\n            node1.childNodes.length !== node2.childNodes.length) {\n          return false;\n        }\n\n        // string attribute check\n        var domAttributes = qx.module.Traversing.EQUALITY_ATTRIBUTES;\n        for (var i=0, l=domAttributes.length; i<l; i++) {\n          var domAttrib = domAttributes[i];\n          if (node1[domAttrib] !== node2[domAttrib]) {\n            return false;\n          }\n        }\n\n        // attribute values\n        if (hasAttributes) {\n          var node1Attributes = qx.module.Traversing.__getAttributes(node1);\n          var node2Attributes = qx.module.Traversing.__getAttributes(node2);\n          for (var attr in node1Attributes) {\n            if (node1Attributes[attr] !== node2Attributes[attr]) {\n              return false;\n            }\n          }\n        }\n\n        // child nodes\n        if (hasChildNodes) {\n          for (var j=0, m=node1.childNodes.length; j<m; j++) {\n            var child1 = node1.childNodes[j];\n            var child2 = node2.childNodes[j];\n            if (!qx.module.Traversing.equalNodes(child1, child2)) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      }\n    }\n  },\n\n\n  members :\n  {\n\n    __getAncestors : null,\n\n    /**\n     * Adds an element to the collection\n     *\n     * @attach {qxWeb}\n     * @param el {Element|qxWeb} DOM element to add to the collection.\n     * If a collection is given, only the first element will be added\n     * @return {qxWeb} The collection for chaining\n     */\n    add : function(el) {\n      if (el instanceof qxWeb) {\n        el = el[0];\n      }\n      if (qx.module.Traversing.isElement(el) ||\n          qx.module.Traversing.isDocument(el) ||\n          qx.module.Traversing.isWindow(el) ||\n          qx.module.Traversing.isDocumentFragment(el))\n      {\n        this.push(el);\n      }\n      return this;\n    },\n\n\n    /**\n     * Gets a set of elements containing all of the unique immediate children of\n     * each of the matched set of elements.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the child elements\n     */\n    getChildren : function(selector) {\n      var children = [];\n      for (var i=0; i < this.length; i++) {\n        var found = qx.dom.Hierarchy.getChildElements(this[i]);\n        if (selector) {\n          found = qx.bom.Selector.matches(selector, found);\n        }\n        children = children.concat(found);\n      };\n      return qxWeb.$init(children, qxWeb);\n    },\n\n\n    /**\n     * Executes the provided callback function once for each item in the\n     * collection.\n     *\n     * @attach {qxWeb}\n     * @param fn {Function} Callback function which is called with two parameters\n     * <ul>\n     *  <li>current item - DOM node</li>\n     *  <li>current index - Number</li>\n     * </ul>\n     * @param ctx {Object} Context object\n     * @return {qxWeb} The collection for chaining\n     */\n    forEach : function(fn, ctx) {\n      for (var i=0; i < this.length; i++) {\n        fn.call(ctx, this[i], i, this);\n      };\n      return this;\n    },\n\n\n    /**\n     * Gets a set of elements containing the parent of each element in the\n     * collection.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the parent elements\n     */\n    getParents : function(selector) {\n      var parents = [];\n      for (var i=0; i < this.length; i++) {\n        var found = qx.dom.Element.getParentElement(this[i]);\n        if (selector) {\n          found = qx.bom.Selector.matches(selector, [found]);\n        }\n        parents = parents.concat(found);\n      };\n      return qxWeb.$init(parents, qxWeb);\n    },\n\n\n    /**\n    * Checks if any element of the current collection is child of any element of a given\n    * parent collection.\n    *\n    * @attach{qxWeb}\n    * @param parent {qxWeb | String} Collection or selector of the parent collection to check.\n    * @return {Boolean} Returns true if at least one element of the current collection is child of the parent collection\n    *\n    */\n    isChildOf : function(parent){\n      if(this.length == 0){\n        return false;\n      }\n      var ancestors = null, parentCollection = qxWeb(parent), isChildOf = false;\n      for(var i = 0, l = this.length; i < l && !isChildOf; i++){\n        ancestors = qxWeb(this[i]).getAncestors();\n        for(var j = 0, len = parentCollection.length; j < len; j++){\n          if(ancestors.indexOf(parentCollection[j]) != -1){\n            isChildOf = true;\n            break;\n          }\n        };\n      }\n      return isChildOf;\n    },\n\n\n    /**\n     * Gets a set of elements containing all ancestors of each element in the\n     * collection.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param filter {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the ancestor elements\n     */\n    getAncestors : function(filter) {\n      return this.__getAncestors(null, filter);\n    },\n\n\n    /**\n     * Gets a set of elements containing all ancestors of each element in the\n     * collection, up to (but not including) the element matched by the provided\n     * selector.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector that indicates where to stop including\n     * ancestor elements\n     * @param filter {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the ancestor elements\n     */\n    getAncestorsUntil : function(selector, filter) {\n      return this.__getAncestors(selector, filter);\n    },\n\n\n    /**\n     * Gets a set containing the closest matching ancestor for each item in\n     * the collection.\n     * If the item itself matches, it is added to the new set. Otherwise, the\n     * item's parent chain will be traversed until a match is found.\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector expression to match\n     * @return {qxWeb} New collection containing the closest matching ancestors\n     */\n    getClosest : function(selector) {\n      var closest = [];\n\n      var findClosest = function(current) {\n        var found = qx.bom.Selector.matches(selector, current);\n        if (found.length) {\n          closest.push(found[0]);\n        } else {\n          current = current.getParents(); // One up\n          if(current[0] && current[0].parentNode) {\n            findClosest(current);\n          }\n        }\n      };\n\n      for (var i=0; i < this.length; i++) {\n        findClosest(qxWeb(this[i]));\n      };\n\n      return qxWeb.$init(closest, qxWeb);\n    },\n\n\n    /**\n     * Searches the child elements of each item in the collection and returns\n     * a new collection containing the children that match the provided selector\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector expression to match the child elements\n     * against\n     * @return {qxWeb} New collection containing the matching child elements\n     */\n    find : function(selector) {\n      var found = [];\n      for (var i=0; i < this.length; i++) {\n        found = found.concat(qx.bom.Selector.query(selector, this[i]));\n      };\n      return qxWeb.$init(found, qxWeb);\n    },\n\n\n    /**\n     * Gets a new set of elements containing the child nodes of each item in the\n     * current set.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} New collection containing the child nodes\n     */\n    getContents : function() {\n      var found = [];\n      this._forEachElement(function(item) {\n        found = found.concat(qx.lang.Array.fromCollection(item.childNodes));\n      });\n      return qxWeb.$init(found, qxWeb);\n    },\n\n\n    /**\n     * Checks if at least one element in the collection passes the provided\n     * filter. This can be either a selector expression or a filter\n     * function\n     *\n     * @attach {qxWeb}\n     * @param selector {String|Function} Selector expression or filter function\n     * @return {Boolean} <code>true</code> if at least one element matches\n     */\n    is : function(selector) {\n      if (qx.lang.Type.isFunction(selector)) {\n        return this.filter(selector).length > 0;\n      }\n      return !!selector && qx.bom.Selector.matches(selector, this).length > 0;\n    },\n\n\n    /**\n     * Reduce the set of matched elements to a single element.\n     *\n     * @attach {qxWeb}\n     * @param index {Number} The position of the element in the collection\n     * @return {qxWeb} A new collection containing one element\n     */\n    eq : function(index) {\n      return this.slice(index, +index + 1);\n    },\n\n\n    /**\n     * Reduces the collection to the first element.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} A new collection containing one element\n     */\n    getFirst : function() {\n      return this.slice(0, 1);\n    },\n\n\n    /**\n     * Reduces the collection to the last element.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} A new collection containing one element\n     */\n    getLast : function() {\n      return this.slice(this.length - 1);\n    },\n\n\n    /**\n     * Gets a collection containing only the elements that have descendants\n     * matching the given selector\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector expression\n     * @return {qxWeb} a new collection containing only elements with matching descendants\n     */\n    has : function(selector) {\n      var found = [];\n      this._forEachElement(function(item, index) {\n        var descendants = qx.bom.Selector.matches(selector, this.eq(index).getContents());\n        if (descendants.length > 0) {\n          found.push(item);\n        }\n      });\n\n      return qxWeb.$init(found, this.constructor);\n    },\n\n\n    /**\n     * Returns a new collection containing only those nodes that\n     * contain the given element. Also accepts a qxWeb\n     * collection or an Array of elements. In those cases, the first element\n     * in the list is used.\n     *\n     * @attach {qxWeb}\n     * @param element {Element|Window|Element[]|qxWeb} element to check for.\n     * @return {qxWeb} Collection with matching items\n     */\n    contains : function(element) {\n      // qxWeb does not inherit from Array in IE\n      if (element instanceof Array || element instanceof qxWeb) {\n        element = element[0];\n      }\n\n      if (!element) {\n        return qxWeb();\n      }\n\n      if (qx.dom.Node.isWindow(element)) {\n        element = element.document;\n      }\n\n      return this.filter(function(el) {\n        if (qx.dom.Node.isWindow(el)) {\n          el = el.document;\n        }\n        return qx.dom.Hierarchy.contains(el, element);\n      });\n    },\n\n\n    /**\n     * Gets a collection containing the next sibling element of each item in\n     * the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing next siblings\n     */\n    getNext : function(selector) {\n      var found = this.map(qx.dom.Hierarchy.getNextElementSibling, qx.dom.Hierarchy);\n      if (selector) {\n        found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);\n      }\n      return found;\n    },\n\n\n    /**\n     * Gets a collection containing all following sibling elements of each\n     * item in the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing following siblings\n     */\n    getNextAll : function(selector) {\n      var ret = qx.module.Traversing.__hierarchyHelper(this, \"getNextSiblings\", selector);\n      return qxWeb.$init(ret, qxWeb);\n    },\n\n\n    /**\n     * Gets a collection containing the following sibling elements of each\n     * item in the current set up to but not including any element that matches\n     * the given selector.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing following siblings\n     */\n    getNextUntil : function(selector) {\n      var found = [];\n      this.forEach(function(item, index) {\n        var nextSiblings = qx.dom.Hierarchy.getNextSiblings(item);\n        for (var i=0, l=nextSiblings.length; i<l; i++) {\n          if (qx.bom.Selector.matches(selector, [nextSiblings[i]]).length > 0) {\n            break;\n          }\n          found.push(nextSiblings[i]);\n        }\n      });\n\n      return qxWeb.$init(found, qxWeb);\n    },\n\n\n    /**\n     * Gets a collection containing the previous sibling element of each item in\n     * the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing previous siblings\n     */\n    getPrev : function(selector) {\n      var found = this.map(qx.dom.Hierarchy.getPreviousElementSibling, qx.dom.Hierarchy);\n      if (selector) {\n        found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);\n      }\n      return found;\n    },\n\n\n    /**\n     * Gets a collection containing all preceding sibling elements of each\n     * item in the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing preceding siblings\n     */\n    getPrevAll : function(selector) {\n      var ret = qx.module.Traversing.__hierarchyHelper(this, \"getPreviousSiblings\", selector);\n      return qxWeb.$init(ret, qxWeb);\n    },\n\n\n    /**\n     * Gets a collection containing the preceding sibling elements of each\n     * item in the current set up to but not including any element that matches\n     * the given selector.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing preceding siblings\n     */\n    getPrevUntil : function(selector) {\n      var found = [];\n      this.forEach(function(item, index) {\n        var previousSiblings = qx.dom.Hierarchy.getPreviousSiblings(item);\n        for (var i=0, l=previousSiblings.length; i<l; i++) {\n          if (qx.bom.Selector.matches(selector, [previousSiblings[i]]).length > 0) {\n            break;\n          }\n          found.push(previousSiblings[i]);\n        }\n      });\n\n      return qxWeb.$init(found, qxWeb);\n    },\n\n\n    /**\n     * Gets a collection containing all sibling elements of the items in the\n     * current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing sibling elements\n     */\n    getSiblings : function(selector) {\n      var ret = qx.module.Traversing.__hierarchyHelper(this, \"getSiblings\", selector);\n      return qxWeb.$init(ret, qxWeb);\n    },\n\n\n    /**\n     * Remove elements from the collection that do not pass the given filter.\n     * This can be either a selector expression or a filter function\n     *\n     * @attach {qxWeb}\n     * @param selector {String|Function} Selector or filter function\n     * @return {qxWeb} Reduced collection\n     */\n    not : function(selector) {\n      if (qx.lang.Type.isFunction(selector)) {\n        return this.filter(function(item, index, obj) {\n          return !selector(item, index, obj);\n        });\n      }\n\n      var res = qx.bom.Selector.matches(selector, this);\n      return this.filter(function(value) {\n        return res.indexOf(value) === -1;\n      });\n    },\n\n\n    /**\n     * Gets a new collection containing the offset parent of each item in the\n     * current set.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} New collection containing offset parents\n     */\n    getOffsetParent : function() {\n      return this.map(qx.bom.element.Location.getOffsetParent);\n    },\n\n\n    /**\n     * Whether the first element in the collection is inserted into\n     * the document for which it was created.\n     *\n     * @attach {qxWeb}\n     * @return {Boolean} <code>true</code> when the element is inserted\n     *    into the document.\n     */\n    isRendered : function() {\n      if (!this[0]) {\n        return false;\n      }\n      return qx.dom.Hierarchy.isRendered(this[0]);\n    }\n  },\n\n\n  defer : function(statics) {\n    qxWeb.$attachAll(this);\n    // manually attach private method which is ignored by attachAll\n    qxWeb.$attach({\n      \"__getAncestors\" : statics.__getAncestors\n    });\n  }\n});\n"
  ]
}