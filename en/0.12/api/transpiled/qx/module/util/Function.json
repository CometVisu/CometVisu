{
  "className": "qx.module.util.Function",
  "packageName": "qx.module.util",
  "name": "Function",
  "superClass": null,
  "interfaces": [],
  "mixins": [],
  "functionName": null,
  "clazz": {
    "location": {
      "start": {
        "line": 24,
        "column": 0
      },
      "end": {
        "line": 66,
        "column": 3
      }
    },
    "jsdoc": {
      "@description": [
        {
          "name": "@description",
          "body": "<p>Utility module to give some support to work with functions.</p>"
        }
      ],
      "@group": [
        {
          "name": "@group",
          "body": "Utilities"
        }
      ]
    }
  },
  "type": "class",
  "statics": {
    "debounce": {
      "location": {
        "start": {
          "line": 42,
          "column": 4
        },
        "end": {
          "line": 42,
          "column": 39
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns a debounced version of the given callback. The execution of the callback\n is delayed by the given delay and after no events were triggered anymore.\n This mechanism is very useful for event handling: only after a specified delay\n the event should be handled (e.g. at keyboard input by the user) to prevent flooding\n the handler with a large amounts of events.</p>"
          }
        ],
        "@attachStatic": [
          {
            "name": "@attachStatic",
            "body": "{qxWeb, func.debounce}"
          }
        ],
        "@signature": [
          {
            "name": "@signature",
            "body": "function (callback, delay, immediate)"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "callback {Function} the callback which should be executed after the given delay\n if the wrapper method is *not* called during this delay.",
            "paramName": "callback",
            "description": " the callback which should be executed after the given delay\n if the wrapper method is *not* called during this delay.",
            "type": "qx.module.util.Function"
          },
          {
            "name": "@param",
            "body": "delay {Number} Delay in milliseconds",
            "paramName": "delay",
            "description": " Delay in milliseconds",
            "type": "Number"
          },
          {
            "name": "@param",
            "body": "immediate {Boolean?} whether to run the callback at the beginning and then debounce, default is <code>false</code>",
            "paramName": "immediate",
            "description": " whether to run the callback at the beginning and then debounce, default is <code>false</code>",
            "optional": true,
            "type": "Boolean"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Function} a wrapper function which <em>shields</em> the given callback function",
            "type": "qx.module.util.Function",
            "description": " a wrapper function which <em>shields</em> the given callback function"
          }
        ]
      },
      "type": "variable",
      "access": "public"
    },
    "throttle": {
      "location": {
        "start": {
          "line": 60,
          "column": 4
        },
        "end": {
          "line": 60,
          "column": 39
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "<p>Returns a throttled version of the given callback. The execution of the callback\n is throttled which means it is only executed in the given interval.\n This mechanism is very useful for event handling: only in specified intervals\n the event should be handled (e.g. at resize of the browser window) to prevent flooding\n the handler with a large amounts of events.\n As default the <code>leading</code> and <code>trailing</code> calls are executed.</p>"
          }
        ],
        "@attachStatic": [
          {
            "name": "@attachStatic",
            "body": "{qxWeb, func.throttle}"
          }
        ],
        "@signature": [
          {
            "name": "@signature",
            "body": "function (callback, interval, options)"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "callback {Function} the callback which should be executed in the given interval",
            "paramName": "callback",
            "description": " the callback which should be executed in the given interval",
            "type": "qx.module.util.Function"
          },
          {
            "name": "@param",
            "body": "interval {Number} Interval in milliseconds",
            "paramName": "interval",
            "description": " Interval in milliseconds",
            "type": "Number"
          },
          {
            "name": "@param",
            "body": "options {Map} the keys are <code>leading</code> and <code>trailing</code> to control the\n executing of the callback precisely. Default values are <code>true</code> for both options.",
            "paramName": "options",
            "description": " the keys are <code>leading</code> and <code>trailing</code> to control the\n executing of the callback precisely. Default values are <code>true</code> for both options.",
            "type": "Map"
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Function} a wrapper function which <em>shields</em> the given callback function",
            "type": "qx.module.util.Function",
            "description": " a wrapper function which <em>shields</em> the given callback function"
          }
        ]
      },
      "type": "variable",
      "access": "public"
    }
  },
  "defer": {
    "location": {
      "start": {
        "line": 63,
        "column": 9
      },
      "end": {
        "line": 65,
        "column": 3
      }
    },
    "jsdoc": {}
  },
  "descendants": []
}