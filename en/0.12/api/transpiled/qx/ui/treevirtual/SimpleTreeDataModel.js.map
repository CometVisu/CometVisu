{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/framework/source/class/qx/ui/treevirtual/SimpleTreeDataModel.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "ui",
    "table",
    "model",
    "Abstract",
    "include",
    "treevirtual",
    "MTreePrimitive",
    "construct",
    "_rowArr",
    "_nodeArr",
    "_nodeRowMap",
    "_treeColumn",
    "_selections",
    "push",
    "_getEmptyTree",
    "__editableColArr",
    "properties",
    "filter",
    "check",
    "nullable",
    "apply",
    "members",
    "__tree",
    "__tempTreeData",
    "__recalculateLastChildFlags",
    "setTree",
    "tree",
    "getTree",
    "setEditable",
    "editable",
    "col",
    "getColumnCount",
    "fireEvent",
    "setColumnEditable",
    "columnIndex",
    "isColumnEditable",
    "getAllowNodeEdit",
    "isColumnSortable",
    "sortByColumn",
    "ascending",
    "Error",
    "getSortColumnIndex",
    "setTreeColumn",
    "getTreeColumn",
    "getRowCount",
    "length",
    "getRowData",
    "rowIndex",
    "getValue",
    "setValue",
    "value",
    "node",
    "getNodeFromRow",
    "undefined",
    "updatedNode",
    "lang",
    "Object",
    "clone",
    "label",
    "nodeId",
    "columnData",
    "hasListener",
    "data",
    "firstRow",
    "lastRow",
    "firstColumn",
    "lastColumn",
    "fireDataEvent",
    "getNode",
    "addBranch",
    "parentNodeId",
    "bOpened",
    "bHideOpenCloseButton",
    "icon",
    "iconSelected",
    "_addNode",
    "Type",
    "BRANCH",
    "addLeaf",
    "LEAF",
    "prune",
    "nodeReference",
    "bSelfAlso",
    "i",
    "children",
    "Array",
    "remove",
    "move",
    "moveNodeReference",
    "parentNodeReference",
    "moveNode",
    "moveNodeId",
    "parentNode",
    "type",
    "oldParent",
    "__inorder",
    "level",
    "getFilter",
    "child",
    "childNodeId",
    "numChildren",
    "index",
    "call",
    "bFirstChild",
    "__setLastChildFlag",
    "rowData",
    "j",
    "bSelected",
    "selected",
    "__calculateLastChildFlags",
    "tempTreeData",
    "hasChildren",
    "isLastChild",
    "lastChild",
    "parent",
    "bLast",
    "unshift",
    "__render",
    "setData",
    "nodeArr",
    "selectionModel",
    "getSelectionModel",
    "selections",
    "nRowIndex",
    "getRowFromNodeId",
    "setSelectionInterval",
    "getData",
    "clearData",
    "_clearSelections",
    "setColumnData",
    "getColumnData",
    "setState",
    "attributes",
    "attribute",
    "TV",
    "TreeVirtual",
    "bChangeSelection",
    "getSelectionMode",
    "SelectionMode",
    "NONE",
    "isSelectedIndex",
    "removeSelectionInterval",
    "bHideOpenClose",
    "_resetSelection",
    "getNodeRowMap",
    "selection",
    "getSelectedNodes",
    "nodes",
    "_applyFilter",
    "old",
    "isNodeEditable",
    "bCanEdit",
    "destruct",
    "defer",
    "statics",
    "SimpleTreeDataModel"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAAA,EAAAA,EAAE,CAACC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,EAAAA,EAAE,CAACI,KAAH,CAASC,MAAT,CAAgB,uCAAhB,EACA;AACEC,IAAAA,MAAM,EAAGN,EAAE,CAACO,EAAH,CAAMC,KAAN,CAAYC,KAAZ,CAAkBC,QAD7B;AAGEC,IAAAA,OAAO,EAAGX,EAAE,CAACO,EAAH,CAAMK,WAAN,CAAkBC,cAH9B;;AAME;AACF;AACA;AACA;AACA;AAEEC,IAAAA,SAAS,EAAG,qBACZ;AACE;AAEA,WAAKC,OAAL,GAAe,EAAf,CAHF,CAGqB;;AACnB,WAAKC,QAAL,GAAgB,EAAhB,CAJF,CAIsB;;AAEpB,WAAKC,WAAL,GAAmB,EAAnB,CANF,CAMyB;AACA;AACA;AACA;;AAEvB,WAAKC,WAAL,GAAmB,CAAnB,CAXF,CAWwB;;AAEtB,WAAKC,WAAL,GAAmB,EAAnB,CAbF,CAayB;AAEvB;;AACA,WAAKH,QAAL,CAAcI,IAAd,CAAmBpB,EAAE,CAACO,EAAH,CAAMK,WAAN,CAAkBC,cAAlB,CAAiCQ,aAAjC,EAAnB,EAhBF,CAkBE;;;AACA,WAAKC,SAAL,GAAwB,IAAxB;AACD,KAjCH;AAoCEC,IAAAA,UAAU,EACV;AACE;AACJ;AACA;AACA;AACA;AACA;AACA;AACIC,MAAAA,MAAM,EACN;AACEC,QAAAA,KAAK,EAAG,UADV;AAEEC,QAAAA,QAAQ,EAAG,IAFb;AAGEC,QAAAA,KAAK,EAAG;AAHV;AATF,KArCF;;AAuDE;AACF;AACA;AACA;AACA;AAEEC,IAAAA,OAAO,EACP;AACEC,MAAAA,SAAM,EAAa,IADrB;AAEEP,MAAAA,SAAgB,EAAG,IAFrB;AAGEQ,MAAAA,SAAc,EAAG,IAHnB;AAIEC,MAAAA,SAA2B,EAAG,IAJhC;;AAME;AACAhB,MAAAA,OAAO,EAAG,IAPZ;;AASE;AACAC,MAAAA,QAAQ,EAAG,IAVb;;AAYE;AACJ;AACA;AACA;AACA;AACIC,MAAAA,WAAW,EAAG,IAjBhB;;AAmBE;AACAC,MAAAA,WAAW,EAAG,IApBhB;;AAsBE;AACAC,MAAAA,WAAW,EAAG,IAvBhB;;AAyBE;AACJ;AACA;AACA;AACA;AACA;AACA;AACIa,MAAAA,OAAO,EAAG,iBAASC,IAAT,EACV;AACE,aAAKJ,SAAL,GAAcI,IAAd;AACD,OAnCH;;AAqCE;AACJ;AACA;AACA;AACA;AACIC,MAAAA,OAAO,EAAG,mBACV;AACE,eAAO,KAAKL,SAAZ;AACD,OA7CH;;AA+CE;AACJ;AACA;AACA;AACA;AACA;AACA;AACIM,MAAAA,WAAW,EAAG,qBAASC,QAAT,EACd;AACE,aAAKd,SAAL,GAAwB,EAAxB;;AAEA,aAAK,IAAIe,GAAG,GAAC,CAAb,EAAgBA,GAAG,GAAC,KAAKC,cAAL,EAApB,EAA2CD,GAAG,EAA9C,EACA;AACE,eAAKf,SAAL,CAAsBe,GAAtB,IAA6BD,QAA7B;AACD;;AAED,aAAKG,SAAL,CAAe,iBAAf;AACD,OAhEH;;AAmEE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,MAAAA,iBAAiB,EAAG,2BAASC,WAAT,EAAsBL,QAAtB,EACpB;AACE,YAAIA,QAAQ,IAAI,KAAKM,gBAAL,CAAsBD,WAAtB,CAAhB,EACA;AACE,cAAI,KAAKnB,SAAL,IAAyB,IAA7B,EACA;AACE,iBAAKA,SAAL,GAAwB,EAAxB;AACD;;AAED,eAAKA,SAAL,CAAsBmB,WAAtB,IAAqCL,QAArC;AAEA,eAAKG,SAAL,CAAe,iBAAf;AACD;AACF,OA1FH;AA4FE;AACAG,MAAAA,gBAAgB,EAAG,0BAASD,WAAT,EACnB;AACE,YAAIA,WAAW,IAAI,KAAKvB,WAAxB,EACA;AACE,iBAAO,KAAKW,SAAL,CAAYc,gBAAZ,EAAP;AACD;;AAED,eAAO,KAAKrB,SAAL,GACE,KAAKA,SAAL,CAAsBmB,WAAtB,KAAsC,IADxC,GAEE,KAFT;AAGD,OAvGH;AA0GE;AACAG,MAAAA,gBAAgB,EAAG,0BAASH,WAAT,EACnB;AACE,eAAO,KAAP;AACD,OA9GH;;AAiHE;AACJ;AACA;AACA;AACA;AACA;AACA;AACII,MAAAA,YAAY,EAAG,sBAASJ,WAAT,EAAsBK,SAAtB,EACf;AACE,cAAM,IAAIC,KAAJ,CAAU,mCAAV,CAAN;AACD,OA3HH;;AA8HE;AACJ;AACA;AACA;AACA;AACA;AACA;AACIC,MAAAA,kBAAkB,EAAG,8BACrB;AACE,eAAO,CAAC,CAAR;AACD,OAxIH;;AA2IE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,MAAAA,aAAa,EAAG,uBAASR,WAAT,EAChB;AACE,aAAKvB,WAAL,GAAmBuB,WAAnB;AACD,OAnKH;;AAsKE;AACJ;AACA;AACA;AACA;AACA;AACIS,MAAAA,aAAa,EAAG,yBAChB;AACE,eAAO,KAAKhC,WAAZ;AACD,OA/KH;AAiLE;AACAiC,MAAAA,WAAW,EAAG,uBACd;AACE,eAAO,KAAKpC,OAAL,CAAaqC,MAApB;AACD,OArLH;AAuLE;AACAC,MAAAA,UAAU,EAAG,oBAASC,QAAT,EACb;AACE,eAAO,KAAKvC,OAAL,CAAauC,QAAb,CAAP;AACD,OA3LH;;AA8LE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,MAAAA,QAAQ,EAAG,kBAASd,WAAT,EAAsBa,QAAtB,EACX;AACE,YAAIA,QAAQ,GAAG,CAAX,IAAgBA,QAAQ,IAAI,KAAKvC,OAAL,CAAaqC,MAA7C,EACA;AACE,gBAAM,IAAIL,KAAJ,CAAU,uBACMO,QADN,GACiB,mBADjB,GAEA,KAAKvC,OAFL,GAGA,OAHA,IAGW,KAAKA,OAAL,CAAaqC,MAAb,GAAsB,CAHjC,IAGsC,GAHhD,CAAN;AAID;;AAED,YAAIX,WAAW,GAAG,CAAd,IAAmBA,WAAW,IAAI,KAAK1B,OAAL,CAAauC,QAAb,EAAuBF,MAA7D,EACA;AACE,gBAAM,IAAIL,KAAJ,CAAU,0BACMN,WADN,GACoB,mBADpB,GAEA,KAAK1B,OAAL,CAAauC,QAAb,CAFA,GAGA,OAHA,IAGW,KAAKvC,OAAL,CAAauC,QAAb,EAAuBF,MAAvB,GAAgC,CAH3C,IAGgD,GAH1D,CAAN;AAID;;AAED,eAAO,KAAKrC,OAAL,CAAauC,QAAb,EAAuBb,WAAvB,CAAP;AACD,OA1NH;AA6NE;AACAe,MAAAA,QAAQ,EAAG,kBAASf,WAAT,EAAsBa,QAAtB,EAAgCG,KAAhC,EACX;AACE;AACA,YAAIC,IAAI,GAAG,KAAKC,cAAL,CAAoBL,QAApB,CAAX;;AAEA,YAAIb,WAAW,KAAK,KAAKvB,WAAzB,EACA;AACE,cAAI,CAAC,KAAKW,SAAL,CAAYc,gBAAZ,EAAD,IAAmCc,KAAK,CAAC,OAAD,CAAL,KAAmBG,SAA1D,EAAqE;AACnE;AACD,WAHH,CAIE;;;AACA,cAAIC,WAAW,GAAG7D,EAAE,CAAC8D,IAAH,CAAQC,MAAR,CAAeC,KAAf,CAAqBN,IAArB,CAAlB;AACAG,UAAAA,WAAW,CAACI,KAAZ,GAAoBR,KAAK,CAACQ,KAA1B;AACA,eAAKjD,QAAL,CAAc0C,IAAI,CAACQ,MAAnB,IAA6BL,WAA7B;AACD,SATD,MASO;AACL,cAAIH,IAAI,CAACS,UAAL,CAAgB1B,WAAhB,KAAgCgB,KAApC,EAA2C;AACzC;AACD;;AACDC,UAAAA,IAAI,CAACS,UAAL,CAAgB1B,WAAhB,IAA+BgB,KAA/B;AACA,eAAK1C,OAAL,CAAauC,QAAb,EAAuBb,WAAvB,IAAsCgB,KAAtC;AACD,SAnBH,CAoBE;;;AACA,YAAI,KAAKW,WAAL,CAAiB,aAAjB,CAAJ,EACA;AACE,cAAIC,IAAI,GAAG;AACTC,YAAAA,QAAQ,EAAEhB,QADD;AAETiB,YAAAA,OAAO,EAAEjB,QAFA;AAGTkB,YAAAA,WAAW,EAAE/B,WAHJ;AAITgC,YAAAA,UAAU,EAAEhC;AAJH,WAAX;AAMA,eAAKiC,aAAL,CAAmB,aAAnB,EAAkCL,IAAlC;AACD;AACF,OA9PH;;AAiQE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIM,MAAAA,OAAO,EAAG,iBAASrB,QAAT,EACV;AACE,YAAIA,QAAQ,GAAG,CAAX,IAAgBA,QAAQ,IAAI,KAAKvC,OAAL,CAAaqC,MAA7C,EACA;AACE,gBAAM,IAAIL,KAAJ,CAAU,uBACMO,QADN,GACiB,mBADjB,GAEA,KAAKvC,OAFL,GAGA,OAHA,IAGW,KAAKA,OAAL,CAAaqC,MAAb,GAAsB,CAHjC,IAGsC,GAHhD,CAAN;AAID;;AAED,eAAO,KAAKrC,OAAL,CAAauC,QAAb,EAAuB,KAAKpC,WAA5B,CAAP;AACD,OA1RH;;AA6RE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI0D,MAAAA,SAAS,EAAG,mBAASC,YAAT,EACSZ,KADT,EAESa,OAFT,EAGSC,oBAHT,EAISC,IAJT,EAKSC,YALT,EAMZ;AACE,eAAOjF,EAAE,CAACO,EAAH,CAAMK,WAAN,CAAkBC,cAAlB,CAAiCqE,QAAjC,CACL,KAAKlE,QADA,EAEL6D,YAFK,EAGLZ,KAHK,EAILa,OAJK,EAKLC,oBALK,EAML/E,EAAE,CAACO,EAAH,CAAMK,WAAN,CAAkBC,cAAlB,CAAiCsE,IAAjC,CAAsCC,MANjC,EAOLJ,IAPK,EAQLC,YARK,CAAP;AASD,OAzUH;;AA4UE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACII,MAAAA,OAAO,EAAG,iBAASR,YAAT,EACSZ,KADT,EAESe,IAFT,EAGSC,YAHT,EAIV;AACE,eAAOjF,EAAE,CAACO,EAAH,CAAMK,WAAN,CAAkBC,cAAlB,CAAiCqE,QAAjC,CACL,KAAKlE,QADA,EAEL6D,YAFK,EAGLZ,KAHK,EAIL,KAJK,EAKL,KALK,EAMLjE,EAAE,CAACO,EAAH,CAAMK,WAAN,CAAkBC,cAAlB,CAAiCsE,IAAjC,CAAsCG,IANjC,EAOLN,IAPK,EAQLC,YARK,CAAP;AASD,OA7WH;;AAgXE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIM,MAAAA,KAAK,EAAG,eAASC,aAAT,EAAwBC,SAAxB,EACR;AACE,YAAI/B,IAAJ;AACA,YAAIQ,MAAJ;;AAEA,YAAI,QAAOsB,aAAP,KAAyB,QAA7B,EACA;AACE9B,UAAAA,IAAI,GAAG8B,aAAP;AACAtB,UAAAA,MAAM,GAAGR,IAAI,CAACQ,MAAd;AACD,SAJD,MAKK,IAAI,OAAOsB,aAAP,IAAyB,QAA7B,EACL;AACEtB,UAAAA,MAAM,GAAGsB,aAAT;AACD,SAHI,MAKL;AACE,gBAAM,IAAIzC,KAAJ,CAAU,iCAAV,CAAN;AACD,SAhBH,CAkBE;;;AACA,aAAK,IAAI2C,CAAC,GAAC,KAAK1E,QAAL,CAAckD,MAAd,EAAsByB,QAAtB,CAA+BvC,MAA/B,GAAsC,CAAjD,EAAoDsC,CAAC,IAAE,CAAvD,EAA0DA,CAAC,EAA3D,EACA;AACE,eAAKH,KAAL,CAAW,KAAKvE,QAAL,CAAckD,MAAd,EAAsByB,QAAtB,CAA+BD,CAA/B,CAAX,EAA8C,IAA9C;AACD,SAtBH,CAwBE;;;AACA,YAAID,SAAS,IAAIvB,MAAM,IAAI,CAA3B,EACA;AACE;AACAR,UAAAA,IAAI,GAAG,KAAK1C,QAAL,CAAckD,MAAd,CAAP;AACAlE,UAAAA,EAAE,CAAC8D,IAAH,CAAQ8B,KAAR,CAAcC,MAAd,CAAqB,KAAK7E,QAAL,CAAc0C,IAAI,CAACmB,YAAnB,EAAiCc,QAAtD,EACqBzB,MADrB,EAHF,CAME;;AACA,cAAI,KAAK/C,WAAL,CAAiB+C,MAAjB,CAAJ,EACA;AACE,mBAAO,KAAK/C,WAAL,CAAiB+C,MAAjB,CAAP;AACD,WAVH,CAYE;AACA;AACA;;;AACA,eAAKlD,QAAL,CAAckD,MAAd,IAAwB,IAAxB;AACD;AACF,OA5aH;;AA+aE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI4B,MAAAA,IAAI,EAAG,cAASC,iBAAT,EACSC,mBADT,EAEP;AACE,YAAIC,QAAJ;AACA,YAAIC,UAAJ;AACA,YAAIC,UAAJ;AACA,YAAItB,YAAJ,CAJF,CAME;;AACAmB,QAAAA,mBAAmB,GAAGA,mBAAmB,IAAI,CAA7C;;AAEA,YAAI,QAAOD,iBAAP,KAA6B,QAAjC,EACA;AACEE,UAAAA,QAAQ,GAAGF,iBAAX;AACAG,UAAAA,UAAU,GAAGD,QAAQ,CAAC/B,MAAtB;AACD,SAJD,MAKK,IAAI,OAAO6B,iBAAP,IAA6B,QAAjC,EACL;AACEG,UAAAA,UAAU,GAAGH,iBAAb;AACAE,UAAAA,QAAQ,GAAG,KAAKjF,QAAL,CAAckF,UAAd,CAAX;AACD,SAJI,MAML;AACE,gBAAM,IAAInD,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,YAAI,QAAOiD,mBAAP,KAA+B,QAAnC,EACA;AACEG,UAAAA,UAAU,GAAGH,mBAAb;AACAnB,UAAAA,YAAY,GAAGsB,UAAU,CAACjC,MAA1B;AACD,SAJD,MAKK,IAAI,OAAO8B,mBAAP,IAA+B,QAAnC,EACL;AACEnB,UAAAA,YAAY,GAAGmB,mBAAf;AACAG,UAAAA,UAAU,GAAG,KAAKnF,QAAL,CAAc6D,YAAd,CAAb;AACD,SAJI,MAML;AACE,gBAAM,IAAI9B,KAAJ,CAAU,wCAAV,CAAN;AACD,SArCH,CAuCE;;;AACA,YAAIoD,UAAU,CAACC,IAAX,IAAmBpG,EAAE,CAACO,EAAH,CAAMK,WAAN,CAAkBC,cAAlB,CAAiCsE,IAAjC,CAAsCG,IAA7D,EACA;AACE,gBAAM,IAAIvC,KAAJ,CAAU,sCAAV,CAAN;AACD,SA3CH,CA6CE;;;AACA,YAAIsD,SAAS,GAAG,KAAKrF,QAAL,CAAciF,QAAQ,CAACpB,YAAvB,CAAhB;AACA7E,QAAAA,EAAE,CAAC8D,IAAH,CAAQ8B,KAAR,CAAcC,MAAd,CAAqBQ,SAAS,CAACV,QAA/B,EAAyCO,UAAzC,EA/CF,CAiDE;;AACAC,QAAAA,UAAU,CAACR,QAAX,CAAoBvE,IAApB,CAAyB8E,UAAzB,EAlDF,CAoDE;;AACA,aAAKlF,QAAL,CAAckF,UAAd,EAA0BrB,YAA1B,GAAyCA,YAAzC;AACD,OAxfH;;AA2fE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIyB,MAAAA,SAAS,EAAG,mBAASpC,MAAT,EAAiBqC,KAAjB,EACZ;AACE,YAAI/E,MAAM,GAAG,KAAKgF,SAAL,EAAb;AACA,YAAIC,KAAK,GAAG,IAAZ;AACA,YAAIC,WAAJ,CAHF,CAKE;;AACA,YAAIC,WAAW,GAAG,KAAK3F,QAAL,CAAckD,MAAd,EAAsByB,QAAtB,CAA+BvC,MAAjD;AACA,YAAIwD,KAAK,GAAG,CAAZ;AACA,YAAIjB,QAAQ,GAAG,KAAK7D,SAAL,CAAoBoC,MAApB,IAA8B,EAA7C;;AACA,aAAK,IAAIwB,CAAC,GAAC,CAAX,EAAcA,CAAC,GAACiB,WAAhB,EAA6BjB,CAAC,EAA9B,EACA;AACE;AACAgB,UAAAA,WAAW,GAAG,KAAK1F,QAAL,CAAckD,MAAd,EAAsByB,QAAtB,CAA+BD,CAA/B,CAAd,CAFF,CAIE;;AACAe,UAAAA,KAAK,GAAG,KAAKzF,QAAL,CAAc0F,WAAd,CAAR,CALF,CAOE;;AACA,cAAID,KAAK,IAAI,IAAT,IAAkBjF,MAAM,IAAI,CAACA,MAAM,CAACqF,IAAP,CAAY,IAAZ,EAAkBJ,KAAlB,CAAjC,EAA4D;AAC1D,iBAAK1E,SAAL,GAAmC,IAAnC;AACA;AACD,WAXH,CAaE;;;AACA4D,UAAAA,QAAQ,CAACvE,IAAT,CAAcqF,KAAd,EAdF,CAgBE;;AACAA,UAAAA,KAAK,CAACF,KAAN,GAAcA,KAAd,CAjBF,CAmBE;;AACAE,UAAAA,KAAK,CAACK,WAAN,GAAqBF,KAAK,IAAI,CAA9B,CApBF,CAsBE;AACA;AACA;;AACA,cAAI,CAAC,KAAK7E,SAAV,EAAuC;AACrC,iBAAKgF,SAAL,CAAwBN,KAAxB,EAA+Bf,CAAC,IAAIiB,WAAW,GAAG,CAAlD;AACD,WA3BH,CA6BE;;;AACA,cAAI,CAACF,KAAK,CAACtC,UAAX,EACA;AACEsC,YAAAA,KAAK,CAACtC,UAAN,GAAmB,EAAnB;AACD;;AAED,cAAIsC,KAAK,CAACtC,UAAN,CAAiBf,MAAjB,GAA0B,KAAKd,cAAL,EAA9B,EACA;AACEmE,YAAAA,KAAK,CAACtC,UAAN,CAAiB,KAAK7B,cAAL,KAAwB,CAAzC,IAA8C,IAA9C;AACD,WAtCH,CAwCE;;;AACA,cAAI0E,OAAO,GAAG,EAAd,CAzCF,CA2CE;;AACA,cAAIP,KAAK,CAACtC,UAAV,EACA;AACE;AACA,iBAAK,IAAI8C,CAAC,GAAC,CAAX,EAAcA,CAAC,GAACR,KAAK,CAACtC,UAAN,CAAiBf,MAAjC,EAAyC6D,CAAC,EAA1C,EACA;AACE;AACA,kBAAIA,CAAC,IAAI,KAAK/F,WAAd,EACA;AACE;AACA8F,gBAAAA,OAAO,CAAC5F,IAAR,CAAaqF,KAAb;AACD,eAJD,MAMA;AACE;AACAO,gBAAAA,OAAO,CAAC5F,IAAR,CAAaqF,KAAK,CAACtC,UAAN,CAAiB8C,CAAjB,CAAb;AACD;AACF;AACF,WAjBD,MAmBA;AACE;AACAD,YAAAA,OAAO,CAAC5F,IAAR,CAAaqF,KAAb;AACD,WAlEH,CAoEE;AACA;;;AACA,eAAKxF,WAAL,CAAiBwF,KAAK,CAACvC,MAAvB,IAAiC,KAAKnD,OAAL,CAAaqC,MAA9C,CAtEF,CAwEE;;AACA,eAAKrC,OAAL,CAAaK,IAAb,CAAkB4F,OAAlB,EAzEF,CA2EE;;;AACA,cAAIP,KAAK,CAACS,SAAV,EACA;AACE;AACAF,YAAAA,OAAO,CAACG,QAAR,GAAmB,IAAnB;AACA,iBAAKhG,WAAL,CAAiBsF,KAAK,CAACvC,MAAvB,IAAiC,IAAjC;AACD,WAjFH,CAmFE;;;AACA,cAAIuC,KAAK,CAAC3B,OAAV,EACA;AACE;AACA,iBAAKwB,SAAL,CAAeI,WAAf,EAA4BH,KAAK,GAAG,CAApC;AACD;;AACDK,UAAAA,KAAK;AACN;AACF,OAzmBH;;AA4mBE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIQ,MAAAA,SAAyB,EAAG,mBAASlD,MAAT,EAC5B;AACE,YAAImD,YAAY,GAAG,KAAKvF,SAAxB;AACA,YAAI6D,QAAQ,GAAI0B,YAAY,CAACnD,MAAD,CAA5B;AACA,YAAIyC,WAAW,GAAGhB,QAAQ,CAACvC,MAA3B;;AACA,aAAK,IAAIsC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiB,WAApB,EAAiCjB,CAAC,EAAlC,EACA;AACE,cAAIe,KAAK,GAAGd,QAAQ,CAACD,CAAD,CAApB;;AAEA,eAAKqB,SAAL,CAAwBN,KAAxB,EAA+Bf,CAAC,IAAIiB,WAAW,GAAG,CAAlD;;AAEA,cAAIW,WAAW,GAAGD,YAAY,CAACZ,KAAK,CAACvC,MAAP,CAAZ,IAA8BmD,YAAY,CAACZ,KAAK,CAACvC,MAAP,CAAZ,CAA2Bd,MAA3B,GAAoC,CAApF;;AACA,cAAIkE,WAAJ,EAAiB;AACf,iBAAKF,SAAL,CAA+BX,KAAK,CAACvC,MAArC;AACD;AACF;AACF,OApoBH;;AAuoBE;AACJ;AACA;AACA;AACA;AACA;AACI6C,MAAAA,SAAkB,EAAG,mBAASrD,IAAT,EAAe6D,WAAf,EACrB;AACE;AACA7D,QAAAA,IAAI,CAAC8D,SAAL,GAAiB,CAAED,WAAF,CAAjB,CAFF,CAIE;;AACA,YAAIE,MAAM,GAAI,KAAKzG,QAAL,CAAc0C,IAAI,CAACmB,YAAnB,CAAd,CALF,CAOE;;AACA,eAAO4C,MAAM,CAACvD,MAAd,EACA;AACE,cAAIwD,KAAK,GAAGD,MAAM,CAACD,SAAP,CAAiBC,MAAM,CAACD,SAAP,CAAiBpE,MAAjB,GAA0B,CAA3C,CAAZ;AACAM,UAAAA,IAAI,CAAC8D,SAAL,CAAeG,OAAf,CAAuBD,KAAvB;AACAD,UAAAA,MAAM,GAAG,KAAKzG,QAAL,CAAcyG,MAAM,CAAC5C,YAArB,CAAT;AACD;AACF,OA5pBH;;AA+pBE;AACJ;AACA;AACI+C,MAAAA,SAAQ,EAAG,qBACX;AACE;AACA,aAAK9F,SAAL,GAAsB,EAAtB;AACA,aAAKC,SAAL,GAAmC,KAAnC,CAHF,CAKE;;AACA,aAAKhB,OAAL,GAAe,EAAf,CANF,CAQE;;AACA,aAAKE,WAAL,GAAmB,EAAnB,CATF,CAWE;;AACA,aAAKE,WAAL,GAAmB,EAAnB,CAZF,CAcE;AACA;;AACA,aAAKmF,SAAL,CAAe,CAAf,EAAkB,CAAlB,EAhBF,CAkBE;AACA;;;AACA,YAAI,KAAKvE,SAAT,EAAsC;AACpC,eAAKqF,SAAL,CAA+B,CAA/B;AACD,SAtBH,CAwBE;;;AACA,aAAKtF,SAAL,GAAsB,IAAtB,CAzBF,CA2BE;;AACA,YAAI,KAAKsC,WAAL,CAAiB,aAAjB,CAAJ,EACA;AACE,cAAIC,IAAI,GACR;AACEC,YAAAA,QAAQ,EAAM,CADhB;AAEEC,YAAAA,OAAO,EAAO,KAAKxD,OAAL,CAAaqC,MAAb,GAAsB,CAFtC;AAGEoB,YAAAA,WAAW,EAAG,CAHhB;AAIEC,YAAAA,UAAU,EAAI,KAAKnC,cAAL,KAAwB;AAJxC,WADA;AAQA,eAAKoC,aAAL,CAAmB,aAAnB,EAAkCL,IAAlC;AACD;AACF,OA3sBH;;AA8sBE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIwD,MAAAA,OAAO,EAAG,iBAASC,OAAT,EACV;AACE,YAAIA,OAAO,YAAYlC,KAAvB,EACA;AACE;AACA,eAAK5E,QAAL,GAAgB8G,OAAhB;AACD,SAJD,MAKK,IAAIA,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAKlE,SAApC,EACL;AACE,gBAAM,IAAIb,KAAJ,CAAU,mEACiB+E,OADjB,CAAV,CAAN;AAED,SAVH,CAYE;;;AACA,aAAKF,SAAL,GAbF,CAeE;;;AACA,YAAIG,cAAc,GAAG,KAAK7F,OAAL,GAAe8F,iBAAf,EAArB;AACA,YAAIC,UAAU,GAAG,KAAK9G,WAAtB;;AACA,aAAK,IAAI+C,MAAT,IAAmB+D,UAAnB,EACA;AACE,cAAIC,SAAS,GAAG,KAAKC,gBAAL,CAAsBjE,MAAtB,CAAhB;AACA6D,UAAAA,cAAc,CAACK,oBAAf,CAAoCF,SAApC,EAA+CA,SAA/C;AACD;AACF,OA3vBH;;AA8vBE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIG,MAAAA,OAAO,EAAG,mBACV;AACE,eAAO,KAAKrH,QAAZ;AACD,OAzwBH;;AA4wBE;AACJ;AACA;AACA;AACIsH,MAAAA,SAAS,EAAG,qBACZ;AACE,aAAKC,gBAAL;;AACA,aAAKV,OAAL,CAAa,CAAE7H,EAAE,CAACO,EAAH,CAAMK,WAAN,CAAkBC,cAAlB,CAAiCQ,aAAjC,EAAF,CAAb;AACD,OApxBH;;AAuxBE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACImH,MAAAA,aAAa,EAAG,uBAAStE,MAAT,EAAiBzB,WAAjB,EAA8B4B,IAA9B,EAChB;AACE,aAAKrD,QAAL,CAAckD,MAAd,EAAsBC,UAAtB,CAAiC1B,WAAjC,IAAgD4B,IAAhD;AACD,OAzyBH;;AA4yBE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIoE,MAAAA,aAAa,EAAG,uBAASvE,MAAT,EAAiBzB,WAAjB,EAChB;AACE,eAAO,KAAKzB,QAAL,CAAckD,MAAd,EAAsBC,UAAtB,CAAiC1B,WAAjC,CAAP;AACD,OA5zBH;;AA+zBE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIiG,MAAAA,QAAQ,EAAG,kBAASlD,aAAT,EAAwBmD,UAAxB,EACX;AACE,YAAIjF,IAAJ;AACA,YAAIQ,MAAJ;;AAEA,YAAI,QAAOsB,aAAP,KAAyB,QAA7B,EACA;AACE9B,UAAAA,IAAI,GAAG8B,aAAP;AACAtB,UAAAA,MAAM,GAAGR,IAAI,CAACQ,MAAd;AACD,SAJD,MAKK,IAAI,OAAOsB,aAAP,IAAyB,QAA7B,EACL;AACEtB,UAAAA,MAAM,GAAGsB,aAAT;AACA9B,UAAAA,IAAI,GAAG,KAAK1C,QAAL,CAAckD,MAAd,CAAP;AACD,SAJI,MAML;AACE,gBAAM,IAAInB,KAAJ,CAAU,iCAAV,CAAN;AACD;;AAED,aAAK,IAAI6F,SAAT,IAAsBD,UAAtB,EACA;AACE;AACA,kBAAOC,SAAP;AAEA,iBAAK,WAAL;AACE,kBAAIV,SAAS,GAAG,KAAKC,gBAAL,CAAsBjE,MAAtB,CAAhB;AACA,kBAAI6D,cAAc,GAAG,KAAK7F,OAAL,GAAe8F,iBAAf,EAArB;AACA,kBAAIa,EAAE,GAAG7I,EAAE,CAACO,EAAH,CAAMK,WAAN,CAAkBkI,WAA3B;AACA,kBAAIC,gBAAgB,GACjB,OAAOb,SAAP,KAAsB,QAAtB,IACA,KAAKhG,OAAL,GAAe8G,gBAAf,MAAqCH,EAAE,CAACI,aAAH,CAAiBC,IAFzD,CAJF,CAQE;;AACA,kBAAIP,UAAU,CAACC,SAAD,CAAd,EACA;AACE,qBAAKzH,WAAL,CAAiB+C,MAAjB,IAA2B,IAA3B,CADF,CAGE;;AACA,oBAAI6E,gBAAgB,IAChB,CAAEhB,cAAc,CAACoB,eAAf,CAA+BjB,SAA/B,CADN,EAEA;AACEH,kBAAAA,cAAc,CAACK,oBAAf,CAAoCF,SAApC,EAA+CA,SAA/C;AACD;AACF,eAVD,MAYA;AACE,uBAAO,KAAK/G,WAAL,CAAiB+C,MAAjB,CAAP,CADF,CAGE;;AACA,oBAAI6E,gBAAgB,IAChBhB,cAAc,CAACoB,eAAf,CAA+BjB,SAA/B,CADJ,EAEA;AACEH,kBAAAA,cAAc,CAACqB,uBAAf,CAAuClB,SAAvC,EAAkDA,SAAlD;AACD;AACF;;AACD;;AAEF,iBAAK,SAAL;AACE;AACA,kBAAIxE,IAAI,CAAC0C,IAAL,KAAcpG,EAAE,CAACO,EAAH,CAAMK,WAAN,CAAkBC,cAAlB,CAAiCsE,IAAjC,CAAsCG,IAAxD,EAA8D;AAC5D;AACD,eAJH,CAME;AACA;;;AACA,kBAAIqD,UAAU,CAACC,SAAD,CAAV,IAAyBlF,IAAI,CAACoB,OAAlC,EACA;AACE;AACD,eAXH,CAaE;;;AACA,kBAAI7C,IAAI,GAAG,KAAKJ,SAAhB,CAdF,CAgBE;;AACA,kBAAI6B,IAAI,CAACoB,OAAT,EACA;AACE;AACA;AACA7C,gBAAAA,IAAI,CAACyC,aAAL,CAAmB,WAAnB,EAAgChB,IAAhC;AACD,eALD,MAOA;AACE;AACA,oBAAIA,IAAI,CAACiC,QAAL,CAAcvC,MAAd,GAAuB,CAA3B,EACA;AACE;AACA;AACAnB,kBAAAA,IAAI,CAACyC,aAAL,CAAmB,qBAAnB,EAA0ChB,IAA1C;AACD,iBALD,MAOA;AACE;AACA;AACAzB,kBAAAA,IAAI,CAACyC,aAAL,CAAmB,oBAAnB,EAAyChB,IAAzC;AACD;AACF,eAtCH,CAwCE;AACA;;;AACA,kBAAI,CAACA,IAAI,CAAC2F,cAAV,EACA;AACE;AACA3F,gBAAAA,IAAI,CAACoB,OAAL,GAAe,CAACpB,IAAI,CAACoB,OAArB,CAFF,CAIE;;AACA7C,gBAAAA,IAAI,CAAC+F,iBAAL,GAAyBsB,eAAzB;AACD,eAjDH,CAmDE;AACA;;;AACA,mBAAKzB,OAAL;AACA;;AAEF;AACE;AACA;AA7FF,WAFF,CAkGE;;;AACAnE,UAAAA,IAAI,CAACkF,SAAD,CAAJ,GAAkBD,UAAU,CAACC,SAAD,CAA5B;AACD;AACF,OAz8BH;;AA48BE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIW,MAAAA,aAAa,EAAG,yBAChB;AACE,eAAO,KAAKtI,WAAZ;AACD,OAv9BH;;AAy9BE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIkH,MAAAA,gBAAgB,EAAG,0BAASjE,MAAT,EACnB;AACE,eAAO,KAAKjD,WAAL,CAAiBiD,MAAjB,CAAP;AACD,OAp+BH;;AAs+BE;AACJ;AACA;AACA;AACA;AACA;AACA;AACIP,MAAAA,cAAc,EAAG,wBAASL,QAAT,EACjB;AACE,eAAO,KAAKtC,QAAL,CAAc,KAAKD,OAAL,CAAauC,QAAb,EAAuB,KAAKpC,WAA5B,EAAyCgD,MAAvD,CAAP;AACD,OAh/BH;;AAm/BE;AACJ;AACA;AACA;AACA;AACA;AACIqE,MAAAA,gBAAgB,EAAG,4BACnB;AACE;AACA,aAAK,IAAIiB,SAAT,IAAsB,KAAKrI,WAA3B,EACA;AACE,eAAKH,QAAL,CAAcwI,SAAd,EAAyBtC,SAAzB,GAAqC,KAArC;AACD,SALH,CAOE;;;AACA,aAAK/F,WAAL,GAAmB,EAAnB;AACD,OAngCH;;AAsgCE;AACJ;AACA;AACA;AACA;AACA;AACIsI,MAAAA,gBAAgB,EAAG,4BACnB;AACE,YAAIC,KAAK,GAAG,EAAZ;;AAEA,aAAK,IAAIxF,MAAT,IAAmB,KAAK/C,WAAxB,EACA;AACEuI,UAAAA,KAAK,CAACtI,IAAN,CAAW,KAAKJ,QAAL,CAAckD,MAAd,CAAX;AACD;;AAED,eAAOwF,KAAP;AACD,OAthCH;AAyhCE;AACAC,MAAAA,YAAY,EAAG,sBAASlG,KAAT,EAAgBmG,GAAhB,EACf;AACE,aAAK/B,OAAL;AACD,OA7hCH;;AA+hCE;AACJ;AACA;AACA;AACA;AACA;AACA;AACIgC,MAAAA,cAAc,EAAG,wBAASvG,QAAT,EACjB;AACE,eAAO,KAAKzB,SAAL,CAAYc,gBAAZ,MAAkC,KAAKgB,cAAL,CAAoBL,QAApB,EAA8BwG,QAAvE;AACD;AAziCH,KA9DF;AA0mCEC,IAAAA,QAAQ,EAAG,oBACX;AACE,WAAKhJ,OAAL,GAAe,KAAKC,QAAL,GAAgB,KAAKC,WAAL,GAAmB,KAAKE,WAAL,GAChD,KAAKU,SAAL,GAAc,KAAKC,SAAL,GAAsB,IADtC;AAED,KA9mCH;AAgnCEkI,IAAAA,KAAK,EAAG,eAASC,OAAT,EACR;AACE;AACA;AACAA,MAAAA,OAAO,CAAC9E,IAAR,GAAenF,EAAE,CAACO,EAAH,CAAMK,WAAN,CAAkBC,cAAlB,CAAiCsE,IAAhD;AACD;AArnCH,GADA;AAvFAnF,EAAAA,EAAE,CAACO,EAAH,CAAMK,WAAN,CAAkBsJ,mBAAlB,CAAsC/J,aAAtC,GAAsDA,aAAtD",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007-2010 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * A simple tree data model used as the table model\n *\n * The object structure of a single node of the tree is:\n *\n * <pre class='javascript'>\n * {\n *   // USER-PROVIDED ATTRIBUTES\n *   // ------------------------\n *   type           : qx.ui.treevirtual.MTreePrimitive.Type.LEAF,\n *   parentNodeId   : 23,    // index of the parent node in _nodeArr\n *\n *   label          : \"My Documents\",\n *   bSelected      : true,  // true if node is selected; false otherwise.\n *   bOpened        : true,  // true (-), false (+)\n *   bHideOpenClose : false, // whether to hide the open/close button\n *   bCanEdit       : true,  // true if the node label can be edited, false to prevent edit\n *   icon           : \"images/folder.gif\",\n *   iconSelected   : \"images/folder_selected.gif\",\n *\n *   cellStyle      : \"background-color:cyan\"\n *   labelStyle     : \"background-color:red;color:white\"\n *\n *   // USER-PROVIDED COLUMN DATA\n *   columnData     : [\n *                      null, // null at index of tree column (typically 0)\n *                      \"text of column 1\",\n *                      \"text of column 2\"\n *                    ],\n *\n *   // APPLICATION-, MIXIN-, and SUBCLASS-PROVIDED CUSTOM DATA\n *   data           : {\n *                      application :\n *                      {\n *                          // application-specific user data goes in here\n *                          foo: \"bar\",\n *                          ...\n *                      },\n *                      MDragAndDropSupport :\n *                      {\n *                          // Data required for the Drag & Drop mixin.\n *                          // When a mixin is included, its constructor\n *                          // should create this object, named according\n *                          // to the mixin or subclass name (empty or\n *                          // otherwise)\n *                      },\n *                      ... // Additional mixins or subclasses.\n *                    },\n *\n *   // INTERNALLY-CALCULATED ATTRIBUTES\n *   // --------------------------------\n *   // The following properties need not (and should not) be set by the\n *   // caller, but are automatically calculated.  Some are used internally,\n *   // while others may be of use to event listeners.\n *\n *   nodeId         : 42,   // The index in _nodeArr, useful to event listeners.\n *   children       : [ ],  // each value is an index into _nodeArr\n *\n *   level          : 2,    // The indentation level of this tree node\n *   labelPos       : 40,   // The left position of the label text - stored when the cell is rendered\n *\n *   bFirstChild    : true,\n *   lastChild      : [ false ],  // Array where the index is the column of\n *                                // indentation, and the value is a boolean.\n *                                // These are used to locate the\n *                                // appropriate \"tree line\" icon.\n * }\n * </pre>\n */\nqx.Class.define(\"qx.ui.treevirtual.SimpleTreeDataModel\",\n{\n  extend : qx.ui.table.model.Abstract,\n\n  include : qx.ui.treevirtual.MTreePrimitive,\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  construct : function()\n  {\n    this.base(arguments);\n\n    this._rowArr = []; // rows, resorted into tree order as necessary\n    this._nodeArr = []; // tree nodes, organized with hierarchy\n\n    this._nodeRowMap = []; // map nodeArr index to rowArr index.  The\n                           // index of this array is the index of\n                           // _nodeArr, and the values in this array are\n                           // the indexes into _rowArr.\n\n    this._treeColumn = 0; // default column for tree nodes\n\n    this._selections = {}; // list of indexes of selected nodes\n\n    // the root node, needed to store its children\n    this._nodeArr.push(qx.ui.treevirtual.MTreePrimitive._getEmptyTree());\n\n    // Track which columns are editable\n    this.__editableColArr = null;\n  },\n\n\n  properties :\n  {\n    /**\n     * Gives the user the opportunity to filter the model. The filter\n     * function is called for every node in the model. It gets as an argument the\n     * <code>node</code> object and has to return\n     * <code>true</code> if the given data should be shown and\n     * <code>false</code> if the given data should be ignored.\n     */\n    filter :\n    {\n      check : \"Function\",\n      nullable : true,\n      apply : \"_applyFilter\"\n    }\n  },\n\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n    __tree           : null,\n    __editableColArr : null,\n    __tempTreeData : null,\n    __recalculateLastChildFlags : null,\n\n    /** Rows, resorted into tree order as necessary */\n    _rowArr : null,\n\n    /** Tree nodes, organized with hierarchy */\n    _nodeArr : null,\n\n    /**\n     * Map nodeArr index to rowArr index.  The index of this array is the\n     * index of _nodeArr, and the values in this array are the indexes into\n     * _rowArr.\n     */\n    _nodeRowMap : null,\n\n    /** Column for tree nodes */\n    _treeColumn : null,\n\n    /** list of indexes of selected nodes */\n    _selections : null,\n\n    /**\n     * Set the tree object for which this data model is used.\n     *\n     * @param tree {qx.ui.treevirtual.TreeVirtual}\n     *    The tree used to render the data in this model.\n     *\n     */\n    setTree : function(tree)\n    {\n      this.__tree = tree;\n    },\n\n    /**\n     * Get the tree object for which this data model is used.\n     *\n     * @return {qx.ui.treevirtual.TreeVirtual}\n     */\n    getTree : function()\n    {\n      return this.__tree;\n    },\n\n    /**\n     * Sets all columns editable or not editable.\n     *\n     * @param editable {Boolean}\n     *   Whether all columns are editable.\n     *\n     */\n    setEditable : function(editable)\n    {\n      this.__editableColArr = [];\n\n      for (var col=0; col<this.getColumnCount(); col++)\n      {\n        this.__editableColArr[col] = editable;\n      }\n\n      this.fireEvent(\"metaDataChanged\");\n    },\n\n\n    /**\n     * Sets whether a column is editable.\n     *\n     * @param columnIndex {Integer}\n     *   The column of which to set the editable state.\n     *\n     * @param editable {Boolean}\n     *   Whether the column should be editable.\n     *\n     */\n    setColumnEditable : function(columnIndex, editable)\n    {\n      if (editable != this.isColumnEditable(columnIndex))\n      {\n        if (this.__editableColArr == null)\n        {\n          this.__editableColArr = [];\n        }\n\n        this.__editableColArr[columnIndex] = editable;\n\n        this.fireEvent(\"metaDataChanged\");\n      }\n    },\n\n    // overridden\n    isColumnEditable : function(columnIndex)\n    {\n      if (columnIndex == this._treeColumn)\n      {\n        return this.__tree.getAllowNodeEdit();\n      }\n\n      return(this.__editableColArr\n             ? this.__editableColArr[columnIndex] == true\n             : false);\n    },\n\n\n    // overridden\n    isColumnSortable : function(columnIndex)\n    {\n      return false;\n    },\n\n\n    /**\n     * Sorts the model by a column.\n     *\n     * @param columnIndex {Integer} the column to sort by.\n     * @param ascending {Boolean} whether to sort ascending.\n     * @throws {Error} If one tries to sort the tree by column\n     */\n    sortByColumn : function(columnIndex, ascending)\n    {\n      throw new Error(\"Trees can not be sorted by column\");\n    },\n\n\n    /**\n     * Returns the column index the model is sorted by. This model is never\n     * sorted, so -1 is returned.\n     *\n     * @return {Integer}\n     *   -1, to indicate that the model is not sorted.\n     */\n    getSortColumnIndex : function()\n    {\n      return -1;\n    },\n\n\n    /**\n     * Specifies which column the tree is to be displayed in.  The tree is\n     * displayed using the SimpleTreeDataCellRenderer.  Other columns may be\n     * provided which use different cell renderers.\n     *\n     * Setting the tree column involves more than simply setting this column\n     * index; it also requires setting an appropriate cell renderer for this\n     * column, that knows how to render a tree. The expected and typical\n     * method of setting the tree column is to provide it in the 'custom'\n     * parameter to the TreeVirtual constructor, which also initializes the\n     * proper cell renderers. This method does not set any cell renderers. If\n     * you wish to call this method on your own, you should also manually set\n     * the cell renderer for the specified column, and likely also set the\n     * cell renderer for column 0 (the former tree column) to something\n     * appropriate to your data.\n     *\n     *\n     * @param columnIndex {Integer}\n     *   The index of the column in which the tree should be displayed.\n     *\n     */\n    setTreeColumn : function(columnIndex)\n    {\n      this._treeColumn = columnIndex;\n    },\n\n\n    /**\n     * Get the column in which the tree is to be displayed.\n     *\n     * @return {Integer}\n     *   The column in which the tree is to be displayed\n     */\n    getTreeColumn : function()\n    {\n      return this._treeColumn;\n    },\n\n    // overridden\n    getRowCount : function()\n    {\n      return this._rowArr.length;\n    },\n\n    // overridden\n    getRowData : function(rowIndex)\n    {\n      return this._rowArr[rowIndex];\n    },\n\n\n    /**\n     * Returns a cell value by column index.\n     *\n     * @throws {Error} if the row index is out of bounds.\n     * @param columnIndex {Integer} the index of the column.\n     * @param rowIndex {Integer} the index of the row.\n     * @return {var} The value of the cell.\n     * @see #getValueById\n     */\n    getValue : function(columnIndex, rowIndex)\n    {\n      if (rowIndex < 0 || rowIndex >= this._rowArr.length)\n      {\n        throw new Error(\"this._rowArr row \" +\n                        \"(\" + rowIndex + \") out of bounds: \" +\n                        this._rowArr +\n                        \" (0..\" + (this._rowArr.length - 1) + \")\");\n      }\n\n      if (columnIndex < 0 || columnIndex >= this._rowArr[rowIndex].length)\n      {\n        throw new Error(\"this._rowArr column \" +\n                        \"(\" + columnIndex + \") out of bounds: \" +\n                        this._rowArr[rowIndex] +\n                        \" (0..\" + (this._rowArr[rowIndex].length - 1) + \")\");\n      }\n\n      return this._rowArr[rowIndex][columnIndex];\n    },\n\n\n    // overridden\n    setValue : function(columnIndex, rowIndex, value)\n    {\n      // convert from rowArr to nodeArr, and get the requested node\n      var node = this.getNodeFromRow(rowIndex);\n\n      if (columnIndex === this._treeColumn)\n      {\n        if (!this.__tree.getAllowNodeEdit() || value[\"label\"] === undefined) {\n          return;\n        }\n        // only allow to set the node label via this method, clone the original node\n        var updatedNode = qx.lang.Object.clone(node);\n        updatedNode.label = value.label;\n        this._nodeArr[node.nodeId] = updatedNode;\n      } else {\n        if (node.columnData[columnIndex] == value) {\n          return;\n        }\n        node.columnData[columnIndex] = value;\n        this._rowArr[rowIndex][columnIndex] = value;\n      }\n      // Inform the listeners\n      if (this.hasListener(\"dataChanged\"))\n      {\n        var data = {\n          firstRow: rowIndex,\n          lastRow: rowIndex,\n          firstColumn: columnIndex,\n          lastColumn: columnIndex\n        };\n        this.fireDataEvent(\"dataChanged\", data);\n      }\n    },\n\n\n    /**\n     * Returns the node object specific to a currently visible row. In this\n     * simple tree data model, that's the same as retrieving the value of the\n     * tree column of the specified row.\n     *\n     * @throws {Error}\n     *   Thrown if the row index is out of bounds.\n     *\n     * @param rowIndex {Integer}\n     *   The index of the row.\n     *\n     * @return {Object}\n     *   The node object associated with the specified row.\n     */\n    getNode : function(rowIndex)\n    {\n      if (rowIndex < 0 || rowIndex >= this._rowArr.length)\n      {\n        throw new Error(\"this._rowArr row \" +\n                        \"(\" + rowIndex + \") out of bounds: \" +\n                        this._rowArr +\n                        \" (0..\" + (this._rowArr.length - 1) + \")\");\n      }\n\n      return this._rowArr[rowIndex][this._treeColumn];\n    },\n\n\n    /**\n     * Add a branch to the tree.\n     *\n     * @param parentNodeId {Integer}\n     *   The node id of the parent of the node being added\n     *\n     * @param label {String}\n     *   The string to display as the label for this node\n     *\n     * @param bOpened {Boolean}\n     *   <i>True</i> if the branch should be rendered in its opened state;\n     *   <i>false</i> otherwise.\n     *\n     * @param bHideOpenCloseButton {Boolean}\n     *   <i>True</i> if the open/close button should not be displayed;\n     *   <i>false</i> if the open/close button should be displayed\n     *\n     * @param icon {String}\n     *   The relative (subject to alias expansion) or full path of the icon to\n     *   display for this node when it is not a selected node.\n     *\n     * @param iconSelected {String}\n     *   The relative (subject to alias expansion) or full path of the icon to\n     *   display for this node when it is a selected node.\n     *\n     * @return {Integer}\n     *   The node id of the newly-added branch.\n     */\n    addBranch : function(parentNodeId,\n                         label,\n                         bOpened,\n                         bHideOpenCloseButton,\n                         icon,\n                         iconSelected)\n    {\n      return qx.ui.treevirtual.MTreePrimitive._addNode(\n        this._nodeArr,\n        parentNodeId,\n        label,\n        bOpened,\n        bHideOpenCloseButton,\n        qx.ui.treevirtual.MTreePrimitive.Type.BRANCH,\n        icon,\n        iconSelected);\n    },\n\n\n    /**\n     * Add a leaf to the tree.\n     *\n     * @param parentNodeId {Integer}\n     *   The node id of the parent of the node being added\n     *\n     * @param label {String}\n     *   The string to display as the label for this node\n     *\n     * @param icon {String}\n     *   The relative (subject to alias expansion) or full path of the icon to\n     *   display for this node when it is not a selected node.\n     *\n     * @param iconSelected {String}\n     *   The relative (subject to alias expansion) or full path of the icon to\n     *   display for this node when it is a selected node.\n     *\n     * @return {Integer} The node id of the newly-added leaf.\n     */\n    addLeaf : function(parentNodeId,\n                       label,\n                       icon,\n                       iconSelected)\n    {\n      return qx.ui.treevirtual.MTreePrimitive._addNode(\n        this._nodeArr,\n        parentNodeId,\n        label,\n        false,\n        false,\n        qx.ui.treevirtual.MTreePrimitive.Type.LEAF,\n        icon,\n        iconSelected);\n    },\n\n\n    /**\n     * Prune the tree by removing, recursively, all of a node's children.  If\n     * requested, also remove the node itself.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node to be pruned from the tree.  The node can be represented\n     *   either by the node object, or the node id (as would have been\n     *   returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param bSelfAlso {Boolean}\n     *   If <i>true</i> then remove the node identified by <i>nodeId</i> as\n     *   well as all of the children.\n     *\n     * @throws {Error} If the node object or id is not valid.\n     *\n     */\n    prune : function(nodeReference, bSelfAlso)\n    {\n      var node;\n      var nodeId;\n\n      if (typeof(nodeReference) == \"object\")\n      {\n        node = nodeReference;\n        nodeId = node.nodeId;\n      }\n      else if (typeof(nodeReference) == \"number\")\n      {\n        nodeId = nodeReference;\n      }\n      else\n      {\n        throw new Error(\"Expected node object or node id\");\n      }\n\n      // First, recursively remove all children\n      for (var i=this._nodeArr[nodeId].children.length-1; i>=0; i--)\n      {\n        this.prune(this._nodeArr[nodeId].children[i], true);\n      }\n\n      // Now remove ourself, if requested. (Don't try to remove the root node)\n      if (bSelfAlso && nodeId != 0)\n      {\n        // Delete ourself from our parent's children list\n        node = this._nodeArr[nodeId];\n        qx.lang.Array.remove(this._nodeArr[node.parentNodeId].children,\n                             nodeId);\n\n        // Delete ourself from the selections list, if we're in it.\n        if (this._selections[nodeId])\n        {\n          delete this._selections[nodeId];\n        }\n\n        // We can't splice the node itself out, because that would muck up the\n        // nodeId == index correspondence.  Instead, just replace the node\n        // with null so its index just becomes unused.\n        this._nodeArr[nodeId] = null;\n      }\n    },\n\n\n    /**\n     * Move a node in the tree.\n     *\n     * @param moveNodeReference {Object | Integer}\n     *   The node to be moved.  The node can be represented\n     *   either by the node object, or the node id (as would have been\n     *   returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param parentNodeReference {Object | Integer}\n     *   The new parent node, which must not be a LEAF.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @throws {Error} If the node object or id is not valid.\n     * @throws {Error} If one tries to add a child to a non-existent parent.\n     * @throws {Error} If one tries to add a node to a leaf.\n     */\n    move : function(moveNodeReference,\n                    parentNodeReference)\n    {\n      var moveNode;\n      var moveNodeId;\n      var parentNode;\n      var parentNodeId;\n\n      // Replace null parent with node id 0\n      parentNodeReference = parentNodeReference || 0;\n\n      if (typeof(moveNodeReference) == \"object\")\n      {\n        moveNode = moveNodeReference;\n        moveNodeId = moveNode.nodeId;\n      }\n      else if (typeof(moveNodeReference) == \"number\")\n      {\n        moveNodeId = moveNodeReference;\n        moveNode = this._nodeArr[moveNodeId];\n      }\n      else\n      {\n        throw new Error(\"Expected move node object or node id\");\n      }\n\n      if (typeof(parentNodeReference) == \"object\")\n      {\n        parentNode = parentNodeReference;\n        parentNodeId = parentNode.nodeId;\n      }\n      else if (typeof(parentNodeReference) == \"number\")\n      {\n        parentNodeId = parentNodeReference;\n        parentNode = this._nodeArr[parentNodeId];\n      }\n      else\n      {\n        throw new Error(\"Expected parent node object or node id\");\n      }\n\n      // Ensure parent isn't a leaf\n      if (parentNode.type == qx.ui.treevirtual.MTreePrimitive.Type.LEAF)\n      {\n        throw new Error(\"Sorry, a LEAF may not have children.\");\n      }\n\n      // Remove the node from its current parent's children list\n      var oldParent = this._nodeArr[moveNode.parentNodeId];\n      qx.lang.Array.remove(oldParent.children, moveNodeId);\n\n      // Add the node to its new parent's children list\n      parentNode.children.push(moveNodeId);\n\n      // Replace this node's parent reference\n      this._nodeArr[moveNodeId].parentNodeId = parentNodeId;\n    },\n\n\n    /**\n     * Orders the node and creates all data needed to render the tree.\n     *\n     * @param nodeId {Integer}\n     *   A node identifier, as previously returned by {@link #addBranch} or\n     *   {@link #addLeaf}.\n     * @param level {Integer} the level in the hierarchy\n     */\n    __inorder : function(nodeId, level)\n    {\n      var filter = this.getFilter();\n      var child = null;\n      var childNodeId;\n\n      // For each child of the specified node...\n      var numChildren = this._nodeArr[nodeId].children.length;\n      var index = 0;\n      var children = this.__tempTreeData[nodeId] = [];\n      for (var i=0; i<numChildren; i++)\n      {\n        // Determine the node id of this child\n        childNodeId = this._nodeArr[nodeId].children[i];\n\n        // Get the child node\n        child = this._nodeArr[childNodeId];\n\n        // Skip deleted nodes or apply the filter\n        if (child == null || (filter && !filter.call(this, child))) {\n          this.__recalculateLastChildFlags = true;\n          continue;\n        }\n\n        // Remember the children so that we can add the lastChild flags later\n        children.push(child);\n\n        // (Re-)assign this node's level\n        child.level = level;\n\n        // Determine if we're the first child of our parent\n        child.bFirstChild = (index == 0);\n\n        // Set the last child flag of the node only when no node was skipped.\n        // Otherwise we will have to recalculate the last child flags, as\n        // the parent or sibling node might become the first child.\n        if (!this.__recalculateLastChildFlags) {\n          this.__setLastChildFlag(child, i == numChildren - 1);\n        }\n\n        // Ensure there's an entry in the columnData array for each column\n        if (!child.columnData)\n        {\n          child.columnData = [ ];\n        }\n\n        if (child.columnData.length < this.getColumnCount())\n        {\n          child.columnData[this.getColumnCount() - 1] = null;\n        }\n\n        // Add this node to the row array.  Initialize a row data array.\n        var rowData = [ ];\n\n        // If additional column data is provided...\n        if (child.columnData)\n        {\n          // ... then add each column data.\n          for (var j=0; j<child.columnData.length; j++)\n          {\n            // Is this the tree column?\n            if (j == this._treeColumn)\n            {\n              // Yup.  Add the tree node data\n              rowData.push(child);\n            }\n            else\n            {\n              // Otherwise, add the column data verbatim.\n              rowData.push(child.columnData[j]);\n            }\n          }\n        }\n        else\n        {\n          // No column data.  Just add the tree node.\n          rowData.push(child);\n        }\n\n        // Track the _rowArr index for each node so we can handle\n        // selections.\n        this._nodeRowMap[child.nodeId] = this._rowArr.length;\n\n        // Add the row data to the row array\n        this._rowArr.push(rowData);\n\n        // If this node is selected, ...\n        if (child.bSelected)\n        {\n          // ... indicate so for the row.\n          rowData.selected = true;\n          this._selections[child.nodeId] = true;\n        }\n\n        // If this child is opened, ...\n        if (child.bOpened)\n        {\n          // ... then add its children too.\n          this.__inorder(childNodeId, level + 1);\n        }\n        index++;\n      }\n    },\n\n\n    /**\n     * Calculates the lastChild flags to the nodes, so that the tree can render the\n     * tree lines right.\n     *\n     * @param nodeId {Integer}\n     *   A node identifier, as previously returned by {@link #addBranch} or\n     *   {@link #addLeaf}.\n     */\n    __calculateLastChildFlags : function(nodeId)\n    {\n      var tempTreeData = this.__tempTreeData;\n      var children =  tempTreeData[nodeId];\n      var numChildren = children.length;\n      for (var i = 0; i < numChildren; i++)\n      {\n        var child = children[i];\n\n        this.__setLastChildFlag(child, i == numChildren - 1);\n\n        var hasChildren = tempTreeData[child.nodeId] && tempTreeData[child.nodeId].length > 0;\n        if (hasChildren) {\n          this.__calculateLastChildFlags(child.nodeId);\n        }\n      }\n    },\n\n\n    /**\n     * Sets the last child flag for a node and all it's parents.\n     *\n     * @param node {Object} the node object\n     * @param isLastChild {Boolean} whether the node is the last child\n     */\n    __setLastChildFlag : function(node, isLastChild)\n    {\n      // Determine if we're the last child of our parent\n      node.lastChild = [ isLastChild ];\n\n      // Get our parent.\n      var parent =  this._nodeArr[node.parentNodeId];\n\n      // For each parent node, determine if it is a last child\n      while (parent.nodeId)\n      {\n        var bLast = parent.lastChild[parent.lastChild.length - 1];\n        node.lastChild.unshift(bLast);\n        parent = this._nodeArr[parent.parentNodeId];\n      }\n    },\n\n\n    /**\n     * Renders the tree data.\n     */\n    __render : function()\n    {\n      // Reset the __tempTreeData\n      this.__tempTreeData = [];\n      this.__recalculateLastChildFlags = false;\n\n      // Reset the row array\n      this._rowArr = [];\n\n      // Reset the _nodeArr -> _rowArr map\n      this._nodeRowMap = [];\n\n      // Reset the set of selections\n      this._selections = {};\n\n      // Begin in-order traversal of the tree from the root to regenerate\n      // _rowArr.\n      this.__inorder(0, 1);\n\n      // Reset the lastChild flags when needed, so that the tree can render the\n      // tree lines right.\n      if (this.__recalculateLastChildFlags) {\n        this.__calculateLastChildFlags(0);\n      }\n\n      // Give the memory free\n      this.__tempTreeData = null;\n\n      // Inform the listeners\n      if (this.hasListener(\"dataChanged\"))\n      {\n        var data =\n        {\n          firstRow    : 0,\n          lastRow     : this._rowArr.length - 1,\n          firstColumn : 0,\n          lastColumn  : this.getColumnCount() - 1\n        };\n\n        this.fireDataEvent(\"dataChanged\", data);\n      }\n    },\n\n\n    /**\n     * Sets the whole data en bulk, or notifies the data model that node\n     * modifications are complete.\n     *\n     * @param nodeArr {Array | null}\n     *   Pass either an Array of node objects, or null.\n     *\n     *   If non-null, nodeArr is an array of node objects containing the\n     *   entire tree to be displayed.  If loading the whole data en bulk in\n     *   this way, it is assumed that the data is correct!  No error checking\n     *   or validation is done.  You'd better know what you're doing!  Caveat\n     *   emptor.\n     *\n     *\n     *   If nodeArr is null, then this call is a notification that the user\n     *   has completed building or modifying a tree by issuing a series of\n     *   calls to {@link #addBranch} and/or {@link #addLeaf}.\n     *\n     *\n     * @throws {Error} If the parameter has the wrong type.\n     */\n    setData : function(nodeArr)\n    {\n      if (nodeArr instanceof Array)\n      {\n        // Save the user-supplied data.\n        this._nodeArr = nodeArr;\n      }\n      else if (nodeArr !== null && nodeArr !== undefined)\n      {\n        throw new Error(\"Expected array of node objects or null/undefined; \" +\n                        \"got \" + typeof (nodeArr));\n      }\n\n      // Re-render the row array\n      this.__render();\n\n      // Set selections in the selection model now\n      var selectionModel = this.getTree().getSelectionModel();\n      var selections = this._selections;\n      for (var nodeId in selections)\n      {\n        var nRowIndex = this.getRowFromNodeId(nodeId);\n        selectionModel.setSelectionInterval(nRowIndex, nRowIndex);\n      }\n    },\n\n\n    /**\n     * Return the array of node data.\n     *\n     * @return {Array}\n     *  Array of node objects.\n     *  See {@link qx.ui.treevirtual.SimpleTreeDataModel} for a description\n     *  nodes in this array.\n     */\n    getData : function()\n    {\n      return this._nodeArr;\n    },\n\n\n    /**\n     * Clears the tree of all nodes\n     *\n     */\n    clearData : function ()\n    {\n      this._clearSelections();\n      this.setData([ qx.ui.treevirtual.MTreePrimitive._getEmptyTree() ]);\n    },\n\n\n    /**\n     * Add data to an additional column (a column other than the tree column)\n     * of the tree.\n     *\n     * @param nodeId {Integer}\n     *   A node identifier, as previously returned by {@link #addBranch} or\n     *   {@link #addLeaf}.\n     *\n     * @param columnIndex {Integer}\n     *   The column number to which the provided data applies\n     *\n     * @param data {var}\n     *   The cell data for the specified column\n     *\n     */\n    setColumnData : function(nodeId, columnIndex, data)\n    {\n      this._nodeArr[nodeId].columnData[columnIndex] = data;\n    },\n\n\n    /**\n     * Retrieve the data from an additional column (a column other than the\n     * tree column) of the tree.\n     *\n     * @param nodeId {Integer}\n     *   A node identifier, as previously returned by {@link #addBranch} or\n     *   {@link #addLeaf}.\n     *\n     * @param columnIndex {Integer}\n     *   The column number to which the provided data applies\n     *\n     * @return {var} The cell data for the specified column\n     */\n    getColumnData : function(nodeId, columnIndex)\n    {\n      return this._nodeArr[nodeId].columnData[columnIndex];\n    },\n\n\n    /**\n     * Set state attributes of a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node to have its attributes set.  The node can be represented\n     *   either by the node object, or the node id (as would have been\n     *   returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param attributes {Map}\n     *   Each property name in the map may correspond to the property names of\n     *   a node which are specified as <i>USER-PROVIDED ATTRIBUTES</i> in\n     *   {@link SimpleTreeDataModel}.  Each property value will be assigned\n     *   to the corresponding property of the node specified by nodeId.\n     *\n     * @throws {Error} If the node object or id is not valid.\n     */\n    setState : function(nodeReference, attributes)\n    {\n      var node;\n      var nodeId;\n\n      if (typeof(nodeReference) == \"object\")\n      {\n        node = nodeReference;\n        nodeId = node.nodeId;\n      }\n      else if (typeof(nodeReference) == \"number\")\n      {\n        nodeId = nodeReference;\n        node = this._nodeArr[nodeId];\n      }\n      else\n      {\n        throw new Error(\"Expected node object or node id\");\n      }\n\n      for (var attribute in attributes)\n      {\n        // Do any attribute-specific processing\n        switch(attribute)\n        {\n        case \"bSelected\":\n          var nRowIndex = this.getRowFromNodeId(nodeId);\n          var selectionModel = this.getTree().getSelectionModel();\n          var TV = qx.ui.treevirtual.TreeVirtual;\n          var bChangeSelection =\n            (typeof(nRowIndex) === \"number\" &&\n             this.getTree().getSelectionMode() != TV.SelectionMode.NONE);\n\n          // The selected state is changing. Keep track of what is selected\n          if (attributes[attribute])\n          {\n            this._selections[nodeId] = true;\n\n            // Add selection range for node\n            if (bChangeSelection &&\n                ! selectionModel.isSelectedIndex(nRowIndex))\n            {\n              selectionModel.setSelectionInterval(nRowIndex, nRowIndex);\n            }\n          }\n          else\n          {\n            delete this._selections[nodeId];\n\n            // Delete selection range for node\n            if (bChangeSelection &&\n                selectionModel.isSelectedIndex(nRowIndex))\n            {\n              selectionModel.removeSelectionInterval(nRowIndex, nRowIndex);\n            }\n          }\n          break;\n\n        case \"bOpened\":\n          // Don't do anything if this is a leaf, leaf has no opened/closed\n          if (node.type === qx.ui.treevirtual.MTreePrimitive.Type.LEAF) {\n            break;\n          }\n\n          // Don't do anything if the requested state is the same as the\n          // current state.\n          if (attributes[attribute] == node.bOpened)\n          {\n            break;\n          }\n\n          // Get the tree to which this data model is attached\n          var tree = this.__tree;\n\n          // Are we opening or closing?\n          if (node.bOpened)\n          {\n            // We're closing.  If there are listeners, generate a treeClose\n            // event.\n            tree.fireDataEvent(\"treeClose\", node);\n          }\n          else\n          {\n            // We're opening.  Are there any children?\n            if (node.children.length > 0)\n            {\n              // Yup.  If there any listeners, generate a \"treeOpenWithContent\"\n              // event.\n              tree.fireDataEvent(\"treeOpenWithContent\", node);\n            }\n            else\n            {\n              // No children.  If there are listeners, generate a\n              // \"treeOpenWhileEmpty\" event.\n              tree.fireDataEvent(\"treeOpenWhileEmpty\", node);\n            }\n          }\n\n          // Event handler may have modified the opened state.  Check before\n          // toggling.\n          if (!node.bHideOpenClose)\n          {\n            // It's still boolean.  Toggle the state\n            node.bOpened = !node.bOpened;\n\n            // Clear the old selections in the tree\n            tree.getSelectionModel()._resetSelection();\n          }\n\n          // Re-render the row data since formerly visible rows may now be\n          // invisible, or vice versa.\n          this.setData();\n          break;\n\n        default:\n          // no attribute-specific processing required\n          break;\n        }\n\n        // Set the new attribute value\n        node[attribute] = attributes[attribute];\n      }\n    },\n\n\n    /**\n     * Return the mapping of nodes to rendered rows.  This function is intended\n     * for use by the cell renderer, not by users of this class.\n     * It is also useful to select a node.\n     *\n     * @return {Array}\n     *   The array containing mappings of nodes to rendered rows.\n     */\n    getNodeRowMap : function()\n    {\n      return this._nodeRowMap;\n    },\n\n    /**\n     * This operation maps nodes to rowIndexes.  It does the opposite job to {@link #getNodeFromRow}.\n     *\n     * @param nodeId {Integer}\n     *   The id of the node (as would have been returned by addBranch(),\n     *   addLeaf(), etc.) to get the row index for.\n     * @return {Integer} row index for the given node ID\n     */\n    getRowFromNodeId : function(nodeId)\n    {\n      return this._nodeRowMap[nodeId];\n    },\n\n    /**\n     * This operation maps rowIndexes to nodes.  It does the opposite job to {@link #getRowFromNodeId}.\n     * This function is useful to map selection (row based) to nodes.\n     *\n     * @param rowIndex {Integer} zero-based row index.\n     * @return {Object} node associated to <tt>rowIndex</tt>.\n     */\n    getNodeFromRow : function(rowIndex)\n    {\n      return this._nodeArr[this._rowArr[rowIndex][this._treeColumn].nodeId];\n    },\n\n\n    /**\n     * Clear all selections in the data model.  This method does not clear\n     * selections displayed in the widget, and is intended for internal use,\n     * not by users of this class.\n     *\n     */\n    _clearSelections : function()\n    {\n      // Clear selected state for any selected nodes.\n      for (var selection in this._selections)\n      {\n        this._nodeArr[selection].bSelected = false;\n      }\n\n      // Reinitialize selections array.\n      this._selections = { };\n    },\n\n\n    /**\n     * Return the nodes that are currently selected.\n     *\n     * @return {Array}\n     *   An array containing the nodes that are currently selected.\n     */\n    getSelectedNodes : function()\n    {\n      var nodes = [ ];\n\n      for (var nodeId in this._selections)\n      {\n        nodes.push(this._nodeArr[nodeId]);\n      }\n\n      return nodes;\n    },\n\n\n    // property apply\n    _applyFilter : function(value, old)\n    {\n      this.setData();\n    },\n\n    /**\n     * This checks whether a node label is editable\n     * Used in the NodeEditor to check if edit is permitted\n     *\n     * @param rowIndex {Integer} zero-based row index.\n     * @return {Boolean} If the node has edit permitted\n     */\n    isNodeEditable : function(rowIndex)\n    {\n      return this.__tree.getAllowNodeEdit() && this.getNodeFromRow(rowIndex).bCanEdit;\n    }\n  },\n\n  destruct : function()\n  {\n    this._rowArr = this._nodeArr = this._nodeRowMap = this._selections =\n      this.__tree = this.__tempTreeData = null;\n  },\n\n  defer : function(statics)\n  {\n    // For backward compatibility, ensure the Type values are available from\n    // this class as well as from the mixin.\n    statics.Type = qx.ui.treevirtual.MTreePrimitive.Type;\n  }\n});\n"
  ]
}