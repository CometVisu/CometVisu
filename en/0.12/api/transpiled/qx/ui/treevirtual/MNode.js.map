{
  "version": 3,
  "sources": [
    "/home/travis/build/CometVisu/CometVisu/external/qooxdoo/framework/source/class/qx/ui/treevirtual/MNode.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Mixin",
    "define",
    "members",
    "nodeGet",
    "nodeReference",
    "getTableModel",
    "getData",
    "Error",
    "nodeToggleOpened",
    "node",
    "nodeId",
    "setState",
    "bOpened",
    "nodeSetState",
    "attributes",
    "nodeSetLabel",
    "label",
    "nodeGetLabel",
    "nodeSetSelected",
    "b",
    "bSelected",
    "nodeGetSelected",
    "nodeSetOpened",
    "nodeGetOpened",
    "nodeSetHideOpenClose",
    "bHideOpenClose",
    "nodeGetHideOpenClose",
    "nodeSetIcon",
    "path",
    "icon",
    "nodeGetIcon",
    "nodeSetSelectedIcon",
    "iconSelected",
    "nodeGetSelectedIcon",
    "nodeSetCellStyle",
    "style",
    "cellStyle",
    "nodeGetCellStyle",
    "nodeSetLabelStyle",
    "labelStyle",
    "nodeGetLabelStyle",
    "ui",
    "treevirtual",
    "MNode"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * Utility functions for working with nodes.  These methods allow reference\n * to a node by either the object itself or the object's node id.\n */\nqx.Mixin.define(\"qx.ui.treevirtual.MNode\",\n{\n  members :\n  {\n    /**\n     * Get a node object given its node id.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node to have its opened/closed state toggled.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.).\n     *\n     * @return {Object}\n     *   If the nodeReference is a node object itself, that same node object\n     *   is returned (identity).  Otherwise, the node object is looked up\n     *   using the specified node id.\n     */\n    nodeGet : function(nodeReference)\n    {\n      if (typeof(nodeReference) == \"object\")\n      {\n        return nodeReference;\n      }\n      else if (typeof(nodeReference) == \"number\")\n      {\n        return this.getTableModel().getData()[nodeReference];\n      }\n      else\n      {\n        throw new Error(\"Expected node object or node id\");\n      }\n    },\n\n\n    /**\n     * Toggle the opened state of the node: if the node is opened, close\n     * it; if it is closed, open it.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node to have its opened/closed state toggled.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     */\n    nodeToggleOpened : function(nodeReference)\n    {\n      var node;\n      var nodeId;\n\n      if (typeof(nodeReference) == \"object\")\n      {\n        node = nodeReference;\n        nodeId = node.nodeId;\n      }\n      else if (typeof(nodeReference) == \"number\")\n      {\n        nodeId = nodeReference;\n        node = this.getTableModel().getData()[nodeId];\n      }\n      else\n      {\n        throw new Error(\"Expected node object or node id\");\n      }\n\n      this.getTableModel().setState(nodeId, { bOpened : ! node.bOpened });\n    },\n\n\n    /**\n     * Set state attributes of a tree node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which attributes are being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param attributes {Map}\n     *   Map with the node properties to be set.  The map may contain any of\n     *   the properties described in\n     *   {@link qx.ui.treevirtual.SimpleTreeDataModel}\n     *\n     */\n    nodeSetState : function(nodeReference, attributes)\n    {\n      var nodeId;\n\n      if (typeof(nodeReference) == \"object\")\n      {\n        nodeId = nodeReference.nodeId;\n      }\n      else if (typeof(nodeReference) == \"number\")\n      {\n        nodeId = nodeReference;\n      }\n      else\n      {\n        throw new Error(\"Expected node object or node id\");\n      }\n\n      this.getTableModel().setState(nodeId, attributes);\n    },\n\n\n    /**\n     * Set the label for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the label is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param label {String}\n     *   The new label for the specified node\n     *\n     */\n    nodeSetLabel : function(nodeReference, label)\n    {\n      this.nodeSetState(nodeReference, { label : label });\n    },\n\n\n    /**\n     * Get the label for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the label is being retrieved.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {String}\n     *   The label for the specified node\n     */\n    nodeGetLabel : function(nodeReference)\n    {\n      var node = this.nodeGet(nodeReference);\n      return node.label;\n    },\n\n\n    /**\n     * Set the selected state for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the selected state is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param b {Boolean}\n     *   The new selected state for the specified node.\n     *\n     */\n    nodeSetSelected : function(nodeReference, b)\n    {\n      this.nodeSetState(nodeReference, { bSelected : b });\n    },\n\n\n    /**\n     * Get the selected state for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the selected state is being retrieved.  The node\n     *   can be represented either by the node object, or the node id (as\n     *   would have been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {Boolean}\n     *   The selected state for the specified node.\n     */\n    nodeGetSelected : function(nodeReference)\n    {\n      var node = this.nodeGet(nodeReference);\n      return node.bSelected;\n    },\n\n\n    /**\n     * Set the opened state for a node.  (Note that this method has no effect\n     * if the requested state is the same as the current state.)\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the opened state is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param b {Boolean}\n     *   The new opened state for the specified node.\n     *\n     */\n    nodeSetOpened : function(nodeReference, b)\n    {\n      var node;\n\n      if (typeof(nodeReference) == \"object\")\n      {\n        node = nodeReference;\n      }\n      else if (typeof(nodeReference) == \"number\")\n      {\n        node = this.getTableModel().getData()[nodeReference];\n      }\n      else\n      {\n        throw new Error(\"Expected node object or node id\");\n      }\n\n      // Only set new state if not already in the requested state, since\n      // setting new state involves dispatching events.\n      if (b != node.bOpened)\n      {\n        this.nodeToggleOpened(node);\n      }\n    },\n\n\n    /**\n     * Get the opened state for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the opened state is being retrieved.  The node can\n     *   be represented either by the node object, or the node id (as would\n     *   have been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {Boolean}\n     *   The opened state for the specified node.\n     */\n    nodeGetOpened : function(nodeReference)\n    {\n      var node = this.nodeGet(nodeReference);\n      return node.bOpened;\n    },\n\n\n    /**\n     * Set the hideOpenClose state for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the hideOpenClose state is being set.  The node\n     *   can be represented either by the node object, or the node id (as\n     *   would have been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param b {Boolean}\n     *   The new hideOpenClose state for the specified node.\n     *\n     */\n    nodeSetHideOpenClose : function(nodeReference, b)\n    {\n      this.nodeSetState(nodeReference, { bHideOpenClose : b });\n    },\n\n\n    /**\n     * Get the hideOpenClose state for a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the hideOpenClose state is being retrieved.  The\n     *   node can be represented either by the node object, or the node id (as\n     *   would have been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {Boolean}\n     *   The new hideOpenClose state for the specified node.\n     */\n    nodeGetHideOpenClose : function(nodeReference)\n    {\n      var node = this.nodeGet(nodeReference);\n      return node.bHideOpenClose;\n    },\n\n\n    /**\n     * Set the icon for a node when in its unselected (normal) state.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the icon is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param path {String}\n     *   The path to the icon to be used when the node is not selected\n     *\n     */\n    nodeSetIcon : function(nodeReference, path)\n    {\n      this.nodeSetState(nodeReference, { icon : path });\n    },\n\n\n    /**\n     * Get the icon for a node when in its unselected (normal) state.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the icon is being retrieved.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {String}\n     *   The path to the icon to be used when the node is not selected, if a\n     *   path has been previously provided (i.e. not using the default icon).\n     */\n    nodeGetIcon : function(nodeReference)\n    {\n      var node = this.nodeGet(nodeReference);\n      return node.icon;\n    },\n\n\n    /**\n     * Set the icon for a node when in its selected state.\n     * <p>\n     * NOTE: As of 13 Mar 2009, this feature is disabled by default, by\n     *       virtue of the fact that the tree's \"alwaysUpdateCells\" property\n     *       has a setting of 'false' now instead of 'true'. Setting this\n     *       property to true allows the icon to change upon selection, but\n     *       causes problems such as single clicks not always selecting a\n     *       row, and, in IE, double click operations failing\n     *       completely. (For more information, see bugs 605 and 2021.) To\n     *       re-enable the option to have an unique icon that is displayed\n     *       when the node is selected, issue\n     *       <code>tree.setAlwaysUpdateCells(true);</code>\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the icon is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param path {String}\n     *   The path to the icon to be used when the node is selected\n     *\n     */\n    nodeSetSelectedIcon : function(nodeReference, path)\n    {\n      this.nodeSetState(nodeReference, { iconSelected : path });\n    },\n\n\n    /**\n     * Get the icon for a node when in its selected state.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the icon is being retrieved.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {String}\n     *   The path to the icon to be used when the node is selected, if a path\n     *   has been previously provided (i.e. not using the default icon).\n     */\n    nodeGetSelectedIcon : function(nodeReference)\n    {\n      var node = this.nodeGet(nodeReference);\n      return node.iconSelected;\n    },\n\n\n    /**\n     * Set the cell style for a node\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the cell style is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param style {String}\n\n     *   The CSS style to be applied for the tree column cell for this node,\n     *   if a style has been previously provided (i.e. not using the default\n     *   style).\n     *\n     */\n    nodeSetCellStyle : function(nodeReference, style)\n    {\n      this.nodeSetState(nodeReference, { cellStyle : style });\n    },\n\n\n    /**\n     * Get the cell style for a node\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the cell style is being retrieved.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {String}\n     *   The CSS style being applied for the tree column cell for this node.\n     */\n    nodeGetCellStyle : function(nodeReference)\n    {\n      var node = this.nodeGet(nodeReference);\n      return node.cellStyle;\n    },\n\n\n    /**\n     * Set the label style for a node\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the label style is being set.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param style {String}\n     *   The CSS style to be applied for the label for this node.\n     *\n     */\n    nodeSetLabelStyle : function(nodeReference, style)\n    {\n      this.nodeSetState(nodeReference, { labelStyle : style });\n    },\n\n\n    /**\n     * Get the label style for a node\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node for which the label style is being retrieved.  The node can\n     *   be represented either by the node object, or the node id (as would\n     *   have been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @return {String}\n     *   The CSS style being applied for the label for this node, if a style\n     *   has been previously provided (i.e. not using the default style).\n     */\n    nodeGetLabelStyle : function(nodeReference)\n    {\n      var node = this.nodeGet(nodeReference);\n      return node.cellStyle;\n    }\n  }\n});\n"
  ]
}