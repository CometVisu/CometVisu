{
  "version": 3,
  "sources": [
    "/home/travis/build/CometVisu/CometVisu/node_modules/@qooxdoo/compiler/node_modules/@qooxdoo/framework/source/class/qx/ui/progressive/Progressive.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "ui",
    "container",
    "Composite",
    "construct",
    "structure",
    "layout",
    "VBox",
    "__renderer",
    "set",
    "backgroundColor",
    "progressive",
    "Default",
    "__structure",
    "applyStructure",
    "__bInitialRenderComplete",
    "__bRendering",
    "__initialNumElements",
    "events",
    "properties",
    "dataModel",
    "check",
    "apply",
    "batchSize",
    "init",
    "flushWidgetQueueAfterBatch",
    "interElementTimeout",
    "members",
    "__t1",
    "getStructure",
    "addRenderer",
    "name",
    "renderer",
    "join",
    "removeRenderer",
    "Error",
    "render",
    "state",
    "State",
    "model",
    "getDataModel",
    "pane",
    "getPane",
    "getBatchSize",
    "rendererData",
    "__createStateRendererData",
    "userData",
    "Date",
    "getModel",
    "getElementCount",
    "fireDataEvent",
    "initial",
    "__renderElementBatch",
    "event",
    "Timer",
    "once",
    "_applyDataModel",
    "value",
    "old",
    "removeListener",
    "__dataAvailable",
    "dispose",
    "addListener",
    "current",
    "element",
    "i",
    "getNextElement",
    "debug",
    "remaining",
    "getFlushWidgetQueueAfterBatch",
    "core",
    "queue",
    "Manager",
    "flush",
    "getInterElementTimeout",
    "e",
    "getData",
    "destruct",
    "Progressive"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2008 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * <i>Progressive</i>.\n *\n * Follow progressive instructions provided by a data model.  A variable\n * number of instructions are executed at one time, after which control is\n * returned briefly to the browser.  This allows browser rendering between\n * batches of instructions, improving the visual experience.\n *\n * <i>Progressive</i> may be used for various purposes.  Two predefined\n * purposes for which \"renderers\" are provided, are a progressively-rendered\n * table which allows variable row height, and a program load/initialization\n * renderer with progress bar.  (Note that the term \"renderer\" is interpreted\n * quite broadly.  A renderer needn't actually render; rather it is just some\n * set of activities that takes place at one time, e.g a row of table data or\n * a single widget added to the document or a sending a request to a server,\n * etc.)\n */\nqx.Class.define(\"qx.ui.progressive.Progressive\",\n{\n  extend : qx.ui.container.Composite,\n\n\n  /**\n   * @param structure {qx.ui.progressive.structure.Abstract}\n   *   The structure of the Progressive pane.\n   */\n  construct : function(structure)\n  {\n    this.base(arguments, new qx.ui.layout.VBox());\n\n    // Create an object in which we'll track renderers that have been added\n    this.__renderer = { };\n\n    // Prepare to have our pane structure added to us.\n    this.set(\n      {\n        backgroundColor : \"white\"\n      });\n\n    // If no structure is provided...\n    if (! structure)\n    {\n      // ... then create a default one.\n      structure = new qx.ui.progressive.structure.Default();\n    }\n\n    // Prepare our pane structure\n    this.__structure = structure;\n    structure.applyStructure(this);\n\n    // We've not yet done our initial render\n    this.__bInitialRenderComplete = false;\n\n    // We're not currently rendering\n    this.__bRendering = false;\n\n    // Number of elements available to be rendered.  Useful for progress\n    // handlers, e.g. a progress bar or status counter.\n    this.__initialNumElements = 0;\n  },\n\n\n  events :\n  {\n    /**\n     * Event fired when rendering begins.\n     *\n     * The event data is an object with the following members:\n     * <dl>\n     *   <dt>state</dt>\n     *   <dd>\n     *     The state object.\n     *   </dd>\n     *\n     *   <dt>initial</dt>\n     *     The number of elements that are available to be rendered\n     *   <dd>\n     *   </dd>\n     * </dl>\n     */\n    \"renderStart\" : \"qx.event.type.Data\",\n\n    /**\n     * Event fired when rendering ends.  The data is the state object.\n     */\n    \"renderEnd\"   : \"qx.event.type.Data\",\n\n    /**\n     * This event is fired after each batch of elements is rendered, and\n     * control is about to be yielded to the browser.  This is an appropriate\n     * event to listen for, to implement a progress bar.\n     *\n     * The event data is an object with the following members:\n     * <dl>\n     *   <dt>initial</dt>\n     *   <dd>\n     *     The number of elements that were available at the start of this\n     *     rendering request.\n     *   </dd>\n     *\n     *   <dt>remaining</dt>\n     *   <dd>\n     *     The number of elements still remaining to be rendered.\n     *   </dd>\n     * </dl>\n     */\n    \"progress\" : \"qx.event.type.Data\",\n\n    /**\n     * This event is fired after each element is rendered.\n     *\n     * The event data is an object with the following members:\n     * <dl>\n     *   <dt>initial</dt>\n     *   <dd>\n     *     The number of elements that were available at the start of this\n     *     rendering request.\n     *   </dd>\n     *\n     *   <dt>remaining</dt>\n     *   <dd>\n     *     The number of elements still remaining to be rendered.\n     *   </dd>\n     *\n     *   <dt>element</dt>\n     *   <dd>\n     *     The object, returned by the data model's getNextElement() method,\n     *     that was just rendered.\n     *   </dd>\n     * </dl>\n     *\n     * Note: Unless batchSize is set to 1 or we happen to be at the end of a\n     *       batch, widgets will not be rendered at this time.  Use this event\n     *       for programmatically processing rendered elements, but not for\n     *       such things as progress bars.  Instead, where only user-visible\n     *       changes such as progress bars are being updated, use the\n     *       \"progress\" event.\n     */\n    \"progressDetail\" : \"qx.event.type.Data\"\n  },\n\n\n  properties :\n  {\n    /** The data model. */\n    dataModel :\n    {\n      check : \"qx.ui.progressive.model.Abstract\",\n      apply : \"_applyDataModel\"\n    },\n\n    /**\n     * Number of elements to render at one time.  After this number of\n     * elements has been rendered, control will be yielded to the browser\n     * allowing the elements to actually be displayed.  A short-interval timer\n     * will be set, to regain control to render the next batch of elements.\n     */\n    batchSize :\n    {\n      check : \"Integer\",\n      init  : 20\n    },\n\n    /**\n     * Flush the widget queue after each batch is rendered.  This is\n     * particularly relevant for such things as progressive loading, where\n     * the whole purpose is to be able to see the loading progressing.\n     */\n    flushWidgetQueueAfterBatch :\n    {\n      check : \"Boolean\",\n      init : false\n    },\n\n    /**\n     * Delay between rendering elements. Zero is normally adequate, but\n     * there are times that the user wants more time between rendering\n     * some elements.\n     */\n    interElementTimeout :\n    {\n      check: \"Integer\",\n      init  : 0\n    }\n  },\n\n\n  members :\n  {\n\n    __renderer : null,\n    __bRendering : null,\n    __t1 : null,\n    __initialNumElements : null,\n    __bInitialRenderComplete : null,\n    __structure : null,\n\n    /**\n     * Return the structure object\n     *\n     * @return {qx.ui.progressive.structure.Abstract} The structure object\n     */\n    getStructure : function()\n    {\n      return this.__structure;\n    },\n\n    /**\n     * Add a renderer that can be referenced by the data model.\n     *\n     * @param name {String}\n     *   Name referenced in the data model when this renderer is to be used.\n     *\n     * @param renderer {qx.ui.progressive.renderer.Abstract}\n     *   Renderer object used if the data model references the specified name.\n     *\n     */\n    addRenderer : function(name, renderer)\n    {\n      this.__renderer[name] = renderer;\n      renderer.join(this, name);\n    },\n\n    /**\n     * Remove a previously added renderer.\n     *\n     * @param name {String}\n     *   Remove the renderer which was assigned this name.\n     *\n     */\n    removeRenderer : function(name)\n    {\n      if (! this.__renderer[name])\n      {\n        throw new Error(\"No existing renderer named \" + name);\n      }\n\n      delete this.__renderer[name];\n    },\n\n    /**\n     * Render the elements available from the data model.  Elements are\n     * rendered in batches of size {@link #batchSize}.  After each batch of\n     * elements are rendered, control is returned temporarily to the\n     * browser, so that actual screen updates can take place.  A timer is\n     * used to regain control a short while later, in order to render the\n     * next batch of element.\n     *\n     */\n    render : function()\n    {\n      // Prevent render calls while we're already rendering\n      if (this.__bRendering)\n      {\n        return;\n      }\n\n      this.__bRendering = true;\n\n      var state = new qx.ui.progressive.State(\n        {\n          progressive  : this,\n          model        : this.getDataModel(),\n          pane         : this.__structure.getPane(),\n          batchSize    : this.getBatchSize(),\n          rendererData : this.__createStateRendererData(),\n          userData     : { }\n        });\n\n      // Record render start time\n      this.__t1 = new Date();\n\n      // Render the first batch of elements.  Subsequent batches will be via\n      // timer started from this.__renderElementBatch().\n      if (this.__bInitialRenderComplete)\n      {\n        // Get the starting number of elements\n        this.__initialNumElements = state.getModel().getElementCount();\n\n        // Let listeners know we're beginning to render\n        this.fireDataEvent(\"renderStart\",\n                           {\n                             state   : state,\n                             initial : this.__initialNumElements\n                           });\n\n        // Begin rendering\n        this.__renderElementBatch(state);\n      }\n      else\n      {\n        // Ensure we leave enough time that 'this' has been rendered, so that\n        // this.getContentElement().getDomElement() is valid and has\n        // properties.  It's needed by some renderers.\n        //\n        // FIXME: Why isn't an event listener for \"appear\" an adequate delay???\n        //        (It's done with a timer like this in Table's Pane too.)\n        qx.event.Timer.once(function()\n                            {\n                              this.__initialNumElements =\n                                state.getModel().getElementCount();\n                              this.fireDataEvent(\n                                \"renderStart\",\n                                {\n                                  state   : state,\n                                  initial : this.__initialNumElements\n                                });\n                              this.__renderElementBatch(state);\n                              this.__bInitialRenderComplete = true;\n                            },\n                            this, 10);\n      }\n    },\n\n    /**\n     * Called when the dataModel property is changed.\n     *\n     * @param value {qx.ui.progressive.model.Abstract}\n     *   The new data model.\n     *\n     * @param old {qx.ui.progressive.model.Abstract}\n     *   The old data model.\n     *\n     */\n    _applyDataModel : function(value, old)\n    {\n      if (old)\n      {\n        // Remove the old event listener\n        old.removeListener(\"dataAvailable\", this.__dataAvailable, this);\n\n        // Dispose the old model\n        old.dispose();\n      }\n\n      // Add an event listener so we know when data is available in the model\n      value.addListener(\"dataAvailable\", this.__dataAvailable, this);\n    },\n\n    /**\n     * Render a batch of elements.  The batch size is determined by the\n     * Progressive's batch size at the time that rendering began.  That batch\n     * size was copied into the {@link qx.ui.progressive.State} object and is\n     * used herein.\n     *\n     * @param state {qx.ui.progressive.State}\n     *   The current state of rendering.\n     *\n     */\n    __renderElementBatch : function(state)\n    {\n      var current;\n      var element;\n      var renderer;\n\n      for (var i = state.getBatchSize(); i > 0; i--)\n      {\n        // Retrieve the current element\n        current = state.getModel().getNextElement();\n        if (! current)\n        {\n          // No more elements.  We're done.\n          this.debug(\"Render time: \" + (new Date() - this.__t1) + \"ms\");\n          this.__bRendering = false;\n\n          // Notify any progress handlers that are listening\n          this.fireDataEvent(\"renderEnd\", state);\n\n          // We don't need our render state any longer\n          state.dispose();\n\n          // See ya!\n          return;\n        }\n\n        // Get the element member\n        element = current.element;\n\n        // Get the element's renderer\n        renderer = this.__renderer[element.renderer];\n\n        // Render this element\n        renderer.render(state, element);\n\n        // Notify any progress detail handlers that are listening\n        this.fireDataEvent(\"progressDetail\",\n                           {\n                             initial   : this.__initialNumElements,\n                             remaining : current.remaining,\n                             element   : element\n                           });\n      }\n\n      // Notify any progress handlers that are listening\n      this.fireDataEvent(\"progress\",\n                         {\n                           initial   : this.__initialNumElements,\n                           remaining : current.remaining\n                         });\n\n      // Flush the widget queue\n      if (this.getFlushWidgetQueueAfterBatch())\n      {\n        qx.ui.core.queue.Manager.flush();\n      }\n\n      // Set a timer to render the next element\n      qx.event.Timer.once(function()\n                          {\n                            this.__renderElementBatch(state);\n                          },\n                          this,\n                          this.getInterElementTimeout());\n    },\n\n\n    /**\n     * Create the map of empty objects for use by the renderers.\n     * @return {Map} renderer data map\n     */\n    __createStateRendererData : function()\n    {\n      var rendererData = { };\n\n      for (var name in this.__renderer)\n      {\n        rendererData[name] = { };\n      }\n\n      return rendererData;\n    },\n\n    /**\n     * Event callback for the \"dataAvailable\" event.\n     *\n     * @param e {qx.event.type.Data}\n     *   A \"dataAvailable\" event's data contains the initial number of elements\n     *\n     */\n    __dataAvailable : function(e)\n    {\n      this.__initialNumElements = e.getData();\n      this.render();\n    }\n  },\n\n\n  /**\n   */\n  destruct : function()\n  {\n    // For each renderer...\n    for (var name in this.__renderer)\n    {\n      // ... dispose it\n      this.__renderer[name].dispose();\n    }\n\n    // Clean up references\n    this.__t1 = this.__renderer = this.__structure = null;\n  }\n});\n"
  ]
}