{
  "version": 3,
  "sources": [
    "/home/travis/build/CometVisu/CometVisu/external/qooxdoo/framework/source/class/qx/ui/virtual/layer/CellSpanManager.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "rowConfig",
    "columnConfig",
    "_cells",
    "_invalidateSortCache",
    "_invalidatePositionCache",
    "addListener",
    "_onRowConfigChange",
    "_onColumnConfigChange",
    "_rowConfig",
    "_columnConfig",
    "members",
    "addCell",
    "id",
    "row",
    "column",
    "rowSpan",
    "columnSpan",
    "firstRow",
    "lastRow",
    "firstColumn",
    "lastColumn",
    "removeCell",
    "_sorted",
    "_getSortedCells",
    "key",
    "sorted",
    "values",
    "sort",
    "a",
    "b",
    "_findCellsInRange",
    "min",
    "max",
    "cells",
    "length",
    "start",
    "end",
    "pivot",
    "cell",
    "result",
    "findCellsInWindow",
    "rowCount",
    "columnCount",
    "verticalInWindow",
    "lang",
    "mergeWith",
    "horizontalInWindow",
    "__intersectionAsArray",
    "setA",
    "setB",
    "intersection",
    "push",
    "e",
    "_rowPos",
    "_columnPos",
    "_getRowPosition",
    "pos",
    "undefined",
    "getItemPosition",
    "_getColumnPosition",
    "_getSingleCellBounds",
    "firstVisibleRow",
    "firstVisibleColumn",
    "bounds",
    "left",
    "top",
    "width",
    "height",
    "getItemSize",
    "getCellBounds",
    "i",
    "l",
    "computeCellSpanMap",
    "map",
    "rowStartIndex",
    "Math",
    "rowEndIndex",
    "rowIndex",
    "columnStartIndex",
    "columnEndIndex",
    "columnIndex",
    "destruct",
    "removeListener",
    "ui",
    "virtual",
    "layer",
    "CellSpanManager"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * The CellSpanManager manages cells, which span several rows or columns.\n *\n * It provides functionality to compute, which spanning cells are visible\n * in a given view port and how they have to be placed.\n */\nqx.Class.define(\"qx.ui.virtual.layer.CellSpanManager\",\n{\n  extend : qx.core.Object,\n\n  /**\n   * @param rowConfig {qx.ui.virtual.core.Axis} The row configuration of the pane\n   *    in which the cells will be rendered\n   * @param columnConfig {qx.ui.virtual.core.Axis} The column configuration of the pane\n   *    in which the cells will be rendered\n   */\n  construct : function(rowConfig, columnConfig)\n  {\n    this.base(arguments);\n\n    if (qx.core.Environment.get(\"qx.debug\"))\n    {\n      this.assertInstance(rowConfig, qx.ui.virtual.core.Axis);\n      this.assertInstance(columnConfig, qx.ui.virtual.core.Axis);\n    }\n\n    this._cells = {};\n    this._invalidateSortCache();\n    this._invalidatePositionCache();\n\n    rowConfig.addListener(\"change\", this._onRowConfigChange, this);\n    columnConfig.addListener(\"change\", this._onColumnConfigChange, this);\n\n    this._rowConfig = rowConfig;\n    this._columnConfig = columnConfig;\n  },\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n    /**\n     * Add a spanning cell to the manager.\n     *\n     * @param id {String} Unique id for the cell definition. This id is required\n     *    for removing the cell from the manager\n     * @param row {PositiveInteger} The cell's row\n     * @param column {PositiveInteger} The cell's column\n     * @param rowSpan {PositiveInteger} The number of rows the cells spans\n     * @param columnSpan {PositiveInteger} The number of columns the cells spans\n     */\n    addCell : function(id, row, column, rowSpan, columnSpan)\n    {\n      this._cells[id] = {\n        firstRow: row,\n        lastRow : row + rowSpan - 1,\n        firstColumn: column,\n        lastColumn: column + columnSpan - 1,\n        id: id\n      };\n      this._invalidateSortCache();\n    },\n\n\n    /**\n     * Remove a cell from the manager\n     *\n     * @param id {String} The id of the cell to remove\n     */\n    removeCell : function(id)\n    {\n      delete(this._cells[id]);\n      this._invalidateSortCache();\n    },\n\n\n    /**\n     * Invalidate the sort cache\n     */\n    _invalidateSortCache : function() {\n      this._sorted = {};\n    },\n\n\n    /**\n     * Get the cell array sorted by the given key (ascending)\n     *\n     * @param key {String} The sort key. One of <code>firstRow</code>,\n     *     <code>lastRow</code>, <code>firstColumn</code> or <code>lastColumn</code>\n     * @return {Map[]} sorted array of cell descriptions\n     */\n    _getSortedCells : function(key)\n    {\n      if (this._sorted[key]) {\n        return this._sorted[key];\n      }\n      var sorted = this._sorted[key] = Object.values(this._cells);\n      sorted.sort(function(a, b) {\n        return a[key] < b[key] ? -1 : 1;\n      });\n      return sorted;\n    },\n\n\n    /**\n     * Finds all cells with a sort key within the given range.\n     *\n     * Complexity: O(log n)\n     *\n     * @param key {String} The key to search for\n     * @param min {Integer} minimum value\n     * @param max {Integer} maximum value (inclusive)\n     * @return {Map} Map, which will contain the search results\n     */\n    _findCellsInRange : function(key, min, max)\n    {\n      var cells = this._getSortedCells(key);\n      if (cells.length == 0) {\n        return {};\n      }\n\n      var start = 0;\n      var end = cells.length-1;\n\n      // find first cell, which is >= \"min\"\n      while (true)\n      {\n        var pivot = start + ((end - start) >> 1);\n\n        var cell = cells[pivot];\n        if (\n          cell[key] >= min &&\n          (pivot == 0 || cells[pivot-1][key] < min)\n        ) {\n          // the start cell was found\n          break;\n        }\n\n        if (cell[key] >= min) {\n          end = pivot - 1;\n        } else {\n          start = pivot + 1;\n        }\n        if (start > end) {\n          // nothing found\n          return {};\n        }\n      }\n\n      var result = {};\n      var cell = cells[pivot];\n      while (cell && cell[key] >= min && cell[key] <= max)\n      {\n        result[cell.id] = cell;\n        cell = cells[pivot++];\n      }\n      return result;\n    },\n\n\n    /**\n     * Find all cells, which are visible in the given grid window.\n     *\n     * @param firstRow {PositiveInteger} first visible row\n     * @param firstColumn {PositiveInteger} first visible column\n     * @param rowCount {PositiveInteger} number of rows in the window\n     * @param columnCount {PositiveInteger} number of columns in the window\n     * @return {Map[]} The array of found cell descriptions. A cell description\n     *    contains the keys <code>firstRow</code>, <code>lastRow</code>,\n     *    <code>firstColumn</code> or <code>lastColumn</code>\n     */\n    findCellsInWindow : function(firstRow, firstColumn, rowCount, columnCount)\n    {\n      var verticalInWindow = {};\n\n      if (rowCount > 0)\n      {\n        var lastRow = firstRow + rowCount - 1;\n        qx.lang.Object.mergeWith(\n          verticalInWindow,\n          this._findCellsInRange(\"firstRow\", firstRow, lastRow)\n        );\n        qx.lang.Object.mergeWith(\n          verticalInWindow,\n          this._findCellsInRange(\"lastRow\", firstRow, lastRow)\n        );\n\n      }\n\n      var horizontalInWindow = {};\n\n      if (columnCount > 0)\n      {\n        var lastColumn = firstColumn + columnCount - 1;\n        qx.lang.Object.mergeWith(\n            horizontalInWindow,\n            this._findCellsInRange(\"firstColumn\", firstColumn, lastColumn)\n        );\n        qx.lang.Object.mergeWith(\n            horizontalInWindow,\n            this._findCellsInRange(\"lastColumn\", firstColumn, lastColumn)\n        );\n\n      }\n\n      return this.__intersectionAsArray(horizontalInWindow, verticalInWindow);\n    },\n\n\n    /**\n     * Return the intersection of two maps as an array. The objects intersect if\n     * they have the same keys.\n     *\n     * @param setA {Object} The first map\n     * @param setB {Object} The second map\n     * @return {String[]} An array keys found in both maps\n     */\n    __intersectionAsArray : function(setA, setB)\n    {\n      var intersection = [];\n      for (var key in setA)\n      {\n        if (setB[key]) {\n          intersection.push(setB[key]);\n        }\n      }\n      return intersection;\n    },\n\n\n    /**\n     * Event handler for row configuration changes\n     *\n     * @param e {qx.event.type.Event} the event object\n     */\n    _onRowConfigChange : function(e) {\n      this._rowPos = [];\n    },\n\n\n    /**\n     * Event handler for column configuration changes\n     *\n     * @param e {qx.event.type.Event} the event object\n     */\n    _onColumnConfigChange : function(e) {\n      this._columnPos = [];\n    },\n\n\n    /**\n     * Invalidates the row/column position cache\n     */\n    _invalidatePositionCache : function()\n    {\n      this._rowPos = [];\n      this._columnPos = [];\n    },\n\n\n    /**\n     * Get the pixel start position of the given row\n     *\n     * @param row {Integer} The row index\n     * @return {Integer} The pixel start position of the given row\n     */\n    _getRowPosition : function(row)\n    {\n      var pos = this._rowPos[row];\n      if (pos !== undefined) {\n        return pos;\n      }\n\n      pos = this._rowPos[row] = this._rowConfig.getItemPosition(row);\n      return pos;\n    },\n\n\n    /**\n     * Get the pixel start position of the given column\n     *\n     * @param column {Integer} The column index\n     * @return {Integer} The pixel start position of the given column\n     */\n    _getColumnPosition : function(column)\n    {\n      var pos = this._columnPos[column];\n      if (pos !== undefined) {\n        return pos;\n      }\n\n      pos = this._columnPos[column] = this._columnConfig.getItemPosition(column);\n      return pos;\n    },\n\n\n    /**\n     * Get the bounds of a single cell\n     *\n     * @param cell {Map} the cell description as returned by\n     *    {@link #findCellsInWindow} to get the bounds for\n     * @param firstVisibleRow {Map} The pane's first visible row\n     * @param firstVisibleColumn {Map} The pane's first visible column\n     * @return {Map} Boundaries map with the keys <code>left</code>,\n     * <code>top</code>, <code>width</code> and <code>height</code>\n     */\n    _getSingleCellBounds : function(cell, firstVisibleRow, firstVisibleColumn)\n    {\n      var bounds = {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      };\n\n      bounds.height =\n        this._getRowPosition(cell.lastRow) +\n        this._rowConfig.getItemSize(cell.lastRow) -\n        this._getRowPosition(cell.firstRow);\n\n      bounds.top =\n        this._getRowPosition(cell.firstRow) -\n        this._getRowPosition(firstVisibleRow);\n\n      bounds.width =\n        this._getColumnPosition(cell.lastColumn) +\n        this._columnConfig.getItemSize(cell.lastColumn) -\n        this._getColumnPosition(cell.firstColumn);\n\n      bounds.left =\n        this._getColumnPosition(cell.firstColumn) -\n        this._getColumnPosition(firstVisibleColumn);\n\n      return bounds;\n    },\n\n\n    /**\n     * Get the bounds of a list of cells as returned by {@link #findCellsInWindow}\n     *\n     * @param cells {Map[]} Array of cell descriptions\n     * @param firstVisibleRow {Map} The pane's first visible row\n     * @param firstVisibleColumn {Map} The pane's first visible column\n     * @return {Map[]} Array, which contains a bounds map for each cell.\n     */\n    getCellBounds : function(cells, firstVisibleRow, firstVisibleColumn)\n    {\n      var bounds = [];\n      for (var i=0, l=cells.length; i<l; i++)\n      {\n        bounds.push(this._getSingleCellBounds(\n          cells[i], firstVisibleRow, firstVisibleColumn)\n        );\n      }\n      return bounds;\n    },\n\n\n    /**\n     * Compute a bitmap, which marks for each visible cell, whether the cell\n     * is covered by a spanning cell.\n     *\n     * @param cells {Map[]} Array of cell descriptions as returned by\n     *     {@link #findCellsInWindow}.\n     * @param firstRow {PositiveInteger} first visible row\n     * @param firstColumn {PositiveInteger} first visible column\n     * @param rowCount {PositiveInteger} number of rows in the window\n     * @param columnCount {PositiveInteger} number of columns in the window\n     * @return {Map[][]} Two dimensional array, which contains a <code>1</code>\n     *    for each visible cell, which is covered by a spanned cell.\n     */\n    computeCellSpanMap : function(cells, firstRow, firstColumn, rowCount, columnCount)\n    {\n      var map = [];\n\n      if (rowCount <= 0) {\n        return map;\n      }\n      var lastRow = firstRow + rowCount - 1;\n\n      for (var i=firstRow; i<= lastRow; i++) {\n        map[i] = [];\n      }\n\n      if (columnCount <= 0) {\n        return map;\n      }\n      var lastColumn = firstColumn + columnCount - 1;\n\n      for (var i=0, l=cells.length; i<l; i++)\n      {\n        var cell = cells[i];\n\n        var rowStartIndex = Math.max(firstRow, cell.firstRow);\n        var rowEndIndex = Math.min(lastRow, cell.lastRow);\n        var row;\n\n        for (var rowIndex=rowStartIndex; rowIndex <= rowEndIndex; rowIndex++)\n        {\n          row = map[rowIndex];\n\n          var columnStartIndex = Math.max(firstColumn, cell.firstColumn);\n          var columnEndIndex = Math.min(lastColumn, cell.lastColumn);\n          for (var columnIndex=columnStartIndex; columnIndex <= columnEndIndex; columnIndex++)\n          {\n            row[columnIndex] = 1;\n          }\n        }\n      }\n\n      return map;\n    }\n  },\n\n\n  destruct : function()\n  {\n    this._rowConfig.removeListener(\"change\", this._onRowConfigChange, this);\n    this._columnConfig.removeListener(\"change\", this._onColumnConfigChange, this);\n\n    this._cells = this._sorted = this._rowPos = this._columnPos =\n      this._rowConfig = this._columnConfig = null;\n  }\n});\n"
  ]
}