{
  "version": 3,
  "sources": [
    "/home/travis/build/CometVisu/CometVisu/node_modules/@qooxdoo/compiler/node_modules/@qooxdoo/framework/source/class/qx/ui/form/validation/Manager.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "__formItems",
    "__asyncResults",
    "setRequiredFieldMessage",
    "locale",
    "Manager",
    "tr",
    "events",
    "properties",
    "validator",
    "check",
    "init",
    "nullable",
    "invalidMessage",
    "requiredFieldMessage",
    "context",
    "members",
    "__valid",
    "__syncValid",
    "add",
    "formItem",
    "__supportsInvalid",
    "Error",
    "__supportsSingleSelection",
    "getValue",
    "dataEntry",
    "item",
    "valid",
    "push",
    "remove",
    "items",
    "i",
    "len",
    "length",
    "splice",
    "getItems",
    "validate",
    "validatorResult",
    "_validateRequired",
    "_validateItem",
    "formValid",
    "__validateForm",
    "lang",
    "Type",
    "isBoolean",
    "_setValid",
    "isEmpty",
    "fireEvent",
    "getRequired",
    "getSelection",
    "__supportsDataBindingSelection",
    "getLength",
    "value",
    "setValid",
    "individualMessage",
    "getRequiredInvalidMessage",
    "message",
    "getRequiredFieldMessage",
    "setInvalidMessage",
    "__isAsyncValidator",
    "toHashCode",
    "call",
    "undefined",
    "e",
    "ValidationError",
    "type",
    "BaseError",
    "DEFAULTMESSAGE",
    "getComment",
    "formValidator",
    "getValidator",
    "getContext",
    "validateForm",
    "async",
    "isFunction",
    "isSubClassOf",
    "constructor",
    "ui",
    "form",
    "validation",
    "AsyncValidator",
    "clazz",
    "hasInterface",
    "IForm",
    "ISingleSelection",
    "data",
    "controller",
    "ISelection",
    "_showToolTip",
    "oldValue",
    "fireDataEvent",
    "tooltip",
    "getInstance",
    "getSharedErrorTooltip",
    "firstInvalid",
    "isValid",
    "getContentLocation",
    "isSeeable",
    "setLabel",
    "getInvalidMessage",
    "getPlaceMethod",
    "location",
    "top",
    "getOffsetTop",
    "placeToPoint",
    "left",
    "right",
    "placeToWidget",
    "show",
    "exclude",
    "getValid",
    "getInvalidMessages",
    "messages",
    "getInvalidFormItems",
    "res",
    "reset",
    "setItemValid",
    "__checkValidationComplete",
    "setFormValid",
    "hash",
    "currentResult",
    "destruct"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (martinwittemann)\n\n************************************************************************ */\n/**\n * This validation manager is responsible for validation of forms.\n *\n * @ignore(qx.ui.tooltip)\n * @ignore(qx.ui.tooltip.Manager.*)\n */\nqx.Class.define(\"qx.ui.form.validation.Manager\",\n{\n  extend : qx.core.Object,\n\n  construct : function()\n  {\n    this.base(arguments);\n\n    // storage for all form items\n    this.__formItems = [];\n    // storage for all results of async validation calls\n    this.__asyncResults = {};\n    // set the default required field message\n    this.setRequiredFieldMessage(qx.locale.Manager.tr(\"This field is required\"));\n  },\n\n\n  events :\n  {\n    /**\n     * Change event for the valid state.\n     */\n    \"changeValid\" : \"qx.event.type.Data\",\n\n    /**\n     * Signals that the validation is done. This is not needed on synchronous\n     * validation (validation is done right after the call) but very important\n     * in the case an asynchronous validator will be used.\n     */\n    \"complete\" : \"qx.event.type.Event\"\n  },\n\n\n  properties :\n  {\n    /**\n     * The validator of the form itself. You can set a function (for\n     * synchronous validation) or a {@link qx.ui.form.validation.AsyncValidator}.\n     * In both cases, the function can have all added form items as first\n     * argument and the manager as a second argument. The manager should be used\n     * to set the {@link #invalidMessage}.\n     *\n     * Keep in mind that the validator is optional if you don't need the\n     * validation in the context of the whole form.\n     * @type {Function | AsyncValidator}\n     */\n    validator :\n    {\n      check : \"value instanceof Function || qx.Class.isSubClassOf(value.constructor, qx.ui.form.validation.AsyncValidator)\",\n      init : null,\n      nullable : true\n    },\n\n    /**\n     * The invalid message should store the message why the form validation\n     * failed. It will be added to the array returned by\n     * {@link #getInvalidMessages}.\n     */\n    invalidMessage :\n    {\n      check : \"String\",\n      init: \"\"\n    },\n\n\n    /**\n     * This message will be shown if a required field is empty and no individual\n     * {@link qx.ui.form.MForm#requiredInvalidMessage} is given.\n     */\n    requiredFieldMessage :\n    {\n      check : \"String\",\n      init : \"\"\n    },\n\n\n    /**\n     * The context for the form validation.\n     */\n    context :\n    {\n      nullable : true\n    }\n  },\n\n\n  members :\n  {\n    __formItems : null,\n    __valid : null,\n    __asyncResults : null,\n    __syncValid : null,\n\n\n    /**\n     * Add a form item to the validation manager.\n     *\n     * The form item has to implement at least two interfaces:\n     * <ol>\n     *   <li>The {@link qx.ui.form.IForm} Interface</li>\n     *   <li>One of the following interfaces:\n     *     <ul>\n     *       <li>{@link qx.ui.form.IBooleanForm}</li>\n     *       <li>{@link qx.ui.form.IColorForm}</li>\n     *       <li>{@link qx.ui.form.IDateForm}</li>\n     *       <li>{@link qx.ui.form.INumberForm}</li>\n     *       <li>{@link qx.ui.form.IStringForm}</li>\n     *     </ul>\n     *   </li>\n     * </ol>\n     * The validator can be a synchronous or asynchronous validator. In\n     * both cases the validator can either returns a boolean or fire an\n     * {@link qx.core.ValidationError}. For synchronous validation, a plain\n     * JavaScript function should be used. For all asynchronous validations,\n     * a {@link qx.ui.form.validation.AsyncValidator} is needed to wrap the\n     * plain function.\n     *\n     * @param formItem {qx.ui.core.Widget} The form item to add.\n     * @param validator {Function | qx.ui.form.validation.AsyncValidator}\n     *   The validator.\n     * @param context {var?null} The context of the validator.\n     */\n    add: function(formItem, validator, context) {\n      // check for the form API\n      if (!this.__supportsInvalid(formItem)) {\n        throw new Error(\"Added widget not supported.\");\n      }\n      // check for the data type\n      if (this.__supportsSingleSelection(formItem) && !formItem.getValue) {\n        // check for a validator\n        if (validator != null) {\n          throw new Error(\"Widgets supporting selection can only be validated \" +\n          \"in the form validator\");\n        }\n      }\n      var dataEntry =\n      {\n        item : formItem,\n        validator : validator,\n        valid : null,\n        context : context\n      };\n      this.__formItems.push(dataEntry);\n    },\n\n\n    /**\n     * Remove a form item from the validation manager.\n     *\n     * @param formItem {qx.ui.core.Widget} The form item to remove.\n     * @return {qx.ui.core.Widget?null} The removed form item or\n     *  <code>null</code> if the item could not be found.\n     */\n    remove : function(formItem)\n    {\n      var items = this.__formItems;\n\n      for (var i = 0, len = items.length; i < len; i++)\n      {\n        if (formItem === items[i].item)\n        {\n          items.splice(i, 1);\n          return formItem;\n        }\n      }\n\n      return null;\n    },\n\n\n    /**\n     * Returns registered form items from the validation manager.\n     *\n     * @return {Array} The form items which will be validated.\n     */\n    getItems : function()\n    {\n      var items = [];\n      for (var i=0; i < this.__formItems.length; i++) {\n        items.push(this.__formItems[i].item);\n      };\n      return items;\n    },\n\n\n    /**\n     * Invokes the validation. If only synchronous validators are set, the\n     * result of the whole validation is available at the end of the method\n     * and can be returned. If an asynchronous validator is set, the result\n     * is still unknown at the end of this method so nothing will be returned.\n     * In both cases, a {@link #complete} event will be fired if the validation\n     * has ended. The result of the validation can then be accessed with the\n     * {@link #getValid} method.\n     *\n     * @return {Boolean|undefined} The validation result, if available.\n     */\n    validate : function() {\n      var valid = true;\n      this.__syncValid = true; // collaboration of all synchronous validations\n      var items = [];\n\n      // check all validators for the added form items\n      for (var i = 0; i < this.__formItems.length; i++) {\n        var formItem = this.__formItems[i].item;\n        var validator = this.__formItems[i].validator;\n\n        // store the items in case of form validation\n        items.push(formItem);\n\n        // ignore all form items without a validator\n        if (validator == null) {\n          // check for the required property\n          var validatorResult = this._validateRequired(formItem);\n          valid = valid && validatorResult;\n          this.__syncValid = validatorResult && this.__syncValid;\n          continue;\n        }\n\n        var validatorResult = this._validateItem(\n          this.__formItems[i], formItem.getValue()\n        );\n        // keep that order to ensure that null is returned on async cases\n        valid = validatorResult && valid;\n        if (validatorResult != null) {\n          this.__syncValid = validatorResult && this.__syncValid;\n        }\n      }\n\n      // check the form validator (be sure to invoke it even if the form\n      // items are already false, so keep the order!)\n      var formValid = this.__validateForm(items);\n      if (qx.lang.Type.isBoolean(formValid)) {\n        this.__syncValid = formValid && this.__syncValid;\n      }\n      valid = formValid && valid;\n\n      this._setValid(valid);\n\n      if (qx.lang.Object.isEmpty(this.__asyncResults)) {\n        this.fireEvent(\"complete\");\n      }\n      return valid;\n    },\n\n\n    /**\n     * Checks if the form item is required. If so, the value is checked\n     * and the result will be returned. If the form item is not required, true\n     * will be returned.\n     *\n     * @param formItem {qx.ui.core.Widget} The form item to check.\n     * @return {var} Validation result\n     */\n    _validateRequired : function(formItem) {\n      if (formItem.getRequired()) {\n        var validatorResult;\n        // if its a widget supporting the selection\n        if (this.__supportsSingleSelection(formItem)) {\n          validatorResult = !!formItem.getSelection()[0];\n\n        } else if (this.__supportsDataBindingSelection(formItem)) {\n          validatorResult = (formItem.getSelection().getLength() > 0);\n\n        } else {\n          var value = formItem.getValue();\n          validatorResult = !!value || value === 0;\n        }\n        formItem.setValid(validatorResult);\n        var individualMessage = formItem.getRequiredInvalidMessage();\n        var message = individualMessage ? individualMessage : this.getRequiredFieldMessage();\n        formItem.setInvalidMessage(message);\n        return validatorResult;\n      }\n      return true;\n    },\n\n\n    /**\n     * Validates a form item. This method handles the differences of\n     * synchronous and asynchronous validation and returns the result of the\n     * validation if possible (synchronous cases). If the validation is\n     * asynchronous, null will be returned.\n     *\n     * @param dataEntry {Object} The map stored in {@link #add}\n     * @param value {var} The currently set value\n     * @return {Boolean|null} Validation result or <code>null</code> for async\n     * validation\n     */\n    _validateItem : function(dataEntry, value) {\n      var formItem = dataEntry.item;\n      var context = dataEntry.context;\n      var validator = dataEntry.validator;\n\n      // check for asynchronous validation\n      if (this.__isAsyncValidator(validator)) {\n        // used to check if all async validations are done\n        this.__asyncResults[formItem.toHashCode()] = null;\n        validator.validate(formItem, formItem.getValue(), this, context);\n        return null;\n      }\n\n      var validatorResult = null;\n\n      try {\n        var validatorResult = validator.call(context || this, value, formItem);\n        if (validatorResult === undefined) {\n          validatorResult = true;\n        }\n\n      } catch (e) {\n        if (e instanceof qx.core.ValidationError) {\n          validatorResult = false;\n          if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {\n            var invalidMessage = e.message;\n          } else {\n            var invalidMessage = e.getComment();\n          }\n          formItem.setInvalidMessage(invalidMessage);\n        } else {\n          throw e;\n        }\n      }\n\n      formItem.setValid(validatorResult);\n      dataEntry.valid = validatorResult;\n\n      return validatorResult;\n    },\n\n\n    /**\n     * Validates the form. It checks for asynchronous validation and handles\n     * the differences to synchronous validation. If no form validator is given,\n     * true will be returned. If a synchronous validator is given, the\n     * validation result will be returned. In asynchronous cases, null will be\n     * returned cause the result is not available.\n     *\n     * @param items {qx.ui.core.Widget[]} An array of all form items.\n     * @return {Boolean|null} description\n     */\n    __validateForm: function(items) {\n      var formValidator = this.getValidator();\n      var context = this.getContext() || this;\n\n      if (formValidator == null) {\n        return true;\n      }\n\n      // reset the invalidMessage\n      this.setInvalidMessage(\"\");\n\n      if (this.__isAsyncValidator(formValidator)) {\n        this.__asyncResults[this.toHashCode()] = null;\n        formValidator.validateForm(items, this, context);\n        return null;\n      }\n\n      try {\n        var formValid = formValidator.call(context, items, this);\n        if (formValid === undefined) {\n          formValid = true;\n        }\n      } catch (e) {\n        if (e instanceof qx.core.ValidationError) {\n          formValid = false;\n\n          if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {\n            var invalidMessage = e.message;\n          } else {\n            var invalidMessage = e.getComment();\n          }\n          this.setInvalidMessage(invalidMessage);\n        } else {\n          throw e;\n        }\n      }\n      return formValid;\n    },\n\n\n    /**\n     * Helper function which checks, if the given validator is synchronous\n     * or asynchronous.\n     *\n     * @param validator {Function|qx.ui.form.validation.AsyncValidator}\n     *   The validator to check.\n     * @return {Boolean} True, if the given validator is asynchronous.\n     */\n    __isAsyncValidator : function(validator) {\n      var async = false;\n      if (!qx.lang.Type.isFunction(validator)) {\n        async = qx.Class.isSubClassOf(\n          validator.constructor, qx.ui.form.validation.AsyncValidator\n        );\n      }\n      return async;\n    },\n\n\n    /**\n     * Returns true, if the given item implements the {@link qx.ui.form.IForm}\n     * interface.\n     *\n     * @param formItem {qx.core.Object} The item to check.\n     * @return {Boolean} true, if the given item implements the\n     *   necessary interface.\n     */\n    __supportsInvalid : function(formItem) {\n      var clazz = formItem.constructor;\n      return qx.Class.hasInterface(clazz, qx.ui.form.IForm);\n    },\n\n\n    /**\n     * Returns true, if the given item implements the\n     * {@link qx.ui.core.ISingleSelection} interface.\n     *\n     * @param formItem {qx.core.Object} The item to check.\n     * @return {Boolean} true, if the given item implements the\n     *   necessary interface.\n     */\n    __supportsSingleSelection : function(formItem) {\n      var clazz = formItem.constructor;\n      return qx.Class.hasInterface(clazz, qx.ui.core.ISingleSelection);\n    },\n\n\n    /**\n     * Returns true, if the given item implements the\n     * {@link qx.data.controller.ISelection} interface.\n     *\n     * @param formItem {qx.core.Object} The item to check.\n     * @return {Boolean} true, if the given item implements the\n     *   necessary interface.\n     */\n    __supportsDataBindingSelection : function(formItem) {\n      var clazz = formItem.constructor;\n      return qx.Class.hasInterface(clazz, qx.data.controller.ISelection);\n    },\n\n\n    /**\n     * Sets the valid state of the manager. It generates the event if\n     * necessary and stores the new value.\n     *\n     * @param value {Boolean|null} The new valid state of the manager.\n     */\n    _setValid: function(value) {\n      this._showToolTip(value);\n      var oldValue = this.__valid;\n      this.__valid = value;\n      // check for the change event\n      if (oldValue != value) {\n        this.fireDataEvent(\"changeValid\", value, oldValue);\n      }\n    },\n\n\n    /**\n     * Responsible for showing a tooltip in case the validation is done for\n     * widgets based on qx.ui.core.Widget.\n     * @param valid {Boolean} <code>false</code>, if the tooltip should be shown\n     */\n    _showToolTip : function(valid) {\n      // ignore if we don't have a tooltip manager e.g. mobile apps\n      if (!qx.ui.tooltip || !qx.ui.tooltip.Manager) {\n        return;\n      }\n      var tooltip = qx.ui.tooltip.Manager.getInstance().getSharedErrorTooltip();\n\n      if (!valid) {\n        var firstInvalid;\n        for (var i = 0; i < this.__formItems.length; i++) {\n          var item = this.__formItems[i].item;\n          if (!item.isValid()) {\n            firstInvalid = item;\n            // only for desktop widgets\n            if (!(item.getContentLocation)) {\n              return;\n            }\n            // only consider items on the screen\n            if (item.isSeeable() === false) {\n              continue;\n            }\n\n            tooltip.setLabel(item.getInvalidMessage());\n\n            if (tooltip.getPlaceMethod() == \"mouse\") {\n              var location = item.getContentLocation();\n              var top = location.top - tooltip.getOffsetTop();\n              tooltip.placeToPoint({left: location.right, top: top});\n            } else {\n              tooltip.placeToWidget(item);\n            }\n\n            tooltip.show();\n            return;\n          }\n        }\n      } else {\n        tooltip.exclude();\n      }\n    },\n\n\n    /**\n     * Returns the valid state of the manager.\n     *\n     * @return {Boolean|null} The valid state of the manager.\n     */\n    getValid: function() {\n      return this.__valid;\n    },\n\n\n    /**\n     * Returns the valid state of the manager.\n     *\n     * @return {Boolean|null} The valid state of the manager.\n     */\n    isValid: function() {\n      return this.getValid();\n    },\n\n\n    /**\n     * Returns an array of all invalid messages of the invalid form items and\n     * the form manager itself.\n     *\n     * @return {String[]} All invalid messages.\n     */\n    getInvalidMessages: function() {\n      var messages = [];\n      // combine the messages of all form items\n      for (var i = 0; i < this.__formItems.length; i++) {\n        var formItem = this.__formItems[i].item;\n        if (!formItem.getValid()) {\n          messages.push(formItem.getInvalidMessage());\n        }\n      }\n      // add the forms fail message\n      if (this.getInvalidMessage() != \"\") {\n        messages.push(this.getInvalidMessage());\n      }\n\n      return messages;\n    },\n\n\n    /**\n     * Selects invalid form items\n     *\n     * @return {Array} invalid form items\n     */\n    getInvalidFormItems : function() {\n      var res = [];\n      for (var i = 0; i < this.__formItems.length; i++) {\n        var formItem = this.__formItems[i].item;\n        if (!formItem.getValid()) {\n          res.push(formItem);\n        }\n      }\n\n      return res;\n    },\n\n\n    /**\n     * Resets the validator.\n     */\n    reset: function() {\n      // reset all form items\n      for (var i = 0; i < this.__formItems.length; i++) {\n        var dataEntry = this.__formItems[i];\n        // set the field to valid\n        dataEntry.item.setValid(true);\n      }\n      // set the manager to its initial valid value\n      this.__valid = null;\n      this._showToolTip(true);\n    },\n\n\n    /**\n     * Internal helper method to set the given item to valid for asynchronous\n     * validation calls. This indirection is used to determinate if the\n     * validation process is completed or if other asynchronous validators\n     * are still validating. {@link #__checkValidationComplete} checks if the\n     * validation is complete and will be called at the end of this method.\n     *\n     * @param formItem {qx.ui.core.Widget} The form item to set the valid state.\n     * @param valid {Boolean} The valid state for the form item.\n     *\n     * @internal\n     */\n    setItemValid: function(formItem, valid) {\n      // store the result\n      this.__asyncResults[formItem.toHashCode()] = valid;\n      formItem.setValid(valid);\n      this.__checkValidationComplete();\n    },\n\n\n    /**\n     * Internal helper method to set the form manager to valid for asynchronous\n     * validation calls. This indirection is used to determinate if the\n     * validation process is completed or if other asynchronous validators\n     * are still validating. {@link #__checkValidationComplete} checks if the\n     * validation is complete and will be called at the end of this method.\n     *\n     * @param valid {Boolean} The valid state for the form manager.\n     *\n     * @internal\n     */\n    setFormValid : function(valid) {\n      this.__asyncResults[this.toHashCode()] = valid;\n      this.__checkValidationComplete();\n    },\n\n\n    /**\n     * Checks if all asynchronous validators have validated so the result\n     * is final and the {@link #complete} event can be fired. If that's not\n     * the case, nothing will happen in the method.\n     */\n    __checkValidationComplete : function() {\n      var valid = this.__syncValid;\n\n      // check if all async validators are done\n      for (var hash in this.__asyncResults) {\n        var currentResult = this.__asyncResults[hash];\n        valid = currentResult && valid;\n        // the validation is not done so just do nothing\n        if (currentResult == null) {\n          return;\n        }\n      }\n      // set the actual valid state of the manager\n      this._setValid(valid);\n      // reset the results\n      this.__asyncResults = {};\n      // fire the complete event (no entry in the results with null)\n      this.fireEvent(\"complete\");\n    }\n  },\n\n\n  /*\n  *****************************************************************************\n     DESTRUCTOR\n  *****************************************************************************\n  */\n  destruct : function()\n  {\n    this._showToolTip(true);\n    this.__formItems = null;\n  }\n});\n"
  ]
}