<p>The @qx.bom.rest@ package consists of only one class: {@link Resource}.
 {@link Resource} allows to encapsulate the specifics of a REST interface.
 Rather than requesting URLs with a specific HTTP method manually, a resource
 representing the remote resource is instantiated and actions are invoked on this resource.
 A resource with its actions can be configured declaratively or programmatically.
 There is also {@link qx.io.rest.Resource} which uses {@link Resource} under the hood.
 The main differences between them are:</p>
<ul>
<li>The event object available in the listeners (e.g. @success()@, @getSuccess()@ and @getError()@) is
a native JavaScript object instead of a qooxdoo object ({@link qx.event.type.Rest}):<ul>
<li>See {@link qx.io.rest.Resource} vs. {@link Resource}</li>
<li>@event.getId()@ =&gt; @event.id@</li>
<li>@event.getRequest()@ =&gt; @event.request@</li>
<li>@event.getAction()@ =&gt; @event.action@</li>
<li>@event.getData()@ =&gt; @event.response@</li>
<li>@event.getPhase()@ =&gt; @---@ (see below)</li></ul></li>
<li>Methods which allow request manipulation (e.g. @configureRequest()@) will operate on an
instance of {@link qx.bom.request.SimpleXhr} instead of {@link qx.io.request.Xhr}
(their API is similar but not identical)</li>
<li>The method @poll()@ returns no {@link qx.event.Timer} object. There are two new methods
(@stopPollByAction()@ and @restartPollByAction()@) available at {@link Resource}
which replace the functionality provided by the Timer object.</li>
<li>The phase support, which is a more elaborate version of readyState, is not available.
So use readyState instead.<ul>
<li>Phases (available only in {@link qx.io.rest.Resource}):<ul>
<li>@unsent@, @opened@, @sent@, @loading@, @load@, @success@</li>
<li>@abort@, @timeout@, @statusError@</li></ul></li>
<li>readyState (available in {@link Resource} and {@link qx.io.rest.Resource}):<ul>
<li>@UNSENT@</li>
<li>@OPENED@</li>
<li>@HEADERS_RECEIVED@</li>
<li>@LOADING@</li>
<li>@DONE@</li></ul></li></ul></li>
</ul>