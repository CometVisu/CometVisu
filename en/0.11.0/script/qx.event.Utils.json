{"attributes": {"name": "Utils", "hasWarning": true, "isInternal": true, "packageName": "qx.event", "access": "internal", "superClass": "qx.core.Object", "fullName": "qx.event.Utils", "type": "class"}, "type": "class", "children": [{"attributes": {"text": "<p>Utility methods which implement a fast, psuedo-promises mechanism used by event handlers\nand dispatchers.</p>\n\n<p>Event handlers are allowed to return instances of `qx.Promise`, in which case the event\nqueue is suspended until the promise is resolved.  The simplest way to handle this would be\nto convert the result of every event handler into a `qx.Promise` via `qx.Promise.resolve`,\nbut given that by far the majority of event handlers do not return promises, this could add\na significant overhead; the static methods in this class allow the event handlers to be\ntriggered and only when a `qx.Promise` is returned from a handler does the event dispatch\nmechanism switch to using promise to suspend the event queue.</p>\n\n<p>To use this, the calling code simply creates an empty object (i.e. `var tracker = {};`)\nwhich is then passed to `qx.event.Utils.then`, for example:</p>\n\n<code>\nvar tracker = {};\nUtils.then(tracker, function() { ... });\nUtils.then(tracker, function() { ... });\nUtils.then(tracker, function() { ... });\nUtils.catch(tracker, function() { ... });\n</code>\n\n<p>Following with the morphing nature of this class, the return type will be either the value\nreturned from the event handlers, or a promise which evaluates to that value.</p>\n\n<p>When events are aborted (eg via `event.stopPropagation()`) that causes the promise (if there\nis one) to be rejected.</p>\n\n<p>Note that this class is not a replacement for promises and has its limitations because it\nhas been built for the express purposes of the event dispatchers.</p>"}, "type": "desc"}, {"attributes": {}, "type": "constants", "children": [{"attributes": {"name": "then"}, "type": "constant", "children": [{"attributes": {"text": "<p>Equivalent of `promise.then()`</p><p>the tracker object</p><p>the function to call when previous promises are complete</p><p>the new promise, or the return value from `fn` if no promises are in use</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "track"}, "type": "constant", "children": [{"attributes": {"text": "<p>Evaluates a value, and adds it to the tracker</p><p>the tracker object</p><p>if a function, it&#8217;s evaluated as a `then`, otherwise it&#8217;s encapulated in a function for `then`</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}, {"attributes": {"type": "Object"}, "type": "entry"}]}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}, {"attributes": {"type": "Object"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "series"}, "type": "constant", "children": [{"attributes": {"text": "<p>Provides a handy way to iterate over an array which at any point could\nbecome asynchronous</p><p>an array to interate over</p><p>the function to call, with parameters (item, index)</p><p>whether to ignore the &#8220;ABORT&#8221; return value</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Array"}, "type": "entry"}]}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Boolean"}, "type": "entry"}]}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}, {"attributes": {"type": "Object"}, "type": "entry"}]}]}, {"attributes": {"type": "String", "name": "ABORT", "value": "[[ qx.event.Utils.ABORT ]]"}, "type": "constant"}]}, {"attributes": {}, "type": "methods-static", "children": [{"attributes": {"access": "private", "line": 210, "isStatic": true, "name": "__addCatcher"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "tracker"}, "type": "param", "children": [{"attributes": {"text": "<p>the tracker object</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Helper method that adds a catcher to the tracker</p>"}, "type": "desc"}]}, {"attributes": {"access": "private", "isStatic": true, "hasError": true, "line": 226, "name": "__catcher"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "tracker"}, "type": "param", "children": [{"attributes": {"text": "<p>the tracker object</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}, {"attributes": {"name": "err"}, "type": "param"}]}, {"attributes": {"text": "<p>This method is added with `.catch` to every promise created; because this is added\nall the way up the promise chain to ensure that it catches everything, this method\nsupresses multiple invocations (i.e. ignores everything except the first)</p>"}, "type": "desc"}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Parameter is not documented: 'err'", "column": 16, "line": 226}, "type": "error"}, {"attributes": {"msg": "Missing documentation for return value.", "column": 16, "line": 226}, "type": "error"}]}]}, {"attributes": {"access": "private", "line": 90, "isStatic": true, "name": "__push"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "tracker"}, "type": "param", "children": [{"attributes": {"text": "<p>the tracker object</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}, {"attributes": {"name": "newPromise"}, "type": "param", "children": [{"attributes": {"text": "<p>the new promise</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Helper method to store a promise in a tracker</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": "<p>the new promise</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"access": "private", "line": 173, "isStatic": true, "name": "__thenPromise"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "tracker"}, "type": "param", "children": [{"attributes": {"text": "<p>the tracker object</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}, {"attributes": {"name": "newPromise"}, "type": "param", "children": [{"attributes": {"text": "<p>the new promise</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Helper method to append a promise after the current one</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": "<p>the new promise</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}, {"attributes": {"isStatic": true, "hasError": true, "line": 280, "name": "callListener"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "tracker"}, "type": "param", "children": [{"attributes": {"text": "<p>the tracker object</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}, {"attributes": {"name": "listener"}, "type": "param", "children": [{"attributes": {"text": "<p>the event handler</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}, {"attributes": {"optional": true, "name": "context"}, "type": "param", "children": [{"attributes": {"text": "<p>the `this` for the event handler</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}, {"attributes": {"name": "event"}, "type": "param", "children": [{"attributes": {"text": "<p>the event being fired</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Event"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Calls a listener, converting propagationStopped into a rejection</p>"}, "type": "desc"}, {"attributes": {}, "type": "errors", "children": [{"attributes": {"msg": "Missing documentation for return value.", "column": 19, "line": 280}, "type": "error"}]}]}, {"attributes": {"line": 246, "isStatic": true, "name": "catch"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "tracker"}, "type": "param", "children": [{"attributes": {"text": "<p>the tracker object</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}, {"attributes": {"name": "fn"}, "type": "param", "children": [{"attributes": {"text": "<p>the function to call</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Function"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Equivalent to `.catch()`; note that unlike promises, this method must be called <strong>before</strong>\n`.then()` so that it is able to handle rejections when promises are not in use; this is\nbecause `Promise.catch` only catches rejections from previous promises, but because promises\nare <strong>always</strong> asynchronous the `.catch` goes at the end.  For synchronous, this is nt possible\nso `Utils.catch` must go before `Utils.then`</p>"}, "type": "desc"}]}, {"attributes": {"line": 192, "isStatic": true, "name": "reject"}, "type": "method", "children": [{"attributes": {}, "type": "params", "children": [{"attributes": {"name": "tracker"}, "type": "param", "children": [{"attributes": {"text": "<p>the tracker object</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "Object"}, "type": "entry"}]}]}]}, {"attributes": {"text": "<p>Rejects the tracker, aborting the promise if there is one.  The caller should stop\nimmediately because if promises are not in use and exception is not thrown.</p>"}, "type": "desc"}, {"attributes": {}, "type": "return", "children": [{"attributes": {"text": "<p>the last promise or the value returned by the catcher</p>"}, "type": "desc"}, {"attributes": {}, "type": "types", "children": [{"attributes": {"type": "qx.Promise"}, "type": "entry"}]}]}]}]}]}