qx.$$packageData['130']={"resources":{"@MaterialIcons/360":[32,32.0,58743],"@MaterialIcons/3d_rotation":[32,32.0,59469],"@MaterialIcons/4k":[32,32.0,57458],"@MaterialIcons/a":[32,32.0,97],"@MaterialIcons/ac_unit":[32,32.0,60219],"@MaterialIcons/access_alarm":[32,32.0,57744],"@MaterialIcons/access_alarms":[32,32.0,57745],"@MaterialIcons/access_time":[32,32.0,57746],"@MaterialIcons/accessibility":[32,32.0,59470],"@MaterialIcons/accessibility_new":[32,32.0,59692],"@MaterialIcons/accessible":[32,32.0,59668],"@MaterialIcons/accessible_forward":[32,32.0,59700],"@MaterialIcons/account_balance":[32,32.0,59471],"@MaterialIcons/account_balance_wallet":[32,32.0,59472],"@MaterialIcons/account_box":[32,32.0,59473],"@MaterialIcons/account_circle":[32,32.0,59475],"@MaterialIcons/adb":[32,32.0,58894],"@MaterialIcons/add":[32,32.0,57669],"@MaterialIcons/add_a_photo":[32,32.0,58425],"@MaterialIcons/add_alarm":[32,32.0,57747],"@MaterialIcons/add_alert":[32,32.0,57347],"@MaterialIcons/add_box":[32,32.0,57670],"@MaterialIcons/add_call":[32,32.0,57576],"@MaterialIcons/add_circle":[32,32.0,57671],"@MaterialIcons/add_circle_outline":[32,32.0,57672],"@MaterialIcons/add_comment":[32,32.0,57958],"@MaterialIcons/add_link":[32,32.0,57720],"@MaterialIcons/add_location":[32,32.0,58727],"@MaterialIcons/add_photo_alternate":[32,32.0,58430],"@MaterialIcons/add_shopping_cart":[32,32.0,59476],"@MaterialIcons/add_to_home_screen":[32,32.0,57854],"@MaterialIcons/add_to_photos":[32,32.0,58269],"@MaterialIcons/add_to_queue":[32,32.0,57436],"@MaterialIcons/adjust":[32,32.0,58270],"@MaterialIcons/airline_seat_flat":[32,32.0,58928],"@MaterialIcons/airline_seat_flat_angled":[32,32.0,58929],"@MaterialIcons/airline_seat_individual_suite":[32,32.0,58930],"@MaterialIcons/airline_seat_legroom_extra":[32,32.0,58931],"@MaterialIcons/airline_seat_legroom_normal":[32,32.0,58932],"@MaterialIcons/airline_seat_legroom_reduced":[32,32.0,58933],"@MaterialIcons/airline_seat_recline_extra":[32,32.0,58934],"@MaterialIcons/airline_seat_recline_normal":[32,32.0,58935],"@MaterialIcons/airplanemode_active":[32,32.0,57749],"@MaterialIcons/airplanemode_inactive":[32,32.0,57748],"@MaterialIcons/airplay":[32,32.0,57429],"@MaterialIcons/airport_shuttle":[32,32.0,60220],"@MaterialIcons/alarm":[32,32.0,59477],"@MaterialIcons/alarm_add":[32,32.0,59478],"@MaterialIcons/alarm_off":[32,32.0,59479],"@MaterialIcons/alarm_on":[32,32.0,59480],"@MaterialIcons/album":[32,32.0,57369],"@MaterialIcons/all_inclusive":[32,32.0,60221],"@MaterialIcons/all_out":[32,32.0,59659],"@MaterialIcons/alternate_email":[32,32.0,57574],"@MaterialIcons/android":[32,32.0,59481],"@MaterialIcons/announcement":[32,32.0,59482],"@MaterialIcons/apps":[32,32.0,58819],"@MaterialIcons/archive":[32,32.0,57673],"@MaterialIcons/arrow_back":[32,32.0,58820],"@MaterialIcons/arrow_back_ios":[32,32.0,58848],"@MaterialIcons/arrow_downward":[32,32.0,58843],"@MaterialIcons/arrow_drop_down":[32,32.0,58821],"@MaterialIcons/arrow_drop_down_circle":[32,32.0,58822],"@MaterialIcons/arrow_drop_up":[32,32.0,58823],"@MaterialIcons/arrow_forward":[32,32.0,58824],"@MaterialIcons/arrow_forward_ios":[32,32.0,58849],"@MaterialIcons/arrow_left":[32,32.0,58846],"@MaterialIcons/arrow_right":[32,32.0,58847],"@MaterialIcons/arrow_right_alt":[32,32.0,59713],"@MaterialIcons/arrow_upward":[32,32.0,58840],"@MaterialIcons/art_track":[32,32.0,57440],"@MaterialIcons/aspect_ratio":[32,32.0,59483],"@MaterialIcons/assessment":[32,32.0,59484],"@MaterialIcons/assignment":[32,32.0,59485],"@MaterialIcons/assignment_ind":[32,32.0,59486],"@MaterialIcons/assignment_late":[32,32.0,59487],"@MaterialIcons/assignment_return":[32,32.0,59488],"@MaterialIcons/assignment_returned":[32,32.0,59489],"@MaterialIcons/assignment_turned_in":[32,32.0,59490],"@MaterialIcons/assistant":[32,32.0,58271],"@MaterialIcons/assistant_photo":[32,32.0,58272],"@MaterialIcons/atm":[32,32.0,58739],"@MaterialIcons/attach_file":[32,32.0,57894],"@MaterialIcons/attach_money":[32,32.0,57895],"@MaterialIcons/attachment":[32,32.0,58044],"@MaterialIcons/audiotrack":[32,32.0,58273],"@MaterialIcons/autorenew":[32,32.0,59491],"@MaterialIcons/av_timer":[32,32.0,57371],"@MaterialIcons/b":[32,32.0,98],"@MaterialIcons/backspace":[32,32.0,57674],"@MaterialIcons/backup":[32,32.0,59492],"@MaterialIcons/ballot":[32,32.0,57714],"@MaterialIcons/bar_chart":[32,32.0,57963],"@MaterialIcons/battery_alert":[32,32.0,57756],"@MaterialIcons/battery_charging_full":[32,32.0,57763],"@MaterialIcons/battery_full":[32,32.0,57764],"@MaterialIcons/battery_std":[32,32.0,57765],"@MaterialIcons/battery_unknown":[32,32.0,57766],"@MaterialIcons/beach_access":[32,32.0,60222],"@MaterialIcons/beenhere":[32,32.0,58669],"@MaterialIcons/block":[32,32.0,57675],"@MaterialIcons/bluetooth":[32,32.0,57767],"@MaterialIcons/bluetooth_audio":[32,32.0,58895],"@MaterialIcons/bluetooth_connected":[32,32.0,57768],"@MaterialIcons/bluetooth_disabled":[32,32.0,57769],"@MaterialIcons/bluetooth_searching":[32,32.0,57770],"@MaterialIcons/blur_circular":[32,32.0,58274],"@MaterialIcons/blur_linear":[32,32.0,58275],"@MaterialIcons/blur_off":[32,32.0,58276],"@MaterialIcons/blur_on":[32,32.0,58277],"@MaterialIcons/book":[32,32.0,59493],"@MaterialIcons/bookmark":[32,32.0,59494],"@MaterialIcons/bookmark_border":[32,32.0,59495],"@MaterialIcons/border_all":[32,32.0,57896],"@MaterialIcons/border_bottom":[32,32.0,57897],"@MaterialIcons/border_clear":[32,32.0,57898],"@MaterialIcons/border_color":[32,32.0,57899],"@MaterialIcons/border_horizontal":[32,32.0,57900],"@MaterialIcons/border_inner":[32,32.0,57901],"@MaterialIcons/border_left":[32,32.0,57902],"@MaterialIcons/border_outer":[32,32.0,57903],"@MaterialIcons/border_right":[32,32.0,57904],"@MaterialIcons/border_style":[32,32.0,57905],"@MaterialIcons/border_top":[32,32.0,57906],"@MaterialIcons/border_vertical":[32,32.0,57907],"@MaterialIcons/branding_watermark":[32,32.0,57451],"@MaterialIcons/brightness_1":[32,32.0,58278],"@MaterialIcons/brightness_2":[32,32.0,58279],"@MaterialIcons/brightness_3":[32,32.0,58280],"@MaterialIcons/brightness_4":[32,32.0,58281],"@MaterialIcons/brightness_5":[32,32.0,58282],"@MaterialIcons/brightness_6":[32,32.0,58283],"@MaterialIcons/brightness_7":[32,32.0,58284],"@MaterialIcons/brightness_auto":[32,32.0,57771],"@MaterialIcons/brightness_high":[32,32.0,57772],"@MaterialIcons/brightness_low":[32,32.0,57773],"@MaterialIcons/brightness_medium":[32,32.0,57774],"@MaterialIcons/broken_image":[32,32.0,58285],"@MaterialIcons/brush":[32,32.0,58286],"@MaterialIcons/bubble_chart":[32,32.0,59101],"@MaterialIcons/bug_report":[32,32.0,59496],"@MaterialIcons/build":[32,32.0,59497],"@MaterialIcons/burst_mode":[32,32.0,58428],"@MaterialIcons/business":[32,32.0,57519],"@MaterialIcons/business_center":[32,32.0,60223],"@MaterialIcons/c":[32,32.0,99],"@MaterialIcons/cached":[32,32.0,59498],"@MaterialIcons/cake":[32,32.0,59369],"@MaterialIcons/calendar_today":[32,32.0,59701],"@MaterialIcons/calendar_view_day":[32,32.0,59702],"@MaterialIcons/call":[32,32.0,57520],"@MaterialIcons/call_end":[32,32.0,57521],"@MaterialIcons/call_made":[32,32.0,57522],"@MaterialIcons/call_merge":[32,32.0,57523],"@MaterialIcons/call_missed":[32,32.0,57524],"@MaterialIcons/call_missed_outgoing":[32,32.0,57572],"@MaterialIcons/call_received":[32,32.0,57525],"@MaterialIcons/call_split":[32,32.0,57526],"@MaterialIcons/call_to_action":[32,32.0,57452],"@MaterialIcons/camera":[32,32.0,58287],"@MaterialIcons/camera_alt":[32,32.0,58288],"@MaterialIcons/camera_enhance":[32,32.0,59644],"@MaterialIcons/camera_front":[32,32.0,58289],"@MaterialIcons/camera_rear":[32,32.0,58290],"@MaterialIcons/camera_roll":[32,32.0,58291],"@MaterialIcons/cancel":[32,32.0,58825],"@MaterialIcons/cancel_presentation":[32,32.0,57577],"@MaterialIcons/card_giftcard":[32,32.0,59638],"@MaterialIcons/card_membership":[32,32.0,59639],"@MaterialIcons/card_travel":[32,32.0,59640],"@MaterialIcons/casino":[32,32.0,60224],"@MaterialIcons/cast":[32,32.0,58119],"@MaterialIcons/cast_connected":[32,32.0,58120],"@MaterialIcons/category":[32,32.0,58740],"@MaterialIcons/cell_wifi":[32,32.0,57580],"@MaterialIcons/center_focus_strong":[32,32.0,58292],"@MaterialIcons/center_focus_weak":[32,32.0,58293],"@MaterialIcons/change_history":[32,32.0,59499],"@MaterialIcons/chat":[32,32.0,57527],"@MaterialIcons/chat_bubble":[32,32.0,57546],"@MaterialIcons/chat_bubble_outline":[32,32.0,57547],"@MaterialIcons/check":[32,32.0,58826],"@MaterialIcons/check_box":[32,32.0,59444],"@MaterialIcons/check_box_outline_blank":[32,32.0,59445],"@MaterialIcons/check_circle":[32,32.0,59500],"@MaterialIcons/check_circle_outline":[32,32.0,59693],"@MaterialIcons/chevron_left":[32,32.0,58827],"@MaterialIcons/chevron_right":[32,32.0,58828],"@MaterialIcons/child_care":[32,32.0,60225],"@MaterialIcons/child_friendly":[32,32.0,60226],"@MaterialIcons/chrome_reader_mode":[32,32.0,59501],"@MaterialIcons/class":[32,32.0,59502],"@MaterialIcons/clear":[32,32.0,57676],"@MaterialIcons/clear_all":[32,32.0,57528],"@MaterialIcons/close":[32,32.0,58829],"@MaterialIcons/closed_caption":[32,32.0,57372],"@MaterialIcons/cloud":[32,32.0,58045],"@MaterialIcons/cloud_circle":[32,32.0,58046],"@MaterialIcons/cloud_done":[32,32.0,58047],"@MaterialIcons/cloud_download":[32,32.0,58048],"@MaterialIcons/cloud_off":[32,32.0,58049],"@MaterialIcons/cloud_queue":[32,32.0,58050],"@MaterialIcons/cloud_upload":[32,32.0,58051],"@MaterialIcons/code":[32,32.0,59503],"@MaterialIcons/collections":[32,32.0,58294],"@MaterialIcons/collections_bookmark":[32,32.0,58417],"@MaterialIcons/color_lens":[32,32.0,58295],"@MaterialIcons/colorize":[32,32.0,58296],"@MaterialIcons/comment":[32,32.0,57529],"@MaterialIcons/commute":[32,32.0,59712],"@MaterialIcons/compare":[32,32.0,58297],"@MaterialIcons/compare_arrows":[32,32.0,59669],"@MaterialIcons/compass_calibration":[32,32.0,58748],"@MaterialIcons/computer":[32,32.0,58122],"@MaterialIcons/confirmation_number":[32,32.0,58936],"@MaterialIcons/contact_mail":[32,32.0,57552],"@MaterialIcons/contact_phone":[32,32.0,57551],"@MaterialIcons/contact_support":[32,32.0,59724],"@MaterialIcons/contacts":[32,32.0,57530],"@MaterialIcons/content_copy":[32,32.0,57677],"@MaterialIcons/content_cut":[32,32.0,57678],"@MaterialIcons/content_paste":[32,32.0,57679],"@MaterialIcons/control_camera":[32,32.0,57460],"@MaterialIcons/control_point":[32,32.0,58298],"@MaterialIcons/control_point_duplicate":[32,32.0,58299],"@MaterialIcons/copyright":[32,32.0,59660],"@MaterialIcons/create":[32,32.0,57680],"@MaterialIcons/create_new_folder":[32,32.0,58060],"@MaterialIcons/credit_card":[32,32.0,59504],"@MaterialIcons/crop":[32,32.0,58302],"@MaterialIcons/crop_16_9":[32,32.0,58300],"@MaterialIcons/crop_3_2":[32,32.0,58301],"@MaterialIcons/crop_5_4":[32,32.0,58303],"@MaterialIcons/crop_7_5":[32,32.0,58304],"@MaterialIcons/crop_din":[32,32.0,58305],"@MaterialIcons/crop_free":[32,32.0,58306],"@MaterialIcons/crop_landscape":[32,32.0,58307],"@MaterialIcons/crop_original":[32,32.0,58308],"@MaterialIcons/crop_portrait":[32,32.0,58309],"@MaterialIcons/crop_rotate":[32,32.0,58423],"@MaterialIcons/crop_square":[32,32.0,58310],"@MaterialIcons/d":[32,32.0,100],"@MaterialIcons/dashboard":[32,32.0,59505],"@MaterialIcons/data_usage":[32,32.0,57775],"@MaterialIcons/date_range":[32,32.0,59670],"@MaterialIcons/dehaze":[32,32.0,58311],"@MaterialIcons/delete":[32,32.0,59506],"@MaterialIcons/delete_forever":[32,32.0,59691],"@MaterialIcons/delete_outline":[32,32.0,59694],"@MaterialIcons/delete_sweep":[32,32.0,57708],"@MaterialIcons/departure_board":[32,32.0,58742],"@MaterialIcons/description":[32,32.0,59507],"@MaterialIcons/desktop_mac":[32,32.0,58123],"@MaterialIcons/desktop_windows":[32,32.0,58124],"@MaterialIcons/details":[32,32.0,58312],"@MaterialIcons/developer_board":[32,32.0,58125],"@MaterialIcons/developer_mode":[32,32.0,57776],"@MaterialIcons/device_hub":[32,32.0,58165],"@MaterialIcons/device_unknown":[32,32.0,58169],"@MaterialIcons/devices":[32,32.0,57777],"@MaterialIcons/devices_other":[32,32.0,58167],"@MaterialIcons/dialer_sip":[32,32.0,57531],"@MaterialIcons/dialpad":[32,32.0,57532],"@MaterialIcons/directions":[32,32.0,58670],"@MaterialIcons/directions_bike":[32,32.0,58671],"@MaterialIcons/directions_boat":[32,32.0,58674],"@MaterialIcons/directions_bus":[32,32.0,58672],"@MaterialIcons/directions_car":[32,32.0,58673],"@MaterialIcons/directions_railway":[32,32.0,58676],"@MaterialIcons/directions_run":[32,32.0,58726],"@MaterialIcons/directions_subway":[32,32.0,58675],"@MaterialIcons/directions_transit":[32,32.0,58677],"@MaterialIcons/directions_walk":[32,32.0,58678],"@MaterialIcons/disc_full":[32,32.0,58896],"@MaterialIcons/dns":[32,32.0,59509],"@MaterialIcons/do_not_disturb":[32,32.0,58898],"@MaterialIcons/do_not_disturb_alt":[32,32.0,58897],"@MaterialIcons/do_not_disturb_off":[32,32.0,58947],"@MaterialIcons/do_not_disturb_on":[32,32.0,58948],"@MaterialIcons/dock":[32,32.0,58126],"@MaterialIcons/domain":[32,32.0,59374],"@MaterialIcons/domain_disabled":[32,32.0,57583],"@MaterialIcons/done":[32,32.0,59510],"@MaterialIcons/done_all":[32,32.0,59511],"@MaterialIcons/done_outline":[32,32.0,59695],"@MaterialIcons/donut_large":[32,32.0,59671],"@MaterialIcons/donut_small":[32,32.0,59672],"@MaterialIcons/drafts":[32,32.0,57681],"@MaterialIcons/drag_handle":[32,32.0,57949],"@MaterialIcons/drag_indicator":[32,32.0,59717],"@MaterialIcons/drive_eta":[32,32.0,58899],"@MaterialIcons/dvr":[32,32.0,57778],"@MaterialIcons/e":[32,32.0,101],"@MaterialIcons/edit":[32,32.0,58313],"@MaterialIcons/edit_attributes":[32,32.0,58744],"@MaterialIcons/edit_location":[32,32.0,58728],"@MaterialIcons/edit_off":[32,32.0,59728],"@MaterialIcons/eight":[32,32.0,56],"@MaterialIcons/eject":[32,32.0,59643],"@MaterialIcons/email":[32,32.0,57534],"@MaterialIcons/enhanced_encryption":[32,32.0,58943],"@MaterialIcons/equalizer":[32,32.0,57373],"@MaterialIcons/error":[32,32.0,57344],"@MaterialIcons/error_outline":[32,32.0,57345],"@MaterialIcons/euro_symbol":[32,32.0,59686],"@MaterialIcons/ev_station":[32,32.0,58733],"@MaterialIcons/event":[32,32.0,59512],"@MaterialIcons/event_available":[32,32.0,58900],"@MaterialIcons/event_busy":[32,32.0,58901],"@MaterialIcons/event_note":[32,32.0,58902],"@MaterialIcons/event_seat":[32,32.0,59651],"@MaterialIcons/exit_to_app":[32,32.0,59513],"@MaterialIcons/expand":[32,32.0,59727],"@MaterialIcons/expand_less":[32,32.0,58830],"@MaterialIcons/expand_more":[32,32.0,58831],"@MaterialIcons/explicit":[32,32.0,57374],"@MaterialIcons/explore":[32,32.0,59514],"@MaterialIcons/exposure":[32,32.0,58314],"@MaterialIcons/exposure_neg_1":[32,32.0,58315],"@MaterialIcons/exposure_neg_2":[32,32.0,58316],"@MaterialIcons/exposure_plus_1":[32,32.0,58317],"@MaterialIcons/exposure_plus_2":[32,32.0,58318],"@MaterialIcons/exposure_zero":[32,32.0,58319],"@MaterialIcons/extension":[32,32.0,59515],"@MaterialIcons/f":[32,32.0,102],"@MaterialIcons/face":[32,32.0,59516],"@MaterialIcons/fast_forward":[32,32.0,57375],"@MaterialIcons/fast_rewind":[32,32.0,57376],"@MaterialIcons/fastfood":[32,32.0,58746],"@MaterialIcons/favorite":[32,32.0,59517],"@MaterialIcons/favorite_border":[32,32.0,59518],"@MaterialIcons/featured_play_list":[32,32.0,57453],"@MaterialIcons/featured_video":[32,32.0,57454],"@MaterialIcons/feedback":[32,32.0,59519],"@MaterialIcons/fiber_dvr":[32,32.0,57437],"@MaterialIcons/fiber_manual_record":[32,32.0,57441],"@MaterialIcons/fiber_new":[32,32.0,57438],"@MaterialIcons/fiber_pin":[32,32.0,57450],"@MaterialIcons/fiber_smart_record":[32,32.0,57442],"@MaterialIcons/file_copy":[32,32.0,57715],"@MaterialIcons/file_download":[32,32.0,58052],"@MaterialIcons/file_upload":[32,32.0,58054],"@MaterialIcons/filter":[32,32.0,58323],"@MaterialIcons/filter_1":[32,32.0,58320],"@MaterialIcons/filter_2":[32,32.0,58321],"@MaterialIcons/filter_3":[32,32.0,58322],"@MaterialIcons/filter_4":[32,32.0,58324],"@MaterialIcons/filter_5":[32,32.0,58325],"@MaterialIcons/filter_6":[32,32.0,58326],"@MaterialIcons/filter_7":[32,32.0,58327],"@MaterialIcons/filter_8":[32,32.0,58328],"@MaterialIcons/filter_9":[32,32.0,58329],"@MaterialIcons/filter_9_plus":[32,32.0,58330],"@MaterialIcons/filter_b_and_w":[32,32.0,58331],"@MaterialIcons/filter_center_focus":[32,32.0,58332],"@MaterialIcons/filter_drama":[32,32.0,58333],"@MaterialIcons/filter_frames":[32,32.0,58334],"@MaterialIcons/filter_hdr":[32,32.0,58335],"@MaterialIcons/filter_list":[32,32.0,57682],"@MaterialIcons/filter_none":[32,32.0,58336],"@MaterialIcons/filter_tilt_shift":[32,32.0,58338],"@MaterialIcons/filter_vintage":[32,32.0,58339],"@MaterialIcons/find_in_page":[32,32.0,59520],"@MaterialIcons/find_replace":[32,32.0,59521],"@MaterialIcons/fingerprint":[32,32.0,59661],"@MaterialIcons/first_page":[32,32.0,58844],"@MaterialIcons/fitness_center":[32,32.0,60227],"@MaterialIcons/five":[32,32.0,53],"@MaterialIcons/flag":[32,32.0,57683],"@MaterialIcons/flare":[32,32.0,58340],"@MaterialIcons/flash_auto":[32,32.0,58341],"@MaterialIcons/flash_off":[32,32.0,58342],"@MaterialIcons/flash_on":[32,32.0,58343],"@MaterialIcons/flight":[32,32.0,58681],"@MaterialIcons/flight_land":[32,32.0,59652],"@MaterialIcons/flight_takeoff":[32,32.0,59653],"@MaterialIcons/flip":[32,32.0,58344],"@MaterialIcons/flip_to_back":[32,32.0,59522],"@MaterialIcons/flip_to_front":[32,32.0,59523],"@MaterialIcons/folder":[32,32.0,58055],"@MaterialIcons/folder_open":[32,32.0,58056],"@MaterialIcons/folder_shared":[32,32.0,58057],"@MaterialIcons/folder_special":[32,32.0,58903],"@MaterialIcons/font_download":[32,32.0,57703],"@MaterialIcons/format_align_center":[32,32.0,57908],"@MaterialIcons/format_align_justify":[32,32.0,57909],"@MaterialIcons/format_align_left":[32,32.0,57910],"@MaterialIcons/format_align_right":[32,32.0,57911],"@MaterialIcons/format_bold":[32,32.0,57912],"@MaterialIcons/format_clear":[32,32.0,57913],"@MaterialIcons/format_color_fill":[32,32.0,57914],"@MaterialIcons/format_color_reset":[32,32.0,57915],"@MaterialIcons/format_color_text":[32,32.0,57916],"@MaterialIcons/format_indent_decrease":[32,32.0,57917],"@MaterialIcons/format_indent_increase":[32,32.0,57918],"@MaterialIcons/format_italic":[32,32.0,57919],"@MaterialIcons/format_line_spacing":[32,32.0,57920],"@MaterialIcons/format_list_bulleted":[32,32.0,57921],"@MaterialIcons/format_list_numbered":[32,32.0,57922],"@MaterialIcons/format_list_numbered_rtl":[32,32.0,57959],"@MaterialIcons/format_paint":[32,32.0,57923],"@MaterialIcons/format_quote":[32,32.0,57924],"@MaterialIcons/format_shapes":[32,32.0,57950],"@MaterialIcons/format_size":[32,32.0,57925],"@MaterialIcons/format_strikethrough":[32,32.0,57926],"@MaterialIcons/format_textdirection_l_to_r":[32,32.0,57927],"@MaterialIcons/format_textdirection_r_to_l":[32,32.0,57928],"@MaterialIcons/format_underlined":[32,32.0,57929],"@MaterialIcons/forum":[32,32.0,57535],"@MaterialIcons/forward":[32,32.0,57684],"@MaterialIcons/forward_10":[32,32.0,57430],"@MaterialIcons/forward_30":[32,32.0,57431],"@MaterialIcons/forward_5":[32,32.0,57432],"@MaterialIcons/four":[32,32.0,52],"@MaterialIcons/free_breakfast":[32,32.0,60228],"@MaterialIcons/fullscreen":[32,32.0,58832],"@MaterialIcons/fullscreen_exit":[32,32.0,58833],"@MaterialIcons/functions":[32,32.0,57930],"@MaterialIcons/g":[32,32.0,103],"@MaterialIcons/g_translate":[32,32.0,59687],"@MaterialIcons/gamepad":[32,32.0,58127],"@MaterialIcons/games":[32,32.0,57377],"@MaterialIcons/gavel":[32,32.0,59662],"@MaterialIcons/gesture":[32,32.0,57685],"@MaterialIcons/get_app":[32,32.0,59524],"@MaterialIcons/gif":[32,32.0,59656],"@MaterialIcons/golf_course":[32,32.0,60229],"@MaterialIcons/gps_fixed":[32,32.0,57779],"@MaterialIcons/gps_not_fixed":[32,32.0,57780],"@MaterialIcons/gps_off":[32,32.0,57781],"@MaterialIcons/grade":[32,32.0,59525],"@MaterialIcons/gradient":[32,32.0,58345],"@MaterialIcons/grain":[32,32.0,58346],"@MaterialIcons/graphic_eq":[32,32.0,57784],"@MaterialIcons/grid_off":[32,32.0,58347],"@MaterialIcons/grid_on":[32,32.0,58348],"@MaterialIcons/group":[32,32.0,59375],"@MaterialIcons/group_add":[32,32.0,59376],"@MaterialIcons/group_work":[32,32.0,59526],"@MaterialIcons/h":[32,32.0,104],"@MaterialIcons/hd":[32,32.0,57426],"@MaterialIcons/hdr_off":[32,32.0,58349],"@MaterialIcons/hdr_on":[32,32.0,58350],"@MaterialIcons/hdr_strong":[32,32.0,58353],"@MaterialIcons/hdr_weak":[32,32.0,58354],"@MaterialIcons/headset":[32,32.0,58128],"@MaterialIcons/headset_mic":[32,32.0,58129],"@MaterialIcons/headset_off":[32,32.0,58170],"@MaterialIcons/healing":[32,32.0,58355],"@MaterialIcons/hearing":[32,32.0,57379],"@MaterialIcons/help":[32,32.0,59527],"@MaterialIcons/help_outline":[32,32.0,59645],"@MaterialIcons/high_quality":[32,32.0,57380],"@MaterialIcons/highlight":[32,32.0,57951],"@MaterialIcons/highlight_off":[32,32.0,59528],"@MaterialIcons/history":[32,32.0,59529],"@MaterialIcons/home":[32,32.0,59530],"@MaterialIcons/horizontal_split":[32,32.0,59719],"@MaterialIcons/hot_tub":[32,32.0,60230],"@MaterialIcons/hotel":[32,32.0,58682],"@MaterialIcons/hourglass_empty":[32,32.0,59531],"@MaterialIcons/hourglass_full":[32,32.0,59532],"@MaterialIcons/how_to_reg":[32,32.0,57716],"@MaterialIcons/how_to_vote":[32,32.0,57717],"@MaterialIcons/http":[32,32.0,59650],"@MaterialIcons/https":[32,32.0,59533],"@MaterialIcons/i":[32,32.0,105],"@MaterialIcons/image":[32,32.0,58356],"@MaterialIcons/image_aspect_ratio":[32,32.0,58357],"@MaterialIcons/image_search":[32,32.0,58431],"@MaterialIcons/import_contacts":[32,32.0,57568],"@MaterialIcons/import_export":[32,32.0,57539],"@MaterialIcons/important_devices":[32,32.0,59666],"@MaterialIcons/inbox":[32,32.0,57686],"@MaterialIcons/indeterminate_check_box":[32,32.0,59657],"@MaterialIcons/info":[32,32.0,59534],"@MaterialIcons/info_outline":[32,32.0,59535],"@MaterialIcons/input":[32,32.0,59536],"@MaterialIcons/insert_chart":[32,32.0,57931],"@MaterialIcons/insert_chart_outlined":[32,32.0,57962],"@MaterialIcons/insert_comment":[32,32.0,57932],"@MaterialIcons/insert_drive_file":[32,32.0,57933],"@MaterialIcons/insert_emoticon":[32,32.0,57934],"@MaterialIcons/insert_invitation":[32,32.0,57935],"@MaterialIcons/insert_link":[32,32.0,57936],"@MaterialIcons/insert_photo":[32,32.0,57937],"@MaterialIcons/invert_colors":[32,32.0,59537],"@MaterialIcons/invert_colors_off":[32,32.0,57540],"@MaterialIcons/iso":[32,32.0,58358],"@MaterialIcons/j":[32,32.0,106],"@MaterialIcons/k":[32,32.0,107],"@MaterialIcons/keyboard":[32,32.0,58130],"@MaterialIcons/keyboard_arrow_down":[32,32.0,58131],"@MaterialIcons/keyboard_arrow_left":[32,32.0,58132],"@MaterialIcons/keyboard_arrow_right":[32,32.0,58133],"@MaterialIcons/keyboard_arrow_up":[32,32.0,58134],"@MaterialIcons/keyboard_backspace":[32,32.0,58135],"@MaterialIcons/keyboard_capslock":[32,32.0,58136],"@MaterialIcons/keyboard_hide":[32,32.0,58138],"@MaterialIcons/keyboard_return":[32,32.0,58139],"@MaterialIcons/keyboard_tab":[32,32.0,58140],"@MaterialIcons/keyboard_voice":[32,32.0,58141],"@MaterialIcons/kitchen":[32,32.0,60231],"@MaterialIcons/l":[32,32.0,108],"@MaterialIcons/label":[32,32.0,59538],"@MaterialIcons/label_important":[32,32.0,59703],"@MaterialIcons/label_important_outline":[32,32.0,59720],"@MaterialIcons/label_outline":[32,32.0,59539],"@MaterialIcons/landscape":[32,32.0,58359],"@MaterialIcons/language":[32,32.0,59540],"@MaterialIcons/laptop":[32,32.0,58142],"@MaterialIcons/laptop_chromebook":[32,32.0,58143],"@MaterialIcons/laptop_mac":[32,32.0,58144],"@MaterialIcons/laptop_windows":[32,32.0,58145],"@MaterialIcons/last_page":[32,32.0,58845],"@MaterialIcons/launch":[32,32.0,59541],"@MaterialIcons/layers":[32,32.0,58683],"@MaterialIcons/layers_clear":[32,32.0,58684],"@MaterialIcons/leak_add":[32,32.0,58360],"@MaterialIcons/leak_remove":[32,32.0,58361],"@MaterialIcons/lens":[32,32.0,58362],"@MaterialIcons/library_add":[32,32.0,57390],"@MaterialIcons/library_books":[32,32.0,57391],"@MaterialIcons/library_music":[32,32.0,57392],"@MaterialIcons/lightbulb":[32,32.0,57584],"@MaterialIcons/lightbulb_outline":[32,32.0,59663],"@MaterialIcons/line_style":[32,32.0,59673],"@MaterialIcons/line_weight":[32,32.0,59674],"@MaterialIcons/linear_scale":[32,32.0,57952],"@MaterialIcons/link":[32,32.0,57687],"@MaterialIcons/link_off":[32,32.0,57711],"@MaterialIcons/linked_camera":[32,32.0,58424],"@MaterialIcons/list":[32,32.0,59542],"@MaterialIcons/list_alt":[32,32.0,57582],"@MaterialIcons/live_help":[32,32.0,57542],"@MaterialIcons/live_tv":[32,32.0,58937],"@MaterialIcons/local_activity":[32,32.0,58687],"@MaterialIcons/local_airport":[32,32.0,58685],"@MaterialIcons/local_atm":[32,32.0,58686],"@MaterialIcons/local_bar":[32,32.0,58688],"@MaterialIcons/local_cafe":[32,32.0,58689],"@MaterialIcons/local_car_wash":[32,32.0,58690],"@MaterialIcons/local_convenience_store":[32,32.0,58691],"@MaterialIcons/local_dining":[32,32.0,58710],"@MaterialIcons/local_drink":[32,32.0,58692],"@MaterialIcons/local_florist":[32,32.0,58693],"@MaterialIcons/local_gas_station":[32,32.0,58694],"@MaterialIcons/local_grocery_store":[32,32.0,58695],"@MaterialIcons/local_hospital":[32,32.0,58696],"@MaterialIcons/local_hotel":[32,32.0,58697],"@MaterialIcons/local_laundry_service":[32,32.0,58698],"@MaterialIcons/local_library":[32,32.0,58699],"@MaterialIcons/local_mall":[32,32.0,58700],"@MaterialIcons/local_movies":[32,32.0,58701],"@MaterialIcons/local_offer":[32,32.0,58702],"@MaterialIcons/local_parking":[32,32.0,58703],"@MaterialIcons/local_pharmacy":[32,32.0,58704],"@MaterialIcons/local_phone":[32,32.0,58705],"@MaterialIcons/local_pizza":[32,32.0,58706],"@MaterialIcons/local_play":[32,32.0,58707],"@MaterialIcons/local_post_office":[32,32.0,58708],"@MaterialIcons/local_printshop":[32,32.0,58709],"@MaterialIcons/local_see":[32,32.0,58711],"@MaterialIcons/local_shipping":[32,32.0,58712],"@MaterialIcons/local_taxi":[32,32.0,58713],"@MaterialIcons/location_city":[32,32.0,59377],"@MaterialIcons/location_disabled":[32,32.0,57782],"@MaterialIcons/location_off":[32,32.0,57543],"@MaterialIcons/location_on":[32,32.0,57544],"@MaterialIcons/location_searching":[32,32.0,57783],"@MaterialIcons/lock":[32,32.0,59543],"@MaterialIcons/lock_open":[32,32.0,59544],"@MaterialIcons/lock_outline":[32,32.0,59545],"@MaterialIcons/looks":[32,32.0,58364],"@MaterialIcons/looks_3":[32,32.0,58363],"@MaterialIcons/looks_4":[32,32.0,58365],"@MaterialIcons/looks_5":[32,32.0,58366],"@MaterialIcons/looks_6":[32,32.0,58367],"@MaterialIcons/looks_one":[32,32.0,58368],"@MaterialIcons/looks_two":[32,32.0,58369],"@MaterialIcons/loop":[32,32.0,57384],"@MaterialIcons/loupe":[32,32.0,58370],"@MaterialIcons/low_priority":[32,32.0,57709],"@MaterialIcons/loyalty":[32,32.0,59546],"@MaterialIcons/m":[32,32.0,109],"@MaterialIcons/mail":[32,32.0,57688],"@MaterialIcons/mail_outline":[32,32.0,57569],"@MaterialIcons/map":[32,32.0,58715],"@MaterialIcons/markunread":[32,32.0,57689],"@MaterialIcons/markunread_mailbox":[32,32.0,59547],"@MaterialIcons/maximize":[32,32.0,59696],"@MaterialIcons/meeting_room":[32,32.0,60239],"@MaterialIcons/memory":[32,32.0,58146],"@MaterialIcons/menu":[32,32.0,58834],"@MaterialIcons/merge_type":[32,32.0,57938],"@MaterialIcons/message":[32,32.0,57545],"@MaterialIcons/mic":[32,32.0,57385],"@MaterialIcons/mic_none":[32,32.0,57386],"@MaterialIcons/mic_off":[32,32.0,57387],"@MaterialIcons/minimize":[32,32.0,59697],"@MaterialIcons/missed_video_call":[32,32.0,57459],"@MaterialIcons/mms":[32,32.0,58904],"@MaterialIcons/mobile_friendly":[32,32.0,57856],"@MaterialIcons/mobile_off":[32,32.0,57857],"@MaterialIcons/mobile_screen_share":[32,32.0,57575],"@MaterialIcons/mode_comment":[32,32.0,57939],"@MaterialIcons/mode_edit":[32,32.0,57940],"@MaterialIcons/monetization_on":[32,32.0,57955],"@MaterialIcons/money":[32,32.0,58749],"@MaterialIcons/money_off":[32,32.0,57948],"@MaterialIcons/monochrome_photos":[32,32.0,58371],"@MaterialIcons/mood":[32,32.0,59378],"@MaterialIcons/mood_bad":[32,32.0,59379],"@MaterialIcons/more":[32,32.0,58905],"@MaterialIcons/more_horiz":[32,32.0,58835],"@MaterialIcons/more_vert":[32,32.0,58836],"@MaterialIcons/motorcycle":[32,32.0,59675],"@MaterialIcons/mouse":[32,32.0,58147],"@MaterialIcons/move_to_inbox":[32,32.0,57704],"@MaterialIcons/movie":[32,32.0,57388],"@MaterialIcons/movie_creation":[32,32.0,58372],"@MaterialIcons/movie_filter":[32,32.0,58426],"@MaterialIcons/multiline_chart":[32,32.0,59103],"@MaterialIcons/music_note":[32,32.0,58373],"@MaterialIcons/music_off":[32,32.0,58432],"@MaterialIcons/music_video":[32,32.0,57443],"@MaterialIcons/my_location":[32,32.0,58716],"@MaterialIcons/n":[32,32.0,110],"@MaterialIcons/nature":[32,32.0,58374],"@MaterialIcons/nature_people":[32,32.0,58375],"@MaterialIcons/navigate_before":[32,32.0,58376],"@MaterialIcons/navigate_next":[32,32.0,58377],"@MaterialIcons/navigation":[32,32.0,58717],"@MaterialIcons/near_me":[32,32.0,58729],"@MaterialIcons/network_cell":[32,32.0,57785],"@MaterialIcons/network_check":[32,32.0,58944],"@MaterialIcons/network_locked":[32,32.0,58906],"@MaterialIcons/network_wifi":[32,32.0,57786],"@MaterialIcons/new_releases":[32,32.0,57393],"@MaterialIcons/next_week":[32,32.0,57706],"@MaterialIcons/nfc":[32,32.0,57787],"@MaterialIcons/nine":[32,32.0,57],"@MaterialIcons/no_encryption":[32,32.0,58945],"@MaterialIcons/no_meeting_room":[32,32.0,60238],"@MaterialIcons/no_sim":[32,32.0,57548],"@MaterialIcons/not_interested":[32,32.0,57395],"@MaterialIcons/not_listed_location":[32,32.0,58741],"@MaterialIcons/note":[32,32.0,57455],"@MaterialIcons/note_add":[32,32.0,59548],"@MaterialIcons/notes":[32,32.0,57964],"@MaterialIcons/notification_important":[32,32.0,57348],"@MaterialIcons/notifications":[32,32.0,59380],"@MaterialIcons/notifications_active":[32,32.0,59383],"@MaterialIcons/notifications_none":[32,32.0,59381],"@MaterialIcons/notifications_off":[32,32.0,59382],"@MaterialIcons/notifications_paused":[32,32.0,59384],"@MaterialIcons/o":[32,32.0,111],"@MaterialIcons/offline_bolt":[32,32.0,59698],"@MaterialIcons/offline_pin":[32,32.0,59658],"@MaterialIcons/ondemand_video":[32,32.0,58938],"@MaterialIcons/one":[32,32.0,49],"@MaterialIcons/opacity":[32,32.0,59676],"@MaterialIcons/open_in_browser":[32,32.0,59549],"@MaterialIcons/open_in_new":[32,32.0,59550],"@MaterialIcons/open_with":[32,32.0,59551],"@MaterialIcons/outlined_flag":[32,32.0,57710],"@MaterialIcons/p":[32,32.0,112],"@MaterialIcons/pages":[32,32.0,59385],"@MaterialIcons/pageview":[32,32.0,59552],"@MaterialIcons/palette":[32,32.0,58378],"@MaterialIcons/pan_tool":[32,32.0,59685],"@MaterialIcons/panorama":[32,32.0,58379],"@MaterialIcons/panorama_fish_eye":[32,32.0,58380],"@MaterialIcons/panorama_horizontal":[32,32.0,58381],"@MaterialIcons/panorama_vertical":[32,32.0,58382],"@MaterialIcons/panorama_wide_angle":[32,32.0,58383],"@MaterialIcons/party_mode":[32,32.0,59386],"@MaterialIcons/pause":[32,32.0,57396],"@MaterialIcons/pause_circle_filled":[32,32.0,57397],"@MaterialIcons/pause_circle_outline":[32,32.0,57398],"@MaterialIcons/pause_presentation":[32,32.0,57578],"@MaterialIcons/payment":[32,32.0,59553],"@MaterialIcons/people":[32,32.0,59387],"@MaterialIcons/people_outline":[32,32.0,59388],"@MaterialIcons/perm_camera_mic":[32,32.0,59554],"@MaterialIcons/perm_contact_calendar":[32,32.0,59555],"@MaterialIcons/perm_data_setting":[32,32.0,59556],"@MaterialIcons/perm_device_information":[32,32.0,59557],"@MaterialIcons/perm_identity":[32,32.0,59558],"@MaterialIcons/perm_media":[32,32.0,59559],"@MaterialIcons/perm_phone_msg":[32,32.0,59560],"@MaterialIcons/perm_scan_wifi":[32,32.0,59561],"@MaterialIcons/person":[32,32.0,59389],"@MaterialIcons/person_add":[32,32.0,59390],"@MaterialIcons/person_outline":[32,32.0,59391],"@MaterialIcons/person_pin":[32,32.0,58714],"@MaterialIcons/person_pin_circle":[32,32.0,58730],"@MaterialIcons/personal_video":[32,32.0,58939],"@MaterialIcons/pets":[32,32.0,59677],"@MaterialIcons/phone":[32,32.0,57549],"@MaterialIcons/phone_android":[32,32.0,58148],"@MaterialIcons/phone_bluetooth_speaker":[32,32.0,58907],"@MaterialIcons/phone_callback":[32,32.0,58953],"@MaterialIcons/phone_forwarded":[32,32.0,58908],"@MaterialIcons/phone_in_talk":[32,32.0,58909],"@MaterialIcons/phone_iphone":[32,32.0,58149],"@MaterialIcons/phone_locked":[32,32.0,58910],"@MaterialIcons/phone_missed":[32,32.0,58911],"@MaterialIcons/phone_paused":[32,32.0,58912],"@MaterialIcons/phonelink":[32,32.0,58150],"@MaterialIcons/phonelink_erase":[32,32.0,57563],"@MaterialIcons/phonelink_lock":[32,32.0,57564],"@MaterialIcons/phonelink_off":[32,32.0,58151],"@MaterialIcons/phonelink_ring":[32,32.0,57565],"@MaterialIcons/phonelink_setup":[32,32.0,57566],"@MaterialIcons/photo":[32,32.0,58384],"@MaterialIcons/photo_album":[32,32.0,58385],"@MaterialIcons/photo_camera":[32,32.0,58386],"@MaterialIcons/photo_filter":[32,32.0,58427],"@MaterialIcons/photo_library":[32,32.0,58387],"@MaterialIcons/photo_size_select_actual":[32,32.0,58418],"@MaterialIcons/photo_size_select_large":[32,32.0,58419],"@MaterialIcons/photo_size_select_small":[32,32.0,58420],"@MaterialIcons/picture_as_pdf":[32,32.0,58389],"@MaterialIcons/picture_in_picture":[32,32.0,59562],"@MaterialIcons/picture_in_picture_alt":[32,32.0,59665],"@MaterialIcons/pie_chart":[32,32.0,59076],"@MaterialIcons/pie_chart_outlined":[32,32.0,59077],"@MaterialIcons/pin_drop":[32,32.0,58718],"@MaterialIcons/place":[32,32.0,58719],"@MaterialIcons/play_arrow":[32,32.0,57399],"@MaterialIcons/play_circle_filled":[32,32.0,57400],"@MaterialIcons/play_circle_outline":[32,32.0,57401],"@MaterialIcons/play_for_work":[32,32.0,59654],"@MaterialIcons/playlist_add":[32,32.0,57403],"@MaterialIcons/playlist_add_check":[32,32.0,57445],"@MaterialIcons/playlist_play":[32,32.0,57439],"@MaterialIcons/plus_one":[32,32.0,59392],"@MaterialIcons/poll":[32,32.0,59393],"@MaterialIcons/polymer":[32,32.0,59563],"@MaterialIcons/pool":[32,32.0,60232],"@MaterialIcons/portable_wifi_off":[32,32.0,57550],"@MaterialIcons/portrait":[32,32.0,58390],"@MaterialIcons/power":[32,32.0,58940],"@MaterialIcons/power_input":[32,32.0,58166],"@MaterialIcons/power_off":[32,32.0,58950],"@MaterialIcons/power_settings_new":[32,32.0,59564],"@MaterialIcons/pregnant_woman":[32,32.0,59678],"@MaterialIcons/present_to_all":[32,32.0,57567],"@MaterialIcons/print":[32,32.0,59565],"@MaterialIcons/priority_high":[32,32.0,58949],"@MaterialIcons/public":[32,32.0,59403],"@MaterialIcons/publish":[32,32.0,57941],"@MaterialIcons/q":[32,32.0,113],"@MaterialIcons/query_builder":[32,32.0,59566],"@MaterialIcons/question_answer":[32,32.0,59567],"@MaterialIcons/queue":[32,32.0,57404],"@MaterialIcons/queue_music":[32,32.0,57405],"@MaterialIcons/queue_play_next":[32,32.0,57446],"@MaterialIcons/r":[32,32.0,114],"@MaterialIcons/radio":[32,32.0,57406],"@MaterialIcons/radio_button_checked":[32,32.0,59447],"@MaterialIcons/radio_button_unchecked":[32,32.0,59446],"@MaterialIcons/rate_review":[32,32.0,58720],"@MaterialIcons/receipt":[32,32.0,59568],"@MaterialIcons/recent_actors":[32,32.0,57407],"@MaterialIcons/record_voice_over":[32,32.0,59679],"@MaterialIcons/redeem":[32,32.0,59569],"@MaterialIcons/redo":[32,32.0,57690],"@MaterialIcons/refresh":[32,32.0,58837],"@MaterialIcons/remove":[32,32.0,57691],"@MaterialIcons/remove_circle":[32,32.0,57692],"@MaterialIcons/remove_circle_outline":[32,32.0,57693],"@MaterialIcons/remove_from_queue":[32,32.0,57447],"@MaterialIcons/remove_red_eye":[32,32.0,58391],"@MaterialIcons/remove_shopping_cart":[32,32.0,59688],"@MaterialIcons/reorder":[32,32.0,59646],"@MaterialIcons/repeat":[32,32.0,57408],"@MaterialIcons/repeat_one":[32,32.0,57409],"@MaterialIcons/replay":[32,32.0,57410],"@MaterialIcons/replay_10":[32,32.0,57433],"@MaterialIcons/replay_30":[32,32.0,57434],"@MaterialIcons/replay_5":[32,32.0,57435],"@MaterialIcons/reply":[32,32.0,57694],"@MaterialIcons/reply_all":[32,32.0,57695],"@MaterialIcons/report":[32,32.0,57696],"@MaterialIcons/report_off":[32,32.0,57712],"@MaterialIcons/report_problem":[32,32.0,59570],"@MaterialIcons/restaurant":[32,32.0,58732],"@MaterialIcons/restaurant_menu":[32,32.0,58721],"@MaterialIcons/restore":[32,32.0,59571],"@MaterialIcons/restore_from_trash":[32,32.0,59704],"@MaterialIcons/restore_page":[32,32.0,59689],"@MaterialIcons/ring_volume":[32,32.0,57553],"@MaterialIcons/room":[32,32.0,59572],"@MaterialIcons/room_service":[32,32.0,60233],"@MaterialIcons/rotate_90_degrees_ccw":[32,32.0,58392],"@MaterialIcons/rotate_left":[32,32.0,58393],"@MaterialIcons/rotate_right":[32,32.0,58394],"@MaterialIcons/rounded_corner":[32,32.0,59680],"@MaterialIcons/router":[32,32.0,58152],"@MaterialIcons/rowing":[32,32.0,59681],"@MaterialIcons/rss_feed":[32,32.0,57573],"@MaterialIcons/rv_hookup":[32,32.0,58946],"@MaterialIcons/s":[32,32.0,115],"@MaterialIcons/satellite":[32,32.0,58722],"@MaterialIcons/save":[32,32.0,57697],"@MaterialIcons/save_alt":[32,32.0,57713],"@MaterialIcons/scanner":[32,32.0,58153],"@MaterialIcons/scatter_plot":[32,32.0,57960],"@MaterialIcons/schedule":[32,32.0,59573],"@MaterialIcons/school":[32,32.0,59404],"@MaterialIcons/score":[32,32.0,57961],"@MaterialIcons/screen_lock_landscape":[32,32.0,57790],"@MaterialIcons/screen_lock_portrait":[32,32.0,57791],"@MaterialIcons/screen_lock_rotation":[32,32.0,57792],"@MaterialIcons/screen_rotation":[32,32.0,57793],"@MaterialIcons/screen_share":[32,32.0,57570],"@MaterialIcons/sd_card":[32,32.0,58915],"@MaterialIcons/sd_storage":[32,32.0,57794],"@MaterialIcons/search":[32,32.0,59574],"@MaterialIcons/security":[32,32.0,58154],"@MaterialIcons/select_all":[32,32.0,57698],"@MaterialIcons/send":[32,32.0,57699],"@MaterialIcons/sentiment_dissatisfied":[32,32.0,59409],"@MaterialIcons/sentiment_neutral":[32,32.0,59410],"@MaterialIcons/sentiment_satisfied":[32,32.0,59411],"@MaterialIcons/sentiment_satisfied_alt":[32,32.0,57581],"@MaterialIcons/sentiment_very_dissatisfied":[32,32.0,59412],"@MaterialIcons/sentiment_very_satisfied":[32,32.0,59413],"@MaterialIcons/settings":[32,32.0,59576],"@MaterialIcons/settings_applications":[32,32.0,59577],"@MaterialIcons/settings_backup_restore":[32,32.0,59578],"@MaterialIcons/settings_bluetooth":[32,32.0,59579],"@MaterialIcons/settings_brightness":[32,32.0,59581],"@MaterialIcons/settings_cell":[32,32.0,59580],"@MaterialIcons/settings_ethernet":[32,32.0,59582],"@MaterialIcons/settings_input_antenna":[32,32.0,59583],"@MaterialIcons/settings_input_component":[32,32.0,59584],"@MaterialIcons/settings_input_composite":[32,32.0,59585],"@MaterialIcons/settings_input_hdmi":[32,32.0,59586],"@MaterialIcons/settings_input_svideo":[32,32.0,59587],"@MaterialIcons/settings_overscan":[32,32.0,59588],"@MaterialIcons/settings_phone":[32,32.0,59589],"@MaterialIcons/settings_power":[32,32.0,59590],"@MaterialIcons/settings_remote":[32,32.0,59591],"@MaterialIcons/settings_system_daydream":[32,32.0,57795],"@MaterialIcons/settings_voice":[32,32.0,59592],"@MaterialIcons/seven":[32,32.0,55],"@MaterialIcons/share":[32,32.0,59405],"@MaterialIcons/shop":[32,32.0,59593],"@MaterialIcons/shop_two":[32,32.0,59594],"@MaterialIcons/shopping_basket":[32,32.0,59595],"@MaterialIcons/shopping_cart":[32,32.0,59596],"@MaterialIcons/short_text":[32,32.0,57953],"@MaterialIcons/show_chart":[32,32.0,59105],"@MaterialIcons/shuffle":[32,32.0,57411],"@MaterialIcons/shutter_speed":[32,32.0,58429],"@MaterialIcons/signal_cellular_4_bar":[32,32.0,57800],"@MaterialIcons/signal_cellular_alt":[32,32.0,57858],"@MaterialIcons/signal_cellular_connected_no_internet_4_bar":[32,32.0,57805],"@MaterialIcons/signal_cellular_no_sim":[32,32.0,57806],"@MaterialIcons/signal_cellular_null":[32,32.0,57807],"@MaterialIcons/signal_cellular_off":[32,32.0,57808],"@MaterialIcons/signal_wifi_4_bar":[32,32.0,57816],"@MaterialIcons/signal_wifi_4_bar_lock":[32,32.0,57817],"@MaterialIcons/signal_wifi_off":[32,32.0,57818],"@MaterialIcons/sim_card":[32,32.0,58155],"@MaterialIcons/sim_card_alert":[32,32.0,58916],"@MaterialIcons/six":[32,32.0,54],"@MaterialIcons/skip_next":[32,32.0,57412],"@MaterialIcons/skip_previous":[32,32.0,57413],"@MaterialIcons/slideshow":[32,32.0,58395],"@MaterialIcons/slow_motion_video":[32,32.0,57448],"@MaterialIcons/smartphone":[32,32.0,58156],"@MaterialIcons/smoke_free":[32,32.0,60234],"@MaterialIcons/smoking_rooms":[32,32.0,60235],"@MaterialIcons/sms":[32,32.0,58917],"@MaterialIcons/sms_failed":[32,32.0,58918],"@MaterialIcons/snooze":[32,32.0,57414],"@MaterialIcons/sort":[32,32.0,57700],"@MaterialIcons/sort_by_alpha":[32,32.0,57427],"@MaterialIcons/spa":[32,32.0,60236],"@MaterialIcons/space_bar":[32,32.0,57942],"@MaterialIcons/speaker":[32,32.0,58157],"@MaterialIcons/speaker_group":[32,32.0,58158],"@MaterialIcons/speaker_notes":[32,32.0,59597],"@MaterialIcons/speaker_notes_off":[32,32.0,59690],"@MaterialIcons/speaker_phone":[32,32.0,57554],"@MaterialIcons/spellcheck":[32,32.0,59598],"@MaterialIcons/star":[32,32.0,59448],"@MaterialIcons/star_border":[32,32.0,59450],"@MaterialIcons/star_half":[32,32.0,59449],"@MaterialIcons/stars":[32,32.0,59600],"@MaterialIcons/stay_current_landscape":[32,32.0,57555],"@MaterialIcons/stay_current_portrait":[32,32.0,57556],"@MaterialIcons/stay_primary_landscape":[32,32.0,57557],"@MaterialIcons/stay_primary_portrait":[32,32.0,57558],"@MaterialIcons/stop":[32,32.0,57415],"@MaterialIcons/stop_screen_share":[32,32.0,57571],"@MaterialIcons/storage":[32,32.0,57819],"@MaterialIcons/store":[32,32.0,59601],"@MaterialIcons/store_mall_directory":[32,32.0,58723],"@MaterialIcons/straighten":[32,32.0,58396],"@MaterialIcons/streetview":[32,32.0,58734],"@MaterialIcons/strikethrough_s":[32,32.0,57943],"@MaterialIcons/style":[32,32.0,58397],"@MaterialIcons/subdirectory_arrow_left":[32,32.0,58841],"@MaterialIcons/subdirectory_arrow_right":[32,32.0,58842],"@MaterialIcons/subject":[32,32.0,59602],"@MaterialIcons/subscriptions":[32,32.0,57444],"@MaterialIcons/subtitles":[32,32.0,57416],"@MaterialIcons/subway":[32,32.0,58735],"@MaterialIcons/supervised_user_circle":[32,32.0,59705],"@MaterialIcons/supervisor_account":[32,32.0,59603],"@MaterialIcons/surround_sound":[32,32.0,57417],"@MaterialIcons/swap_calls":[32,32.0,57559],"@MaterialIcons/swap_horiz":[32,32.0,59604],"@MaterialIcons/swap_horizontal_circle":[32,32.0,59699],"@MaterialIcons/swap_vert":[32,32.0,59605],"@MaterialIcons/swap_vertical_circle":[32,32.0,59606],"@MaterialIcons/switch_camera":[32,32.0,58398],"@MaterialIcons/switch_video":[32,32.0,58399],"@MaterialIcons/sync":[32,32.0,58919],"@MaterialIcons/sync_disabled":[32,32.0,58920],"@MaterialIcons/sync_problem":[32,32.0,58921],"@MaterialIcons/system_update":[32,32.0,58922],"@MaterialIcons/system_update_alt":[32,32.0,59607],"@MaterialIcons/t":[32,32.0,116],"@MaterialIcons/tab":[32,32.0,59608],"@MaterialIcons/tab_unselected":[32,32.0,59609],"@MaterialIcons/table_chart":[32,32.0,57957],"@MaterialIcons/tablet":[32,32.0,58159],"@MaterialIcons/tablet_android":[32,32.0,58160],"@MaterialIcons/tablet_mac":[32,32.0,58161],"@MaterialIcons/tag_faces":[32,32.0,58400],"@MaterialIcons/tap_and_play":[32,32.0,58923],"@MaterialIcons/terrain":[32,32.0,58724],"@MaterialIcons/text_fields":[32,32.0,57954],"@MaterialIcons/text_format":[32,32.0,57701],"@MaterialIcons/text_rotate_up":[32,32.0,59706],"@MaterialIcons/text_rotate_vertical":[32,32.0,59707],"@MaterialIcons/text_rotation_down":[32,32.0,59710],"@MaterialIcons/text_rotation_none":[32,32.0,59711],"@MaterialIcons/textsms":[32,32.0,57560],"@MaterialIcons/texture":[32,32.0,58401],"@MaterialIcons/theaters":[32,32.0,59610],"@MaterialIcons/three":[32,32.0,51],"@MaterialIcons/thumb_down":[32,32.0,59611],"@MaterialIcons/thumb_down_alt":[32,32.0,59414],"@MaterialIcons/thumb_up":[32,32.0,59612],"@MaterialIcons/thumb_up_alt":[32,32.0,59415],"@MaterialIcons/thumbs_up_down":[32,32.0,59613],"@MaterialIcons/time_to_leave":[32,32.0,58924],"@MaterialIcons/timelapse":[32,32.0,58402],"@MaterialIcons/timeline":[32,32.0,59682],"@MaterialIcons/timer":[32,32.0,58405],"@MaterialIcons/timer_10":[32,32.0,58403],"@MaterialIcons/timer_3":[32,32.0,58404],"@MaterialIcons/timer_off":[32,32.0,58406],"@MaterialIcons/title":[32,32.0,57956],"@MaterialIcons/toc":[32,32.0,59614],"@MaterialIcons/today":[32,32.0,59615],"@MaterialIcons/toll":[32,32.0,59616],"@MaterialIcons/tonality":[32,32.0,58407],"@MaterialIcons/touch_app":[32,32.0,59667],"@MaterialIcons/toys":[32,32.0,58162],"@MaterialIcons/track_changes":[32,32.0,59617],"@MaterialIcons/traffic":[32,32.0,58725],"@MaterialIcons/train":[32,32.0,58736],"@MaterialIcons/tram":[32,32.0,58737],"@MaterialIcons/transfer_within_a_station":[32,32.0,58738],"@MaterialIcons/transform":[32,32.0,58408],"@MaterialIcons/transit_enterexit":[32,32.0,58745],"@MaterialIcons/translate":[32,32.0,59618],"@MaterialIcons/trending_down":[32,32.0,59619],"@MaterialIcons/trending_flat":[32,32.0,59620],"@MaterialIcons/trending_up":[32,32.0,59621],"@MaterialIcons/trip_origin":[32,32.0,58747],"@MaterialIcons/tune":[32,32.0,58409],"@MaterialIcons/turned_in":[32,32.0,59622],"@MaterialIcons/turned_in_not":[32,32.0,59623],"@MaterialIcons/tv":[32,32.0,58163],"@MaterialIcons/tv_off":[32,32.0,58951],"@MaterialIcons/two":[32,32.0,50],"@MaterialIcons/u":[32,32.0,117],"@MaterialIcons/u10FFFD":[32,32.0,1114109],"@MaterialIcons/unarchive":[32,32.0,57705],"@MaterialIcons/underscore":[32,32.0,95],"@MaterialIcons/undo":[32,32.0,57702],"@MaterialIcons/unfold_less":[32,32.0,58838],"@MaterialIcons/unfold_more":[32,32.0,58839],"@MaterialIcons/uniE179":[32,32.0,57721],"@MaterialIcons/uniE1FF":[32,32.0,57855],"@MaterialIcons/uniE93C":[32,32.0,59708],"@MaterialIcons/uniE93D":[32,32.0,59709],"@MaterialIcons/uniE94B":[32,32.0,59723],"@MaterialIcons/uniE94D":[32,32.0,59725],"@MaterialIcons/uniE94E":[32,32.0,59726],"@MaterialIcons/uniE951":[32,32.0,59729],"@MaterialIcons/uniE952":[32,32.0,59730],"@MaterialIcons/uniE953":[32,32.0,59731],"@MaterialIcons/uniE954":[32,32.0,59732],"@MaterialIcons/uniE955":[32,32.0,59733],"@MaterialIcons/uniE956":[32,32.0,59734],"@MaterialIcons/uniE957":[32,32.0,59735],"@MaterialIcons/uniE958":[32,32.0,59736],"@MaterialIcons/uniE959":[32,32.0,59737],"@MaterialIcons/uniE95A":[32,32.0,59738],"@MaterialIcons/uniE95B":[32,32.0,59739],"@MaterialIcons/uniE95C":[32,32.0,59740],"@MaterialIcons/uniE95D":[32,32.0,59741],"@MaterialIcons/uniE95E":[32,32.0,59742],"@MaterialIcons/uniE95F":[32,32.0,59743],"@MaterialIcons/uniE960":[32,32.0,59744],"@MaterialIcons/uniE961":[32,32.0,59745],"@MaterialIcons/uniE962":[32,32.0,59746],"@MaterialIcons/uniE963":[32,32.0,59747],"@MaterialIcons/uniE964":[32,32.0,59748],"@MaterialIcons/uniE965":[32,32.0,59749],"@MaterialIcons/uniE966":[32,32.0,59750],"@MaterialIcons/uniE967":[32,32.0,59751],"@MaterialIcons/uniE968":[32,32.0,59752],"@MaterialIcons/uniE969":[32,32.0,59753],"@MaterialIcons/uniE96A":[32,32.0,59754],"@MaterialIcons/uniE96B":[32,32.0,59755],"@MaterialIcons/uniE96C":[32,32.0,59756],"@MaterialIcons/uniE96D":[32,32.0,59757],"@MaterialIcons/uniE96E":[32,32.0,59758],"@MaterialIcons/uniE96F":[32,32.0,59759],"@MaterialIcons/uniE970":[32,32.0,59760],"@MaterialIcons/uniE971":[32,32.0,59761],"@MaterialIcons/uniE972":[32,32.0,59762],"@MaterialIcons/uniE973":[32,32.0,59763],"@MaterialIcons/uniE974":[32,32.0,59764],"@MaterialIcons/uniE975":[32,32.0,59765],"@MaterialIcons/uniE976":[32,32.0,59766],"@MaterialIcons/uniE977":[32,32.0,59767],"@MaterialIcons/uniE978":[32,32.0,59768],"@MaterialIcons/uniE979":[32,32.0,59769],"@MaterialIcons/uniE97A":[32,32.0,59770],"@MaterialIcons/uniE97B":[32,32.0,59771],"@MaterialIcons/uniE97C":[32,32.0,59772],"@MaterialIcons/uniE97D":[32,32.0,59773],"@MaterialIcons/uniE97F":[32,32.0,59775],"@MaterialIcons/uniE982":[32,32.0,59778],"@MaterialIcons/uniE988":[32,32.0,59784],"@MaterialIcons/uniE989":[32,32.0,59785],"@MaterialIcons/uniE98B":[32,32.0,59787],"@MaterialIcons/uniE98F":[32,32.0,59791],"@MaterialIcons/uniE992":[32,32.0,59794],"@MaterialIcons/uniE994":[32,32.0,59796],"@MaterialIcons/uniE996":[32,32.0,59798],"@MaterialIcons/uniE998":[32,32.0,59800],"@MaterialIcons/uniE99A":[32,32.0,59802],"@MaterialIcons/uniE99B":[32,32.0,59803],"@MaterialIcons/uniE99D":[32,32.0,59805],"@MaterialIcons/uniE9A1":[32,32.0,59809],"@MaterialIcons/uniE9A2":[32,32.0,59810],"@MaterialIcons/uniE9A3":[32,32.0,59811],"@MaterialIcons/uniE9A5":[32,32.0,59813],"@MaterialIcons/uniE9A8":[32,32.0,59816],"@MaterialIcons/uniE9AA":[32,32.0,59818],"@MaterialIcons/uniE9AD":[32,32.0,59821],"@MaterialIcons/uniE9B0":[32,32.0,59824],"@MaterialIcons/uniE9B1":[32,32.0,59825],"@MaterialIcons/uniE9B2":[32,32.0,59826],"@MaterialIcons/uniE9B4":[32,32.0,59828],"@MaterialIcons/uniE9B6":[32,32.0,59830],"@MaterialIcons/uniE9B7":[32,32.0,59831],"@MaterialIcons/uniE9BA":[32,32.0,59834],"@MaterialIcons/uniE9BB":[32,32.0,59835],"@MaterialIcons/uniE9BC":[32,32.0,59836],"@MaterialIcons/uniE9BD":[32,32.0,59837],"@MaterialIcons/uniE9C3":[32,32.0,59843],"@MaterialIcons/uniE9C5":[32,32.0,59845],"@MaterialIcons/uniE9C8":[32,32.0,59848],"@MaterialIcons/uniE9C9":[32,32.0,59849],"@MaterialIcons/uniE9CA":[32,32.0,59850],"@MaterialIcons/uniE9CB":[32,32.0,59851],"@MaterialIcons/uniE9CC":[32,32.0,59852],"@MaterialIcons/uniE9CD":[32,32.0,59853],"@MaterialIcons/uniE9CE":[32,32.0,59854],"@MaterialIcons/uniE9CF":[32,32.0,59855],"@MaterialIcons/uniE9D1":[32,32.0,59857],"@MaterialIcons/uniE9D2":[32,32.0,59858],"@MaterialIcons/uniE9D3":[32,32.0,59859],"@MaterialIcons/uniE9D4":[32,32.0,59860],"@MaterialIcons/uniE9D6":[32,32.0,59862],"@MaterialIcons/uniE9D7":[32,32.0,59863],"@MaterialIcons/uniE9D8":[32,32.0,59864],"@MaterialIcons/uniE9D9":[32,32.0,59865],"@MaterialIcons/uniE9DD":[32,32.0,59869],"@MaterialIcons/uniE9E0":[32,32.0,59872],"@MaterialIcons/uniE9E1":[32,32.0,59873],"@MaterialIcons/uniE9E4":[32,32.0,59876],"@MaterialIcons/uniE9E6":[32,32.0,59878],"@MaterialIcons/uniE9E9":[32,32.0,59881],"@MaterialIcons/uniE9EC":[32,32.0,59884],"@MaterialIcons/uniE9ED":[32,32.0,59885],"@MaterialIcons/uniE9EF":[32,32.0,59887],"@MaterialIcons/uniE9F2":[32,32.0,59890],"@MaterialIcons/uniE9F3":[32,32.0,59891],"@MaterialIcons/uniE9F5":[32,32.0,59893],"@MaterialIcons/uniE9F6":[32,32.0,59894],"@MaterialIcons/uniE9F9":[32,32.0,59897],"@MaterialIcons/uniE9FC":[32,32.0,59900],"@MaterialIcons/uniE9FE":[32,32.0,59902],"@MaterialIcons/uniEA00":[32,32.0,59904],"@MaterialIcons/uniEA01":[32,32.0,59905],"@MaterialIcons/uniEA02":[32,32.0,59906],"@MaterialIcons/uniEA09":[32,32.0,59913],"@MaterialIcons/uniEA0A":[32,32.0,59914],"@MaterialIcons/uniEA0B":[32,32.0,59915],"@MaterialIcons/uniEA0C":[32,32.0,59916],"@MaterialIcons/uniEA0D":[32,32.0,59917],"@MaterialIcons/uniEA0E":[32,32.0,59918],"@MaterialIcons/uniEA0F":[32,32.0,59919],"@MaterialIcons/uniEA10":[32,32.0,59920],"@MaterialIcons/uniEA11":[32,32.0,59921],"@MaterialIcons/uniEA12":[32,32.0,59922],"@MaterialIcons/uniEA13":[32,32.0,59923],"@MaterialIcons/uniEA14":[32,32.0,59924],"@MaterialIcons/uniEA15":[32,32.0,59925],"@MaterialIcons/uniEA16":[32,32.0,59926],"@MaterialIcons/uniEA17":[32,32.0,59927],"@MaterialIcons/uniEA18":[32,32.0,59928],"@MaterialIcons/uniEA19":[32,32.0,59929],"@MaterialIcons/uniEA1A":[32,32.0,59930],"@MaterialIcons/uniEA1B":[32,32.0,59931],"@MaterialIcons/uniEA1C":[32,32.0,59932],"@MaterialIcons/uniEA1D":[32,32.0,59933],"@MaterialIcons/uniEA1E":[32,32.0,59934],"@MaterialIcons/uniEA1F":[32,32.0,59935],"@MaterialIcons/uniEA20":[32,32.0,59936],"@MaterialIcons/uniEA21":[32,32.0,59937],"@MaterialIcons/uniEA22":[32,32.0,59938],"@MaterialIcons/uniEA23":[32,32.0,59939],"@MaterialIcons/uniEA24":[32,32.0,59940],"@MaterialIcons/uniEA26":[32,32.0,59942],"@MaterialIcons/uniEA27":[32,32.0,59943],"@MaterialIcons/uniEA28":[32,32.0,59944],"@MaterialIcons/uniEA29":[32,32.0,59945],"@MaterialIcons/uniEA2A":[32,32.0,59946],"@MaterialIcons/uniEA2B":[32,32.0,59947],"@MaterialIcons/uniEA2C":[32,32.0,59948],"@MaterialIcons/uniEA2D":[32,32.0,59949],"@MaterialIcons/uniEA2E":[32,32.0,59950],"@MaterialIcons/uniEA2F":[32,32.0,59951],"@MaterialIcons/uniEA30":[32,32.0,59952],"@MaterialIcons/uniEA31":[32,32.0,59953],"@MaterialIcons/uniEA32":[32,32.0,59954],"@MaterialIcons/uniEA33":[32,32.0,59955],"@MaterialIcons/uniEA34":[32,32.0,59956],"@MaterialIcons/uniEA35":[32,32.0,59957],"@MaterialIcons/uniEA36":[32,32.0,59958],"@MaterialIcons/uniEA37":[32,32.0,59959],"@MaterialIcons/uniEA38":[32,32.0,59960],"@MaterialIcons/uniEA39":[32,32.0,59961],"@MaterialIcons/uniEA40":[32,32.0,59968],"@MaterialIcons/uniEA41":[32,32.0,59969],"@MaterialIcons/uniEA42":[32,32.0,59970],"@MaterialIcons/uniEA43":[32,32.0,59971],"@MaterialIcons/uniEA44":[32,32.0,59972],"@MaterialIcons/uniEA45":[32,32.0,59973],"@MaterialIcons/uniEA46":[32,32.0,59974],"@MaterialIcons/uniEA47":[32,32.0,59975],"@MaterialIcons/uniEA48":[32,32.0,59976],"@MaterialIcons/uniEA49":[32,32.0,59977],"@MaterialIcons/uniEA50":[32,32.0,59984],"@MaterialIcons/uniEA51":[32,32.0,59985],"@MaterialIcons/unsubscribe":[32,32.0,57579],"@MaterialIcons/update":[32,32.0,59683],"@MaterialIcons/usb":[32,32.0,57824],"@MaterialIcons/v":[32,32.0,118],"@MaterialIcons/verified_user":[32,32.0,59624],"@MaterialIcons/vertical_align_bottom":[32,32.0,57944],"@MaterialIcons/vertical_align_center":[32,32.0,57945],"@MaterialIcons/vertical_align_top":[32,32.0,57946],"@MaterialIcons/vertical_split":[32,32.0,59721],"@MaterialIcons/vibration":[32,32.0,58925],"@MaterialIcons/video_call":[32,32.0,57456],"@MaterialIcons/video_label":[32,32.0,57457],"@MaterialIcons/video_library":[32,32.0,57418],"@MaterialIcons/videocam":[32,32.0,57419],"@MaterialIcons/videocam_off":[32,32.0,57420],"@MaterialIcons/videogame_asset":[32,32.0,58168],"@MaterialIcons/view_agenda":[32,32.0,59625],"@MaterialIcons/view_array":[32,32.0,59626],"@MaterialIcons/view_carousel":[32,32.0,59627],"@MaterialIcons/view_column":[32,32.0,59628],"@MaterialIcons/view_comfy":[32,32.0,58410],"@MaterialIcons/view_compact":[32,32.0,58411],"@MaterialIcons/view_day":[32,32.0,59629],"@MaterialIcons/view_headline":[32,32.0,59630],"@MaterialIcons/view_list":[32,32.0,59631],"@MaterialIcons/view_module":[32,32.0,59632],"@MaterialIcons/view_quilt":[32,32.0,59633],"@MaterialIcons/view_stream":[32,32.0,59634],"@MaterialIcons/view_week":[32,32.0,59635],"@MaterialIcons/vignette":[32,32.0,58421],"@MaterialIcons/visibility":[32,32.0,59636],"@MaterialIcons/visibility_off":[32,32.0,59637],"@MaterialIcons/voice_chat":[32,32.0,58926],"@MaterialIcons/voice_over_off":[32,32.0,59722],"@MaterialIcons/voicemail":[32,32.0,57561],"@MaterialIcons/volume_down":[32,32.0,57421],"@MaterialIcons/volume_mute":[32,32.0,57422],"@MaterialIcons/volume_off":[32,32.0,57423],"@MaterialIcons/volume_up":[32,32.0,57424],"@MaterialIcons/vpn_key":[32,32.0,57562],"@MaterialIcons/vpn_lock":[32,32.0,58927],"@MaterialIcons/w":[32,32.0,119],"@MaterialIcons/wallpaper":[32,32.0,57788],"@MaterialIcons/warning":[32,32.0,57346],"@MaterialIcons/watch":[32,32.0,58164],"@MaterialIcons/watch_later":[32,32.0,59684],"@MaterialIcons/waves":[32,32.0,57718],"@MaterialIcons/wb_auto":[32,32.0,58412],"@MaterialIcons/wb_cloudy":[32,32.0,58413],"@MaterialIcons/wb_incandescent":[32,32.0,58414],"@MaterialIcons/wb_iridescent":[32,32.0,58422],"@MaterialIcons/wb_sunny":[32,32.0,58416],"@MaterialIcons/wc":[32,32.0,58941],"@MaterialIcons/web":[32,32.0,57425],"@MaterialIcons/web_asset":[32,32.0,57449],"@MaterialIcons/weekend":[32,32.0,57707],"@MaterialIcons/whatshot":[32,32.0,59406],"@MaterialIcons/where_to_vote":[32,32.0,57719],"@MaterialIcons/widgets":[32,32.0,57789],"@MaterialIcons/wifi":[32,32.0,58942],"@MaterialIcons/wifi_lock":[32,32.0,57825],"@MaterialIcons/wifi_off":[32,32.0,58952],"@MaterialIcons/wifi_tethering":[32,32.0,57826],"@MaterialIcons/work":[32,32.0,59641],"@MaterialIcons/work_off":[32,32.0,59714],"@MaterialIcons/work_outline":[32,32.0,59715],"@MaterialIcons/wrap_text":[32,32.0,57947],"@MaterialIcons/x":[32,32.0,120],"@MaterialIcons/y":[32,32.0,121],"@MaterialIcons/youtube_searched_for":[32,32.0,59642],"@MaterialIcons/z":[32,32.0,122],"@MaterialIcons/zero":[32,32.0,48],"@MaterialIcons/zoom_in":[32,32.0,59647],"@MaterialIcons/zoom_out":[32,32.0,59648],"@MaterialIcons/zoom_out_map":[32,32.0,58731],"iconfont/material/MaterialIcons-Regular.eot":["MaterialIcons",32,32,"iconfont.material"],"iconfont/material/MaterialIcons-Regular.json":"iconfont.material","iconfont/material/MaterialIcons-Regular.ttf":["MaterialIcons",32,32,"iconfont.material"],"iconfont/material/MaterialIcons-Regular.woff":["MaterialIcons",32,32,"iconfont.material"],"iconfont/material/MaterialIcons-Regular.woff2":["MaterialIcons",32,32,"iconfont.material"],"osparc/font/roboto-mono-v6-latin_latin-ext-700.eot":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-700.ttf":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-700.woff":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-700.woff2":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-700italic.eot":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-700italic.ttf":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-700italic.woff":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-700italic.woff2":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-italic.eot":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-italic.ttf":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-italic.woff":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-italic.woff2":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-regular.eot":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-regular.ttf":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-regular.woff":"osparc.theme","osparc/font/roboto-mono-v6-latin_latin-ext-regular.woff2":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-700.eot":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-700.ttf":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-700.woff":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-700.woff2":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-700italic.eot":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-700italic.ttf":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-700italic.woff":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-700italic.woff2":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-italic.eot":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-italic.ttf":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-italic.woff":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-italic.woff2":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-regular.eot":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-regular.ttf":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-regular.woff":"osparc.theme","osparc/font/roboto-v18-latin_latin-ext-regular.woff2":"osparc.theme","qx/decoration/Simple/arrows/down-invert.gif":[7,4,"gif","qx"],"qx/decoration/Simple/arrows/down-small.gif":[5,3,"gif","qx"],"qx/decoration/Simple/arrows/down.gif":[7,4,"gif","qx"],"qx/decoration/Simple/arrows/forward.gif":[8,7,"gif","qx"],"qx/decoration/Simple/arrows/left-invert.gif":[4,7,"gif","qx"],"qx/decoration/Simple/arrows/left.gif":[4,7,"gif","qx"],"qx/decoration/Simple/arrows/rewind.gif":[8,7,"gif","qx"],"qx/decoration/Simple/arrows/right-invert.gif":[4,7,"gif","qx"],"qx/decoration/Simple/arrows/right.gif":[4,7,"gif","qx"],"qx/decoration/Simple/arrows/up-invert.gif":[7,4,"gif","qx"],"qx/decoration/Simple/arrows/up-small.gif":[5,3,"gif","qx"],"qx/decoration/Simple/arrows/up.gif":[7,4,"gif","qx"],"qx/decoration/Simple/checkbox/checked-disabled.png":[6,6,"png","qx"],"qx/decoration/Simple/checkbox/checked.png":[6,6,"png","qx"],"qx/decoration/Simple/checkbox/undetermined-disabled.png":[6,2,"png","qx"],"qx/decoration/Simple/checkbox/undetermined.png":[6,2,"png","qx"],"qx/decoration/Simple/colorselector/brightness-field.png":[19,256,"png","qx"],"qx/decoration/Simple/colorselector/brightness-handle.gif":[35,11,"gif","qx"],"qx/decoration/Simple/colorselector/huesaturation-field.jpg":[256,256,"jpeg","qx"],"qx/decoration/Simple/colorselector/huesaturation-handle.gif":[11,11,"gif","qx"],"qx/decoration/Simple/cursors/alias.gif":[19,15,"gif","qx"],"qx/decoration/Simple/cursors/copy.gif":[19,15,"gif","qx"],"qx/decoration/Simple/cursors/move.gif":[13,9,"gif","qx"],"qx/decoration/Simple/cursors/nodrop.gif":[20,20,"gif","qx"],"qx/decoration/Simple/menu/checkbox-invert.gif":[16,7,"gif","qx"],"qx/decoration/Simple/menu/checkbox.gif":[16,7,"gif","qx"],"qx/decoration/Simple/menu/radiobutton-invert.gif":[16,5,"gif","qx"],"qx/decoration/Simple/menu/radiobutton.gif":[16,5,"gif","qx"],"qx/decoration/Simple/splitpane/knob-horizontal.png":[1,8,"png","qx"],"qx/decoration/Simple/splitpane/knob-vertical.png":[8,1,"png","qx"],"qx/decoration/Simple/table/ascending-invert.png":[10,10,"png","qx"],"qx/decoration/Simple/table/ascending.png":[10,10,"png","qx"],"qx/decoration/Simple/table/boolean-false.png":[11,11,"png","qx"],"qx/decoration/Simple/table/boolean-true.png":[11,11,"png","qx"],"qx/decoration/Simple/table/descending-invert.png":[10,10,"png","qx"],"qx/decoration/Simple/table/descending.png":[10,10,"png","qx"],"qx/decoration/Simple/table/select-column-order.png":[10,9,"png","qx"],"qx/decoration/Simple/tabview/close.gif":[10,9,"gif","qx"],"qx/decoration/Simple/tree/minus.gif":[19,16,"gif","qx"],"qx/decoration/Simple/tree/plus.gif":[19,16,"gif","qx"],"qx/decoration/Simple/treevirtual/cross.gif":[19,16,"gif","qx"],"qx/decoration/Simple/treevirtual/cross_minus.gif":[19,16,"gif","qx"],"qx/decoration/Simple/treevirtual/cross_plus.gif":[19,16,"gif","qx"],"qx/decoration/Simple/treevirtual/end.gif":[19,16,"gif","qx"],"qx/decoration/Simple/treevirtual/end_minus.gif":[19,16,"gif","qx"],"qx/decoration/Simple/treevirtual/end_plus.gif":[19,16,"gif","qx"],"qx/decoration/Simple/treevirtual/line.gif":[19,16,"gif","qx"],"qx/decoration/Simple/treevirtual/only_minus.gif":[19,16,"gif","qx"],"qx/decoration/Simple/treevirtual/only_plus.gif":[19,16,"gif","qx"],"qx/decoration/Simple/treevirtual/start.gif":[19,16,"gif","qx"],"qx/decoration/Simple/treevirtual/start_minus.gif":[19,16,"gif","qx"],"qx/decoration/Simple/treevirtual/start_plus.gif":[19,16,"gif","qx"],"qx/decoration/Simple/window/close-white.gif":[10,9,"gif","qx"],"qx/decoration/Simple/window/close.gif":[10,9,"gif","qx"],"qx/decoration/Simple/window/maximize-white.gif":[9,9,"gif","qx"],"qx/decoration/Simple/window/maximize.gif":[9,9,"gif","qx"],"qx/decoration/Simple/window/minimize-white.gif":[9,9,"gif","qx"],"qx/decoration/Simple/window/minimize.gif":[9,9,"gif","qx"],"qx/decoration/Simple/window/restore-white.gif":[8,9,"gif","qx"],"qx/decoration/Simple/window/restore.gif":[8,9,"gif","qx"],"qx/icon/Tango/16/actions/dialog-cancel.png":[16,16,"png","qx"],"qx/icon/Tango/16/actions/dialog-ok.png":[16,16,"png","qx"],"qx/icon/Tango/16/actions/view-refresh.png":[16,16,"png","qx"],"qx/icon/Tango/16/actions/window-close.png":[16,16,"png","qx"],"qx/icon/Tango/16/apps/office-calendar.png":[16,16,"png","qx"],"qx/icon/Tango/16/mimetypes/text-plain.png":[16,16,"png","qx"],"qx/icon/Tango/16/places/folder-open.png":[16,16,"png","qx"],"qx/icon/Tango/16/places/folder.png":[16,16,"png","qx"],"qx/static/blank.png":[1,1,"png","qx"]}};
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * A vertical box layout.
 *
 * The vertical box layout lays out widgets in a vertical column, from top
 * to bottom.
 *
 * *Features*
 *
 * * Minimum and maximum dimensions
 * * Prioritized growing/shrinking (flex)
 * * Margins (with vertical collapsing)
 * * Auto sizing (ignoring percent values)
 * * Percent heights (not relevant for size hint)
 * * Alignment (child property {@link qx.ui.core.LayoutItem#alignY} is ignored)
 * * Vertical spacing (collapsed with margins)
 * * Reversed children layout (from last to first)
 * * Horizontal children stretching (respecting size hints)
 *
 * *Item Properties*
 *
 * <ul>
 * <li><strong>flex</strong> <em>(Integer)</em>: The flexibility of a layout item determines how the container
 *   distributes remaining empty space among its children. If items are made
 *   flexible, they can grow or shrink accordingly. Their relative flex values
 *   determine how the items are being resized, i.e. the larger the flex ratio
 *   of two items, the larger the resizing of the first item compared to the
 *   second.
 *
 *   If there is only one flex item in a layout container, its actual flex
 *   value is not relevant. To disallow items to become flexible, set the
 *   flex value to zero.
 * </li>
 * <li><strong>height</strong> <em>(String)</em>: Allows to define a percent
 *   height for the item. The height in percent, if specified, is used instead
 *   of the height defined by the size hint. The minimum and maximum height still
 *   takes care of the element's limits. It has no influence on the layout's
 *   size hint. Percent values are mostly useful for widgets which are sized by
 *   the outer hierarchy.
 * </li>
 * </ul>
 *
 * *Example*
 *
 * Here is a little example of how to use the vertical box layout.
 *
 * <pre class="javascript">
 * var layout = new qx.ui.layout.VBox();
 * layout.setSpacing(4); // apply spacing
 *
 * var container = new qx.ui.container.Composite(layout);
 *
 * container.add(new qx.ui.core.Widget());
 * container.add(new qx.ui.core.Widget());
 * container.add(new qx.ui.core.Widget());
 * </pre>
 *
 * *External Documentation*
 *
 * See <a href='http://manual.qooxdoo.org/${qxversion}/pages/layout/box.html'>extended documentation</a>
 * and links to demos for this layout.
 *
 */
qx.Class.define("qx.ui.layout.VBox",
{
  extend : qx.ui.layout.Abstract,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param spacing {Integer?0} The spacing between child widgets {@link #spacing}.
   * @param alignY {String?"top"} Vertical alignment of the whole children
   *     block {@link #alignY}.
   * @param separator {String|qx.ui.decoration.IDecorator?} A separator to be rendered between the items
   */
  construct : function(spacing, alignY, separator)
  {
    this.base(arguments);

    if (spacing) {
      this.setSpacing(spacing);
    }

    if (alignY) {
      this.setAlignY(alignY);
    }

    if (separator) {
      this.setSeparator(separator);
    }
  },





  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /**
     * Vertical alignment of the whole children block. The vertical
     * alignment of the child is completely ignored in VBoxes (
     * {@link qx.ui.core.LayoutItem#alignY}).
     */
    alignY :
    {
      check : [ "top", "middle", "bottom" ],
      init : "top",
      apply : "_applyLayoutChange"
    },


    /**
     * Horizontal alignment of each child. Can be overridden through
     * {@link qx.ui.core.LayoutItem#alignX}.
     */
    alignX :
    {
      check : [ "left", "center", "right" ],
      init : "left",
      apply : "_applyLayoutChange"
    },


    /** Vertical spacing between two children */
    spacing :
    {
      check : "Integer",
      init : 0,
      apply : "_applyLayoutChange"
    },


    /** Separator lines to use between the objects */
    separator :
    {
      check : "Decorator",
      nullable : true,
      apply : "_applyLayoutChange"
    },


    /** Whether the actual children list should be laid out in reversed order. */
    reversed :
    {
      check : "Boolean",
      init : false,
      apply : "_applyReversed"
    }
  },





  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    __heights : null,
    __flexs : null,
    __enableFlex : null,
    __children : null,


    /*
    ---------------------------------------------------------------------------
      HELPER METHODS
    ---------------------------------------------------------------------------
    */

    // property apply
    _applyReversed : function()
    {
      // easiest way is to invalidate the cache
      this._invalidChildrenCache = true;

      // call normal layout change
      this._applyLayoutChange();
    },


    /**
     * Rebuilds caches for flex and percent layout properties
     */
    __rebuildCache : function()
    {
      var children = this._getLayoutChildren();
      var length = children.length;
      var enableFlex = false;
      var reuse = this.__heights && this.__heights.length != length && this.__flexs && this.__heights;
      var props;

      // Sparse array (keep old one if lengths has not been modified)
      var heights = reuse ? this.__heights : new Array(length);
      var flexs = reuse ? this.__flexs : new Array(length);

      // Reverse support
      if (this.getReversed()) {
        children = children.concat().reverse();
      }

      // Loop through children to preparse values
      for (var i=0; i<length; i++)
      {
        props = children[i].getLayoutProperties();

        if (props.height != null) {
          heights[i] = parseFloat(props.height) / 100;
        }

        if (props.flex != null)
        {
          flexs[i] = props.flex;
          enableFlex = true;
        } else {
          // reset (in case the index of the children changed: BUG #3131)
          flexs[i] = 0;
        }
      }

      // Store data
      if (!reuse)
      {
        this.__heights = heights;
        this.__flexs = flexs;
      }

      this.__enableFlex = enableFlex;
      this.__children = children;

      // Clear invalidation marker
      delete this._invalidChildrenCache;
    },





    /*
    ---------------------------------------------------------------------------
      LAYOUT INTERFACE
    ---------------------------------------------------------------------------
    */

    // overridden
    verifyLayoutProperty : qx.core.Environment.select("qx.debug",
    {
      "true" : function(item, name, value)
      {
        this.assert(name === "flex" || name === "height", "The property '"+name+"' is not supported by the VBox layout!");

        if (name =="height")
        {
          this.assertMatch(value, qx.ui.layout.Util.PERCENT_VALUE);
        }
        else
        {
          // flex
          this.assertNumber(value);
          this.assert(value >= 0);
        }
      },

      "false" : null
    }),


    // overridden
    renderLayout : function(availWidth, availHeight, padding)
    {
      // Rebuild flex/height caches
      if (this._invalidChildrenCache) {
        this.__rebuildCache();
      }

      // Cache children
      var children = this.__children;
      var length = children.length;
      var util = qx.ui.layout.Util;


      // Compute gaps
      var spacing = this.getSpacing();
      var separator = this.getSeparator();
      if (separator) {
        var gaps = util.computeVerticalSeparatorGaps(children, spacing, separator);
      } else {
        var gaps = util.computeVerticalGaps(children, spacing, true);
      }


      // First run to cache children data and compute allocated height
      var i, child, height, percent;
      var heights = [], hint;
      var allocatedHeight = gaps;

      for (i=0; i<length; i+=1)
      {
        percent = this.__heights[i];
        hint = children[i].getSizeHint();
        
        height = percent != null ?
          Math.floor((availHeight - gaps) * percent) :
          hint.height;

        // Limit computed value
        if (height < hint.minHeight) {
          height = hint.minHeight;
        } else if (height > hint.maxHeight) {
          height = hint.maxHeight;
        }
        
        heights.push(height);
        allocatedHeight += height;
      }


      // Flex support (growing/shrinking)
      if (this.__enableFlex && allocatedHeight != availHeight)
      {
        var flexibles = {};
        var flex, offset;

        for (i=0; i<length; i+=1)
        {
          flex = this.__flexs[i];

          if (flex > 0)
          {
            hint = children[i].getSizeHint();

            flexibles[i]=
            {
              min : hint.minHeight,
              value : heights[i],
              max : hint.maxHeight,
              flex : flex
            };
          }
        }

        var result = util.computeFlexOffsets(flexibles, availHeight, allocatedHeight);

        for (i in result)
        {
          offset = result[i].offset;

          heights[i] += offset;
          allocatedHeight += offset;
        }
      }


      // Start with top coordinate
      var top = children[0].getMarginTop();

      // Alignment support
      if (allocatedHeight < availHeight && this.getAlignY() != "top")
      {
        top = availHeight - allocatedHeight;

        if (this.getAlignY() === "middle") {
          top = Math.round(top / 2);
        }
      }


      // Layouting children
      var hint, left, width, height, marginBottom, marginLeft, marginRight;

      // Pre configure separators
      this._clearSeparators();

      // Compute separator height
      if (separator)
      {
        var separatorInsets = qx.theme.manager.Decoration.getInstance().resolve(separator).getInsets();
        var separatorHeight = separatorInsets.top + separatorInsets.bottom;
      }

      // Render children and separators
      for (i=0; i<length; i+=1)
      {
        child = children[i];
        height = heights[i];
        hint = child.getSizeHint();

        marginLeft = child.getMarginLeft();
        marginRight = child.getMarginRight();

        // Find usable width
        width = Math.max(hint.minWidth, Math.min(availWidth-marginLeft-marginRight, hint.maxWidth));

        // Respect horizontal alignment
        left = util.computeHorizontalAlignOffset(child.getAlignX()||this.getAlignX(), width, availWidth, marginLeft, marginRight);

        // Add collapsed margin
        if (i > 0)
        {
          // Whether a separator has been configured
          if (separator)
          {
            // add margin of last child and spacing
            top += marginBottom + spacing;

            // then render the separator at this position
            this._renderSeparator(separator, {
              top : top + padding.top,
              left : padding.left,
              height : separatorHeight,
              width : availWidth
            });

            // and finally add the size of the separator, the spacing (again) and the top margin
            top += separatorHeight + spacing + child.getMarginTop();
          }
          else
          {
            // Support margin collapsing when no separator is defined
            top += util.collapseMargins(spacing, marginBottom, child.getMarginTop());
          }
        }

        // Layout child
        child.renderLayout(left + padding.left, top + padding.top, width, height);

        // Add height
        top += height;

        // Remember bottom margin (for collapsing)
        marginBottom = child.getMarginBottom();
      }
    },


    // overridden
    _computeSizeHint : function()
    {
      // Rebuild flex/height caches
      if (this._invalidChildrenCache) {
        this.__rebuildCache();
      }

      var util = qx.ui.layout.Util;
      var children = this.__children;

      // Initialize
      var minHeight=0, height=0, percentMinHeight=0;
      var minWidth=0, width=0;
      var child, hint, margin;

      // Iterate over children
      for (var i=0, l=children.length; i<l; i+=1)
      {
        child = children[i];
        hint = child.getSizeHint();

        // Sum up heights
        height += hint.height;

        // Detect if child is shrinkable or has percent height and update minHeight
        var flex = this.__flexs[i];
        var percent = this.__heights[i];
        if (flex) {
          minHeight += hint.minHeight;
        } else if (percent) {
          percentMinHeight = Math.max(percentMinHeight, Math.round(hint.minHeight/percent));
        } else {
          minHeight += hint.height;
        }

        // Build horizontal margin sum
        margin = child.getMarginLeft() + child.getMarginRight();

        // Find biggest width
        if ((hint.width+margin) > width) {
          width = hint.width + margin;
        }

        // Find biggest minWidth
        if ((hint.minWidth+margin) > minWidth) {
          minWidth = hint.minWidth + margin;
        }
      }

      minHeight += percentMinHeight;

      // Respect gaps
      var spacing = this.getSpacing();
      var separator = this.getSeparator();
      if (separator) {
        var gaps = util.computeVerticalSeparatorGaps(children, spacing, separator);
      } else {
        var gaps = util.computeVerticalGaps(children, spacing, true);
      }

      // Return hint
      return {
        minHeight : minHeight + gaps,
        height : height + gaps,
        minWidth : minWidth,
        width : width
      };
    }
  },



  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this.__heights = this.__flexs = this.__children = null;
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * Common set of utility methods used by the standard qooxdoo layouts.
 *
 * @internal
 */
qx.Class.define("qx.ui.layout.Util",
{
  statics :
  {
    /** @type {RegExp} Regular expression to match percent values */
    PERCENT_VALUE : /[0-9]+(?:\.[0-9]+)?%/,


    /**
     * Computes the flex offsets needed to reduce the space
     * difference as much as possible by respecting the
     * potential of the given elements (being in the range of
     * their min/max values)
     *
     * @param flexibles {Map} Each entry must have these keys:
     *   <code>id</code>, <code>potential</code> and <code>flex</code>.
     *   The ID is used in the result map as the key for the user to work
     *   with later (e.g. upgrade sizes etc. to respect the given offset)
     *   The potential is an integer value which is the difference of the
     *   currently interesting direction (e.g. shrinking=width-minWidth, growing=
     *   maxWidth-width). The flex key holds the flex value of the item.
     * @param avail {Integer} Full available space to allocate (ignoring used one)
     * @param used {Integer} Size of already allocated space
     * @return {Map} A map which contains the calculated offsets under the key
     *   which is identical to the ID given in the incoming map.
     */
    computeFlexOffsets : function(flexibles, avail, used)
    {
      var child, key, flexSum, flexStep;
      var grow = avail > used;
      var remaining = Math.abs(avail - used);
      var roundingOffset, currentOffset;


      // Preprocess data
      var result = {};
      for (key in flexibles)
      {
        child = flexibles[key];
        result[key] =
        {
          potential : grow ? child.max - child.value : child.value - child.min,
          flex : grow ? child.flex : 1 / child.flex,
          offset : 0
        };
      }


      // Continue as long as we need to do anything
      while (remaining != 0)
      {
        // Find minimum potential for next correction
        flexStep = Infinity;
        flexSum = 0;
        for (key in result)
        {
          child = result[key];

          if (child.potential > 0)
          {
            flexSum += child.flex;
            flexStep = Math.min(flexStep, child.potential / child.flex);
          }
        }


        // No potential found, quit here
        if (flexSum == 0) {
          break;
        }


        // Respect maximum potential given through remaining space
        // The parent should always win in such conflicts.
        flexStep = Math.min(remaining, flexStep * flexSum) / flexSum;


        // Start with correction
        roundingOffset = 0;
        for (key in result)
        {
          child = result[key];

          if (child.potential > 0)
          {
            // Compute offset for this step
            currentOffset = Math.min(remaining, child.potential, Math.ceil(flexStep * child.flex));

            // Fix rounding issues
            roundingOffset += currentOffset - flexStep * child.flex;
            if (roundingOffset >= 1)
            {
              roundingOffset -= 1;
              currentOffset -= 1;
            }

            // Update child status
            child.potential -= currentOffset;

            if (grow) {
              child.offset += currentOffset;
            } else {
              child.offset -= currentOffset;
            }

            // Update parent status
            remaining -= currentOffset;
          }
        }
      }

      return result;
    },


    /**
     * Computes the offset which needs to be added to the top position
     * to result in the stated vertical alignment. Also respects
     * existing margins (without collapsing).
     *
     * @param align {String} One of <code>top</code>, <code>center</code> or <code>bottom</code>.
     * @param width {Integer} The visible width of the widget
     * @param availWidth {Integer} The available inner width of the parent
     * @param marginLeft {Integer?0} Optional left margin of the widget
     * @param marginRight {Integer?0} Optional right margin of the widget
     * @return {Integer} Computed top coordinate
     */
    computeHorizontalAlignOffset : function(align, width, availWidth, marginLeft, marginRight)
    {
      if (marginLeft == null) {
        marginLeft = 0;
      }

      if (marginRight == null) {
        marginRight = 0;
      }

      var value = 0;
      switch(align)
      {
        case "left":
          value = marginLeft;
          break;

        case "right":
          // Align right changes priority to right edge:
          // To align to the right is more important here than to left.
          value = availWidth - width - marginRight;
          break;

        case "center":
          // Ideal center position
          value = Math.round((availWidth - width) / 2);

          // Try to make this possible (with left-right priority)
          if (value < marginLeft) {
            value = marginLeft;
          } else if (value < marginRight) {
            value = Math.max(marginLeft, availWidth-width-marginRight);
          }

          break;
      }

      return value;
    },


    /**
     * Computes the offset which needs to be added to the top position
     * to result in the stated vertical alignment. Also respects
     * existing margins (without collapsing).
     *
     * @param align {String} One of <code>top</code>, <code>middle</code> or <code>bottom</code>.
     * @param height {Integer} The visible height of the widget
     * @param availHeight {Integer} The available inner height of the parent
     * @param marginTop {Integer?0} Optional top margin of the widget
     * @param marginBottom {Integer?0} Optional bottom margin of the widget
     * @return {Integer} Computed top coordinate
     */
    computeVerticalAlignOffset : function(align, height, availHeight, marginTop, marginBottom)
    {
      if (marginTop == null) {
        marginTop = 0;
      }

      if (marginBottom == null) {
        marginBottom = 0;
      }

      var value = 0;
      switch(align)
      {
        case "top":
          value = marginTop;
          break;

        case "bottom":
          // Align bottom changes priority to bottom edge:
          // To align to the bottom is more important here than to top.
          value = availHeight - height - marginBottom;
          break;

        case "middle":
          // Ideal middle position
          value = Math.round((availHeight - height) / 2);

          // Try to make this possible (with top-down priority)
          if (value < marginTop) {
            value = marginTop;
          } else if (value < marginBottom) {
            value = Math.max(marginTop, availHeight-height-marginBottom);
          }

          break;
      }

      return value;
    },


    /**
     * Collapses two margins.
     *
     * Supports positive and negative margins.
     * Collapsing find the largest positive and the largest
     * negative value. Afterwards the result is computed through the
     * subtraction of the negative from the positive value.
     *
     * @param varargs {arguments} Any number of configured margins
     * @return {Integer} The collapsed margin
     */
    collapseMargins : function(varargs)
    {
      var max=0, min=0;
      for (var i=0, l=arguments.length; i<l; i++)
      {
        var value = arguments[i];

        if (value < 0) {
          min = Math.min(min, value);
        } else if (value > 0) {
          max = Math.max(max, value);
        }
      }

      return max + min;
    },


    /**
     * Computes the sum of all horizontal gaps. Normally the
     * result is used to compute the available width in a widget.
     *
     * The method optionally respects margin collapsing as well. In
     * this mode the spacing is collapsed together with the margins.
     *
     * @param children {Array} List of children
     * @param spacing {Integer?0} Spacing between every child
     * @param collapse {Boolean?false} Optional margin collapsing mode
     * @return {Integer} Sum of all gaps in the final layout.
     */
    computeHorizontalGaps : function(children, spacing, collapse)
    {
      if (spacing == null) {
        spacing = 0;
      }

      var gaps = 0;

      if (collapse)
      {
        // Add first child
        gaps += children[0].getMarginLeft();

        for (var i=1, l=children.length; i<l; i+=1) {
          gaps += this.collapseMargins(spacing, children[i-1].getMarginRight(), children[i].getMarginLeft());
        }

        // Add last child
        gaps += children[l-1].getMarginRight();
      }
      else
      {
        // Simple adding of all margins
        for (var i=1, l=children.length; i<l; i+=1) {
          gaps += children[i].getMarginLeft() + children[i].getMarginRight();
        }

        // Add spacing
        gaps += (spacing * (l-1));
      }

      return gaps;
    },


    /**
     * Computes the sum of all vertical gaps. Normally the
     * result is used to compute the available height in a widget.
     *
     * The method optionally respects margin collapsing as well. In
     * this mode the spacing is collapsed together with the margins.
     *
     * @param children {Array} List of children
     * @param spacing {Integer?0} Spacing between every child
     * @param collapse {Boolean?false} Optional margin collapsing mode
     * @return {Integer} Sum of all gaps in the final layout.
     */
    computeVerticalGaps : function(children, spacing, collapse)
    {
      if (spacing == null) {
        spacing = 0;
      }

      var gaps = 0;

      if (collapse)
      {
        // Add first child
        gaps += children[0].getMarginTop();

        for (var i=1, l=children.length; i<l; i+=1) {
          gaps += this.collapseMargins(spacing, children[i-1].getMarginBottom(), children[i].getMarginTop());
        }

        // Add last child
        gaps += children[l-1].getMarginBottom();
      }
      else
      {
        // Simple adding of all margins
        for (var i=1, l=children.length; i<l; i+=1) {
          gaps += children[i].getMarginTop() + children[i].getMarginBottom();
        }

        // Add spacing
        gaps += (spacing * (l-1));
      }

      return gaps;
    },


    /**
     * Computes the gaps together with the configuration of separators.
     *
     * @param children {qx.ui.core.LayoutItem[]} List of children
     * @param spacing {Integer} Configured spacing
     * @param separator {String|qx.ui.decoration.IDecorator} Separator to render
     * @return {Integer} Sum of gaps
     */
    computeHorizontalSeparatorGaps : function(children, spacing, separator)
    {
      var instance = qx.theme.manager.Decoration.getInstance().resolve(separator);
      var insets = instance.getInsets();
      var width = insets.left + insets.right;

      var gaps = 0;
      for (var i=0, l=children.length; i<l; i++)
      {
        var child = children[i];
        gaps += child.getMarginLeft() + child.getMarginRight();
      }

      gaps += (spacing + width + spacing) * (l-1);

      return gaps;
    },


    /**
     * Computes the gaps together with the configuration of separators.
     *
     * @param children {qx.ui.core.LayoutItem[]} List of children
     * @param spacing {Integer} Configured spacing
     * @param separator {String|qx.ui.decoration.IDecorator} Separator to render
     * @return {Integer} Sum of gaps
     */
    computeVerticalSeparatorGaps : function(children, spacing, separator)
    {
      var instance = qx.theme.manager.Decoration.getInstance().resolve(separator);
      var insets = instance.getInsets();
      var height = insets.top + insets.bottom;

      var gaps = 0;
      for (var i=0, l=children.length; i<l; i++)
      {
        var child = children[i];
        gaps += child.getMarginTop() + child.getMarginBottom();
      }

      gaps += (spacing + height + spacing) * (l-1);

      return gaps;
    },


    /**
     * Arranges two sizes in one box to best respect their individual limitations.
     *
     * Mainly used by split layouts (Split Panes) where the layout is mainly defined
     * by the outer dimensions.
     *
     * @param beginMin {Integer} Minimum size of first widget (from size hint)
     * @param beginIdeal {Integer} Ideal size of first widget (maybe after dragging the splitter)
     * @param beginMax {Integer} Maximum size of first widget (from size hint)
     * @param endMin {Integer} Minimum size of second widget (from size hint)
     * @param endIdeal {Integer} Ideal size of second widget (maybe after dragging the splitter)
     * @param endMax {Integer} Maximum size of second widget (from size hint)
     * @return {Map} Map with the keys <code>begin</code and <code>end</code> with the
     *   arranged dimensions.
     */
    arrangeIdeals : function(beginMin, beginIdeal, beginMax, endMin, endIdeal, endMax)
    {
      if (beginIdeal < beginMin || endIdeal < endMin)
      {
        if (beginIdeal < beginMin && endIdeal < endMin)
        {
          // Just increase both, can not rearrange them otherwise
          // Result into overflowing of the overlapping content
          // Should normally not happen through auto sizing!
          beginIdeal = beginMin;
          endIdeal = endMin;
        }
        else if (beginIdeal < beginMin)
        {
          // Reduce end, increase begin to min
          endIdeal -= (beginMin - beginIdeal);
          beginIdeal = beginMin;

          // Re-check to keep min size of end
          if (endIdeal < endMin) {
            endIdeal = endMin;
          }
        }
        else if (endIdeal < endMin)
        {
          // Reduce begin, increase end to min
          beginIdeal -= (endMin - endIdeal);
          endIdeal = endMin;

          // Re-check to keep min size of begin
          if (beginIdeal < beginMin) {
            beginIdeal = beginMin;
          }
        }
      }

      if (beginIdeal > beginMax || endIdeal > endMax)
      {
        if (beginIdeal > beginMax && endIdeal > endMax)
        {
          // Just reduce both, can not rearrange them otherwise
          // Leaves a blank area in the pane!
          beginIdeal = beginMax;
          endIdeal = endMax;
        }
        else if (beginIdeal > beginMax)
        {
          // Increase end, reduce begin to max
          endIdeal += (beginIdeal - beginMax);
          beginIdeal = beginMax;

          // Re-check to keep max size of end
          if (endIdeal > endMax) {
            endIdeal = endMax;
          }
        }
        else if (endIdeal > endMax)
        {
          // Increase begin, reduce end to max
          beginIdeal += (endIdeal - endMax);
          endIdeal = endMax;

          // Re-check to keep max size of begin
          if (beginIdeal > beginMax) {
            beginIdeal = beginMax;
          }
        }
      }

      return {
        begin : beginIdeal,
        end : endIdeal
      };
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2011 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Tristan Koch (tristankoch)
     * Richard Sternagel (rsternagel)

************************************************************************ */

/**
 * Client-side wrapper of a REST resource.
 *
 * Each instance represents a resource in terms of REST. A number of actions
 * (usually HTTP methods) unique to the resource can be defined and invoked.
 * A resource with its actions is configured declaratively by passing a resource
 * description to the constructor, or programmatically using {@link #map}.
 *
 * Each action is associated to a route. A route is a combination of method,
 * URL pattern and optional parameter constraints.
 *
 * An action is invoked by calling a method with the same name. When a URL
 * pattern of a route contains positional parameters, those parameters must be
 * passed when invoking the associated action. Also, constraints defined in the
 * route must be satisfied.
 *
 * When an action is invoked, a request is configured according to the associated
 * route, is passed the URL parameters, request body data, and finally send.
 * What kind of request is send can be configured by overwriting {@link #_getRequest}.
 *
 * No constraints on the action's name or the scope of the URLs are imposed. However,
 * if you want to follow RESTful design patterns it is recommended to name actions
 * the same as the HTTP action.
 *
 * <pre class="javascript">
 * var description = {
 *  "get": { method: "GET", url: "/photo/{id}" },
 *  "put": { method: "PUT", url: "/photo/{id}"},
 *  "post": { method: "POST", url: "/photos/"}
 * };
 * var photo = new qx.io.rest.Resource(description);
 * // Can also be written: photo.invoke("get", {id: 1});
 * photo.get({id: 1});
 *
 * // Additionally sets request data (provide it as string or set the content type)
 * // In a RESTful environment this creates a new resource with the given 'id'
 * photo.configureRequest(function(req) {
 *  req.setRequestHeader("Content-Type", "application/json");
 * });
 * photo.put({id: 1}, {title: "Monkey"});
 *
 * // Additionally sets request data (provide it as string or set the content type)
 * // In a RESTful environment this adds a new resource to the resource collection 'photos'
 * photo.configureRequest(function(req) {
 *  req.setRequestHeader("Content-Type", "application/json");
 * });
 * photo.post(null, {title: "Monkey"});
 * </pre>
 *
 * To check for existence of URL parameters or constrain them to a certain format, you
 * can add a <code>check</code> property to the description. See {@link #map} for details.
 *
 * <pre class="javascript">
 * var description = {
 *  "get": { method: "GET", url: "/photo/{id}", check: { id: /\d+/ } }
 * };
 * var photo = new qx.io.rest.Resource(description);
 * // photo.get({id: "FAIL"});
 * // -- Error: "Parameter 'id' is invalid"
 * </pre>
 *
 * If your description happens to use the same action more than once, consider
 * defining another resource.
 *
 * <pre class="javascript">
 * var description = {
 *  "get": { method: "GET", url: "/photos"},
 * };
 * // Distinguish "photo" (singular) and "photos" (plural) resource
 * var photos = new qx.io.rest.Resource(description);
 * photos.get();
 * </pre>
 *
 * Basically, all routes of a resource should point to the same URL (resource in
 * terms of HTTP). One acceptable exception of this constraint are resources where
 * required parameters are part of the URL (<code>/photos/1/</code>) or filter
 * resources. For instance:
 *
 * <pre class="javascript">
 * var description = {
 *  "get": { method: "GET", url: "/photos/{tag}" }
 * };
 * var photos = new qx.io.rest.Resource(description);
 * photos.get();
 * photos.get({tag: "wildlife"})
 * </pre>
 *
 * Strictly speaking, the <code>photos</code> instance represents two distinct resources
 * and could therefore just as well mapped to two distinct resources (for instance,
 * named photos and photosTagged). What style to choose depends on the kind of data
 * returned. For instance, it seems sensible to stick with one resource if the filter
 * only limits the result set (i.e. the individual results have the same properties).
 *
 * In order to respond to successful (or erroneous) invocations of actions,
 * either listen to the generic "success" or "error" event and get the action
 * from the event data, or listen to action specific events defined at runtime.
 * Action specific events follow the pattern "&lt;action&gt;Success" and
 * "&lt;action&gt;Error", e.g. "indexSuccess".
 * 
 * NOTE: Instances of this class must be disposed of after use
 *
 */
qx.Class.define("qx.io.rest.Resource",
{
  extend: qx.core.Object,
  implement : [ qx.core.IDisposable ],

  /**
   * @param description {Map?} Each key of the map is interpreted as
   *  <code>action</code> name. The value associated to the key must be a map
   *  with the properties <code>method</code> and <code>url</code>.
   *  <code>check</code> is optional. Also see {@link #map}.
   *
   * For example:
   *
   * <pre class="javascript">
   * { get: {method: "GET", url: "/photos/{id}", check: { id: /\d+/ }} }
   * </pre>
   *
   * @see qx.bom.rest
   * @see qx.io.rest
   */
  construct: function(description)
  {
    this.base(arguments);

    this.__longPollHandlers = {};
    this.__pollTimers = {};
    this.__routes = {};

    this._resource = this._tailorResource(this._getResource());

    try {
      if (typeof description !== "undefined") {
        if (qx.core.Environment.get("qx.debug")) {
          qx.core.Assert.assertMap(description);
        }
        this.__mapFromDescription(description);
      }
    } catch(e) {
      this.dispose();
      throw e;
    }
  },

  events:
  {
    /**
     * Fired when any request was successful.
     *
     * The action the successful request is associated to, as well as the
     * request itself, can be retrieved from the events properties.
     * Additionally, an action specific event is fired that follows the pattern
     * "<action>Success", e.g. "indexSuccess".
     */
    "success": "qx.event.type.Rest",

    /**
     * Fired when request associated to action given in prefix was successful.
     *
     * For example, "indexSuccess" is fired when <code>index()</code> was
     * successful.
     */
    "actionSuccess": "qx.event.type.Rest",

    /**
     * Fired when any request fails.
     *
     * The action the failed request is associated to, as well as the
     * request itself, can be retrieved from the events properties.
     * Additionally, an action specific event is fired that follows the pattern
     * "<action>Error", e.g. "indexError".
     */
    "error": "qx.event.type.Rest",

    /**
     * Fired when any request associated to action given in prefix fails.
     *
     * For example, "indexError" is fired when <code>index()</code> failed.
     */
    "actionError": "qx.event.type.Rest"
  },

  statics:
  {
    /**
     * Number of milliseconds below a long-poll request is considered immediate and
     * subject to throttling checks.
     */
    POLL_THROTTLE_LIMIT: 100,

    /**
     * Number of immediate long-poll responses accepted before throttling takes place.
     */
    POLL_THROTTLE_COUNT: 30,

    /**
     * A symbol used in checks to declare required parameter.
     */
    REQUIRED: true,

    /**
     * Get placeholders from URL.
     *
     * @param url {String} The URL to parse for placeholders.
     * @return {Array} Array of placeholders without the placeholder prefix.
     */
    placeholdersFromUrl: function(url) {
      return qx.bom.rest.Resource.placeholdersFromUrl(url);
    }
  },

  members:
  {
    _resource: null,
    __longPollHandlers: null,
    __pollTimers: null,
    __routes: null,

    /**
     * Get resource.
     *
     * May be overridden to change type of resource.
     * @param description {Map?} See construct.
     * @return {qx.bom.rest.Resource} Resource implementation which does the heavy lifting.
     */
    _getResource: function(description) {
      return new qx.bom.rest.Resource(description);
    },

    /**
     * Tailors (apply dependency injection) the given resource to fit our needs.
     *
     * @param resource {qx.bom.rest.Resource} Resource.
     * @return {qx.bom.rest.Resource} Tailored resource.
     */
    _tailorResource: function(resource) {
      // inject different request implementation
      resource.setRequestFactory(this._getRequest);

      // inject different request handling
      resource.setRequestHandler({
          onsuccess: {
            callback: function(req, action) {
              return function() {
                var props = [req.getResponse(), null, false, req, action, req.getPhase()];
                this.fireEvent(action + "Success", qx.event.type.Rest, props);
                this.fireEvent("success", qx.event.type.Rest, props);
              };
            },
            context: this
          },
          onfail: {
            callback: function(req, action) {
              return function() {
                var props = [req.getResponse(), null, false, req, action, req.getPhase()];
                this.fireEvent(action + "Error", qx.event.type.Rest, props);
                this.fireEvent("error", qx.event.type.Rest, props);
              };
            },
            context: this
          },
          onloadend: {
            callback: function(req, action) {
              return function() {
                req.dispose();
              };
            },
            context: this
          }
      });

      return resource;
    },

    //
    // Request
    //

    /**
     * Configure request.
     *
     * @param callback {Function} Function called before request is send.
     *   Receives request, action, params and data.
     *
     * <pre class="javascript">
     * res.configureRequest(function(req, action, params, data) {
     *   if (action === "index") {
     *     req.setAccept("application/json");
     *   }
     * });
     * </pre>
     */
    configureRequest: function(callback) {
      this._resource.configureRequest(callback);
    },

    /**
     * Get request.
     *
     * May be overridden to change type of request.
     * @return {qx.io.request.Xhr} Xhr object
     */
    _getRequest: function() {
      return new qx.io.request.Xhr();
    },

    //
    // Routes and actions
    //

    /**
     * Map action to combination of method and URL pattern.
     *
     * <pre class="javascript">
     *   res.map("get", "GET", "/photos/{id}", {id: /\d+/});
     *
     *   // GET /photos/123
     *   res.get({id: "123"});
     * </pre>
     *
     * @param action {String} Action to associate to request.
     * @param method {String} Method to configure request with.
     * @param url {String} URL to configure request with. May contain positional
     *   parameters (<code>{param}</code>) that are replaced by values given when the action
     *   is invoked. Parameters are optional, unless a check is defined. A default
     *   value can be provided (<code>{param=default}</code>).
     * @param check {Map?} Map defining parameter constraints, where the key is
     *   the URL parameter and the value a regular expression (to match string) or
     *   <code>qx.io.rest.Resource.REQUIRED</code> (to verify existence).
     */
    map: function(action, method, url, check) {
      // add dynamic methods also on ourself to allow 'invoke()' delegation
      this.__addAction(action, method, url, check);

      this._resource.map(action, method, url, check);
    },

    /**
     * Map actions to members.
     *
     * @param action {String} Action to associate to request.
     * @param method {String} Method to configure request with.
     * @param url {String} URL to configure request with. May contain positional
     *   parameters (<code>{param}</code>) that are replaced by values given when the action
     *   is invoked. Parameters are optional, unless a check is defined. A default
     *   value can be provided (<code>{param=default}</code>).
     * @param check {Map?} Map defining parameter constraints, where the key is
     *   the URL parameter and the value a regular expression (to match string) or
     *   <code>qx.io.rest.Resource.REQUIRED</code> (to verify existence).
     */
    __addAction: function(action, method, url, check) {
      this.__routes[action] = [method, url, check];

      // Undefine generic getter when action is named "get"
      if (action == "get") {
        this[action] = undefined;
      }

      // Do not overwrite existing "non-action" methods unless the method is
      // null (i.e. because it exists as a stub for documentation)
      if (typeof this[action] !== "undefined" && this[action] !== null &&
          this[action].action !== true)
      {
        throw new Error("Method with name of action ("+action+") already exists");
      }

      this.__declareEvent(action + "Success");
      this.__declareEvent(action + "Error");

      this[action] = qx.lang.Function.bind(function() {
        Array.prototype.unshift.call(arguments, action);
        return this.invoke.apply(this, arguments);
      }, this);

      // Method is safe to overwrite
      this[action].action = true;

    },

    /**
     * Invoke action with parameters.
     *
     * Internally called by actions dynamically created.
     *
     * May be overridden to customize action and parameter handling.
     *
     * @lint ignoreUnused(successHandler, failHandler, loadEndHandler)
     *
     * @param action {String} Action to invoke.
     * @param params {Map} Map of parameters inserted into URL when a matching
     *  positional parameter is found.
     * @param data {Map|String} Data to be send as part of the request.
     *  See {@link qx.io.request.AbstractRequest#requestData}.
     * @return {Number} Id of the action's invocation.
     */
    invoke: function(action, params, data) {
      var params = (params == null) ? {} : params;

      // Cache parameters
      this.__routes[action].params = params;

      return this._resource.invoke(action, params, data);
    },

    /**
     * Set base URL.
     *
     * The base URL is prepended to the URLs given in the description.
     * Changes affect all future invocations.
     *
     * @param baseUrl {String} Base URL.
     */
    setBaseUrl: function(baseUrl) {
      this._resource.setBaseUrl(baseUrl);
    },

    /**
     * Abort action.
     *
     * Example:
     *
     * <pre class="javascript">
     *   // Abort all invocations of action
     *   res.get({id: 1});
     *   res.get({id: 2});
     *   res.abort("get");
     *
     *   // Abort specific invocation of action (by id)
     *   var actionId = res.get({id: 1});
     *   res.abort(actionId);
     * </pre>
     *
     * @param varargs {String|Number} Action of which all invocations to abort
     *  (when string), or a single invocation of an action to abort (when number)
     */
    abort: function(varargs) {
      this._resource.abort(varargs);
    },

    /**
     * Resend request associated to action.
     *
     * Replays parameters given when action was invoked originally.
     *
     * @param action {String} Action to refresh.
     */
    refresh: function(action) {
      this._resource.refresh(action);
    },

    /**
     * Periodically invoke action.
     *
     * Replays parameters given when action was invoked originally. When the
     * action was not yet invoked and requires parameters, parameters must be
     * given.
     *
     * Please note that IE tends to cache overly aggressive. One work-around is
     * to disable caching on the client side by configuring the request with
     * <code>setCache(false)</code>. If you control the server, a better
     * work-around is to include appropriate headers to explicitly control
     * caching. This way you still avoid requests that can be correctly answered
     * from cache (e.g. when nothing has changed since the last poll). Please
     * refer to <a href="http://www.mnot.net/javascript/xmlhttprequest/cache.html">
     * XMLHttpRequest Caching Test</a> for available options.
     *
     * @lint ignoreUnused(intervalListener)
     *
     * @param action {String} Action to poll.
     * @param interval {Number} Interval in ms.
     * @param params {Map?} Map of parameters. See {@link #invoke}.
     * @param immediately {Boolean?false} <code>true</code>, if the poll should
     *   invoke a call immediately.
     * @return {qx.event.Timer} Timer that periodically invokes action. Use to
     *   stop or resume. Is automatically disposed on disposal of object.
     */
    poll: function(action, interval, params, immediately) {
      // Dispose timer previously created for action
      if (this.__pollTimers[action]) {
        this.__pollTimers[action].dispose();
      }

      // Fallback to previous params
      if (typeof params == "undefined") {
        params = this.__routes[action].params;
      }

      // Invoke immediately
      if (immediately) {
        this.invoke(action, params);
      }

      var intervalListener = function() {
        var reqs = this.getRequestsByAction(action),
            req = (reqs) ? reqs[0] : null;

        if (!immediately && !req) {
          this.invoke(action, params);
          return;
        }
        if (req && (req.isDone() || req.isDisposed())) {
          this.refresh(action);
        }
      };

      var timer = this.__pollTimers[action] = new qx.event.Timer(interval);
      timer.addListener("interval", intervalListener, this._resource);
      timer.start();
      return timer;
    },

    /**
     * Long-poll action.
     *
     * Use Ajax long-polling to continuously fetch a resource as soon as the
     * server signals new data. The server determines when new data is available,
     * while the client keeps open a request. Requires configuration on the
     * server side. Basically, the server must not close a connection until
     * new data is available. For a high level introduction to long-polling,
     * refer to <a href="http://en.wikipedia.org/wiki/Comet_(programming)#Ajax_with_long_polling">
     * Ajax with long polling</a>.
     *
     * Uses {@link #refresh} internally. Make sure you understand the
     * implications of IE's tendency to cache overly aggressive.
     *
     * Note no interval is given on the client side.
     *
     * @lint ignoreUnused(longPollHandler)
     *
     * @param action {String} Action to poll.
     * @return {String} Id of handler responsible for long-polling. To stop
     *  polling, remove handler using {@link qx.core.Object#removeListenerById}.
     */
    longPoll: function(action) {
      var res = this,
          lastResponse,               // Keep track of last response
          immediateResponseCount = 0; // Count immediate responses

      // Throttle to prevent high load on server and client
      function throttle() {
        var isImmediateResponse =
          lastResponse &&
          ((new Date()) - lastResponse) < res._getThrottleLimit();

        if (isImmediateResponse) {
          immediateResponseCount += 1;
          if (immediateResponseCount > res._getThrottleCount()) {
            if (qx.core.Environment.get("qx.debug")) {
              res.debug("Received successful response more than " +
                res._getThrottleCount() + " times subsequently, each within " +
                res._getThrottleLimit() + " ms. Throttling.");
            }
            return true;
          }
        }

        // Reset counter on delayed response
        if (!isImmediateResponse) {
          immediateResponseCount = 0;
        }

        return false;
      }

      var handlerId = this.__longPollHandlers[action] =
        this.addListener(action + "Success", function longPollHandler() {
          if (res.isDisposed()) {
            return;
          }

          if (!throttle()) {
            lastResponse = new Date();
            res.refresh(action);
          }
        });

      this.invoke(action);
      return handlerId;
    },

    /**
     * Get request configuration for action and parameters.
     *
     * This is were placeholders are replaced with parameters.
     *
     * @param action {String} Action associated to request.
     * @param params {Map} Parameters to embed in request.
     * @return {Map} Map of configuration settings. Has the properties
     *   <code>method</code>, <code>url</code> and <code>check</code>.
     */
    _getRequestConfig: function(action, params) {
      return this._resource._getRequestConfig(action, params);
    },

    /**
     * Override to adjust the throttle limit.
     * @return {Integer} Throttle limit in milliseconds
     */
    _getThrottleLimit: function() {
      return qx.io.rest.Resource.POLL_THROTTLE_LIMIT;
    },

    /**
     * Override to adjust the throttle count.
     * @return {Integer} Throttle count
     */
    _getThrottleCount: function() {
      return qx.io.rest.Resource.POLL_THROTTLE_COUNT;
    },

    /**
     * Map actions from description.
     *
     * Allows to decoratively define routes.
     *
     * @param description {Map} Map that defines the routes.
     */
    __mapFromDescription: function(description) {
      Object.keys(description).forEach(function(action) {
        var route = description[action],
            method = route.method,
            url = route.url,
            check = route.check;

        if (qx.core.Environment.get("qx.debug")) {
          qx.core.Assert.assertString(method, "Method must be string for route '" + action + "'");
          qx.core.Assert.assertString(url, "URL must be string for route '" + action + "'");
        }

        this.map(action, method, url, check);
      }, this);
    },

    /**
     * Declare event at runtime.
     *
     * @param type {String} Type of event.
     */
    __declareEvent: function(type) {
      if (!this.constructor.$$events) {
        this.constructor.$$events = {};
      }

      if (!this.constructor.$$events[type]) {
        this.constructor.$$events[type] = "qx.event.type.Rest";
      }
    }
  },

  /**
   * Destructs the Resource.
   *
   * All created requests, routes and pollTimers will be disposed.
   */
  destruct: function() {
    var action;

    if (this.__pollTimers) {
      for (action in this.__pollTimers) {
        var timer = this.__pollTimers[action];
        timer.stop();
        timer.dispose();
      }
    }

    if (this.__longPollHandlers) {
      for (action in this.__longPollHandlers) {
        var id = this.__longPollHandlers[action];
        this.removeListenerById(id);
      }
    }

    this._resource.destruct();
    this._resource = this.__routes = this.__pollTimers = this.__longPollHandlers = null;
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2013 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Richard Sternagel (rsternagel)

************************************************************************ */

/**
 * Client-side wrapper of a REST resource.
 *
 * Each instance represents a resource in terms of REST. A number of actions
 * (usually HTTP methods) unique to the resource can be defined and invoked.
 * A resource with its actions is configured declaratively by passing a resource
 * description to the constructor, or programmatically using {@link #map}.
 *
 * Each action is associated to a route. A route is a combination of method,
 * URL pattern and optional parameter constraints.
 *
 * An action is invoked by calling a method with the same name. When a URL
 * pattern of a route contains positional parameters, those parameters must be
 * passed when invoking the associated action. Also, constraints defined in the
 * route must be satisfied.
 *
 * When an action is invoked, a request is configured according to the associated
 * route, is passed the URL parameters, request body data, and finally send.
 * What kind of request is send can be configured by overwriting {@link #_getRequest}.
 *
 * No constraints on the action's name or the scope of the URLs are imposed. However,
 * if you want to follow RESTful design patterns it is recommended to name actions
 * the same as the HTTP action.
 *
 * Strictly speaking, the <code>photos</code> instance represents two distinct resources
 * and could therefore just as well mapped to two distinct resources (for instance,
 * named photos and photosTagged). What style to choose depends on the kind of data
 * returned. For instance, it seems sensible to stick with one resource if the filter
 * only limits the result set (i.e. the individual results have the same properties).
 *
 * In order to respond to successful (or erroneous) invocations of actions,
 * either listen to the generic "success" or "error" event and get the action
 * from the event data, or listen to action specific events defined at runtime.
 * Action specific events follow the pattern "&lt;action&gt;Success" and
 * "&lt;action&gt;Error", e.g. "indexSuccess".
 *
 * @group (IO)
 * @ignore(qx.core.Object.*)
 */
qx.Bootstrap.define("qx.bom.rest.Resource",
{
  extend: qx.event.Emitter,
  implement: [ qx.core.IDisposable ],

  /**
   * @param description {Map?} Each key of the map is interpreted as
   *  <code>action</code> name. The value associated to the key must be a map
   *  with the properties <code>method</code> and <code>url</code>.
   *  <code>check</code> is optional. Also see {@link #map}.
   *
   * @see qx.bom.rest
   * @see qx.io.rest
   */
  construct: function(description)
  {
    this.__requests = {};
    this.__routes = {};
    this.__pollTimers = {};
    this.__longPollHandlers = {};

    try {
      if (typeof description !== "undefined") {
        if (qx.core.Environment.get("qx.debug")) {
          qx.core.Assert.assertMap(description);
        }
        this.__mapFromDescription(description);
      }
    } catch(e) {
      this.dispose();
      throw e;
    }
  },

  events:
  {
    /**
     * Fired when any request was successful.
     *
     * The action the successful request is associated to, as well as the
     * request itself, can be retrieved from the events properties.
     * Additionally, an action specific event is fired that follows the pattern
     * "<action>Success", e.g. "indexSuccess".
     */
    "success": "qx.bom.rest.Resource",

    /**
     * Fired when request associated to action given in prefix was successful.
     *
     * For example, "indexSuccess" is fired when <code>index()</code> was
     * successful.
     */
     "actionSuccess": "qx.bom.rest.Resource",

    /**
     * Fired when any request fails.
     *
     * The action the failed request is associated to, as well as the
     * request itself, can be retrieved from the events properties.
     * Additionally, an action specific event is fired that follows the pattern
     * "<action>Error", e.g. "indexError".
     */
    "error": "qx.bom.rest.Resource",

    /**
     * Fired when any request associated to action given in prefix fails.
     *
     * For example, "indexError" is fired when <code>index()</code> failed.
     */
     "actionError": "qx.bom.rest.Resource",

    /**
     * Fired when a request is sent to the given endpoint.
     */
    "sent": "qx.bom.rest.Resource",

    /**
     * Fired when any request associated to action is sent to the given endpoint.
     *
     * For example, "indexSent" is fired when <code>index()</code> was
     * called.
     */
     "actionSent": "qx.bom.rest.Resource",

    /**
     * Fired when a request is started to the given endpoint. This moment is right after the request
     * was opened and send.
     */
    "started": "qx.bom.rest.Resource",

    /**
     * Fired when any request associated to action is started to the given endpoint. This moment is
     * right after the request was opened and send.
     *
     * For example, "indexStarted" is fired when <code>index()</code> was called.
     */
     "actionStarted": "qx.bom.rest.Resource"
  },

  statics:
  {
    /**
     * Number of milliseconds below a long-poll request is considered immediate and
     * subject to throttling checks.
     */
    POLL_THROTTLE_LIMIT: 100,

    /**
     * Number of immediate long-poll responses accepted before throttling takes place.
     */
    POLL_THROTTLE_COUNT: 30,

    /**
     * A symbol used in checks to declare required parameter.
     */
    REQUIRED: true,

    /**
     * Get placeholders from URL.
     *
     * @param url {String} The URL to parse for placeholders.
     * @return {Array} Array of placeholders without the placeholder prefix.
     */
    placeholdersFromUrl: function(url) {
      var placeholderRe = /\{(\w+)(=\w+)?\}/g,
          match,
          placeholders = [];

      // With g flag set, searching begins at the regex object's
      // lastIndex, which is zero initially and increments with each match.
      while ((match = placeholderRe.exec(url))) {
        placeholders.push(match[1]);
      }

      return placeholders;
    }
  },

  members:
  {
    __requests: null,
    __routes: null,
    __baseUrl: null,
    __pollTimers: null,
    __longPollHandlers: null,
    __configureRequestCallback: null,

    /**
     * @type {Map} Request callbacks for 'onsuccess', 'onfail' and 'onloadend' - see {@link #setRequestHandler}.
     */
    __requestHandler: null,

    /**
     * @type {Function} Function which returns instances from {@link qx.io.request.AbstractRequest}.
     */
    __begetRequest: null,

    //
    // Request
    //

    /**
     * Set a request factory function to switch the request implementation.
     * The created requests have to implement {@link qx.io.request.AbstractRequest}.
     *
     * @param fn {Function} Function which returns request instances.
     *
     * @internal
     */
    setRequestFactory: function(fn) {
      this.__begetRequest = fn;
    },

    /**
     * Sets request callbacks for 'onsuccess', 'onfail' and 'onloadend'.
     *
     * @param handler {Map} Map defining callbacks and their context.
     *
     * @internal
     */
    setRequestHandler: function(handler) {
      this.__requestHandler = handler;
    },

    /**
     * Provides the request callbacks for 'onsuccess', 'onfail' and 'onloadend'.
     *
     * @return {Map} Map defining callbacks and their context.
     */
    _getRequestHandler: function() {
      return (this.__requestHandler === null) ? {
        onsuccess: {
          callback: function(req, action) {
            return function() {
              var response = {
                  "id": parseInt(req.toHashCode(), 10),
                  "response": req.getResponse(),
                  "request": req,
                  "action": action
              };
              this.emit(action + "Success", response);
              this.emit("success", response);
            };
          },
          context: this
        },
        onfail: {
          callback: function(req, action) {
            return function() {
              var response = {
                  "id": parseInt(req.toHashCode(), 10),
                  "response": req.getResponse(),
                  "request": req,
                  "action": action
              };
              this.emit(action + "Error", response);
              this.emit("error", response);
            };
          },
          context: this
        },
        onloadend: {
          callback: function(req, action) {
            return function() {
              // [#8315] // dispose asynchronous to work with Sinon.js
              window.setTimeout(function() {
                req.dispose();
              }, 0);
            };
          },
          context: this
        },
        onreadystatechange: {
          callback: function(req, action) {
            return function () {
              if (req.getTransport().readyState === qx.bom.request.Xhr.HEADERS_RECEIVED) {
                var response = {
                    "id": parseInt(req.toHashCode(), 10),
                    "request": req,
                    "action": action
                };
                this.emit(action + "Sent", response);
                this.emit("sent", response);
              }

              if (req.getTransport().readyState === qx.bom.request.Xhr.OPENED) {
                var payload = {
                  "id": parseInt(req.toHashCode(), 10),
                  "request": req,
                  "action": action
                };
                this.emit(action + "Started", payload);
                this.emit("started", payload);
              }
            };
          },
          context: this
        },
        onprogress: {
          callback: function(req, action) {
            return function () {
              var payload = {
                "id": parseInt(req.toHashCode(), 10),
                "request": req,
                "action": action,
                "progress": {
                  "lengthComputable": req.getTransport().progress.lengthComputable,
                  "loaded": req.getTransport().progress.loaded,
                  "total": req.getTransport().progress.total
                }
              };
              this.emit(action + "Progress", payload);
              this.emit("progress", payload);
            };
          },
          context: this
        }
      } : this.__requestHandler;
    },

    /**
     * Retrieve the currently stored request objects for an action.
     *
     * @param action {String} The action (e.g. "get", "post" ...).
     * @return {Array|null} Request objects.
     *
     * @internal
     */
    getRequestsByAction: function (action) {
      var hasRequests = (this.__requests !== null && action in this.__requests);
      return hasRequests ? this.__requests[action] : null;
    },

    /**
     * Configure request.
     *
     * @param callback {Function} Function called before request is send.
     *   Receives request, action, params and data.
     */
    configureRequest: function(callback) {
      this.__configureRequestCallback = callback;
    },

    /**
     * Get request.
     *
     * May be overridden to change type of request.
     * @return {qx.bom.request.SimpleXhr|qx.io.request.AbstractRequest} Request object
     */
    _getRequest: function() {
      return (this.__begetRequest === null) ? new qx.bom.request.SimpleXhr()
                                            : this.__begetRequest();
    },

    /**
     * Create request.
     *
     * @param action {String} The action the created request is associated to.
     * @return {qx.bom.request.SimpleXhr|qx.io.request.AbstractRequest} Request object
     */
    __createRequest: function(action) {
      var req = this._getRequest();

      if (!qx.lang.Type.isArray(this.__requests[action])) {
        this.__requests[action] = [];
      }

      qx.core.ObjectRegistry.register(req);
      this.__requests[action].push(req);

      return req;
    },

    //
    // Routes and actions
    //

    /**
     * Map action to combination of method and URL pattern.
     *
     * @param action {String} Action to associate to request.
     * @param method {String} Method to configure request with.
     * @param url {String} URL to configure request with. May contain positional
     *   parameters (<code>{param}</code>) that are replaced by values given when the action
     *   is invoked. Parameters are optional, unless a check is defined. A default
     *   value can be provided (<code>{param=default}</code>).
     * @param check {Map?} Map defining parameter constraints, where the key is
     *   the URL parameter and the value a regular expression (to match string) or
     *   <code>qx.bom.rest.Resource.REQUIRED</code> (to verify existence).
     */
    map: function(action, method, url, check) {
      this.__routes[action] = [method, url, check];

      // Track requests
      this.__requests[action] = [];

      // Undefine generic getter when action is named "get"
      if (action == "get") {
        this[action] = undefined;
      }

      // Do not overwrite existing "non-action" methods unless the method is
      // null (i.e. because it exists as a stub for documentation)
      if (typeof this[action] !== "undefined" && this[action] !== null &&
          this[action].action !== true)
      {
        throw new Error("Method with name of action (" +
          action + ") already exists");
      }

      this.__declareEvent(action + "Success");
      this.__declareEvent(action + "Error");

      this[action] = qx.lang.Function.bind(function() {
        Array.prototype.unshift.call(arguments, action);
        return this.invoke.apply(this, arguments);
      }, this);

      // Method is safe to overwrite
      this[action].action = true;
    },

    /**
     * Invoke action with parameters.
     *
     * Internally called by actions dynamically created.
     *
     * May be overridden to customize action and parameter handling.
     *
     * @lint ignoreUnused(successHandler, failHandler, loadEndHandler)
     *
     * @param action {String} Action to invoke.
     * @param params {Map} Map of parameters inserted into URL when a matching
     *  positional parameter is found.
     * @param data {Map|String} Data to be send as part of the request.
     *  See {@link qx.bom.request.SimpleXhr#getRequestData}.
     *  See {@link qx.io.request.AbstractRequest#requestData}.
     * @return {Number} Id of the action's invocation.
     */
    invoke: function(action, params, data) {
      var req = this.__createRequest(action),
          params = params == null ? {} : params,
          config = this._getRequestConfig(action, params);

      // Cache parameters
      this.__routes[action].params = params;

      // Check parameters
      this.__checkParameters(params, config.check);

      // Configure request
      this.__configureRequest(req, config, data);

      // Run configuration callback, passing in pre-configured request
      if (this.__configureRequestCallback) {
        this.__configureRequestCallback.call(this, req, action, params, data);
      }

      // Configure JSON request (content type may have been set in configuration callback)
      this.__configureJsonRequest(req, config, data);

      var reqHandler = this._getRequestHandler();

      // Handle successful request
      req.addListenerOnce(
        "success",
        reqHandler.onsuccess.callback(req, action),
        reqHandler.onsuccess.context
      );
      // Handle erroneous request
      req.addListenerOnce(
        "fail",
        reqHandler.onfail.callback(req, action),
        reqHandler.onfail.context
      );
      // Handle loadend (Note that loadEnd is fired after "success")
      req.addListenerOnce(
        "loadEnd",
        reqHandler.onloadend.callback(req, action),
        reqHandler.onloadend.context
      );
      if (reqHandler.hasOwnProperty("onreadystatechange")) {
        req.addListener(
          "readystatechange",
          reqHandler.onreadystatechange.callback(req, action),
          reqHandler.onreadystatechange.context
        );
      }
      // Handle progress (which is fired multiple times)
      if (reqHandler.hasOwnProperty("onprogress")) {
        req.addListener(
          "progress",
          reqHandler.onprogress.callback(req, action),
          reqHandler.onprogress.context
        );
      }

      req.send();

      return parseInt(req.toHashCode(), 10);
    },

    /**
     * Set base URL.
     *
     * The base URL is prepended to the URLs given in the description.
     * Changes affect all future invocations.
     *
     * @param baseUrl {String} Base URL.
     */
    setBaseUrl: function(baseUrl) {
      this.__baseUrl = baseUrl;
    },

    /**
     * Check parameters.
     *
     * @param params {Map} Parameters.
     * @param check {Map} Checks.
     */
    __checkParameters: function(params, check) {
      if(typeof check !== "undefined") {

        if (qx.core.Environment.get("qx.debug")) {
          qx.core.Assert.assertObject(check, "Check must be object with params as keys");
        }

        Object.keys(check).forEach(function(param) {

          // Warn about invalid check
          if (qx.core.Environment.get("qx.debug")) {
            if (check[param] !== true) {
              if (qx.core.Environment.get("qx.debug")) {
                qx.core.Assert.assertRegExp(check[param]);
              }
            }
          }

          // Missing parameter
          if (check[param] === qx.bom.rest.Resource.REQUIRED && typeof params[param] === "undefined") {
            throw new Error("Missing parameter '" + param + "'");
          }

          // Ignore invalid checks
          if (!(check[param] && typeof check[param].test == "function")) {
            return;
          }

          // Invalid parameter
          if (!check[param].test(params[param])) {
            throw new Error("Parameter '" + param + "' is invalid");
          }
        });
      }
    },

    /**
     * Configure request.
     *
     * @param req {qx.bom.request.SimpleXhr|qx.io.request.AbstractRequest} Request.
     * @param config {Map} Configuration.
     * @param data {Map} Data.
     */
    __configureRequest: function(req, config, data) {
      req.setUrl(config.url);

      if (!req.setMethod && config.method !== "GET") {
        throw new Error("Request (" + req.classname + ") doesn't support other HTTP methods than 'GET'");
      }

      if (req.setMethod) {
        req.setMethod(config.method);
      }

      if (data) {
        req.setRequestData(data);
      }
    },

    /**
     * Serialize data to JSON when content type indicates.
     *
     * @param req {qx.bom.request.SimpleXhr|qx.io.request.AbstractRequest} Request.
     * @param config {Map} Configuration.
     * @param data {Map} Data.
     */
    __configureJsonRequest: function(req, config, data) {
      if (data) {
        var contentType = req.getRequestHeader("Content-Type");

        if (req.getMethod && qx.util.Request.methodAllowsRequestBody(req.getMethod())) {
          if ((/application\/.*\+?json/).test(contentType)) {
            data = qx.lang.Json.stringify(data);
            req.setRequestData(data);
          }
        }
      }
    },

    /**
     * Abort action.
     *
     * @param varargs {String|Number} Action of which all invocations to abort
     *  (when string), or a single invocation of an action to abort (when number)
     */
    abort: function(varargs) {
      if (qx.lang.Type.isNumber(varargs)) {
        var id = varargs;
        var post = qx.core.ObjectRegistry.getPostId();
        var req = qx.core.ObjectRegistry.fromHashCode(id + post);
        if (req) {
          req.abort();
        }
      } else {
        var action = varargs;
        var reqs = this.__requests[action];
        if (this.__requests[action]) {
          reqs.forEach(function(req) {
            req.abort();
          });
        }
      }
    },

    /**
     * Resend request associated to action.
     *
     * Replays parameters given when action was invoked originally.
     *
     * @param action {String} Action to refresh.
     */
    refresh: function(action) {
      this.invoke(action, this.__routes[action].params);
    },

    /**
     * Periodically invoke action.
     *
     * Replays parameters given when action was invoked originally. When the
     * action was not yet invoked and requires parameters, parameters must be
     * given.
     *
     * Please note that IE tends to cache overly aggressive. One work-around is
     * to disable caching on the client side by configuring the request with
     * <code>setCache(false)</code>. If you control the server, a better
     * work-around is to include appropriate headers to explicitly control
     * caching. This way you still avoid requests that can be correctly answered
     * from cache (e.g. when nothing has changed since the last poll). Please
     * refer to <a href="http://www.mnot.net/javascript/xmlhttprequest/cache.html">
     * XMLHttpRequest Caching Test</a> for available options.
     *
     * @lint ignoreUnused(intervalListener)
     *
     * @param action {String} Action to poll.
     * @param interval {Number} Interval in ms.
     * @param params {Map?} Map of parameters. See {@link #invoke}.
     * @param immediately {Boolean?false} <code>true</code>, if the poll should
     *   invoke a call immediately.
     */
    poll: function(action, interval, params, immediately) {
      // Dispose timer previously created for action
      if (this.__pollTimers[action]) {
        this.stopPollByAction(action);
      }

      // Fallback to previous params
      if (typeof params == "undefined") {
        params = this.__routes[action].params;
      }

      // Invoke immediately
      if (immediately) {
        this.invoke(action, params);
      }

      var intervalListener = (function(scope) {
        return function() {
          var req = scope.__requests[action][0];
          if (!immediately && !req) {
            scope.invoke(action, params);
            return;
          }
          if (req.isDone() || req.isDisposed()) {
            scope.refresh(action);
          }
        };
      })(this);

      this._startPoll(action, intervalListener, interval);
    },


    /**
     * Start a poll process.
     *
     * @param action {String} Action to poll.
     * @param listener {Function} The function to repeatedly execute at the given interval.
     * @param interval {Number} Interval in ms.
     */
    _startPoll: function(action, listener, interval) {
      this.__pollTimers[action] = {
        "id": window.setInterval(listener, interval),
        "interval": interval,
        "listener": listener
      };
    },

    /**
     * Stops a poll process by the associated action.
     *
     * @param action {String} Action to poll.
     */
    stopPollByAction: function(action) {
      if (action in this.__pollTimers) {
        var intervalId = this.__pollTimers[action].id;
        window.clearInterval(intervalId);
      }
    },

    /**
     * Restarts a poll process by the associated action.
     *
     * @param action {String} Action to poll.
     */
    restartPollByAction: function(action) {
      if (action in this.__pollTimers) {
        var timer = this.__pollTimers[action];
        this.stopPollByAction(action);
        this._startPoll(action, timer.listener, timer.interval);
      }
    },

    /**
     * Long-poll action.
     *
     * Use Ajax long-polling to continuously fetch a resource as soon as the
     * server signals new data. The server determines when new data is available,
     * while the client keeps open a request. Requires configuration on the
     * server side. Basically, the server must not close a connection until
     * new data is available. For a high level introduction to long-polling,
     * refer to <a href="http://en.wikipedia.org/wiki/Comet_(programming)#Ajax_with_long_polling">
     * Ajax with long polling</a>.
     *
     * Uses {@link #refresh} internally. Make sure you understand the
     * implications of IE's tendency to cache overly aggressive.
     *
     * Note no interval is given on the client side.
     *
     * @lint ignoreUnused(longPollHandler)
     *
     * @param action {String} Action to poll.
     * @return {String} Id of handler responsible for long-polling. To stop
     *  polling, remove handler using {@link qx.core.Object#removeListenerById}.
     */
    longPoll: function(action) {
      var res = this,
          lastResponse,               // Keep track of last response
          immediateResponseCount = 0; // Count immediate responses

      // Throttle to prevent high load on server and client
      function throttle() {
        var isImmediateResponse =
          lastResponse &&
          ((new Date()) - lastResponse) < res._getThrottleLimit();

        if (isImmediateResponse) {
          immediateResponseCount += 1;
          if (immediateResponseCount > res._getThrottleCount()) {
            if (qx.core.Environment.get("qx.debug")) {
              qx.Bootstrap.debug("Received successful response more than " +
                res._getThrottleCount() + " times subsequently, each within " +
                res._getThrottleLimit() + " ms. Throttling.");
            }
            return true;
          }
        }

        // Reset counter on delayed response
        if (!isImmediateResponse) {
          immediateResponseCount = 0;
        }

        return false;
      }

      var handlerId = this.__longPollHandlers[action] =
        this.addListener(action + "Success", function longPollHandler() {
          if (res.isDisposed()) {
            return;
          }

          if (!throttle()) {
            lastResponse = new Date();
            res.refresh(action);
          }
        });

      this.invoke(action);
      return handlerId;
    },

    /**
     * Get request configuration for action and parameters.
     *
     * This is were placeholders are replaced with parameters.
     *
     * @param action {String} Action associated to request.
     * @param params {Map} Parameters to embed in request.
     * @return {Map} Map of configuration settings. Has the properties
     *   <code>method</code>, <code>url</code> and <code>check</code>.
     */
    _getRequestConfig: function(action, params) {
      var route = this.__routes[action];

      // Not modify original params
      var params = qx.lang.Object.clone(params);

      if (!qx.lang.Type.isArray(route)) {
        throw new Error("No route for action " + action);
      }

      var method = route[0],
          url = this.__baseUrl !== null ? this.__baseUrl + route[1] : route[1],
          check = route[2],
          placeholders = qx.bom.rest.Resource.placeholdersFromUrl(url);

      params = params || {};

      placeholders.forEach(function(placeholder) {
        // Placeholder part of template and default value
        var re = new RegExp("{" + placeholder + "=?(\\w+)?}"),
            defaultValue = url.match(re)[1];

        // Fill in default or empty string when missing
        if (typeof params[placeholder] === "undefined") {
          if (defaultValue) {
            params[placeholder] = defaultValue;
          } else {
            params[placeholder] = "";
          }
        }

        url = url.replace(re, params[placeholder]);
      });

      return {method: method, url: url, check: check};
    },

    /**
     * Override to adjust the throttle limit.
     * @return {Integer} Throttle limit in milliseconds
     */
    _getThrottleLimit: function() {
      return qx.bom.rest.Resource.POLL_THROTTLE_LIMIT;
    },

    /**
     * Override to adjust the throttle count.
     * @return {Integer} Throttle count
     */
    _getThrottleCount: function() {
      return qx.bom.rest.Resource.POLL_THROTTLE_COUNT;
    },

    /**
     * Map actions from description.
     *
     * Allows to decoratively define routes.
     *
     * @param description {Map} Map that defines the routes.
     */
    __mapFromDescription: function(description) {
      Object.keys(description).forEach(function(action) {
        var route = description[action],
            method = route.method,
            url = route.url,
            check = route.check;

        if (qx.core.Environment.get("qx.debug")) {
          qx.core.Assert.assertString(method, "Method must be string for route '" + action + "'");
          qx.core.Assert.assertString(url, "URL must be string for route '" + action + "'");
        }

        this.map(action, method, url, check);
      }, this);
    },

    /**
     * Declare event at runtime.
     *
     * @param type {String} Type of event.
     */
    __declareEvent: function(type) {
      if (!this.constructor.$$events) {
        this.constructor.$$events = {};
      }

      if (!this.constructor.$$events[type]) {
        this.constructor.$$events[type] = "qx.bom.rest.Resource";
      }
    },

    /*
    ---------------------------------------------------------------------------
      DISPOSER
    ---------------------------------------------------------------------------
    */

    /**
     * Returns true if the object is disposed.
     *
     * @return {Boolean} Whether the object has been disposed
     */
    isDisposed : function() {
      return this.$$disposed || false;
    },


    /**
     * Dispose this object
     *
     */
    dispose : function()
    {
      // Check first
      if (this.$$disposed) {
        return;
      }

      // Mark as disposed (directly, not at end, to omit recursions)
      this.$$disposed = true;

      // Debug output
      if (qx.core.Environment.get("qx.debug"))
      {
        if (qx.core.Environment.get("qx.debug.dispose.level") > 2) {
          qx.Bootstrap.debug(this, "Disposing " + this.classname + "[" + this.toHashCode() + "]");
        }
      }

      this.destruct();

      // Additional checks
      if (qx.core.Environment.get("qx.debug"))
      {
        if (qx.core.Environment.get("qx.debug.dispose.level") > 0)
        {
          var key, value;
          for (key in this)
          {
            value = this[key];

            // Check for Objects but respect values attached to the prototype itself
            if (value !== null && typeof value === "object" && !(qx.Bootstrap.isString(value)))
            {
              // Check prototype value
              // undefined is the best, but null may be used as a placeholder for
              // private variables (hint: checks in qx.Class.define). We accept both.
              if (this.constructor.prototype[key] != null) {
                continue;
              }

              var ff2 = navigator.userAgent.indexOf("rv:1.8.1") != -1;
              var ie6 = navigator.userAgent.indexOf("MSIE 6.0") != -1;
              // keep the old behavior for IE6 and FF2
              if (ff2 || ie6) {
                if (qx.core.Object && value instanceof qx.core.Object || qx.core.Environment.get("qx.debug.dispose.level") > 1) {
                  qx.Bootstrap.warn(this, "Missing destruct definition for '" + key + "' in " + this.classname + "[" + this.toHashCode() + "]: " + value);
                  delete this[key];
                }
              } else {
                if (qx.core.Environment.get("qx.debug.dispose.level") > 1) {
                  qx.Bootstrap.warn(this, "Missing destruct definition for '" + key + "' in " + this.classname + "[" + this.toHashCode() + "]: " + value);
                  delete this[key];
                }
              }
            }
          }
        }
      }
    },

    /**
     * Destructs the Resource.
     *
     * All created requests, routes and pollTimers will be disposed.
     */
    destruct: function() {
      var action;

      for (action in this.__requests) {
        if (this.__requests[action]) {
          this.__requests[action].forEach(function(req) {
            req.dispose();
          });
        }
      }

      if (this.__pollTimers) {
        for (action in this.__pollTimers) {
          this.stopPollByAction(action);
        }
      }

      if (this.__longPollHandlers) {
        for (action in this.__longPollHandlers) {
          var id = this.__longPollHandlers[action];
          this.removeListenerById(id);
        }
      }

      this.__requests = this.__routes = this.__pollTimers = null;
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2013 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Richard Sternagel (rsternagel)

************************************************************************ */

/**
 * This class is internal because it's tailored to {@link qx.io.rest.Resource}
 * which needs more functionality than {@link qx.bom.request.Xhr} provides.
 * The usage of {@link qx.io.request.Xhr} isn't possible either due to it's qx.Class nature.
 *
 * For alternatives to this class have a look at:
 *
 * * "qx.bom.request.Xhr" (low level, cross-browser XHR abstraction compatible with spec)
 * * "qx.io.request.Xhr" (high level XHR abstraction)
 *
 * A wrapper of {@link qx.bom.request.Xhr} which offers:
 *
 * * set/get HTTP method, URL, request data and headers
 * * retrieve the parsed response as object (content-type recognition)
 * * more fine-grained events such as success, fail, ...
 * * supports hash code for request identification
 *
 * It does *not* comply the interface defined by {@link qx.bom.request.IRequest}.
 *
 * <div class="desktop">
 * Example:
 *
 * <pre class="javascript">
 *  var req = new qx.bom.request.SimpleXhr("/some/path/file.json");
 *  req.setRequestData({"a":"b"});
 *  req.once("success", function successHandler() {
 *    var response = req.getResponse();
 *  }, this);
 *  req.once("fail", function successHandler() {
 *    var response = req.getResponse();
 *  }, this);
 *  req.send();
 * </pre>
 * </div>
 *
 * @internal
 */
qx.Bootstrap.define("qx.bom.request.SimpleXhr",
{

  extend: qx.event.Emitter,
  implement: [ qx.core.IDisposable ],

  /**
   * @param url {String?} The URL of the resource to request.
   * @param method {String?"GET"} The HTTP method.
   */
  construct: function(url, method) {
    if (url !== undefined) {
      this.setUrl(url);
    }

    this.useCaching(true);
    this.setMethod((method !== undefined) ? method : "GET");
    this._transport = this._registerTransportListener(this._createTransport());

    qx.core.ObjectRegistry.register(this);

    this.__requestHeaders = {};
    this.__parser = this._createResponseParser();
  },

  members :
  {
    /*
    ---------------------------------------------------------------------------
      PUBLIC
    ---------------------------------------------------------------------------
    */

    /**
     * Sets a request header.
     *
     * @param key {String} Key of the header.
     * @param value {String} Value of the header.
     * @return {qx.bom.request.SimpleXhr} Self for chaining.
     */
    setRequestHeader: function(key, value) {
      this.__requestHeaders[key] = value;
      return this;
    },

    /**
     * Gets a request header.
     *
     * @param key {String} Key of the header.
     * @return {String} The value of the header.
     */
    getRequestHeader: function(key) {
      return this.__requestHeaders[key];
    },


    /**
     * Returns a single response header
     *
     * @param header {String} Name of the header to get.
     * @return {String} Response header
     */
    getResponseHeader: function(header) {
      return this._transport.getResponseHeader(header);
    },


    /**
     * Returns all response headers
     * @return {String} String of response headers
     */
    getAllResponseHeaders: function() {
      return this._transport.getAllResponseHeaders();
    },

    /**
     * Sets the URL.
     *
     * @param url {String} URL to be requested.
     * @return {qx.bom.request.SimpleXhr} Self for chaining.
     */
    setUrl: function(url) {
      if (qx.lang.Type.isString(url)) {
        this.__url = url;
      }
      return this;
    },

    /**
     * Gets the URL.
     *
     * @return {String} URL to be requested.
     */
    getUrl: function() {
      return this.__url;
    },

    /**
     * Sets the HTTP-Method.
     *
     * @param method {String} The method.
     * @return {qx.bom.request.SimpleXhr} Self for chaining.
     */
    setMethod: function(method) {
      if (qx.util.Request.isMethod(method)) {
        this.__method = method;
      }
      return this;
    },

    /**
     * Gets the HTTP-Method.
     *
     * @return {String} The method.
     */
    getMethod: function() {
      return this.__method;
    },

    /**
     * Sets the request data to be send as part of the request.
     *
     * The request data is transparently included as URL query parameters or embedded in the
     * request body as form data.
     *
     * @param data {String|Object} The request data.
     * @return {qx.bom.request.SimpleXhr} Self for chaining.
     */
    setRequestData: function(data) {
      if (qx.lang.Type.isString(data) || qx.lang.Type.isObject(data) ||
         ["ArrayBuffer", "Blob", "FormData"].indexOf(qx.lang.Type.getClass(data)) !== -1) {
        this.__requestData = data;
      }
      return this;
    },

    /**
     * Gets the request data.
     *
     * @return {String} The request data.
     */
    getRequestData: function() {
      return this.__requestData;
    },

    /**
     * Gets parsed response.
     *
     * If problems occurred an empty string ("") is more likely to be returned (instead of null).
     *
     * @return {String|null} The parsed response of the request.
     */
    getResponse: function() {
      if (this.__response !== null) {
        return this.__response;
      } else {
        return (this._transport.responseXML !== null) ? this._transport.responseXML : this._transport.responseText;
      }

      return null;
    },

    /**
     * Gets low-level transport.
     *
     * Note: To be used with caution!
     *
     * This method can be used to query the transport directly,
     * but should be used with caution. Especially, it
     * is not advisable to call any destructive methods
     * such as <code>open</code> or <code>send</code>.
     *
     * @return {Object} An instance of a class found in
     *  <code>qx.bom.request.*</code>
     */
     // This method mainly exists so that some methods found in the
     // low-level transport can be deliberately omitted here,
     // but still be accessed should it be absolutely necessary.
     //
     // Valid use cases include to query the transports responseXML
     // property if performance is critical and any extra parsing
     // should be avoided at all costs.
     //
    getTransport: function() {
      return this._transport;
    },

    /**
     * Sets (i.e. override) the parser for the response parsing.
     *
     * @see qx.util.ResponseParser#setParser
     *
     * @param parser {String|Function}
     * @return {Function} The parser function
     */
    setParser: function(parser) {
      return this.__parser.setParser(parser);
    },

    /**
     * Sets the timout limit in milliseconds.
     *
     * @param millis {Number} limit in milliseconds.
     * @return {qx.bom.request.SimpleXhr} Self for chaining.
     */
    setTimeout: function(millis) {
      if (qx.lang.Type.isNumber(millis)) {
        this.__timeout = millis;
      }
      return this;
    },

    /**
     * The current timeout in milliseconds.
     *
     * @return {Number} The current timeout in milliseconds.
     */
    getTimeout: function() {
      return this.__timeout;
    },

    /**
     * Whether to allow request to be answered from cache.
     *
     * Allowed values:
     *
     * * <code>true</code>: Allow caching (Default)
     * * <code>false</code>: Prohibit caching. Appends 'nocache' parameter to URL.
     *
     * Consider setting a Cache-Control header instead. A requests Cache-Control
     * header may contain a number of directives controlling the behavior of
     * any caches in between client and origin server and allows therefore a more
     * fine grained control over caching. If such a header is provided, the setting
     * of setCache() will be ignored.
     *
     * * <code>"no-cache"</code>: Force caches to submit request in order to
     * validate the freshness of the representation. Note that the requested
     * resource may still be served from cache if the representation is
     * considered fresh. Use this directive to ensure freshness but save
     * bandwidth when possible.
     * * <code>"no-store"</code>: Do not keep a copy of the representation under
     * any conditions.
     *
     * See <a href="http://www.mnot.net/cache_docs/#CACHE-CONTROL">
     * Caching tutorial</a> for an excellent introduction to Caching in general.
     * Refer to the corresponding section in the
     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">
     * HTTP 1.1 specification</a> for more details and advanced directives.
     *
     * It is recommended to choose an appropriate Cache-Control directive rather
     * than prohibit caching using the nocache parameter.
     *
     * @param value {Boolean}
     * @return {qx.bom.request.SimpleXhr} Self for chaining.
     */
    useCaching: function(value) {
      if (qx.lang.Type.isBoolean(value)) {
        this.__cache = value;
      }
      return this;
    },

    /**
     * Whether requests are cached.
     *
     * @return {Boolean} Whether requests are cached.
     */
    isCaching: function() {
      return this.__cache;
    },

    /**
     * Whether request completed (is done).

     * @return {Boolean} Whether request is completed.
     */
    isDone: function() {
      return (this._transport.readyState === qx.bom.request.Xhr.DONE);
    },

    /**
     * Returns unique hash code of object.
     *
     * @return {Integer} unique hash code of the object
     */
    toHashCode : function() {
      return this.$$hash;
    },

    /**
     * Returns true if the object is disposed.
     *
     * @return {Boolean} Whether the object has been disposed
     */
    isDisposed: function() {
      return !!this.__disposed;
    },

    /**
     * Sends request.
     *
     * Relies on set before:
     * * a HTTP method
     * * an URL
     * * optional request headers
     * * optional request data
     */
    send: function() {
      var curTimeout = this.getTimeout(),
          hasRequestData = (this.getRequestData() !== null),
          hasCacheControlHeader = this.__requestHeaders.hasOwnProperty("Cache-Control"),
          isBodyForMethodAllowed = qx.util.Request.methodAllowsRequestBody(this.getMethod()),
          curContentType = this.getRequestHeader("Content-Type"),
          serializedData = this._serializeData(this.getRequestData(), curContentType);

      // add GET params if needed
      if (this.getMethod() === "GET" && hasRequestData) {
        this.setUrl(qx.util.Uri.appendParamsToUrl(this.getUrl(), serializedData));
      }

      // cache prevention
      if (this.isCaching() === false && !hasCacheControlHeader) {
        // Make sure URL cannot be served from cache and new request is made
        this.setUrl(qx.util.Uri.appendParamsToUrl(this.getUrl(), {nocache: new Date().valueOf()}));
      }

      // set timeout
      if (curTimeout) {
        this._transport.timeout = curTimeout;
      }

      // initialize request
      this._transport.open(this.getMethod(), this.getUrl(), true);

      // set all previously stored headers on initialized request
      for (var key in this.__requestHeaders) {
        this._transport.setRequestHeader(key, this.__requestHeaders[key]);
      }

      // send
      if (!isBodyForMethodAllowed) {
        // GET & HEAD
        this._transport.send();
      } else {
        // POST & PUT ...
        if (typeof curContentType === "undefined" && ["ArrayBuffer", "Blob", "FormData"].indexOf(qx.Bootstrap.getClass(serializedData)) === -1) {
          // by default, set content-type urlencoded for requests with body
          this._transport.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        }

        this._transport.send(serializedData);
      }
    },

    /**
     * Aborts request.
     *
     * Cancels any network activity.
     * @return {qx.bom.request.SimpleXhr} Self for chaining.
     */
    abort: function() {
      this._transport.abort();
      return this;
    },

    /**
     * Disposes object and wrapped transport.
     * @return {Boolean} <code>true</code> if the object was successfully disposed
     */
    dispose: function() {
      if (this._transport.dispose()) {
        this.__parser = null;
        this.__disposed = true;
        return true;
      }
      return false;
    },

    /*
    ---------------------------------------------------------------------------
      PROTECTED
    ---------------------------------------------------------------------------
    */

    /**
     * Holds transport.
     */
    _transport: null,

    /**
     * Creates XHR transport.
     *
     * May be overridden to change type of resource.
     * @return {qx.bom.request.IRequest} Transport.
     */
    _createTransport: function() {
      return new qx.bom.request.Xhr();
    },

    /**
     * Registers common listeners on given transport.
     *
     * @param transport {qx.bom.request.IRequest} Transport.
     * @return {qx.bom.request.IRequest} Transport.
     */
    _registerTransportListener: function(transport) {
      transport.onreadystatechange = qx.lang.Function.bind(this._onReadyStateChange, this);
      transport.onloadend = qx.lang.Function.bind(this._onLoadEnd, this);
      transport.ontimeout = qx.lang.Function.bind(this._onTimeout, this);
      transport.onerror = qx.lang.Function.bind(this._onError, this);
      transport.onabort = qx.lang.Function.bind(this._onAbort, this);
      transport.onprogress = qx.lang.Function.bind(this._onProgress, this);
      return transport;
    },

    /**
     * Creates response parser.
     *
     * @return {qx.util.ResponseParser} parser.
     */
    _createResponseParser: function() {
        return new qx.util.ResponseParser();
    },

    /**
     * Sets the response.
     *
     * @param response {String} The parsed response of the request.
     */
    _setResponse: function(response) {
      this.__response = response;
    },

    /**
     * Serializes data.
     *
     * @param data {String|Map} Data to serialize.
     * @param contentType {String?} Content-Type which influences the serialization.
     * @return {String|null} Serialized data.
     */
    _serializeData: function(data, contentType) {
      var isPost = this.getMethod() === "POST",
          isJson = (/application\/.*\+?json/).test(contentType);

      if (!data) {
        return null;
      }

      if (qx.lang.Type.isString(data)) {
        return data;
      }

      if (isJson && (qx.lang.Type.isObject(data) || qx.lang.Type.isArray(data))) {
        return qx.lang.Json.stringify(data);
      }

      if (qx.lang.Type.isObject(data)) {
        return qx.util.Uri.toParameter(data, isPost);
      }

      if (["ArrayBuffer", "Blob", "FormData"].indexOf(qx.Bootstrap.getClass(data)) !== -1) {
        return data;
      }

      return null;
    },

    /*
    ---------------------------------------------------------------------------
      PRIVATE
    ---------------------------------------------------------------------------
    */

    /**
     * {Array} Request headers.
     */
    __requestHeaders: null,
    /**
     * {Object} Request data (i.e. body).
     */
    __requestData: null,
    /**
     * {String} HTTP method to use for request.
     */
    __method: "",
    /**
     * {String} Requested URL.
     */
    __url: "",
    /**
     * {Object} Response data.
     */
    __response: null,
    /**
     * {Function} Parser.
     */
    __parser: null,
    /**
     * {Boolean} Whether caching will be enabled.
     */
    __cache: null,
    /**
     * {Number} The current timeout in milliseconds.
     */
    __timeout: null,
    /**
     * {Boolean} Whether object has been disposed.
     */
    __disposed: null,

    /*
    ---------------------------------------------------------------------------
      EVENT HANDLING
    ---------------------------------------------------------------------------
    */

    /**
     * Adds an event listener for the given event name which is executed only once.
     *
     * @param name {String} The name of the event to listen to.
     * @param listener {Function} The function to execute when the event is fired
     * @param ctx {var?} The context of the listener.
     * @return {qx.bom.request.Xhr} Self for chaining.
     */
    addListenerOnce: function(name, listener, ctx) {
      this.once(name, listener, ctx);
      return this;
    },

    /**
     * Adds an event listener for the given event name.
     *
     * @param name {String} The name of the event to listen to.
     * @param listener {Function} The function to execute when the event is fired
     * @param ctx {var?} The context of the listener.
     * @return {qx.bom.request.Xhr} Self for chaining.
     */
    addListener: function(name, listener, ctx) {
      this._transport._emitter.on(name, listener, ctx);
      return this;
    },

    /**
     * Handles "readyStateChange" event.
     */
    _onReadyStateChange: function() {
      if (qx.core.Environment.get("qx.debug.io")) {
        qx.Bootstrap.debug("Fire readyState: " + this._transport.readyState);
      }

      if (this.isDone()) {
        this.__onReadyStateDone();
      }
    },

    /**
     * Called internally when readyState is DONE.
     */
    __onReadyStateDone: function() {
      if (qx.core.Environment.get("qx.debug.io")) {
        qx.Bootstrap.debug("Request completed with HTTP status: " + this._transport.status);
      }

      var response = this._transport.responseText;
      var contentType = this._transport.getResponseHeader("Content-Type");

      // Successful HTTP status
      if (qx.util.Request.isSuccessful(this._transport.status)) {

        // Parse response
        if (qx.core.Environment.get("qx.debug.io")) {
          qx.Bootstrap.debug("Response is of type: '" + contentType + "'");
        }

        this._setResponse(this.__parser.parse(response, contentType));

        this.emit("success");

      // Erroneous HTTP status
      } else {

        try {
          this._setResponse(this.__parser.parse(response, contentType));
        } catch (e) {
          // ignore if it does not work
        }

        // A remote error failure
        if (this._transport.status !== 0) {
          this.emit("fail");
        }
      }
    },

    /**
     * Handles "loadEnd" event.
     */
    _onLoadEnd: function() {
      this.emit("loadEnd");
    },

    /**
     * Handles "abort" event.
     */
    _onAbort: function() {
      this.emit("abort");
    },

    /**
     * Handles "timeout" event.
     */
    _onTimeout: function() {
      this.emit("timeout");

      // A network error failure
      this.emit("fail");
    },

    /**
     * Handles "error" event.
     */
    _onError: function() {
      this.emit("error");

      // A network error failure
      this.emit("fail");
    },

    /**
     * Handles "error" event.
     */
    _onProgress: function() {
      this.emit("progress");
    }

  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2011 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Tristan Koch (tristankoch)

************************************************************************ */

/**
 * Rest event object.
 */
qx.Class.define("qx.event.type.Rest",
{
  extend: qx.event.type.Data,

  properties:
  {
    /**
     * The request of the event.
     */
    request: {
      check: "qx.io.request.AbstractRequest"
    },

    /**
     * The action that invoked the request.
     */
    action: {
      check: "String"
    },

    /**
     * The phase of the request.
     */
    phase: {
      check: "String"
    },

    /**
     * The id of the request.
     */
    id: {
      check: "Number"
    }
  },

  members:
  {
    /**
     * Initializes an event object.
     *
     * @param data {var} Then event's new data
     * @param old {var?null} The event's old data
     * @param cancelable {Boolean?false} Whether or not an event can have its default
     *  action prevented. The default action can either be the browser's
     *  default action of a native event (e.g. open the context menu on a
     *  right click) or the default action of a qooxdoo class (e.g. close
     *  the window widget). The default action can be prevented by calling
     *  {@link qx.event.type.Event#preventDefault}
     * @param request {qx.io.request.AbstractRequest} The associated request.
     * @param action {String} The associated action.
     * @param phase {String} The associated phase.
     * @return {qx.event.type.Data} The initialized instance.
     */
    init: function(data, old, cancelable, request, action, phase) {
      this.base(arguments, data, old, cancelable);

      this.setRequest(request);
      this.setAction(action);
      this.setPhase(phase);
      this.setId(parseInt(request.toHashCode(), 10));

      return this;
    },

    /**
     * Get a copy of this object
     *
     * @param embryo {qx.event.type.Data?null} Optional event class, which will
     *  be configured using the data of this event instance. The event must be
     *  an instance of this event class. If the data is <code>null</code>,
     *  a new pooled instance is created.
     * @return {qx.event.type.Data} A copy of this object.
     */
    clone: function(embryo) {
      var clone = this.base(arguments, embryo);
      clone.setAction(this.getAction());
      clone.setPhase(this.getPhase());
      clone.setRequest(this.getRequest());
      return clone;
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Christian Hagendorn (chris_schmidt)
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * Each object, which should support single selection have to
 * implement this interface.
 */
qx.Interface.define("qx.ui.core.ISingleSelection",
{
  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */


  events :
  {
    /** Fires after the selection was modified */
    "changeSelection" : "qx.event.type.Data"
  },


  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */


  members :
  {
    /**
     * Returns an array of currently selected items.
     *
     * Note: The result is only a set of selected items, so the order can
     * differ from the sequence in which the items were added.
     *
     * @return {qx.ui.core.Widget[]} List of items.
     */
    getSelection : function() {
      return true;
    },

    /**
     * Replaces current selection with the given items.
     *
     * @param items {qx.ui.core.Widget[]} Items to select.
     * @throws {Error} if the item is not a child element.
     */
    setSelection : function(items) {
      return arguments.length == 1;
    },

    /**
     * Clears the whole selection at once.
     */
    resetSelection : function() {
      return true;
    },

    /**
     * Detects whether the given item is currently selected.
     *
     * @param item {qx.ui.core.Widget} Any valid selectable item
     * @return {Boolean} Whether the item is selected.
     * @throws {Error} if the item is not a child element.
     */
    isSelected : function(item) {
      return arguments.length == 1;
    },

    /**
     * Whether the selection is empty.
     *
     * @return {Boolean} Whether the selection is empty.
     */
    isSelectionEmpty : function() {
      return true;
    },

    /**
     * Returns all elements which are selectable.
     *
     * @param all {Boolean} true for all selectables, false for the
     *   selectables the user can interactively select
     * @return {qx.ui.core.Widget[]} The contained items.
     */
    getSelectables: function(all) {
      return arguments.length == 1;
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */


/**
 * <h2>Object Controller</h2>
 *
 * *General idea*
 *
 * The idea of the object controller is to make the binding of one model object
 * containing one or more properties as easy as possible. Therefore the
 * controller can take a model as property. Every property in that model can be
 * bound to one or more target properties. The binding will be for
 * atomic types only like Numbers, Strings, ...
 *
 * *Features*
 *
 * * Manages the bindings between the model properties and the different targets
 * * No need for the user to take care of the binding ids
 * * Can create an bidirectional binding (read- / write-binding)
 * * Handles the change of the model which means adding the old targets
 *
 * *Usage*
 *
 * The controller only can work if a model is set. If the model property is
 * null, the controller is not working. But it can be null on any time.
 *
 * *Cross reference*
 *
 * * If you want to bind a list like widget, use {@link qx.data.controller.List}
 * * If you want to bind a tree widget, use {@link qx.data.controller.Tree}
 * * If you want to bind a form widget, use {@link qx.data.controller.Form}
 */
qx.Class.define("qx.data.controller.Object",
{
  extend : qx.core.Object,


  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param model {qx.core.Object?null} The model for the model property.
   */
  construct : function(model)
  {
    this.base(arguments);

    // create a map for all created binding ids
    this.__bindings = {};
    // create an array to store all current targets
    this.__targets = [];

    if (model != null) {
      this.setModel(model);
    }
  },



  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /** The model object which does have the properties for the binding. */
    model :
    {
      check: "qx.core.Object",
      event: "changeModel",
      apply: "_applyModel",
      nullable: true,
      dereference: true
    }
  },



  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    // private members
    __targets : null,
    __bindings : null,

    /**
     * Apply-method which will be called if a new model has been set.
     * All bindings will be moved to the new model.
     *
     * @param value {qx.core.Object|null} The new model.
     * @param old {qx.core.Object|null} The old model.
     */
    _applyModel: function(value, old) {
      // for every target
      for (var i = 0; i < this.__targets.length; i++) {
        // get the properties
        var targetObject = this.__targets[i][0];
        var targetProperty = this.__targets[i][1];
        var sourceProperty = this.__targets[i][2];
        var bidirectional = this.__targets[i][3];
        var options = this.__targets[i][4];
        var reverseOptions = this.__targets[i][5];

        // remove it from the old if possible
        if (old != undefined && !old.isDisposed()) {
          this.__removeTargetFrom(targetObject, targetProperty, sourceProperty, old);
        }

        // add it to the new if available
        if (value != undefined) {
          this.__addTarget(
            targetObject, targetProperty, sourceProperty, bidirectional,
            options, reverseOptions
          );
        } else {
          // in shutdown situations, it may be that something is already
          // disposed [BUG #4343]
          if (targetObject.isDisposed() || qx.core.ObjectRegistry.inShutDown) {
            continue;
          }
          // if the model is null, reset the current target
          if (targetProperty.indexOf("[") == -1) {
            targetObject["reset" + qx.lang.String.firstUp(targetProperty)]();
          } else {
            var open = targetProperty.indexOf("[");
            var index = parseInt(
              targetProperty.substring(open + 1, targetProperty.length - 1), 10
            );
            targetProperty = targetProperty.substring(0, open);
            var targetArray = targetObject["get" + qx.lang.String.firstUp(targetProperty)]();
            if (index == "last") {
              index = targetArray.length;
            }
            if (targetArray) {
              targetArray.setItem(index, null);
            }
          }
        }
      }
    },


    /**
     * Adds a new target to the controller. After adding the target, the given
     * property of the model will be bound to the targets property.
     *
     * @param targetObject {qx.core.Object} The object on which the property
     *   should be bound.
     *
     * @param targetProperty {String} The property to which the binding should
     *   go.
     *
     * @param sourceProperty {String} The name of the property in the model.
     *
     * @param bidirectional {Boolean?false} Signals if the binding should also work
     *   in the reverse direction, from the target to source.
     *
     * @param options {Map?null} The options Map used by the binding from source
     *   to target. The possible options can be found in the
     *   {@link qx.data.SingleValueBinding} class.
     *
     * @param reverseOptions {Map?null} The options used by the binding in the
     *   reverse direction. The possible options can be found in the
     *   {@link qx.data.SingleValueBinding} class.
     */
    addTarget: function(
      targetObject, targetProperty, sourceProperty,
      bidirectional, options, reverseOptions
    ) {

      // store the added target
      this.__targets.push([
        targetObject, targetProperty, sourceProperty,
        bidirectional, options, reverseOptions
      ]);

      // delegate the adding
      this.__addTarget(
        targetObject, targetProperty, sourceProperty,
        bidirectional, options, reverseOptions
      );
    },


    /**
    * Does the work for {@link #addTarget} but without saving the target
    * to the internal target registry.
    *
    * @param targetObject {qx.core.Object} The object on which the property
    *   should be bound.
    *
    * @param targetProperty {String} The property to which the binding should
    *   go.
    *
    * @param sourceProperty {String} The name of the property in the model.
    *
    * @param bidirectional {Boolean?false} Signals if the binding should also work
    *   in the reverse direction, from the target to source.
    *
    * @param options {Map?null} The options Map used by the binding from source
    *   to target. The possible options can be found in the
    *   {@link qx.data.SingleValueBinding} class.
    *
    * @param reverseOptions {Map?null} The options used by the binding in the
    *   reverse direction. The possible options can be found in the
    *   {@link qx.data.SingleValueBinding} class.
    */
    __addTarget: function(
      targetObject, targetProperty, sourceProperty,
      bidirectional, options, reverseOptions
    ) {

      // do nothing if no model is set
      if (this.getModel() == null) {
        return;
      }

      // create the binding
      var id = this.getModel().bind(
        sourceProperty, targetObject, targetProperty, options
      );
      // create the reverse binding if necessary
      var idReverse = null;
      if (bidirectional) {
        idReverse = targetObject.bind(
          targetProperty, this.getModel(), sourceProperty, reverseOptions
        );
      }

      // save the binding
      var targetHash = targetObject.toHashCode();
      if (this.__bindings[targetHash] == undefined) {
        this.__bindings[targetHash] = [];
      }
      this.__bindings[targetHash].push(
        [id, idReverse, targetProperty, sourceProperty, options, reverseOptions]
      );
    },

    /**
     * Removes the target identified by the three properties.
     *
     * @param targetObject {qx.core.Object} The target object on which the
     *   binding exist.
     *
     * @param targetProperty {String} The targets property name used by the
     *   adding of the target.
     *
     * @param sourceProperty {String} The name of the property of the model.
     */
    removeTarget: function(targetObject, targetProperty, sourceProperty) {
      this.__removeTargetFrom(
        targetObject, targetProperty, sourceProperty, this.getModel()
      );

      // delete the target in the targets reference
      for (var i = 0; i < this.__targets.length; i++) {
        if (
          this.__targets[i][0] == targetObject
          && this.__targets[i][1] == targetProperty
          && this.__targets[i][2] == sourceProperty
        ) {
          this.__targets.splice(i, 1);
        }
      }
    },


    /**
     * Does the work for {@link #removeTarget} but without removing the target
     * from the internal registry.
     *
     * @param targetObject {qx.core.Object} The target object on which the
     *   binding exist.
     *
     * @param targetProperty {String} The targets property name used by the
     *   adding of the target.
     *
     * @param sourceProperty {String} The name of the property of the model.
     *
     * @param sourceObject {String} The source object from which the binding
     *   comes.
     */
    __removeTargetFrom: function(
      targetObject, targetProperty, sourceProperty, sourceObject
    ) {
      // check for not fitting targetObjects
      if (!(targetObject instanceof qx.core.Object)) {
        // just do nothing
        return;
      }

      var currentListing = this.__bindings[targetObject.toHashCode()];
      // if no binding is stored
      if (currentListing == undefined || currentListing.length == 0) {
        return;
      }

      // go threw all listings for the object
      for (var i = 0; i < currentListing.length; i++) {
        // if it is the listing
        if (
          currentListing[i][2] == targetProperty &&
          currentListing[i][3] == sourceProperty
        ) {
          // remove the binding
          var id = currentListing[i][0];
          sourceObject.removeBinding(id);
          // check for the reverse binding
          if (currentListing[i][1] != null) {
            targetObject.removeBinding(currentListing[i][1]);
          }
          // delete the entry and return
          currentListing.splice(i, 1);
          return;
        }
      }
    }
  },


  /*
   *****************************************************************************
      DESTRUCT
   *****************************************************************************
   */

  destruct : function() {
    // set the model to null to get the bindings removed
    if (this.getModel() != null && !this.getModel().isDisposed()) {
      this.setModel(null);
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * This interface should be used in all objects managing a set of items
 * implementing {@link qx.ui.form.IModel}.
 */
qx.Interface.define("qx.ui.form.IModelSelection",
{

  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Tries to set the selection using the given array containing the
     * representative models for the selectables.
     *
     * @param value {Array} An array of models.
     */
    setModelSelection : function(value) {},


    /**
     * Returns an array of the selected models.
     *
     * @return {Array} An array containing the models of the currently selected
     *   items.
     */
    getModelSelection : function() {}
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */
/**
 * This interface defines the necessary features a form renderer should have.
 * Keep in mind that all renderes has to be widgets.
 */
qx.Interface.define("qx.ui.form.renderer.IFormRenderer",
{
  members :
  {
    /**
     * Add a group of form items with the corresponding names. The names should
     * be displayed as hint for the user what to do with the form item.
     * The title is optional and can be used as grouping for the given form
     * items.
     *
     * @param items {qx.ui.core.Widget[]} An array of form items to render.
     * @param names {String[]} An array of names for the form items.
     * @param title {String?} A title of the group you are adding.
     * @param itemsOptions {Array?null} The added additional data.
     * @param headerOptions {Map?null} The options map as defined by the form
     *   for the current group header.
     */
    addItems : function(items, names, title, itemsOptions, headerOptions) {},


    /**
     * Adds a button the form renderer.
     *
     * @param button {qx.ui.form.Button} A button which should be added to
     *   the form.
     * @param options {Map?null} The added additional data.
     */
    addButton : function(button, options) {}

  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * Abstract renderer for {@link qx.ui.form.Form}. This abstract renderer should
 * be the superclass of all form renderer. It takes the form, which is
 * supplied as constructor parameter and configures itself. So if you need to
 * set some additional information on your renderer before adding the widgets,
 * be sure to do that before calling this.base(arguments, form).
 */
qx.Class.define("qx.ui.form.renderer.AbstractRenderer",
{
  type : "abstract",
  extend : qx.ui.core.Widget,
  implement : qx.ui.form.renderer.IFormRenderer,

  /**
   * @param form {qx.ui.form.Form} The form to render.
   */
  construct : function(form)
  {
    this.base(arguments);

    this._labels = [];

    // translation support
    if (qx.core.Environment.get("qx.dynlocale")) {
      qx.locale.Manager.getInstance().addListener(
        "changeLocale", this._onChangeLocale, this
      );
      this._names = [];
    }
    this._form = form;
    this._render();

    form.addListener("change", this._onFormChange, this);
  },

  properties :
  {
    /**
     * A string that is appended to the label if it is not empty.
     * Defaults to " :"
     */
    labelSuffix :
    {
      check : "String",
      init : " :",
      event : "changeLabelSuffix",
      nullable : true
    },

    /**
     * A string that is appended to the label and the label suffix if the corresponding
     * form field is mandatory. Defaults to space plus a red asterisk.
     */
    requiredSuffix :
    {
      check : "String",
      init : " <span style='color:red'>*</span> ",
      event : "changeRequiredSuffix",
      nullable : false
    }
  },


  members :
  {
    _names : null,
    _form : null,
    _labels : null,


    /**
     * Renders the form: adds the items and buttons.
     */
    _render : function() {
      // add the groups
      var groups = this._form.getGroups();
      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        this.addItems(
          group.items, group.labels, group.title, group.options, group.headerOptions
        );
      }

      // add the buttons
      var buttons = this._form.getButtons();
      var buttonOptions = this._form.getButtonOptions();
      for (var i = 0; i < buttons.length; i++) {
        this.addButton(buttons[i], buttonOptions[i]);
      }
    },


    /**
     * Handler responsible for updating the rendered widget as soon as the
     * form changes.
     */
    _onFormChange : function() {
      this._removeAll();
      // remove all created labels
      for (var i=0; i < this._labels.length; i++) {
        this._labels[i].dispose();
      }
      this._labels = [];

      this._render();
    },


    /**
     * Helper to bind the item's visibility to the label's visibility.
     * @param item {qx.ui.core.Widget} The form element.
     * @param label {qx.ui.basic.Label} The label for the form element.
     */
    _connectVisibility : function(item, label) {
      // map the items visibility to the label
      item.bind("visibility", label, "visibility");
    },


    /**
     * Locale change event handler
     *
     * @signature function(e)
     * @param e {Event} the change event
     */
    _onChangeLocale : qx.core.Environment.select("qx.dynlocale",
    {
      "true" : function(e) {
        for (var i = 0; i < this._names.length; i++) {
          var entry = this._names[i];
          if (entry.name && entry.name.translate) {
            entry.name = entry.name.translate();
          }
          var newText = this._createLabelText(entry.name, entry.item);
          entry.label.setValue(newText);
        }
      },

      "false" : null
    }),


    /**
     * Creates the label text for the given form item.
     *
     * @param name {String} The content of the label without the
     *   trailing * and :
     * @param item {qx.ui.form.IForm} The item, which has the required state.
     * @return {String} The text for the given item.
     */
    _createLabelText : function(name, item)
    {
      var requiredSuffix = "";
      if (item.getRequired()) {
        requiredSuffix = this.getRequiredSuffix();
      }

      // Create the label. Append a suffix only if there's text to display.
      var labelSuffix = name.length > 0 || item.getRequired() ? this.getLabelSuffix() : "";
      return name + requiredSuffix + labelSuffix;
    },


    // interface implementation
    addItems : function(items, names, title) {
      throw new Error("Abstract method call");
    },


    // interface implementation
    addButton : function(button) {
      throw new Error("Abstract method call");
    }
  },



  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    if (qx.core.Environment.get("qx.dynlocale")) {
      qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
    }
    this._names = null;

    this._form.removeListener("change", this._onFormChange, this);
    this._form = null;
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * This mixin exposes all methods to manage the layout manager of a widget.
 * It can only be included into instances of {@link qx.ui.core.Widget}.
 *
 * To optimize the method calls the including widget should call the method
 * {@link #remap} in its defer function. This will map the protected
 * methods to the public ones and save one method call for each function.
 */
qx.Mixin.define("qx.ui.core.MLayoutHandling",
{
  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Set a layout manager for the widget. A a layout manager can only be connected
     * with one widget. Reset the connection with a previous widget first, if you
     * like to use it in another widget instead.
     *
     * @param layout {qx.ui.layout.Abstract} The new layout or
     *     <code>null</code> to reset the layout.
     */
    setLayout : function(layout) {
      this._setLayout(layout);
    },


    /**
     * Get the widget's layout manager.
     *
     * @return {qx.ui.layout.Abstract} The widget's layout manager
     */
    getLayout : function() {
      return this._getLayout();
    }
  },




  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics :
  {
    /**
     * Mapping of protected methods to public.
     * This omits an additional function call when using these methods. Call
     * this methods in the defer block of the including class.
     *
     * @param members {Map} The including classes members map
     */
    remap : function(members)
    {
      members.getLayout = members._getLayout;
      members.setLayout = members._setLayout;
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * This mixin exposes all basic methods to manage widget children as public methods.
 * It can only be included into instances of {@link Widget}.
 *
 * To optimize the method calls the including widget should call the method
 * {@link #remap} in its defer function. This will map the protected
 * methods to the public ones and save one method call for each function.
 */
qx.Mixin.define("qx.ui.core.MChildrenHandling",
{
  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Returns the children list
     *
     * @return {qx.ui.core.LayoutItem[]} The children array (Arrays are
     *   reference types, please do not modify them in-place)
     */
    getChildren : function() {
      return this._getChildren();
    },


    /**
     * Whether the widget contains children.
     *
     * @return {Boolean} Returns <code>true</code> when the widget has children.
     */
    hasChildren : function() {
      return this._hasChildren();
    },


    /**
     * Returns the index position of the given widget if it is
     * a child widget. Otherwise it returns <code>-1</code>.
     *
     * This method works on the widget's children list. Some layout managers
     * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
     * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
     * ignore the children order for the layout process.
     *
     * @param child {qx.ui.core.Widget} the widget to query for
     * @return {Integer} The index position or <code>-1</code> when
     *   the given widget is no child of this layout.
     */
    indexOf : function(child) {
      return this._indexOf(child);
    },


    /**
     * Adds a new child widget.
     *
     * The supported keys of the layout options map depend on the layout manager
     * used to position the widget. The options are documented in the class
     * documentation of each layout manager {@link qx.ui.layout}.
     *
     * @param child {qx.ui.core.LayoutItem} the widget to add.
     * @param options {Map?null} Optional layout data for widget.
     */
    add : function(child, options) {
      this._add(child, options);
    },


    /**
     * Add a child widget at the specified index
     *
     * This method works on the widget's children list. Some layout managers
     * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
     * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
     * ignore the children order for the layout process.
     *
     * @param child {qx.ui.core.LayoutItem} Widget to add
     * @param index {Integer} Index, at which the widget will be inserted
     * @param options {Map?null} Optional layout data for widget.
     */
    addAt : function(child, index, options) {
      this._addAt(child, index, options);
    },


    /**
     * Add a widget before another already inserted widget
     *
     * This method works on the widget's children list. Some layout managers
     * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
     * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
     * ignore the children order for the layout process.
     *
     * @param child {qx.ui.core.LayoutItem} Widget to add
     * @param before {qx.ui.core.LayoutItem} Widget before the new widget will be inserted.
     * @param options {Map?null} Optional layout data for widget.
     */
    addBefore : function(child, before, options) {
      this._addBefore(child, before, options);
    },


    /**
     * Add a widget after another already inserted widget
     *
     * This method works on the widget's children list. Some layout managers
     * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
     * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
     * ignore the children order for the layout process.
     *
     * @param child {qx.ui.core.LayoutItem} Widget to add
     * @param after {qx.ui.core.LayoutItem} Widget, after which the new widget will be inserted
     * @param options {Map?null} Optional layout data for widget.
     */
    addAfter : function(child, after, options) {
      this._addAfter(child, after, options);
    },


    /**
     * Remove the given child widget.
     *
     * @param child {qx.ui.core.LayoutItem} the widget to remove
     */
    remove : function(child) {
      this._remove(child);
    },


    /**
     * Remove the widget at the specified index.
     *
     * This method works on the widget's children list. Some layout managers
     * (e.g. {@link qx.ui.layout.HBox}) use the children order as additional
     * layout information. Other layout manager (e.g. {@link qx.ui.layout.Grid})
     * ignore the children order for the layout process.
     *
     * @param index {Integer} Index of the widget to remove.
     * @return {qx.ui.core.LayoutItem} The child removed.
     */
    removeAt : function(index) {
      return this._removeAt(index);
    },


    /**
     * Remove all children.
     *
     * @return {Array} An array of the removed children.
     */
    removeAll : function() {
      return this._removeAll();
    }
  },



  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics :
  {
    /**
     * Mapping of protected methods to public.
     * This omits an additional function call when using these methods. Call
     * this methods in the defer block of the including class.
     *
     * @param members {Map} The including classes members map
     */
    remap : function(members)
    {
      members.getChildren = members._getChildren;
      members.hasChildren = members._hasChildren;
      members.indexOf = members._indexOf;

      members.add = members._add;
      members.addAt = members._addAt;
      members.addBefore = members._addBefore;
      members.addAfter = members._addAfter;

      members.remove = members._remove;
      members.removeAt = members._removeAt;
      members.removeAll = members._removeAll;
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)

************************************************************************ */


/**
 * The Composite is a generic container widget.
 *
 * It exposes all methods to set layouts and to manage child widgets
 * as public methods. You must configure this widget with a layout manager to
 * define the way the widget's children are positioned.
 *
 * *Example*
 *
 * Here is a little example of how to use the widget.
 *
 * <pre class='javascript'>
 *   // create the composite
 *   var composite = new qx.ui.container.Composite()
 *
 *   // configure it with a horizontal box layout with a spacing of '5'
 *   composite.setLayout(new qx.ui.layout.HBox(5));
 *
 *   // add some children
 *   composite.add(new qx.ui.basic.Label("Name: "));
 *   composite.add(new qx.ui.form.TextField());
 *
 *   this.getRoot().add(composite);
 * </pre>
 *
 * This example horizontally groups a label and text field by using a
 * Composite configured with a horizontal box layout as a container.
 *
 * *External Documentation*
 *
 * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/composite.html' target='_blank'>
 * Documentation of this widget in the qooxdoo manual.</a>
 */
qx.Class.define("qx.ui.container.Composite",
{
  extend : qx.ui.core.Widget,
  include : [ qx.ui.core.MChildrenHandling, qx.ui.core.MLayoutHandling ],



  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param layout {qx.ui.layout.Abstract} A layout instance to use to
   *   place widgets on the screen.
   */
  construct : function(layout)
  {
    this.base(arguments);

    if (layout != null) {
      this._setLayout(layout);
    }
  },



  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events :
  {
    /**
     * This event is fired after a child widget was added to this widget. The
     * {@link qx.event.type.Data#getData} method of the event returns the
     * added child.
     */
    addChildWidget : "qx.event.type.Data",


    /**
     * This event is fired after a child widget has been removed from this widget.
     * The {@link qx.event.type.Data#getData} method of the event returns the
     * removed child.
     */
    removeChildWidget : "qx.event.type.Data"
  },



  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    // overridden
    _afterAddChild : function(child) {
      this.fireNonBubblingEvent("addChildWidget", qx.event.type.Data, [child]);
    },


    // overridden
    _afterRemoveChild : function(child) {
      this.fireNonBubblingEvent("removeChildWidget", qx.event.type.Data, [child]);
    }
  },



  /*
  *****************************************************************************
     DEFER
  *****************************************************************************
  */

  defer : function(statics, members)
  {
    qx.ui.core.MChildrenHandling.remap(members);
    qx.ui.core.MLayoutHandling.remap(members);
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2017 Martijn Evers, The Netherlands

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martijn Evers (mever)

************************************************************************ */

/**
 * Field interface.
 *
 * This interface allows any value to be set as long as the following constraint
 * is met: any value returned by {@link getValue} can be set by {@link setValue}.
 *
 * This specifies the interface for handling the model value of a field.
 * The model value is always in a consistent state (see duration example), and
 * should only handle model values of a type that correctly represents the
 * data available through its UI. E.g.: duration can ideally be modeled by a number
 * of time units, like seconds. When using a date the duration may be
 * unclear (since Unix time?). Type conversions should be handled by data binding.
 *
 * The model value is not necessary what is shown to the end-user
 * by implementing class. A good example is the {@link qx.ui.form.TextField}
 * which is able to operate with or without live updating the model value.
 *
 * Duration example: a field for duration may use two date pickers for begin
 * and end dates. When the end date is before the start date the model is in
 * inconsistent state. getValue should never return such state. And calling
 * it must result in either null or the last consistent value (depending
 * on implementation or setting).
 */
qx.Interface.define("qx.ui.form.IField",
{
  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events :
  {
    /** Fired when the model value was modified */
    "changeValue" : "qx.event.type.Data"
  },



  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      VALUE PROPERTY
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the field model value. Should also update the UI.
     *
     * @param value {var|null} Updates the field with the new model value.
     * @return {null|Error} Should return an error when the type of
     *  model value is not compatible with the implementing class (the concrete field).
     */
    setValue : function(value) {
      return arguments.length == 1;
    },


    /**
     * Resets the model value to its initial value. Should also update the UI.
     */
    resetValue : function() {},


    /**
     * Returns a consistent and up-to-date model value.
     *
     * Note: returned value can also be a promise of type <code>Promise&lt;*|null&gt;</code>.
     *
     * @return {var|null} The model value plain or as promise.
     */
    getValue : function() {}
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * Form interface for all form widgets which have strings as their primary
 * data type like textfield's.
 */
qx.Interface.define("qx.ui.form.IStringForm",
{
  extend : qx.ui.form.IField,


  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events :
  {
    /** Fired when the value was modified */
    "changeValue" : "qx.event.type.Data"
  },



  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      VALUE PROPERTY
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the element's value.
     *
     * @param value {String|null} The new value of the element.
     */
    setValue : function(value) {
      return arguments.length == 1;
    },


    /**
     * Resets the element's value to its initial value.
     */
    resetValue : function() {},


    /**
     * The element's user set value.
     *
     * @return {String|null} The value.
     */
    getValue : function() {}
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * The label class brings typical text content to the widget system.
 *
 * It supports simple text nodes and complex HTML (rich). The default
 * content mode is for text only. The mode is changeable through the property
 * {@link #rich}.
 *
 * The label supports heightForWidth when used in HTML mode. This means
 * that multi line HTML automatically computes the correct preferred height.
 *
 * *Example*
 *
 * Here is a little example of how to use the widget.
 *
 * <pre class='javascript'>
 *   // a simple text label without wrapping and markup support
 *   var label1 = new qx.ui.basic.Label("Simple text label");
 *   this.getRoot().add(label1, {left:20, top:10});
 *
 *   // a HTML label with automatic line wrapping
 *   var label2 = new qx.ui.basic.Label().set({
 *     value: "A <b>long label</b> text with auto-wrapping. This also may contain <b style='color:red'>rich HTML</b> markup.",
 *     rich : true,
 *     width: 120
 *   });
 *   this.getRoot().add(label2, {left:20, top:50});
 * </pre>
 *
 * The first label in this example is a basic text only label. As such no
 * automatic wrapping is supported. The second label is a long label containing
 * HTML markup with automatic line wrapping.
 *
 * *External Documentation*
 *
 * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/label.html' target='_blank'>
 * Documentation of this widget in the qooxdoo manual.</a>
 * 
 * NOTE: Instances of this class must be disposed of after use
 *
 */
qx.Class.define("qx.ui.basic.Label",
{
  extend : qx.ui.core.Widget,
  implement : [qx.ui.form.IStringForm],



  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param value {String} Text or HTML content to use
   */
  construct : function(value)
  {
    this.base(arguments);

    if (value != null) {
      this.setValue(value);
    }

    if (qx.core.Environment.get("qx.dynlocale")) {
      qx.locale.Manager.getInstance().addListener("changeLocale", this._onChangeLocale, this);
    }
  },


  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /**
     * Switches between rich HTML and text content. The text mode (<code>false</code>) supports
     * advanced features like ellipsis when the available space is not
     * enough. HTML mode (<code>true</code>) supports multi-line content and all the
     * markup features of HTML content.
     */
    rich :
    {
      check : "Boolean",
      init : false,
      event : "changeRich",
      apply : "_applyRich"
    },


    /**
     * Controls whether text wrap is activated or not. But please note, that
     * this property works only in combination with the property {@link #rich}.
     * The {@link #wrap} has only an effect if the {@link #rich} property is
     * set to <code>true</code>, otherwise {@link #wrap} has no effect.
     */
    wrap :
    {
      check : "Boolean",
      init : true,
      apply : "_applyWrap"
    },
    
    
    /**
     * Controls whether line wrapping can occur in the middle of a word; this is
     * typically only useful when there is a restricted amount of horizontal space
     * and words would otherwise overflow beyond the width of the element.  Words
     * are typically considered as separated by spaces, so "abc/def/ghi" is a 11 
     * character word that would not be split without `breakWithWords` set to true. 
     */
    breakWithinWords :
    {
      check : "Boolean",
      init : false,
      apply : "_applyBreakWithinWords"
    },


    /**
     * Contains the HTML or text content. Interpretation depends on the value
     * of {@link #rich}. In text mode entities and other HTML special content
     * is not supported. But it is possible to use unicode escape sequences
     * to insert symbols and other non ASCII characters.
     */
    value :
    {
      check : "String",
      apply : "_applyValue",
      event : "changeValue",
      nullable : true
    },


    /**
     * The buddy property can be used to connect the label to another widget.
     * That causes two things:
     * <ul>
     *   <li>The label will always take the same enabled state as the buddy
     *       widget.
     *   </li>
     *   <li>A tap on the label will focus the buddy widget.</li>
     * </ul>
     * This is the behavior of the for attribute of HTML:
     * http://www.w3.org/TR/html401/interact/forms.html#adef-for
     */
    buddy :
    {
      check : "qx.ui.core.Widget",
      apply : "_applyBuddy",
      nullable : true,
      init : null,
      dereference : true
    },


    /** Control the text alignment */
    textAlign :
    {
      check : ["left", "center", "right", "justify"],
      nullable : true,
      themeable : true,
      apply : "_applyTextAlign",
      event : "changeTextAlign"
    },


    // overridden
    appearance :
    {
      refine: true,
      init: "label"
    },


    // overridden
    selectable :
    {
      refine : true,
      init : false
    },


    // overridden
    allowGrowX :
    {
      refine : true,
      init : false
    },


    // overridden
    allowGrowY :
    {
      refine : true,
      init : false
    },

    // overridden
    allowShrinkY :
    {
      refine : true,
      init : false
    }
  },





  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    __font : null,
    __invalidContentSize : null,
    __tapListenerId : null,
    __webfontListenerId : null,



    /*
    ---------------------------------------------------------------------------
      WIDGET API
    ---------------------------------------------------------------------------
    */

    // overridden
    _getContentHint : function()
    {
      if (this.__invalidContentSize)
      {
        this.__contentSize = this.__computeContentSize();
        delete this.__invalidContentSize;
      }

      return {
        width : this.__contentSize.width,
        height : this.__contentSize.height
      };
    },


    // overridden
    _hasHeightForWidth : function() {
      return this.getRich() && this.getWrap();
    },


    // overridden
    _applySelectable : function(value)
    {

      // This is needed for all browsers not having text-overflow:ellipsis
      // but supporting XUL (firefox < 4)
      // https://bugzilla.mozilla.org/show_bug.cgi?id=312156
      if (!qx.core.Environment.get("css.textoverflow") &&
        qx.core.Environment.get("html.xul"))
      {
        if (value && !this.isRich())
        {
          if (qx.core.Environment.get("qx.debug")) {
            this.warn("Only rich labels are selectable in browsers with Gecko engine!");
          }
          return;
        }
      }

      this.base(arguments, value);
    },


    // overridden
    _getContentHeightForWidth : function(width)
    {
      if (!this.getRich() && !this.getWrap()) {
        return null;
      }
      return this.__computeContentSize(width).height;
    },


    // overridden
    _createContentElement : function() {
      return new qx.html.Label;
    },


    // property apply
    _applyTextAlign : function(value, old) {
      this.getContentElement().setStyle("textAlign", value);
    },


    // overridden
    _applyTextColor : function(value, old)
    {
      if (value) {
        this.getContentElement().setStyle("color", qx.theme.manager.Color.getInstance().resolve(value));
      } else {
        this.getContentElement().removeStyle("color");
      }
    },




    /*
    ---------------------------------------------------------------------------
      LABEL ADDONS
    ---------------------------------------------------------------------------
    */

    /**
     * @type {Map} Internal fallback of label size when no font is defined
     *
     * @lint ignoreReferenceField(__contentSize)
     */
    __contentSize :
    {
      width : 0,
      height : 0
    },


    // property apply
    _applyFont : function(value, old)
    {
      if (old && this.__font && this.__webfontListenerId) {
        this.__font.removeListenerById(this.__webfontListenerId);
        this.__webfontListenerId = null;
      }
      // Apply
      var styles;
      if (value)
      {
        this.__font = qx.theme.manager.Font.getInstance().resolve(value);
        if (this.__font instanceof qx.bom.webfonts.WebFont) {
          this.__webfontListenerId = this.__font.addListener("changeStatus", this._onWebFontStatusChange, this);
        }
        styles = this.__font.getStyles();
      }
      else
      {
        this.__font = null;
        styles = qx.bom.Font.getDefaultStyles();
      }

      // check if text color already set - if so this local value has higher priority
      if (this.getTextColor() != null) {
        delete styles["color"];
      }

      this.getContentElement().setStyles(styles);

      // Invalidate text size
      this.__invalidContentSize = true;

      // Update layout
      qx.ui.core.queue.Layout.add(this);
    },


    /**
     * Internal utility to compute the content dimensions.
     *
     * @param width {Integer?null} Optional width constraint
     * @return {Map} Map with <code>width</code> and <code>height</code> keys
     */
    __computeContentSize : function(width)
    {
      var Label = qx.bom.Label;
      var font = this.getFont();

      var styles = font ? this.__font.getStyles() : qx.bom.Font.getDefaultStyles();
      var content = this.getValue() || "A";
      var rich = this.getRich();

      if (this.__webfontListenerId) {
        this.__fixEllipsis();
      }
      if (rich && this.getBreakWithinWords()) {
        styles.wordBreak = "break-all";
      }

      return rich ?
        Label.getHtmlSize(content, styles, width) :
        Label.getTextSize(content, styles);
    },



    /**
    * Firefox > 9 on OS X will draw an ellipsis on top of the label content even
    * though there is enough space for the text. Re-applying the content forces
    * a recalculation and fixes the problem. See qx bug #6293
    */
    __fixEllipsis : function()
    {
      if (!this.getContentElement()) {
        return;
      }
      if (qx.core.Environment.get("os.name") == "osx" &&
        qx.core.Environment.get("engine.name") == "gecko" &&
        parseInt(qx.core.Environment.get("engine.version"), 10) < 16 &&
        parseInt(qx.core.Environment.get("engine.version"), 10) > 9)
      {
        var domEl = this.getContentElement().getDomElement();
        if (domEl) {
          domEl.innerHTML = domEl.innerHTML;
        }
      }
    },



    /*
    ---------------------------------------------------------------------------
      PROPERTY APPLIER
    ---------------------------------------------------------------------------
    */

    // property apply
    _applyBuddy : function(value, old)
    {
      if (old != null)
      {
        this.removeRelatedBindings(old);
        this.removeListenerById(this.__tapListenerId);
        this.__tapListenerId = null;
      }

      if (value != null)
      {
        value.bind("enabled", this, "enabled");
        this.__tapListenerId = this.addListener("tap", function() {
          // only focus focusable elements [BUG #3555]
          if (value.isFocusable()) {
            value.focus.apply(value);
          }
          // furthermore toggle if possible [BUG #6881]
          if ("toggleValue" in value && typeof value.toggleValue === "function") {
            value.toggleValue();
          }
        }, this);
      }
    },


    // property apply
    _applyRich : function(value)
    {
      // Sync with content element
      this.getContentElement().setRich(value);

      // Mark text size cache as invalid
      this.__invalidContentSize = true;

      // Update layout
      qx.ui.core.queue.Layout.add(this);
    },


    // property apply
     _applyWrap : function(value, old)
    {
      if (value && !this.isRich())
      {
        if (qx.core.Environment.get("qx.debug")) {
          this.warn("Only rich labels support wrap.");
        }
      }

      if (this.isRich()) {
        // apply the white space style to the label to force it not
        // to wrap if wrap is set to false [BUG #3732]
        var whiteSpace = value ? "normal" : "nowrap";
        this.getContentElement().setStyle("whiteSpace", whiteSpace);
      }
    },
    
    // property apply
    _applyBreakWithinWords : function(value, old) {
      if (this.isRich()) {
        this.getContentElement().setStyle("wordBreak", value ? "break-all" : "normal");
      }
    },


    /**
     * Locale change event handler
     *
     * @signature function(e)
     * @param e {Event} the change event
     */
    _onChangeLocale : qx.core.Environment.select("qx.dynlocale",
    {
      "true" : function(e)
      {
        var content = this.getValue();
        if (content && content.translate) {
          this.setValue(content.translate());
        }
      },

      "false" : null
    }),


    /**
     * Triggers layout recalculation after a web font was loaded
     *
     * @param ev {qx.event.type.Data} "changeStatus" event
     */
    _onWebFontStatusChange : function(ev)
    {
      if (ev.getData().valid === true) {

        // safari has trouble resizing, adding it again fixed the issue [BUG #8786]
        if (qx.core.Environment.get("browser.name") == "safari" &&
          parseFloat(qx.core.Environment.get("browser.version")) >= 8) {
            window.setTimeout(function() {
              this.__invalidContentSize = true;
              qx.ui.core.queue.Layout.add(this);
            }.bind(this), 0);
        }

        this.__invalidContentSize = true;
        qx.ui.core.queue.Layout.add(this);
      }
    },


    // property apply
    _applyValue : qx.core.Environment.select("qx.dynlocale", {
      "true" : function(value, old)
      {
        // Sync with content element
        if (value && value.translate) {
          this.getContentElement().setValue(value.translate());
        }
        else {
          this.getContentElement().setValue(value);
        }

        // Mark text size cache as invalid
        this.__invalidContentSize = true;

        // Update layout
        qx.ui.core.queue.Layout.add(this);
      },

      "false" : function(value, old)
      {
        this.getContentElement().setValue(value);

        // Mark text size cache as invalid
        this.__invalidContentSize = true;

        // Update layout
        qx.ui.core.queue.Layout.add(this);
      }
    })
  },



  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    if (qx.core.Environment.get("qx.dynlocale")) {
      qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
    }

    if (this.__font && this.__webfontListenerId) {
      this.__font.removeListenerById(this.__webfontListenerId);
    }

    this.__font = null;
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * A horizontal box layout.
 *
 * The horizontal box layout lays out widgets in a horizontal row, from left
 * to right.
 *
 * *Features*
 *
 * * Minimum and maximum dimensions
 * * Prioritized growing/shrinking (flex)
 * * Margins (with horizontal collapsing)
 * * Auto sizing (ignoring percent values)
 * * Percent widths (not relevant for size hint)
 * * Alignment (child property {@link qx.ui.core.LayoutItem#alignX} is ignored)
 * * Horizontal spacing (collapsed with margins)
 * * Reversed children layout (from last to first)
 * * Vertical children stretching (respecting size hints)
 *
 * *Item Properties*
 *
 * <ul>
 * <li><strong>flex</strong> <em>(Integer)</em>: The flexibility of a layout item determines how the container
 *   distributes remaining empty space among its children. If items are made
 *   flexible, they can grow or shrink accordingly. Their relative flex values
 *   determine how the items are being resized, i.e. the larger the flex ratio
 *   of two items, the larger the resizing of the first item compared to the
 *   second.
 *
 *   If there is only one flex item in a layout container, its actual flex
 *   value is not relevant. To disallow items to become flexible, set the
 *   flex value to zero.
 * </li>
 * <li><strong>width</strong> <em>(String)</em>: Allows to define a percent
 *   width for the item. The width in percent, if specified, is used instead
 *   of the width defined by the size hint. The minimum and maximum width still
 *   takes care of the element's limits. It has no influence on the layout's
 *   size hint. Percent values are mostly useful for widgets which are sized by
 *   the outer hierarchy.
 * </li>
 * </ul>
 *
 * *Example*
 *
 * Here is a little example of how to use the HBox layout.
 *
 * <pre class="javascript">
 * var layout = new qx.ui.layout.HBox();
 * layout.setSpacing(4); // apply spacing
 *
 * var container = new qx.ui.container.Composite(layout);
 *
 * container.add(new qx.ui.core.Widget());
 * container.add(new qx.ui.core.Widget());
 * container.add(new qx.ui.core.Widget());
 * </pre>
 *
 * *External Documentation*
 *
 * See <a href='http://manual.qooxdoo.org/${qxversion}/pages/layout/box.html'>extended documentation</a>
 * and links to demos for this layout.
 *
 */
qx.Class.define("qx.ui.layout.HBox",
{
  extend : qx.ui.layout.Abstract,




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param spacing {Integer?0} The spacing between child widgets {@link #spacing}.
   * @param alignX {String?"left"} Horizontal alignment of the whole children
   *     block {@link #alignX}.
   * @param separator {String|qx.ui.decoration.IDecorator?} A separator to render between the items
   */
  construct : function(spacing, alignX, separator)
  {
    this.base(arguments);

    if (spacing) {
      this.setSpacing(spacing);
    }

    if (alignX) {
      this.setAlignX(alignX);
    }

    if (separator) {
      this.setSeparator(separator);
    }
  },





  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /**
     * Horizontal alignment of the whole children block. The horizontal
     * alignment of the child is completely ignored in HBoxes (
     * {@link qx.ui.core.LayoutItem#alignX}).
     */
    alignX :
    {
      check : [ "left", "center", "right" ],
      init : "left",
      apply : "_applyLayoutChange"
    },


    /**
     * Vertical alignment of each child. Can be overridden through
     * {@link qx.ui.core.LayoutItem#alignY}.
     */
    alignY :
    {
      check : [ "top", "middle", "bottom" ],
      init : "top",
      apply : "_applyLayoutChange"
    },


    /** Horizontal spacing between two children */
    spacing :
    {
      check : "Integer",
      init : 0,
      apply : "_applyLayoutChange"
    },


    /** Separator lines to use between the objects */
    separator :
    {
      check : "Decorator",
      nullable : true,
      apply : "_applyLayoutChange"
    },


    /** Whether the actual children list should be laid out in reversed order. */
    reversed :
    {
      check : "Boolean",
      init : false,
      apply : "_applyReversed"
    }
  },





  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    __widths : null,
    __flexs : null,
    __enableFlex : null,
    __children : null,

    /*
    ---------------------------------------------------------------------------
      HELPER METHODS
    ---------------------------------------------------------------------------
    */

    // property apply
    _applyReversed : function()
    {
      // easiest way is to invalidate the cache
      this._invalidChildrenCache = true;

      // call normal layout change
      this._applyLayoutChange();
    },


    /**
     * Rebuilds caches for flex and percent layout properties
     */
    __rebuildCache : function()
    {
      var children = this._getLayoutChildren();
      var length = children.length;
      var enableFlex = false;
      var reuse = this.__widths && this.__widths.length != length && this.__flexs && this.__widths;
      var props;

      // Sparse array (keep old one if lengths has not been modified)
      var widths = reuse ? this.__widths : new Array(length);
      var flexs = reuse ? this.__flexs : new Array(length);

      // Reverse support
      if (this.getReversed()) {
        children = children.concat().reverse();
      }

      // Loop through children to preparse values
      for (var i=0; i<length; i++)
      {
        props = children[i].getLayoutProperties();

        if (props.width != null) {
          widths[i] = parseFloat(props.width) / 100;
        }

        if (props.flex != null)
        {
          flexs[i] = props.flex;
          enableFlex = true;
        } else {
          // reset (in case the index of the children changed: BUG #3131)
          flexs[i] = 0;
        }
      }

      // Store data
      if (!reuse)
      {
        this.__widths = widths;
        this.__flexs = flexs;
      }

      this.__enableFlex = enableFlex;
      this.__children = children;

      // Clear invalidation marker
      delete this._invalidChildrenCache;
    },





    /*
    ---------------------------------------------------------------------------
      LAYOUT INTERFACE
    ---------------------------------------------------------------------------
    */

    // overridden
    verifyLayoutProperty : qx.core.Environment.select("qx.debug",
    {
      "true" : function(item, name, value)
      {
        this.assert(name === "flex" || name === "width", "The property '"+name+"' is not supported by the HBox layout!");

        if (name =="width")
        {
          this.assertMatch(value, qx.ui.layout.Util.PERCENT_VALUE);
        }
        else
        {
          // flex
          this.assertNumber(value);
          this.assert(value >= 0);
        }
      },

      "false" : null
    }),


    // overridden
    renderLayout : function(availWidth, availHeight, padding)
    {
      // Rebuild flex/width caches
      if (this._invalidChildrenCache) {
        this.__rebuildCache();
      }

      // Cache children
      var children = this.__children;
      var length = children.length;
      var util = qx.ui.layout.Util;


      // Compute gaps
      var spacing = this.getSpacing();
      var separator = this.getSeparator();
      if (separator) {
        var gaps = util.computeHorizontalSeparatorGaps(children, spacing, separator);
      } else {
        var gaps = util.computeHorizontalGaps(children, spacing, true);
      }


      // First run to cache children data and compute allocated width
      var i, child, width, percent;
      var widths = [], hint;
      var allocatedWidth = gaps;

      for (i=0; i<length; i+=1)
      {
        percent = this.__widths[i];
        hint = children[i].getSizeHint();

        width = percent != null ?
          Math.floor((availWidth - gaps) * percent) :
          hint.width;

        // Limit computed value
        if (width < hint.minWidth) {
          width = hint.minWidth;
        } else if (width > hint.maxWidth) {
          width = hint.maxWidth;
        }
        
        widths.push(width);
        allocatedWidth += width;
      }


      // Flex support (growing/shrinking)
      if (this.__enableFlex && allocatedWidth != availWidth)
      {
        var flexibles = {};
        var flex, offset;

        for (i=0; i<length; i+=1)
        {
          flex = this.__flexs[i];

          if (flex > 0)
          {
            hint = children[i].getSizeHint();

            flexibles[i]=
            {
              min : hint.minWidth,
              value : widths[i],
              max : hint.maxWidth,
              flex : flex
            };
          }
        }

        var result = util.computeFlexOffsets(flexibles, availWidth, allocatedWidth);

        for (i in result)
        {
          offset = result[i].offset;

          widths[i] += offset;
          allocatedWidth += offset;
        }
      }


      // Start with left coordinate
      var left = children[0].getMarginLeft();

      // Alignment support
      if (allocatedWidth < availWidth && this.getAlignX() != "left")
      {
        left = availWidth - allocatedWidth;

        if (this.getAlignX() === "center") {
          left = Math.round(left / 2);
        }
      }


      // Layouting children
      var hint, top, height, width, marginRight, marginTop, marginBottom;
      var spacing = this.getSpacing();

      // Pre configure separators
      this._clearSeparators();

      // Compute separator width
      if (separator)
      {
        var separatorInsets = qx.theme.manager.Decoration.getInstance().resolve(separator).getInsets();
        var separatorWidth = separatorInsets.left + separatorInsets.right;
      }

      // Render children and separators
      for (i=0; i<length; i+=1)
      {
        child = children[i];
        width = widths[i];
        hint = child.getSizeHint();

        marginTop = child.getMarginTop();
        marginBottom = child.getMarginBottom();

        // Find usable height
        height = Math.max(hint.minHeight, Math.min(availHeight-marginTop-marginBottom, hint.maxHeight));

        // Respect vertical alignment
        top = util.computeVerticalAlignOffset(child.getAlignY()||this.getAlignY(), height, availHeight, marginTop, marginBottom);

        // Add collapsed margin
        if (i > 0)
        {
          // Whether a separator has been configured
          if (separator)
          {
            // add margin of last child and spacing
            left += marginRight + spacing;

            // then render the separator at this position
            this._renderSeparator(separator, {
              left : left + padding.left,
              top : padding.top,
              width : separatorWidth,
              height : availHeight
            });

            // and finally add the size of the separator, the spacing (again) and the left margin
            left += separatorWidth + spacing + child.getMarginLeft();
          }
          else
          {
            // Support margin collapsing when no separator is defined
            left += util.collapseMargins(spacing, marginRight, child.getMarginLeft());
          }
        }

        // Layout child
        child.renderLayout(left + padding.left, top + padding.top, width, height);

        // Add width
        left += width;

        // Remember right margin (for collapsing)
        marginRight = child.getMarginRight();
      }
    },


    // overridden
    _computeSizeHint : function()
    {
      // Rebuild flex/width caches
      if (this._invalidChildrenCache) {
        this.__rebuildCache();
      }

      var util = qx.ui.layout.Util;
      var children = this.__children;

      // Initialize
      var minWidth=0, width=0, percentMinWidth=0;
      var minHeight=0, height=0;
      var child, hint, margin;

      // Iterate over children
      for (var i=0, l=children.length; i<l; i+=1)
      {
        child = children[i];
        hint = child.getSizeHint();

        // Sum up widths
        width += hint.width;

        // Detect if child is shrinkable or has percent width and update minWidth
        var flex = this.__flexs[i];
        var percent = this.__widths[i];
        if (flex) {
          minWidth += hint.minWidth;
        } else if (percent) {
          percentMinWidth = Math.max(percentMinWidth, Math.round(hint.minWidth/percent));
        } else {
          minWidth += hint.width;
        }

        // Build vertical margin sum
        margin = child.getMarginTop() + child.getMarginBottom();

        // Find biggest height
        if ((hint.height+margin) > height) {
          height = hint.height + margin;
        }

        // Find biggest minHeight
        if ((hint.minHeight+margin) > minHeight) {
          minHeight = hint.minHeight + margin;
        }
      }

      minWidth += percentMinWidth;

      // Respect gaps
      var spacing = this.getSpacing();
      var separator = this.getSeparator();
      if (separator) {
        var gaps = util.computeHorizontalSeparatorGaps(children, spacing, separator);
      } else {
        var gaps = util.computeHorizontalGaps(children, spacing, true);
      }

      // Return hint
      return {
        minWidth : minWidth + gaps,
        width : width + gaps,
        minHeight : minHeight,
        height : height
      };
    }
  },



  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this.__widths = this.__flexs = this.__children = null;
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * This mixin is included by all widgets, which support an 'execute' like
 * buttons or menu entries.
 */
qx.Mixin.define("qx.ui.core.MExecutable",
{
  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events :
  {
    /** Fired if the {@link #execute} method is invoked.*/
    "execute" : "qx.event.type.Event"
  },



  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /**
     * A command called if the {@link #execute} method is called, e.g. on a
     * button tap.
     */
    command :
    {
      check : "qx.ui.command.Command",
      apply : "_applyCommand",
      event : "changeCommand",
      nullable : true
    }
  },



  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    __executableBindingIds : null,
    __semaphore : false,
    __executeListenerId : null,


    /**
     * @type {Map} Set of properties, which will by synced from the command to the
     *    including widget
     *
     * @lint ignoreReferenceField(_bindableProperties)
     */
    _bindableProperties : qx.core.Environment.select("qx.command.bindEnabled", {
      "true": [
          "enabled",
          "label",
          "icon",
          "toolTipText",
          "value",
          "menu"
        ],
      "false": [
          "label",
          "icon",
          "toolTipText",
          "value",
          "menu"
        ]
    }),

    /**
     * Initiate the execute action.
     */
    execute : function()
    {
      var cmd = this.getCommand();

      if (cmd) {
        if (this.__semaphore) {
          this.__semaphore = false;
        } else {
          this.__semaphore = true;
          cmd.execute(this);
        }
      }

      this.fireEvent("execute");
    },


    /**
     * Handler for the execute event of the command.
     *
     * @param e {qx.event.type.Event} The execute event of the command.
     */
    __onCommandExecute : function(e) {
      if (this.isEnabled()) {
        if (this.__semaphore) {
          this.__semaphore = false;
          return;
        }
        if (this.isEnabled()) {
          this.__semaphore = true;
          this.execute();
        }
      }
    },


    // property apply
    _applyCommand : function(value, old)
    {
      // execute forwarding
      if (old != null) {
        old.removeListenerById(this.__executeListenerId);
      }
      if (value != null) {
        this.__executeListenerId = value.addListener(
          "execute", this.__onCommandExecute, this
        );
      }

      // binding stuff
      var ids = this.__executableBindingIds;
      if (ids == null) {
        this.__executableBindingIds = ids = {};
      }

      var selfPropertyValue;
      for (var i = 0; i < this._bindableProperties.length; i++) {
        var property = this._bindableProperties[i];

        // remove the old binding
        if (old != null && !old.isDisposed() && ids[property] != null)
        {
          old.removeBinding(ids[property]);
          ids[property] = null;
        }

        // add the new binding
        if (value != null && qx.Class.hasProperty(this.constructor, property)) {
          // handle the init value (don't sync the initial null)
          var cmdPropertyValue = value.get(property);
          if (cmdPropertyValue == null) {
            selfPropertyValue = this.get(property);
            // check also for themed values [BUG #5906]
            if (selfPropertyValue == null) {
              // update the appearance to make sure every themed property is up to date
              this.$$resyncNeeded = true;
              this.syncAppearance();
              selfPropertyValue = qx.util.PropertyUtil.getThemeValue(
                this, property
              );
            }
          } else {
            // Reset the self property value [BUG #4534]
            selfPropertyValue = null;
          }
          // set up the binding
          ids[property] = value.bind(property, this, property);
          // reapply the former value
          if (selfPropertyValue) {
            this.set(property, selfPropertyValue);
          }
        }
      }
    }
  },


  destruct : function() {
    this._applyCommand(null, this.getCommand());
    this.__executableBindingIds = null;
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * A multi-purpose widget, which combines a label with an icon.
 *
 * The intended purpose of qx.ui.basic.Atom is to easily align the common icon-text
 * combination in different ways.
 *
 * This is useful for all types of buttons, tooltips, ...
 *
 * *Example*
 *
 * Here is a little example of how to use the widget.
 *
 * <pre class='javascript'>
 *   var atom = new qx.ui.basic.Atom("Icon Right", "icon/32/actions/go-next.png");
 *   this.getRoot().add(atom);
 * </pre>
 *
 * This example creates an atom with the label "Icon Right" and an icon.
 *
 * *External Documentation*
 *
 * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/atom.html' target='_blank'>
 * Documentation of this widget in the qooxdoo manual.</a>
 *
 *
 * @childControl label {qx.ui.basic.Label} label part of the atom
 * @childControl icon {qx.ui.basic.Image} icon part of the atom
 */
qx.Class.define("qx.ui.basic.Atom",
{
  extend : qx.ui.core.Widget,


  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param label {String} Label to use
   * @param icon {String?null} Icon to use
   */
  construct : function(label, icon)
  {
    if (qx.core.Environment.get("qx.debug")) {
      this.assertArgumentsCount(arguments, 0, 2);
    }

    this.base(arguments);

    this._setLayout(new qx.ui.layout.Atom());

    if (label != null) {
      this.setLabel(label);
    }

    if (icon !== undefined) {
      this.setIcon(icon);
    }
  },



  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    // overridden
    appearance :
    {
      refine : true,
      init : "atom"
    },


    /** The label/caption/text of the qx.ui.basic.Atom instance */
    label :
    {
      apply : "_applyLabel",
      nullable : true,
      check : "String",
      event : "changeLabel"
    },


    /**
     * Switches between rich HTML and text content. The text mode (<code>false</code>) supports
     * advanced features like ellipsis when the available space is not
     * enough. HTML mode (<code>true</code>) supports multi-line content and all the
     * markup features of HTML content.
     */
    rich :
    {
      check : "Boolean",
      init : false,
      apply : "_applyRich"
    },


    /** Any URI String supported by qx.ui.basic.Image to display an icon */
    icon :
    {
      check : "String",
      apply : "_applyIcon",
      nullable : true,
      themeable : true,
      event : "changeIcon"
    },


    /**
     * The space between the icon and the label
     */
    gap :
    {
      check : "Integer",
      nullable : false,
      event : "changeGap",
      apply : "_applyGap",
      themeable : true,
      init : 4
    },


    /**
     * Configure the visibility of the sub elements/widgets.
     * Possible values: both, label, icon
     */
    show :
    {
      init : "both",
      check : [ "both", "label", "icon" ],
      themeable : true,
      inheritable : true,
      apply : "_applyShow",
      event : "changeShow"
    },


    /**
     * The position of the icon in relation to the text.
     * Only useful/needed if text and icon is configured and 'show' is configured as 'both' (default)
     */
    iconPosition :
    {
      init   : "left",
      check : ["top", "right", "bottom", "left", "top-left", "bottom-left" , "top-right", "bottom-right"],
      themeable : true,
      apply : "_applyIconPosition"
    },


    /**
     * Whether the content should be rendered centrally when to much space
     * is available. Enabling this property centers in both axis. The behavior
     * when disabled of the centering depends on the {@link #iconPosition} property.
     * If the icon position is <code>left</code> or <code>right</code>, the X axis
     * is not centered, only the Y axis. If the icon position is <code>top</code>
     * or <code>bottom</code>, the Y axis is not centered. In case of e.g. an
     * icon position of <code>top-left</code> no axis is centered.
     */
    center :
    {
      init : false,
      check : "Boolean",
      themeable : true,
      apply : "_applyCenter"
    }
  },



  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    // overridden
    _createChildControlImpl : function(id, hash)
    {
      var control;

      switch(id)
      {
        case "label":
          control = new qx.ui.basic.Label(this.getLabel());
          control.setAnonymous(true);
          control.setRich(this.getRich());
          control.setSelectable(this.getSelectable());
          this._add(control);
          if (this.getLabel() == null || this.getShow() === "icon") {
            control.exclude();
          }
          break;

        case "icon":
          control = new qx.ui.basic.Image(this.getIcon());
          control.setAnonymous(true);
          this._addAt(control, 0);
          if (this.getIcon() == null || this.getShow() === "label") {
            control.exclude();
          }
          break;
      }

      return control || this.base(arguments, id);
    },


    // overridden
    /**
     * @lint ignoreReferenceField(_forwardStates)
     */
    _forwardStates :
    {
      focused : true,
      hovered : true
    },


    /**
     * Updates the visibility of the label
     */
    _handleLabel : function()
    {
      if (this.getLabel() == null || this.getShow() === "icon") {
        this._excludeChildControl("label");
      } else {
        this._showChildControl("label");
      }
    },


    /**
     * Updates the visibility of the icon
     */
    _handleIcon : function()
    {
      if (this.getIcon() == null || this.getShow() === "label") {
        this._excludeChildControl("icon");
      } else {
        this._showChildControl("icon");
      }
    },


    // property apply
    _applyLabel : function(value, old)
    {
      var label = this.getChildControl("label", true);
      if (label) {
        label.setValue(value);
      }

      this._handleLabel();
    },


    // property apply
    _applyRich : function(value, old)
    {
      var label = this.getChildControl("label", true);
      if (label) {
        label.setRich(value);
      }
    },


    // property apply
    _applyIcon : function(value, old)
    {
      var icon = this.getChildControl("icon", true);
      if (icon) {
        icon.setSource(value);
      }

      this._handleIcon();
    },


    // property apply
    _applyGap : function(value, old) {
      this._getLayout().setGap(value);
    },


    // property apply
    _applyShow : function(value, old)
    {
      this._handleLabel();
      this._handleIcon();
    },


    // property apply
    _applyIconPosition : function(value, old) {
      this._getLayout().setIconPosition(value);
    },


    // property apply
    _applyCenter : function(value, old) {
      this._getLayout().setCenter(value);
    },


    // overridden
    _applySelectable : function(value, old) {
      this.base(arguments, value, old);

      var label = this.getChildControl("label", true);
      if (label) {
        this.getChildControl("label").setSelectable(value);
      }
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * A atom layout. Used to place an image and label in relation
 * to each other. Useful to create buttons, list items, etc.
 *
 * *Features*
 *
 * * Gap between icon and text (using {@link #gap})
 * * Vertical and horizontal mode (using {@link #iconPosition})
 * * Sorting options to place first child on top/left or bottom/right (using {@link #iconPosition})
 * * Automatically middles/centers content to the available space
 * * Auto-sizing
 * * Supports more than two children (will be processed the same way like the previous ones)
 *
 * *Item Properties*
 *
 * None
 *
 * *Notes*
 *
 * * Does not support margins and alignment of {@link qx.ui.core.LayoutItem}.
 *
 * *Alternative Names*
 *
 * None
 */
qx.Class.define("qx.ui.layout.Atom",
{
  extend : qx.ui.layout.Abstract,




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /** The gap between the icon and the text */
    gap :
    {
      check : "Integer",
      init : 4,
      apply : "_applyLayoutChange"
    },


    /** The position of the icon in relation to the text */
    iconPosition :
    {
      check : ["left", "top", "right", "bottom", "top-left", "bottom-left", "top-right", "bottom-right"],
      init : "left",
      apply  : "_applyLayoutChange"
    },


    /**
     * Whether the content should be rendered centrally when to much space
     * is available. Enabling this property centers in both axis. The behavior
     * when disabled of the centering depends on the {@link #iconPosition} property.
     * If the icon position is <code>left</code> or <code>right</code>, the X axis
     * is not centered, only the Y axis. If the icon position is <code>top</code>
     * or <code>bottom</code>, the Y axis is not centered. In case of e.g. an
     * icon position of <code>top-left</code> no axis is centered.
     */
    center :
    {
      check : "Boolean",
      init : false,
      apply : "_applyLayoutChange"
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      LAYOUT INTERFACE
    ---------------------------------------------------------------------------
    */

    // overridden
    verifyLayoutProperty : qx.core.Environment.select("qx.debug",
    {
      "true" : function(item, name, value) {
        this.assert(false, "The property '"+name+"' is not supported by the Atom layout!");
      },

      "false" : null
    }),


    // overridden
    renderLayout : function(availWidth, availHeight, padding)
    {
      var left = padding.left;
      var top = padding.top;
      var Util = qx.ui.layout.Util;

      var iconPosition = this.getIconPosition();
      var children = this._getLayoutChildren();
      var length = children.length;

      var width, height;
      var child, hint;
      var gap = this.getGap();
      var center = this.getCenter();

      // reverse ordering
      var allowedPositions = ["bottom", "right", "top-right", "bottom-right"];
      if (allowedPositions.indexOf(iconPosition) != -1)
      {
        var start = length-1;
        var end = -1;
        var increment = -1;
      }
      else
      {
        var start = 0;
        var end = length;
        var increment = 1;
      }

      // vertical
      if (iconPosition == "top" || iconPosition == "bottom")
      {
        if (center)
        {
          var allocatedHeight = 0;
          for (var i=start; i!=end; i+=increment)
          {
            height = children[i].getSizeHint().height;

            if (height > 0)
            {
              allocatedHeight += height;

              if (i != start) {
                allocatedHeight += gap;
              }
            }
          }

          top += Math.round((availHeight - allocatedHeight) / 2);
        }

        var childTop = top;
        for (var i=start; i!=end; i+=increment)
        {
          child = children[i];

          hint = child.getSizeHint();
          width = Math.min(hint.maxWidth, Math.max(availWidth, hint.minWidth));
          height = hint.height;

          left = Util.computeHorizontalAlignOffset("center", width, availWidth) + padding.left;
          child.renderLayout(left, childTop, width, height);

          // Ignore pseudo invisible elements
          if (height > 0) {
            childTop = top + height + gap;
          }
        }
      }

      // horizontal
      // in this way it also supports shrinking of the first label
      else
      {
        var remainingWidth = availWidth;
        var shrinkTarget = null;

        var count=0;
        for (var i=start; i!=end; i+=increment)
        {
          child = children[i];
          width = child.getSizeHint().width;

          if (width > 0)
          {
            if (!shrinkTarget && child instanceof qx.ui.basic.Label) {
              shrinkTarget = child;
            } else {
              remainingWidth -= width;
            }

            count++;
          }
        }

        if (count > 1)
        {
          var gapSum = (count - 1) * gap;
          remainingWidth -= gapSum;
        }

        if (shrinkTarget)
        {
          var hint = shrinkTarget.getSizeHint();
          var shrinkTargetWidth = Math.max(hint.minWidth, Math.min(remainingWidth, hint.maxWidth));
          remainingWidth -= shrinkTargetWidth;
        }

        if (center && remainingWidth > 0) {
          left += Math.round(remainingWidth / 2);
        }

        for (var i=start; i!=end; i+=increment)
        {
          child = children[i];

          hint = child.getSizeHint();
          height = Math.min(hint.maxHeight, Math.max(availHeight, hint.minHeight));

          if (child === shrinkTarget) {
            width = shrinkTargetWidth;
          } else {
            width = hint.width;
          }

          var align = "middle";
          if(iconPosition == "top-left" || iconPosition == "top-right"){
            align = "top";
          } else if (iconPosition == "bottom-left" || iconPosition == "bottom-right") {
            align = "bottom";
          }
          var childTop = top + Util.computeVerticalAlignOffset(align, hint.height, availHeight);
          child.renderLayout(left, childTop, width, height);

          // Ignore pseudo invisible childs for gap e.g.
          // empty text or unavailable images
          if (width > 0) {
            left += width + gap;
          }
        }
      }
    },


    // overridden
    _computeSizeHint : function()
    {
      var children = this._getLayoutChildren();
      var length = children.length;
      var hint, result;

      // Fast path for only one child
      if (length === 1)
      {
        var hint = children[0].getSizeHint();

        // Work on a copy, but do not respect max
        // values as a Atom can be rendered bigger
        // than its content.
        result = {
          width : hint.width,
          height : hint.height,
          minWidth : hint.minWidth,
          minHeight : hint.minHeight
        };
      }
      else
      {
        var minWidth=0, width=0;
        var minHeight=0, height=0;

        var iconPosition = this.getIconPosition();
        var gap = this.getGap();

        if (iconPosition === "top" || iconPosition === "bottom")
        {
          var count = 0;
          for (var i=0; i<length; i++)
          {
            hint = children[i].getSizeHint();

            // Max of widths
            width = Math.max(width, hint.width);
            minWidth = Math.max(minWidth, hint.minWidth);

            // Sum of heights
            if (hint.height > 0)
            {
              height += hint.height;
              minHeight += hint.minHeight;
              count++;
            }
          }

          if (count > 1)
          {
            var gapSum = (count-1) * gap;
            height += gapSum;
            minHeight += gapSum;
          }
        }
        else
        {
          var count=0;
          for (var i=0; i<length; i++)
          {
            hint = children[i].getSizeHint();

            // Max of heights
            height = Math.max(height, hint.height);
            minHeight = Math.max(minHeight, hint.minHeight);

            // Sum of widths
            if (hint.width > 0)
            {
              width += hint.width;
              minWidth += hint.minWidth;
              count++;
            }
          }

          if (count > 1)
          {
            var gapSum = (count-1) * gap;
            width += gapSum;
            minWidth += gapSum;
          }
        }

        // Build hint
        result = {
          minWidth : minWidth,
          width : width,
          minHeight : minHeight,
          height : height
        };
      }

      return result;
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * Each object, which should be managed by a {@link RadioGroup} have to
 * implement this interface.
 */
qx.Interface.define("qx.ui.form.IRadioItem",
{

  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events :
  {
    /** Fired when the item was checked or unchecked */
    "changeValue" : "qx.event.type.Data"
  },



  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Set whether the item is checked
     *
     * @param value {Boolean} whether the item should be checked
     */
    setValue : function(value) {},


    /**
     * Get whether the item is checked
     *
     * @return {Boolean} whether the item it checked
     */
    getValue : function() {},


    /**
     * Set the radiogroup, which manages this item
     *
     * @param value {qx.ui.form.RadioGroup} The radiogroup, which should
     *     manage the item.
     */
    setGroup : function(value) {
      this.assertInstance(value, qx.ui.form.RadioGroup);
    },


    /**
     * Get the radiogroup, which manages this item
     *
     * @return {qx.ui.form.RadioGroup} The radiogroup, which manages the item.
     */
    getGroup : function() {}
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Christian Hagendorn (chris_schmidt)

************************************************************************ */

/**
 * This mixin links all methods to manage the single selection.
 *
 * The class which includes the mixin has to implements two methods:
 *
 * <ul>
 * <li><code>_getItems</code>, this method has to return a <code>Array</code>
 *    of <code>qx.ui.core.Widget</code> that should be managed from the manager.
 * </li>
 * <li><code>_isAllowEmptySelection</code>, this method has to return a
 *    <code>Boolean</code> value for allowing empty selection or not.
 * </li>
 * </ul>
 */
qx.Mixin.define("qx.ui.core.MSingleSelectionHandling",
{
  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events :
  {
    /** Fires after the value was modified */
    "changeValue" : "qx.event.type.Data",

    /** Fires after the selection was modified */
    "changeSelection" : "qx.event.type.Data"
  },


  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */


  members :
  {
    /** @type {qx.ui.core.SingleSelectionManager} the single selection manager */
    __manager : null,


    /*
    ---------------------------------------------------------------------------
      PUBLIC API
    ---------------------------------------------------------------------------
    */

    /**
     * setValue implements part of the {@link qx.ui.form.IField} interface.
     *
     * @param item {null|qx.ui.core.Widget} Item to set as selected value.
     * @returns {null|TypeError} The status of this operation.
     */
    setValue : function(item) {
      if (null === item) {
        this.resetSelection();
        return null;
      }

      if (item instanceof qx.ui.core.Widget) {
        this.__getManager().setSelected(item);
        return null;

      } else {
        return new TypeError("Given argument is not null or a {qx.ui.core.Widget}.");
      }
    },

    /**
     * getValue implements part of the {@link qx.ui.form.IField} interface.
     *
     * @returns {null|qx.ui.core.Widget} The currently selected widget or null if there is none.
     */
    getValue : function() {
      return this.__getManager().getSelected() || null;
    },

    /**
     * resetValue implements part of the {@link qx.ui.form.IField} interface.
     */
    resetValue : function() {
      this.__getManager().resetSelected();
    },

    /**
     * Returns an array of currently selected items.
     *
     * Note: The result is only a set of selected items, so the order can
     * differ from the sequence in which the items were added.
     *
     * @return {qx.ui.core.Widget[]} List of items.
     */
    getSelection : function() {
      var selected = this.__getManager().getSelected();

      if (selected) {
        return [selected];
      } else {
        return [];
      }
    },

    /**
     * Replaces current selection with the given items.
     *
     * @param items {qx.ui.core.Widget[]} Items to select.
     * @throws {Error} if one of the items is not a child element and if
     *    items contains more than one elements.
     */
    setSelection : function(items) {
      switch(items.length)
      {
        case 0:
          this.resetSelection();
          break;
        case 1:
          this.__getManager().setSelected(items[0]);
          break;
        default:
          throw new Error("Could only select one item, but the selection" +
            " array contains " + items.length + " items!");
      }
    },

    /**
     * Clears the whole selection at once.
     */
    resetSelection : function() {
      this.__getManager().resetSelected();
    },

    /**
     * Detects whether the given item is currently selected.
     *
     * @param item {qx.ui.core.Widget} Any valid selectable item.
     * @return {Boolean} Whether the item is selected.
     * @throws {Error} if one of the items is not a child element.
     */
    isSelected : function(item) {
      return this.__getManager().isSelected(item);
    },

    /**
     * Whether the selection is empty.
     *
     * @return {Boolean} Whether the selection is empty.
     */
    isSelectionEmpty : function() {
      return this.__getManager().isSelectionEmpty();
    },


    /**
     * Returns all elements which are selectable.
     *
     * @param all {Boolean} true for all selectables, false for the
     *   selectables the user can interactively select
     * @return {qx.ui.core.Widget[]} The contained items.
     */
    getSelectables: function(all) {
      return this.__getManager().getSelectables(all);
    },


    /*
    ---------------------------------------------------------------------------
      EVENT HANDLER
    ---------------------------------------------------------------------------
    */


    /**
     * Event listener for <code>changeSelected</code> event on single
     * selection manager.
     *
     * @param e {qx.event.type.Data} Data event.
     */
    _onChangeSelected : function(e) {
      var newValue = e.getData();
      var oldValue = e.getOldData();
      this.fireDataEvent("changeValue", newValue, oldValue);

      newValue == null ? newValue = [] : newValue = [newValue];
      oldValue == null ? oldValue = [] : oldValue = [oldValue];
      this.fireDataEvent("changeSelection", newValue, oldValue);
    },

    /**
     * Return the selection manager if it is already exists, otherwise creates
     * the manager.
     *
     * @return {qx.ui.core.SingleSelectionManager} Single selection manager.
     */
    __getManager : function()
    {
      if (this.__manager == null)
      {
        var that = this;
        this.__manager = new qx.ui.core.SingleSelectionManager(
        {
          getItems : function() {
            return that._getItems();
          },

          isItemSelectable : function(item) {
            if (that._isItemSelectable) {
              return that._isItemSelectable(item);
            } else {
              return item.isVisible();
            }
          }
        });
        this.__manager.addListener("changeSelected", this._onChangeSelected, this);
      }
      this.__manager.setAllowEmptySelection(this._isAllowEmptySelection());

      return this.__manager;
    }
  },


  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */


  destruct : function() {
    this._disposeObjects("__manager");
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Christian Hagendorn (chris_schmidt)

************************************************************************ */

/**
 * Responsible for the single selection management.
 *
 * The class manage a list of {@link qx.ui.core.Widget} which are returned from
 * {@link qx.ui.core.ISingleSelectionProvider#getItems}.
 *
 * @internal
 */
qx.Class.define("qx.ui.core.SingleSelectionManager",
{
  extend : qx.core.Object,


  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */


  /**
   * Construct the single selection manager.
   *
   * @param selectionProvider {qx.ui.core.ISingleSelectionProvider} The provider
   * for selection.
   */
  construct : function(selectionProvider) {
    this.base(arguments);

    if (qx.core.Environment.get("qx.debug")) {
      qx.core.Assert.assertInterface(selectionProvider,
        qx.ui.core.ISingleSelectionProvider,
        "Invalid selectionProvider!");
    }

    this.__selectionProvider = selectionProvider;
  },


  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */


  events :
  {
    /** Fires after the selection was modified */
    "changeSelected" : "qx.event.type.Data"
  },


  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */


  properties :
  {
    /**
     * If the value is <code>true</code> the manager allows an empty selection,
     * otherwise the first selectable element returned from the
     * <code>qx.ui.core.ISingleSelectionProvider</code> will be selected.
     */
    allowEmptySelection :
    {
      check : "Boolean",
      init : true,
      apply : "__applyAllowEmptySelection"
    }
  },


  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */


  members :
  {
    /** @type {qx.ui.core.Widget} The selected widget. */
    __selected : null,

    /** @type {qx.ui.core.ISingleSelectionProvider} The provider for selection management */
    __selectionProvider : null,


    /*
    ---------------------------------------------------------------------------
       PUBLIC API
    ---------------------------------------------------------------------------
    */


    /**
     * Returns the current selected element.
     *
     * @return {qx.ui.core.Widget | null} The current selected widget or
     *    <code>null</code> if the selection is empty.
     */
    getSelected : function() {
      return this.__selected;
    },

    /**
     * Selects the passed element.
     *
     * @param item {qx.ui.core.Widget} Element to select.
     * @throws {Error} if the element is not a child element.
     */
    setSelected : function(item) {
      if (!this.__isChildElement(item)) {
        throw new Error("Could not select " + item +
          ", because it is not a child element!");
      }

      this.__setSelected(item);
    },

    /**
     * Reset the current selection. If {@link #allowEmptySelection} is set to
     * <code>true</code> the first element will be selected.
     */
    resetSelected : function(){
      this.__setSelected(null);
    },

    /**
     * Return <code>true</code> if the passed element is selected.
     *
     * @param item {qx.ui.core.Widget} Element to check if selected.
     * @return {Boolean} <code>true</code> if passed element is selected,
     *    <code>false</code> otherwise.
     * @throws {Error} if the element is not a child element.
     */
    isSelected : function(item) {
      if (!this.__isChildElement(item)) {
        throw new Error("Could not check if " + item + " is selected," +
          " because it is not a child element!");
      }
      return this.__selected === item;
    },

    /**
     * Returns <code>true</code> if selection is empty.
     *
     * @return {Boolean} <code>true</code> if selection is empty,
     *    <code>false</code> otherwise.
     */
    isSelectionEmpty : function() {
      return this.__selected == null;
    },

    /**
     * Returns all elements which are selectable.
     *
     * @param all {Boolean} true for all selectables, false for the
     *   selectables the user can interactively select
     * @return {qx.ui.core.Widget[]} The contained items.
     */
    getSelectables : function(all)
    {
      var items = this.__selectionProvider.getItems();
      var result = [];

      for (var i = 0; i < items.length; i++)
      {
        if (this.__selectionProvider.isItemSelectable(items[i])) {
          result.push(items[i]);
        }
      }

      // in case of an user selectable list, remove the enabled items
      if (!all) {
        for (var i = result.length -1; i >= 0; i--) {
          if (!result[i].getEnabled()) {
            result.splice(i, 1);
          }
        };
      }

      return result;
    },


    /*
    ---------------------------------------------------------------------------
       APPLY METHODS
    ---------------------------------------------------------------------------
    */


    // apply method
    __applyAllowEmptySelection : function(value, old)
    {
      if (!value) {
        this.__setSelected(this.__selected);
      }
    },


    /*
    ---------------------------------------------------------------------------
       HELPERS
    ---------------------------------------------------------------------------
    */

    /**
     * Set selected element.
     *
     * If passes value is <code>null</code>, the selection will be reseted.
     *
     * @param item {qx.ui.core.Widget | null} element to select, or
     *    <code>null</code> to reset selection.
     */
    __setSelected : function(item) {
      var oldSelected = this.__selected;
      var newSelected = item;

      if (newSelected != null && oldSelected === newSelected) {
        return;
      }

      if (!this.isAllowEmptySelection() && newSelected == null) {
        var firstElement = this.getSelectables(true)[0];

        if (firstElement) {
          newSelected = firstElement;
        }
      }

      this.__selected = newSelected;
      this.fireDataEvent("changeSelected", newSelected, oldSelected);
    },

    /**
     * Checks if passed element is a child element.
     *
     * @param item {qx.ui.core.Widget} Element to check if child element.
     * @return {Boolean} <code>true</code> if element is child element,
     *    <code>false</code> otherwise.
     */
    __isChildElement : function(item)
    {
      var items = this.__selectionProvider.getItems();

      for (var i = 0; i < items.length; i++)
      {
        if (items[i] === item)
        {
          return true;
        }
      }
      return false;
    }
  },



  /*
   *****************************************************************************
      DESTRUCTOR
   *****************************************************************************
   */
  destruct : function() {
    if (this.__selectionProvider.toHashCode) {
      this._disposeObjects("__selectionProvider");
    } else {
      this.__selectionProvider = null;
    }

    this._disposeObjects("__selected");
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Christian Hagendorn (chris_schmidt)

************************************************************************ */
/**
 * Defines the callback for the single selection manager.
 *
 * @internal
 */
qx.Interface.define("qx.ui.core.ISingleSelectionProvider",
{
  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Returns the elements which are part of the selection.
     *
     * @return {qx.ui.core.Widget[]} The widgets for the selection.
     */
    getItems: function() {},

    /**
     * Returns whether the given item is selectable.
     *
     * @param item {qx.ui.core.Widget} The item to be checked
     * @return {Boolean} Whether the given item is selectable
     */
    isItemSelectable : function(item) {}
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * Form interface for all form widgets. It includes the API for enabled,
 * required and valid states.
 */
qx.Interface.define("qx.ui.form.IForm",
{
  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events :
  {
    /** Fired when the enabled state was modified */
    "changeEnabled" : "qx.event.type.Data",

    /** Fired when the valid state was modified */
    "changeValid" : "qx.event.type.Data",

    /** Fired when the invalidMessage was modified */
    "changeInvalidMessage" : "qx.event.type.Data",

    /** Fired when the required was modified */
    "changeRequired" : "qx.event.type.Data"
  },


  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      ENABLED PROPERTY
    ---------------------------------------------------------------------------
    */

    /**
     * Set the enabled state of the widget.
     *
     * @param enabled {Boolean} The enabled state.
     */
    setEnabled : function(enabled) {
      return arguments.length == 1;
    },


    /**
     * Return the current set enabled state.
     *
     * @return {Boolean} If the widget is enabled.
     */
    getEnabled : function() {},


    /*
    ---------------------------------------------------------------------------
      REQUIRED PROPERTY
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the required state of a widget.
     *
     * @param required {Boolean} A flag signaling if the widget is required.
     */
    setRequired : function(required) {
      return arguments.length == 1;
    },


    /**
     * Return the current required state of the widget.
     *
     * @return {Boolean} True, if the widget is required.
     */
    getRequired : function() {},


    /*
    ---------------------------------------------------------------------------
      VALID PROPERTY
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the valid state of the widget.
     *
     * @param valid {Boolean} The valid state of the widget.
     */
    setValid : function(valid) {
      return arguments.length == 1;
    },


    /**
     * Returns the valid state of the widget.
     *
     * @return {Boolean} If the state of the widget is valid.
     */
    getValid : function() {},


    /*
    ---------------------------------------------------------------------------
      INVALID MESSAGE PROPERTY
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the invalid message of the widget.
     *
     * @param message {String} The invalid message.
     */
    setInvalidMessage : function(message) {
      return arguments.length == 1;
    },


    /**
     * Returns the invalid message of the widget.
     *
     * @return {String} The current set message.
     */
    getInvalidMessage : function() {},



    /*
    ---------------------------------------------------------------------------
      REQUIRED INVALID MESSAGE PROPERTY
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the invalid message if required of the widget.
     *
     * @param message {String} The invalid message.
     */
    setRequiredInvalidMessage : function(message) {
      return arguments.length == 1;
    },


    /**
     * Returns the invalid message if required of the widget.
     *
     * @return {String} The current set message.
     */
    getRequiredInvalidMessage : function() {}

  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */
/**
 * This mixin offers the selection of the model properties.
 * It can only be included if the object including it implements the
 * {@link qx.ui.core.ISingleSelection} interface and the selectables implement
 * the {@link qx.ui.form.IModel} interface.
 */
qx.Mixin.define("qx.ui.form.MModelSelection",
{

  construct : function() {
    // create the selection array
    this.__modelSelection = new qx.data.Array();

    // listen to the changes
    this.__modelSelection.addListener("change", this.__onModelSelectionArrayChange, this);
    this.addListener("changeSelection", this.__onModelSelectionChange, this);
  },


  events :
  {
    /**
     * Pseudo event. It will never be fired because the array itself can not
     * be changed. But the event description is needed for the data binding.
     */
    changeModelSelection : "qx.event.type.Data"
  },


  members :
  {

    __modelSelection : null,
    __inSelectionChange : false,


    /**
     * Handler for the selection change of the including class e.g. SelectBox,
     * List, ...
     * It sets the new modelSelection via {@link #setModelSelection}.
     */
    __onModelSelectionChange : function() {
      if (this.__inSelectionChange) {
        return;
      }
      var data = this.getSelection();

      // create the array with the modes inside
      var modelSelection = [];
      for (var i = 0; i < data.length; i++) {
        var item = data[i];
        // fallback if getModel is not implemented
        var model = item.getModel ? item.getModel() : null;
        if (model !== null) {
          modelSelection.push(model);
        }
      }

      try {
        this.setModelSelection(modelSelection);
      } catch (e) {
        throw new Error(
          "Could not set the model selection. Maybe your models are not unique? " + e
        );
      }
    },


    /**
     * Listener for the change of the internal model selection data array.
     */
    __onModelSelectionArrayChange : function() {
      this.__inSelectionChange = true;
      var selectables = this.getSelectables(true);
      var itemSelection = [];

      var modelSelection = this.__modelSelection.toArray();
      for (var i = 0; i < modelSelection.length; i++) {
        var model = modelSelection[i];
        for (var j = 0; j < selectables.length; j++) {
          var selectable = selectables[j];
          // fallback if getModel is not implemented
          var selectableModel = selectable.getModel ? selectable.getModel() : null;
          if (model === selectableModel) {
            itemSelection.push(selectable);
            break;
          }
        }
      }
      this.setSelection(itemSelection);
      this.__inSelectionChange = false;

      // check if the setting has worked
      var currentSelection = this.getSelection();
      if (!qx.lang.Array.equals(currentSelection, itemSelection)) {
        // if not, set the actual selection
        this.__onModelSelectionChange();
      }
    },


    /**
     * Returns always an array of the models of the selected items. If no
     * item is selected or no model is given, the array will be empty.
     *
     * *CAREFUL!* The model selection can only work if every item item in the
     * selection providing widget has a model property!
     *
     * @return {qx.data.Array} An array of the models of the selected items.
     */
    getModelSelection : function()
    {
      return this.__modelSelection;
    },


    /**
     * Takes the given models in the array and searches for the corresponding
     * selectables. If an selectable does have that model attached, it will be
     * selected.
     *
     * *Attention:* This method can have a time complexity of O(n^2)!
     *
     * *CAREFUL!* The model selection can only work if every item item in the
     * selection providing widget has a model property!
     *
     * @param modelSelection {Array} An array of models, which should be
     *   selected.
     */
    setModelSelection : function(modelSelection)
    {
      // check for null values
      if (!modelSelection)
      {
        this.__modelSelection.removeAll();
        return;
      }

      if (qx.core.Environment.get("qx.debug")) {
        this.assertArray(modelSelection, "Please use an array as parameter.");
      }

      // add the first two parameter
      modelSelection.unshift(this.__modelSelection.getLength()); // remove index
      modelSelection.unshift(0);  // start index

      var returnArray = this.__modelSelection.splice.apply(this.__modelSelection, modelSelection);
      returnArray.dispose();
    }
  },

  destruct : function() {
    this._disposeObjects("__modelSelection");
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
     * Christian Hagendorn (chris_schmidt)
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * The radio group handles a collection of items from which only one item
 * can be selected. Selection another item will deselect the previously selected
 * item.
 *
 * This class is e.g. used to create radio groups or {@link qx.ui.form.RadioButton}
 * or {@link qx.ui.toolbar.RadioButton} instances.
 *
 * We also offer a widget for the same purpose which uses this class. So if
 * you like to act with a widget instead of a pure logic coupling of the
 * widgets, take a look at the {@link qx.ui.form.RadioButtonGroup} widget.
 */
qx.Class.define("qx.ui.form.RadioGroup",
{
  extend : qx.core.Object,
  implement : [
    qx.ui.core.ISingleSelection,
    qx.ui.form.IField,
    qx.ui.form.IForm,
    qx.ui.form.IModelSelection
  ],
  include : [
    qx.ui.core.MSingleSelectionHandling,
    qx.ui.form.MModelSelection
  ],


  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */


  /**
   * @param varargs {qx.core.Object} A variable number of items, which are
   *     initially added to the radio group, the first item will be selected.
   */
  construct : function(varargs)
  {
    this.base(arguments);

    // create item array
    this.__items = [];

    // add listener before call add!!!
    this.addListener("changeSelection", this.__onChangeSelection, this);

    if (varargs != null) {
      this.add.apply(this, arguments);
    }
  },


  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */


  properties :
  {
    /**
     * The property name in each of the added widgets that is grouped
     */
    groupedProperty :
    {
      check : "String",
      apply : "_applyGroupedProperty",
      event : "changeGroupedProperty",
      init  : "value"
    },

    /**
     * The property name in each of the added widgets that is informed of the
     * RadioGroup object it is a member of
     */
    groupProperty :
    {
      check : "String",
      event : "changeGroupProperty",
      init  : "group"
    },

    /**
     * Whether the radio group is enabled
     */
    enabled :
    {
      check : "Boolean",
      apply : "_applyEnabled",
      event : "changeEnabled",
      init: true
    },

    /**
     * Whether the selection should wrap around. This means that the successor of
     * the last item is the first item.
     */
    wrap :
    {
      check : "Boolean",
      init: true
    },

    /**
     * If is set to <code>true</code> the selection could be empty,
     * otherwise is always one <code>RadioButton</code> selected.
     */
    allowEmptySelection :
    {
      check : "Boolean",
      init : false,
      apply : "_applyAllowEmptySelection"
    },

    /**
     * Flag signaling if the group at all is valid. All children will have the
     * same state.
     */
    valid : {
      check : "Boolean",
      init : true,
      apply : "_applyValid",
      event : "changeValid"
    },

    /**
     * Flag signaling if the group is required.
     */
    required : {
      check : "Boolean",
      init : false,
      event : "changeRequired"
    },

    /**
     * Message which is shown in an invalid tooltip.
     */
    invalidMessage : {
      check : "String",
      init: "",
      event : "changeInvalidMessage",
      apply : "_applyInvalidMessage"
    },


    /**
     * Message which is shown in an invalid tooltip if the {@link #required} is
     * set to true.
     */
    requiredInvalidMessage : {
      check : "String",
      nullable : true,
      event : "changeInvalidMessage"
    }
  },


  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */


  members :
  {
    /** @type {qx.ui.form.IRadioItem[]} The items of the radio group */
    __items : null,


    /*
    ---------------------------------------------------------------------------
      UTILITIES
    ---------------------------------------------------------------------------
    */


    /**
     * Get all managed items
     *
     * @return {qx.ui.form.IRadioItem[]} All managed items.
     */
    getItems : function() {
      return this.__items;
    },


    /*
    ---------------------------------------------------------------------------
      REGISTRY
    ---------------------------------------------------------------------------
    */


    /**
     * Add the passed items to the radio group.
     *
     * @param varargs {qx.ui.form.IRadioItem} A variable number of items to add.
     */
    add : function(varargs)
    {
      var items = this.__items;
      var item;
      var groupedProperty = this.getGroupedProperty();
      var groupedPropertyUp = qx.lang.String.firstUp(groupedProperty);

      for (var i=0, l=arguments.length; i<l; i++)
      {
        item = arguments[i];

        if (items.includes(item)) {
          continue;
        }

        // Register listeners
        item.addListener(
          "change" + groupedPropertyUp, this._onItemChangeChecked, this);

        // Push RadioButton to array
        items.push(item);

        // Inform radio button about new group
        item.set(this.getGroupProperty(), this);

        // Need to update internal value?
        if (item.get(groupedProperty)) {
          this.setSelection([item]);
        }
      }

      // Select first item when only one is registered
      if (!this.isAllowEmptySelection() && items.length > 0 && !this.getSelection()[0]) {
        this.setSelection([items[0]]);
      }
    },

    /**
     * Remove an item from the radio group.
     *
     * @param item {qx.ui.form.IRadioItem} The item to remove.
     */
    remove : function(item)
    {
      var items = this.__items;
      var groupedProperty = this.getGroupedProperty();
      var groupedPropertyUp = qx.lang.String.firstUp(groupedProperty);

      if (items.includes(item))
      {
        // Remove RadioButton from array
        qx.lang.Array.remove(items, item);

        // Inform radio button about new group
        if (item.get(this.getGroupProperty()) === this) {
          item.reset(this.getGroupProperty());
        }

        // Deregister listeners
        item.removeListener(
          "change" + groupedPropertyUp, this._onItemChangeChecked, this);

        // if the radio was checked, set internal selection to null
        if (item.get(groupedProperty)) {
          this.resetSelection();
        }
      }
    },


    /**
     * Returns an array containing the group's items.
     *
     * @return {qx.ui.form.IRadioItem[]} The item array
     */
    getChildren : function()
    {
      return this.__items;
    },


    /*
    ---------------------------------------------------------------------------
      LISTENER FOR ITEM CHANGES
    ---------------------------------------------------------------------------
    */


    /**
     * Event listener for <code>changeValue</code> event of every managed item.
     *
     * @param e {qx.event.type.Data} Data event
     */
    _onItemChangeChecked : function(e)
    {
      var item = e.getTarget();
      var groupedProperty = this.getGroupedProperty();

      if (item.get(groupedProperty)) {
        this.setSelection([item]);
      } else if (this.getSelection()[0] == item) {
        this.resetSelection();
      }
    },


    /*
    ---------------------------------------------------------------------------
      APPLY ROUTINES
    ---------------------------------------------------------------------------
    */

    // property apply
    _applyGroupedProperty : function(value, old) {
      var item;
      var oldFirstUp = qx.lang.String.firstUp(old);
      var newFirstUp = qx.lang.String.firstUp(value);

      for (var i = 0; i < this.__items.length; i++) {
        item = this.__items[i];

        // remove the listener for the old change event
        item.removeListener(
          "change" + oldFirstUp, this._onItemChangeChecked, this);

        // add the listener for the new change event
        item.removeListener(
          "change" + newFirstUp, this._onItemChangeChecked, this);
      }
    },

    // property apply
    _applyInvalidMessage : function(value, old) {
      for (var i = 0; i < this.__items.length; i++) {
        this.__items[i].setInvalidMessage(value);
      }
    },

    // property apply
    _applyValid: function(value, old) {
      for (var i = 0; i < this.__items.length; i++) {
        this.__items[i].setValid(value);
      }
    },

    // property apply
    _applyEnabled : function(value, old)
    {
      var items = this.__items;
      if (value == null)
      {
        for (var i=0, l=items.length; i<l; i++) {
          items[i].resetEnabled();
        }
      }
      else
      {
        for (var i=0, l=items.length; i<l; i++) {
          items[i].setEnabled(value);
        }
      }
    },

    // property apply
    _applyAllowEmptySelection : function(value, old)
    {
      if (!value && this.isSelectionEmpty()) {
        this.resetSelection();
      }
    },


    /*
    ---------------------------------------------------------------------------
      SELECTION
    ---------------------------------------------------------------------------
    */


    /**
     * Select the item following the given item.
     */
    selectNext : function()
    {
      var item = this.getSelection()[0];
      var items = this.__items;
      var index = items.indexOf(item);
      if (index == -1) {
        return;
      }

      var i = 0;
      var length = items.length;

      // Find next enabled item
      if (this.getWrap()) {
        index = (index + 1) % length;
      } else {
        index = Math.min(index + 1, length - 1);
      }

      while (i < length && !items[index].getEnabled())
      {
        index = (index + 1) % length;
        i++;
      }

      this.setSelection([items[index]]);
    },


    /**
     * Select the item previous the given item.
     */
    selectPrevious : function()
    {
      var item = this.getSelection()[0];
      var items = this.__items;
      var index = items.indexOf(item);
      if (index == -1) {
        return;
      }

      var i = 0;
      var length = items.length;

      // Find previous enabled item
      if (this.getWrap()) {
        index = (index - 1 + length) % length;
      } else {
        index = Math.max(index - 1, 0);
      }

      while (i < length && !items[index].getEnabled())
      {
        index = (index - 1 + length) % length;
        i++;
      }

      this.setSelection([items[index]]);
    },


    /*
    ---------------------------------------------------------------------------
      HELPER METHODS FOR SELECTION API
    ---------------------------------------------------------------------------
    */


    /**
     * Returns the items for the selection.
     *
     * @return {qx.ui.form.IRadioItem[]} Items to select.
     */
    _getItems : function() {
      return this.getItems();
    },

    /**
     * Returns if the selection could be empty or not.
     *
     * @return {Boolean} <code>true</code> If selection could be empty,
     *    <code>false</code> otherwise.
     */
    _isAllowEmptySelection: function() {
      return this.isAllowEmptySelection();
    },


    /**
     * Returns whether the item is selectable. In opposite to the default
     * implementation (which checks for visible items) every radio button
     * which is part of the group is selected even if it is currently not visible.
     *
     * @param item {qx.ui.form.IRadioItem} The item to check if its selectable.
     * @return {Boolean} <code>true</code> if the item is part of the radio group
     *    <code>false</code> otherwise.
     */
    _isItemSelectable : function(item) {
      return this.__items.indexOf(item) != -1;
    },


    /**
     * Event handler for <code>changeSelection</code>.
     *
     * @param e {qx.event.type.Data} Data event.
     */
    __onChangeSelection : function(e)
    {
      var value = e.getData()[0];
      var old = e.getOldData()[0];
      var groupedProperty = this.getGroupedProperty();

      if (old) {
        old.set(groupedProperty, false);
      }

      if (value) {
        value.set(groupedProperty, true);
      }
    }
  },


  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */


  destruct : function() {
    this._disposeArray("__items");
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * Form interface for all form widgets which have boolean as their primary
 * data type like a checkbox.
 */
qx.Interface.define("qx.ui.form.IBooleanForm",
{
  extend : qx.ui.form.IField,


  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events :
  {
    /** Fired when the value was modified */
    "changeValue" : "qx.event.type.Data"
  },



  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      VALUE PROPERTY
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the element's value.
     *
     * @param value {Boolean|null} The new value of the element.
     */
    setValue : function(value) {
      return arguments.length == 1;
    },


    /**
     * Resets the element's value to its initial value.
     */
    resetValue : function() {},


    /**
     * The element's user set value.
     *
     * @return {Boolean|null} The value.
     */
    getValue : function() {}
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * Form interface for all form widgets which are executable in some way. This
 * could be a button for example.
 */
qx.Interface.define("qx.ui.form.IExecutable",
{
  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events :
  {
    /**
     * Fired when the widget is executed. Sets the "data" property of the
     * event to the object that issued the command.
     */
    "execute" : "qx.event.type.Data"
  },



  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      COMMAND PROPERTY
    ---------------------------------------------------------------------------
    */

    /**
     * Set the command of this executable.
     *
     * @param command {qx.ui.command.Command} The command.
     */
    setCommand : function(command) {
      return arguments.length == 1;
    },


    /**
     * Return the current set command of this executable.
     *
     * @return {qx.ui.command.Command} The current set command.
     */
    getCommand : function() {},


    /**
     * Fire the "execute" event on the command.
     */
    execute: function() {}
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * A toggle Button widget
 *
 * If the user presses the button by tapping on it pressing the enter or
 * space key, the button toggles between the pressed an not pressed states.
 */
qx.Class.define("qx.ui.form.ToggleButton",
{
  extend : qx.ui.basic.Atom,
  include : [
    qx.ui.core.MExecutable
  ],
  implement : [
    qx.ui.form.IBooleanForm,
    qx.ui.form.IExecutable,
    qx.ui.form.IRadioItem
  ],



  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * Creates a ToggleButton.
   *
   * @param label {String} The text on the button.
   * @param icon {String} An URI to the icon of the button.
   */
  construct : function(label, icon)
  {
    this.base(arguments, label, icon);

    // register pointer events
    this.addListener("pointerover", this._onPointerOver);
    this.addListener("pointerout", this._onPointerOut);
    this.addListener("pointerdown", this._onPointerDown);
    this.addListener("pointerup", this._onPointerUp);

    // register keyboard events
    this.addListener("keydown", this._onKeyDown);
    this.addListener("keyup", this._onKeyUp);

    // register execute event
    this.addListener("execute", this._onExecute, this);

  },



  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties:
  {
    // overridden
    appearance:
    {
      refine: true,
      init: "button"
    },

    // overridden
    focusable :
    {
      refine : true,
      init : true
    },

    /** The value of the widget. True, if the widget is checked. */
    value :
    {
      check : "Boolean",
      nullable : true,
      event : "changeValue",
      apply : "_applyValue",
      init : false
    },

    /** The assigned qx.ui.form.RadioGroup which handles the switching between registered buttons. */
    group :
    {
      check  : "qx.ui.form.RadioGroup",
      nullable : true,
      apply : "_applyGroup"
    },

    /**
    * Whether the button has a third state. Use this for tri-state checkboxes.
    *
    * When enabled, the value null of the property value stands for "undetermined",
    * while true is mapped to "enabled" and false to "disabled" as usual. Note
    * that the value property is set to false initially.
    *
    */
    triState :
    {
      check : "Boolean",
      apply : "_applyTriState",
      nullable : true,
      init : null
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /** The assigned {@link qx.ui.form.RadioGroup} which handles the switching between registered buttons */
    _applyGroup : function(value, old)
    {
      if (old) {
        old.remove(this);
      }

      if (value) {
        value.add(this);
      }
    },


    /**
     * Changes the state of the button dependent on the checked value.
     *
     * @param value {Boolean} Current value
     * @param old {Boolean} Previous value
     */
    _applyValue : function(value, old) {
      value ? this.addState("checked") : this.removeState("checked");

      if (this.isTriState()) {
        if (value === null) {
          this.addState("undetermined");
        } else if (old === null) {
          this.removeState("undetermined");
        }
      }
    },

    /**
    * Apply value property when triState property is modified.
    *
    * @param value {Boolean} Current value
    * @param old {Boolean} Previous value
    */
    _applyTriState : function(value, old) {
      this._applyValue(this.getValue());
    },


    /**
     * Handler for the execute event.
     *
     * @param e {qx.event.type.Event} The execute event.
     */
    _onExecute : function(e) {
      this.toggleValue();
    },


    /**
     * Listener method for "pointerover" event.
     * <ul>
     * <li>Adds state "hovered"</li>
     * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state is set)</li>
     * </ul>
     *
     * @param e {qx.event.type.Pointer} Pointer event
     */
    _onPointerOver : function(e)
    {
      if (e.getTarget() !== this) {
        return;
      }

      this.addState("hovered");

      if (this.hasState("abandoned"))
      {
        this.removeState("abandoned");
        this.addState("pressed");
      }
    },


    /**
     * Listener method for "pointerout" event.
     * <ul>
     * <li>Removes "hovered" state</li>
     * <li>Adds "abandoned" state (if "pressed" state is set)</li>
     * <li>Removes "pressed" state (if "pressed" state is set and button is not checked)
     * </ul>
     *
     * @param e {qx.event.type.Pointer} pointer event
     */
    _onPointerOut : function(e)
    {
      if (e.getTarget() !== this) {
        return;
      }

      this.removeState("hovered");

      if (this.hasState("pressed"))
      {
        if (!this.getValue()) {
          this.removeState("pressed");
        }

        this.addState("abandoned");
      }
    },


    /**
     * Listener method for "pointerdown" event.
     * <ul>
     * <li>Activates capturing</li>
     * <li>Removes "abandoned" state</li>
     * <li>Adds "pressed" state</li>
     * </ul>
     *
     * @param e {qx.event.type.Pointer} pointer event
     */
    _onPointerDown : function(e)
    {
      if (!e.isLeftPressed()) {
        return;
      }

      // Activate capturing if the button get a pointerout while
      // the button is pressed.
      this.capture();

      this.removeState("abandoned");
      this.addState("pressed");
      e.stopPropagation();
    },


    /**
     * Listener method for "pointerup" event.
     * <ul>
     * <li>Releases capturing</li>
     * <li>Removes "pressed" state (if not "abandoned" state is set and "pressed" state is set)</li>
     * <li>Removes "abandoned" state (if set)</li>
     * <li>Toggles {@link #value} (if state "abandoned" is not set and state "pressed" is set)</li>
     * </ul>
     *
     * @param e {qx.event.type.Pointer} pointer event
     */
    _onPointerUp : function(e)
    {
      this.releaseCapture();

      if (this.hasState("abandoned")) {
        this.removeState("abandoned");
      } else if (this.hasState("pressed")) {
        this.execute();
      }

      this.removeState("pressed");
      e.stopPropagation();
    },


    /**
     * Listener method for "keydown" event.<br/>
     * Removes "abandoned" and adds "pressed" state
     * for the keys "Enter" or "Space"
     *
     * @param e {Event} Key event
     */
    _onKeyDown : function(e)
    {
      switch(e.getKeyIdentifier())
      {
        case "Enter":
        case "Space":
          this.removeState("abandoned");
          this.addState("pressed");

          e.stopPropagation();
      }
    },


    /**
     * Listener method for "keyup" event.<br/>
     * Removes "abandoned" and "pressed" state (if "pressed" state is set)
     * for the keys "Enter" or "Space". It also toggles the {@link #value} property.
     *
     * @param e {Event} Key event
     */
    _onKeyUp : function(e)
    {
      if (!this.hasState("pressed")) {
        return;
      }

      switch(e.getKeyIdentifier())
      {
        case "Enter":
        case "Space":
          this.removeState("abandoned");
          this.execute();

          this.removeState("pressed");
          e.stopPropagation();
      }
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * Mixin handling the valid and required properties for the form widgets.
 */
qx.Mixin.define("qx.ui.form.MForm",
{

  construct : function()
  {
    if (qx.core.Environment.get("qx.dynlocale")) {
      qx.locale.Manager.getInstance().addListener("changeLocale", this.__onChangeLocale, this);
    }
  },


  properties : {

    /**
     * Flag signaling if a widget is valid. If a widget is invalid, an invalid
     * state will be set.
     */
    valid : {
      check : "Boolean",
      init : true,
      apply : "_applyValid",
      event : "changeValid"
    },


    /**
     * Flag signaling if a widget is required.
     */
    required : {
      check : "Boolean",
      init : false,
      event : "changeRequired"
    },


    /**
     * Message which is shown in an invalid tooltip.
     */
    invalidMessage : {
      check : "String",
      init: "",
      event : "changeInvalidMessage"
    },


    /**
     * Message which is shown in an invalid tooltip if the {@link #required} is
     * set to true.
     */
    requiredInvalidMessage : {
      check : "String",
      nullable : true,
      event : "changeInvalidMessage"
    }
  },


  members : {
    // apply method
    _applyValid: function(value, old) {
      value ? this.removeState("invalid") : this.addState("invalid");
    },


    /**
     * Locale change event handler
     *
     * @signature function(e)
     * @param e {Event} the change event
     */
    __onChangeLocale : qx.core.Environment.select("qx.dynlocale",
    {
      "true" : function(e)
      {
        // invalid message
        var invalidMessage = this.getInvalidMessage();
        if (invalidMessage && invalidMessage.translate) {
          this.setInvalidMessage(invalidMessage.translate());
        }
        // required invalid message
        var requiredInvalidMessage = this.getRequiredInvalidMessage();
        if (requiredInvalidMessage && requiredInvalidMessage.translate) {
          this.setRequiredInvalidMessage(requiredInvalidMessage.translate());
        }
      },

      "false" : null
    })
  },


  destruct : function()
  {
    if (qx.core.Environment.get("qx.dynlocale")) {
      qx.locale.Manager.getInstance().removeListener("changeLocale", this.__onChangeLocale, this);
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */
/**
 * Can be included for implementing {@link qx.ui.form.IModel}. It only contains
 * a nullable property named 'model' with a 'changeModel' event.
 */
qx.Mixin.define("qx.ui.form.MModelProperty",
{
  properties :
  {
    /**
     * Model property for storing additional information for the including
     * object. It can act as value property on form items for example.
     *
     * Be careful using that property as this is used for the
     * {@link qx.ui.form.MModelSelection} it has some restrictions:
     *
     * * Don't use equal models in one widget using the
     *     {@link qx.ui.form.MModelSelection}.
     *
     * * Avoid setting only some model properties if the widgets are added to
     *     a {@link qx.ui.form.MModelSelection} widget.
     *
     * Both restrictions result of the fact, that the set models are deputies
     * for their widget.
     */
    model :
    {
      nullable : true,
      event : "changeModel",
      apply : "_applyModel",
      dereference : true
    }
  },


  members :
  {
    // apply method
    _applyModel : function(value, old) {
      // Empty implementation
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * Each object which wants to store data representative for the real item
 * should implement this interface.
 */
qx.Interface.define("qx.ui.form.IModel",
{

  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events :
  {
    /** Fired when the model data changes */
    "changeModel" : "qx.event.type.Data"
  },



  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Set the representative data for the item.
     *
     * @param value {var} The data.
     */
    setModel : function(value) {},


    /**
     * Returns the representative data for the item
     *
     * @return {var} The data.
     */
    getModel : function() {},


    /**
     * Sets the representative data to null.
     */
    resetModel : function() {}
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)
     * Andreas Ecker (ecker)

************************************************************************ */

/**
 * A check box widget with an optional label.
 */
qx.Class.define("qx.ui.form.CheckBox",
{
  extend : qx.ui.form.ToggleButton,
  include : [
    qx.ui.form.MForm,
    qx.ui.form.MModelProperty
  ],
  implement : [
    qx.ui.form.IForm,
    qx.ui.form.IModel
  ],

  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param label {String?null} An optional label for the check box.
   */
  construct : function(label)
  {
    if (qx.core.Environment.get("qx.debug")) {
      this.assertArgumentsCount(arguments, 0, 1);
    }

    this.base(arguments, label);

    // Initialize the checkbox to a valid value (the default is null which
    // is invalid)
    this.setValue(false);
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    // overridden
    appearance :
    {
      refine : true,
      init : "checkbox"
    },

    // overridden
    allowGrowX :
    {
      refine : true,
      init : false
    }
  },

  members :
  {
    /**
     * @lint ignoreReferenceField(_forwardStates)
     */
    _forwardStates :
    {
      invalid : true,
      focused : true,
      undetermined : true,
      checked : true,
      hovered : true
    },

    /**
     * overridden (from MExecutable to keep the icon out of the binding)
     * @lint ignoreReferenceField(_bindableProperties)
     */
    _bindableProperties :
    [
      "enabled",
      "label",
      "toolTipText",
      "value",
      "menu"
    ]
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * This is a basic form field with common functionality for
 * {@link TextArea} and {@link TextField}.
 *
 * On every keystroke the value is synchronized with the
 * value of the textfield. Value changes can be monitored by listening to the
 * {@link #input} or {@link #changeValue} events, respectively.
 */
qx.Class.define("qx.ui.form.AbstractField",
{
  extend : qx.ui.core.Widget,
  implement : [
    qx.ui.form.IStringForm,
    qx.ui.form.IForm
  ],
  include : [
    qx.ui.form.MForm
  ],
  type : "abstract",

  statics : {
    /** Stylesheet needed to style the native placeholder element. */
    __stylesheet : null,


    /**
     * Adds the CSS rules needed to style the native placeholder element.
     */
    __addPlaceholderRules : function() {
      var engine = qx.core.Environment.get("engine.name");
      var browser = qx.core.Environment.get("browser.name");
      var colorManager = qx.theme.manager.Color.getInstance();
      var color = colorManager.resolve("text-placeholder");
      var selector;

      if (engine == "gecko") {
        // see https://developer.mozilla.org/de/docs/CSS/:-moz-placeholder for details
       if (parseFloat(qx.core.Environment.get("engine.version")) >= 19) {
          selector = "input::-moz-placeholder, textarea::-moz-placeholder";
        } else {
          selector = "input:-moz-placeholder, textarea:-moz-placeholder";
        }
        qx.ui.style.Stylesheet.getInstance().addRule(selector, "color: " + color + " !important");
      } else if (engine == "webkit" && browser != "edge") {
        selector = "input.qx-placeholder-color::-webkit-input-placeholder, textarea.qx-placeholder-color::-webkit-input-placeholder";
        qx.ui.style.Stylesheet.getInstance().addRule(selector, "color: " + color);
      } else if (engine == "mshtml" || browser == "edge") {
        var separator = browser == "edge" ? "::" : ":";
        selector = ["input.qx-placeholder-color", "-ms-input-placeholder, textarea.qx-placeholder-color", "-ms-input-placeholder"].join(separator);
        qx.ui.style.Stylesheet.getInstance().addRule(selector, "color: " + color + " !important");
      }
    }
  },

  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param value {String} initial text value of the input field ({@link #setValue}).
   */
  construct : function(value)
  {
    this.base(arguments);

    // shortcut for placeholder feature detection
    this.__useQxPlaceholder = !qx.core.Environment.get("css.placeholder");

    if (value != null) {
      this.setValue(value);
    }

    this.getContentElement().addListener(
      "change", this._onChangeContent, this
    );

    // use qooxdoo placeholder if no native placeholder is supported
    if (this.__useQxPlaceholder) {
      // assign the placeholder text after the appearance has been applied
      this.addListener("syncAppearance", this._syncPlaceholder, this);
    } else {
      // add rules for native placeholder color
      qx.ui.form.AbstractField.__addPlaceholderRules();
      // add a class to the input to restrict the placeholder color
      this.getContentElement().addClass("qx-placeholder-color");
    }

    // translation support
    if (qx.core.Environment.get("qx.dynlocale")) {
      qx.locale.Manager.getInstance().addListener(
        "changeLocale", this._onChangeLocale, this
      );
    }
  },



  /*
  *****************************************************************************
     EVENTS
  *****************************************************************************
  */

  events :
  {
    /**
     * The event is fired on every keystroke modifying the value of the field.
     *
     * The method {@link qx.event.type.Data#getData} returns the
     * current value of the text field.
     */
    "input" : "qx.event.type.Data",


    /**
     * The event is fired each time the text field looses focus and the
     * text field values has changed.
     *
     * If you change {@link #liveUpdate} to true, the changeValue event will
     * be fired after every keystroke and not only after every focus loss. In
     * that mode, the changeValue event is equal to the {@link #input} event.
     *
     * The method {@link qx.event.type.Data#getData} returns the
     * current text value of the field.
     */
    "changeValue" : "qx.event.type.Data"
  },



  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /**
     * Alignment of the text
     */
    textAlign :
    {
      check : [ "left", "center", "right" ],
      nullable : true,
      themeable : true,
      apply : "_applyTextAlign"
    },


    /** Whether the field is read only */
    readOnly :
    {
      check : "Boolean",
      apply : "_applyReadOnly",
      event : "changeReadOnly",
      init : false
    },


    // overridden
    selectable :
    {
      refine : true,
      init : true
    },


    // overridden
    focusable :
    {
      refine : true,
      init : true
    },

    /** Maximal number of characters that can be entered in the TextArea. */
    maxLength :
    {
      apply : "_applyMaxLength",
      check : "PositiveInteger",
      init : Infinity
    },

    /**
     * Whether the {@link #changeValue} event should be fired on every key
     * input. If set to true, the changeValue event is equal to the
     * {@link #input} event.
     */
    liveUpdate :
    {
      check : "Boolean",
      init : false
    },

    /**
     * String value which will be shown as a hint if the field is all of:
     * unset, unfocused and enabled. Set to null to not show a placeholder
     * text.
     */
    placeholder :
    {
      check : "String",
      nullable : true,
      apply : "_applyPlaceholder"
    },


    /**
     * RegExp responsible for filtering the value of the textfield. the RegExp
     * gives the range of valid values.
     * Note: The regexp specified is applied to each character in turn, 
     * NOT to the entire string. So only regular expressions matching a 
     * single character make sense in the context.
     * The following example only allows digits in the textfield.
     * <pre class='javascript'>field.setFilter(/[0-9]/);</pre>
     */
    filter :
    {
      check : "RegExp",
      nullable : true,
      init : null
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    __nullValue : true,
    _placeholder : null,
    __oldValue : null,
    __oldInputValue : null,
    __useQxPlaceholder : true,
    __font : null,
    __webfontListenerId : null,


    /*
    ---------------------------------------------------------------------------
      WIDGET API
    ---------------------------------------------------------------------------
    */

    // overridden
    getFocusElement : function() {
      var el = this.getContentElement();
      if (el) {
        return el;
      }
    },


    /**
     * Creates the input element. Derived classes may override this
     * method, to create different input elements.
     *
     * @return {qx.html.Input} a new input element.
     */
    _createInputElement : function() {
      return new qx.html.Input("text");
    },


    // overridden
    renderLayout : function(left, top, width, height)
    {
      var updateInsets = this._updateInsets;
      var changes = this.base(arguments, left, top, width, height);

      // Directly return if superclass has detected that no
      // changes needs to be applied
      if (!changes) {
        return;
      }

      var inner = changes.size || updateInsets;
      var pixel = "px";

      if (inner || changes.local || changes.margin) {
        var innerWidth = width;
        var innerHeight = height;
      }

      var input = this.getContentElement();

      // we don't need to update positions on native placeholders
      if (updateInsets && this.__useQxPlaceholder)
      {
        if (this.__useQxPlaceholder) {
          var insets = this.getInsets();
          this._getPlaceholderElement().setStyles({
            paddingTop : insets.top + pixel,
            paddingRight : insets.right + pixel,
            paddingBottom : insets.bottom + pixel,
            paddingLeft : insets.left + pixel
          });
        }
      }

      if (inner || changes.margin)
      {
        // we don't need to update dimensions on native placeholders
        if (this.__useQxPlaceholder) {
          var insets = this.getInsets();
          this._getPlaceholderElement().setStyles({
            "width": (innerWidth - insets.left - insets.right) + pixel,
            "height": (innerHeight - insets.top - insets.bottom) + pixel
          });
        }

        input.setStyles({
          "width": innerWidth + pixel,
          "height": innerHeight + pixel
        });

        this._renderContentElement(innerHeight, input);

      }

      if (changes.position) {
        if (this.__useQxPlaceholder) {
          this._getPlaceholderElement().setStyles({
            "left": left + pixel,
            "top": top + pixel
          });
        }
      }
    },


    /**
     * Hook into {@link qx.ui.form.AbstractField#renderLayout} method.
     * Called after the contentElement has a width and an innerWidth.
     *
     * Note: This was introduced to fix BUG#1585
     *
     * @param innerHeight {Integer} The inner height of the element.
     * @param element {Element} The element.
     */
    _renderContentElement : function(innerHeight, element) {
      //use it in child classes
    },


    // overridden
    _createContentElement : function()
    {
      // create and add the input element
      var el = this._createInputElement();

      // initialize the html input
      el.setSelectable(this.getSelectable());
      el.setEnabled(this.getEnabled());

      // Add listener for input event
      el.addListener("input", this._onHtmlInput, this);

      // Disable HTML5 spell checking
      el.setAttribute("spellcheck", "false");
      el.addClass("qx-abstract-field");

      // IE8 in standard mode needs some extra love here to receive events.
      if ((qx.core.Environment.get("engine.name") == "mshtml") &&
        (qx.core.Environment.get("browser.documentmode") == 8)) {
        el.setStyles({
          backgroundImage: "url(" + qx.util.ResourceManager.getInstance().toUri("qx/static/blank.gif") + ")"
        });
      }

      return el;
    },


    // overridden
    _applyEnabled : function(value, old)
    {
      this.base(arguments, value, old);

      this.getContentElement().setEnabled(value);

      if (this.__useQxPlaceholder) {
        if (value) {
          this._showPlaceholder();
        } else {
          this._removePlaceholder();
        }
      } else {
        var input = this.getContentElement();
        // remove the placeholder on disabled input elements
        input.setAttribute("placeholder", value ? this.getPlaceholder() : "");
      }
    },


    // default text sizes
    /**
     * @lint ignoreReferenceField(__textSize)
     */
    __textSize :
    {
      width : 16,
      height : 16
    },


    // overridden
    _getContentHint : function()
    {
      return {
        width : this.__textSize.width * 10,
        height : this.__textSize.height || 16
      };
    },


    // overridden
    _applyFont : function(value, old)
    {
      if (old && this.__font && this.__webfontListenerId) {
        this.__font.removeListenerById(this.__webfontListenerId);
        this.__webfontListenerId = null;
      }

      // Apply
      var styles;
      if (value)
      {
        this.__font = qx.theme.manager.Font.getInstance().resolve(value);
        if (this.__font instanceof qx.bom.webfonts.WebFont) {
          this.__webfontListenerId = this.__font.addListener("changeStatus", this._onWebFontStatusChange, this);
        }
        styles = this.__font.getStyles();
      }
      else
      {
        styles = qx.bom.Font.getDefaultStyles();
      }

      // check if text color already set - if so this local value has higher priority
      if (this.getTextColor() != null) {
        delete styles["color"];
      }

      // apply the font to the content element
      // IE 8 - 10 (but not 11 Preview) will ignore the lineHeight value
      // unless it's applied directly.
      if (qx.core.Environment.get("engine.name") == "mshtml" &&
        qx.core.Environment.get("browser.documentmode") < 11)
      {
        qx.html.Element.flush();
        this.getContentElement().setStyles(styles, true);
      } else {
        this.getContentElement().setStyles(styles);
      }

      // the font will adjust automatically on native placeholders
      if (this.__useQxPlaceholder) {
        // don't apply the color to the placeholder
        delete styles["color"];
        // apply the font to the placeholder
        this._getPlaceholderElement().setStyles(styles);
      }

      // Compute text size
      if (value) {
        this.__textSize = qx.bom.Label.getTextSize("A", styles);
      } else {
        delete this.__textSize;
      }

      // Update layout
      qx.ui.core.queue.Layout.add(this);
    },


    // overridden
    _applyTextColor : function(value, old)
    {
      if (value) {
        this.getContentElement().setStyle(
          "color", qx.theme.manager.Color.getInstance().resolve(value)
        );
      } else {
        this.getContentElement().removeStyle("color");
      }
    },


    // property apply
    _applyMaxLength : function(value, old) {
      if (value) {
        this.getContentElement().setAttribute("maxLength", value);
      } else {
        this.getContentElement().removeAttribute("maxLength");
      }
    },


    // overridden
    tabFocus : function() {
      this.base(arguments);

      this.selectAllText();
    },

    /**
     * Returns the text size.
     * @return {Map} The text size.
     */
    _getTextSize : function() {
      return this.__textSize;
    },

    /*
    ---------------------------------------------------------------------------
      EVENTS
    ---------------------------------------------------------------------------
    */

    /**
     * Event listener for native input events. Redirects the event
     * to the widget. Also checks for the filter and max length.
     *
     * @param e {qx.event.type.Data} Input event
     */
    _onHtmlInput : function(e)
    {
      var value = e.getData();
      var fireEvents = true;

      this.__nullValue = false;

      // value unchanged; Firefox fires "input" when pressing ESC [BUG #5309]
      if (this.__oldInputValue && this.__oldInputValue === value) {
        fireEvents = false;
      }

      // check for the filter
      if (this.getFilter() != null)
      {
        var filteredValue = this._validateInput(value);
        if (filteredValue != value)
        {
          fireEvents = this.__oldInputValue !== filteredValue;
          value = filteredValue;
          this.getContentElement().setValue(value);
        }
      }
      // fire the events, if necessary
      if (fireEvents)
      {
        // store the old input value
        this.fireDataEvent("input", value, this.__oldInputValue);
        this.__oldInputValue = value;

        // check for the live change event
        if (this.getLiveUpdate()) {
          this.__fireChangeValueEvent(value);
        }
      }
    },

    /**
     * Triggers text size recalculation after a web font was loaded
     *
     * @param ev {qx.event.type.Data} "changeStatus" event
     */
    _onWebFontStatusChange : function(ev)
    {
      if (ev.getData().valid === true) {
        var styles = this.__font.getStyles();
        this.__textSize = qx.bom.Label.getTextSize("A", styles);
        qx.ui.core.queue.Layout.add(this);
      }
    },


    /**
     * Handles the firing of the changeValue event including the local cache
     * for sending the old value in the event.
     *
     * @param value {String} The new value.
     */
    __fireChangeValueEvent : function(value) {
      var old = this.__oldValue;
      this.__oldValue = value;
      if (old != value) {
        this.fireNonBubblingEvent(
          "changeValue", qx.event.type.Data, [value, old]
        );
      }
    },


    /*
    ---------------------------------------------------------------------------
      TEXTFIELD VALUE API
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the value of the textfield to the given value.
     *
     * @param value {String} The new value
     */
    setValue : function(value)
    {
      if (this.isDisposed()) {
        return null;
      }
      
      // handle null values
      if (value === null) {
        // just do nothing if null is already set
        if (this.__nullValue) {
          return value;
        }
        value = "";
        this.__nullValue = true;
      } else {
        this.__nullValue = false;
        // native placeholders will be removed by the browser
        if (this.__useQxPlaceholder) {
          this._removePlaceholder();
        }
      }

      if (qx.lang.Type.isString(value))
      {
        var elem = this.getContentElement();
        if (elem.getValue() != value)
        {
          var oldValue = elem.getValue();
          elem.setValue(value);
          var data = this.__nullValue ? null : value;
          this.__oldValue = oldValue;
          this.__fireChangeValueEvent(data);
          // reset the input value on setValue calls [BUG #6892]
          this.__oldInputValue = this.__oldValue;
        }
        // native placeholders will be shown by the browser
        if (this.__useQxPlaceholder) {
          this._showPlaceholder();
        }
        return value;
      }
      throw new Error("Invalid value type: " + value);
    },


    /**
     * Returns the current value of the textfield.
     *
     * @return {String|null} The current value
     */
    getValue : function() {
      return (this.isDisposed() || this.__nullValue) ? null : this.getContentElement().getValue();
    },


    /**
     * Resets the value to the default
     */
    resetValue : function() {
      this.setValue(null);
    },


    /**
     * Event listener for change event of content element
     *
     * @param e {qx.event.type.Data} Incoming change event
     */
    _onChangeContent : function(e)
    {
      this.__nullValue = e.getData() === null;
      this.__fireChangeValueEvent(e.getData());
    },


    /*
    ---------------------------------------------------------------------------
      TEXTFIELD SELECTION API
    ---------------------------------------------------------------------------
    */


    /**
     * Returns the current selection.
     * This method only works if the widget is already created and
     * added to the document.
     *
     * @return {String|null}
     */
    getTextSelection : function() {
      return this.getContentElement().getTextSelection();
    },


    /**
     * Returns the current selection length.
     * This method only works if the widget is already created and
     * added to the document.
     *
     * @return {Integer|null}
     */
    getTextSelectionLength : function() {
      return this.getContentElement().getTextSelectionLength();
    },


    /**
     * Returns the start of the text selection
     *
     * @return {Integer|null} Start of selection or null if not available
     */
    getTextSelectionStart : function() {
      return this.getContentElement().getTextSelectionStart();
    },


    /**
     * Returns the end of the text selection
     *
     * @return {Integer|null} End of selection or null if not available
     */
    getTextSelectionEnd : function() {
      return this.getContentElement().getTextSelectionEnd();
    },


    /**
     * Set the selection to the given start and end (zero-based).
     * If no end value is given the selection will extend to the
     * end of the textfield's content.
     * This method only works if the widget is already created and
     * added to the document.
     *
     * @param start {Integer} start of the selection (zero-based)
     * @param end {Integer} end of the selection
     */
    setTextSelection : function(start, end) {
      this.getContentElement().setTextSelection(start, end);
    },


    /**
     * Clears the current selection.
     * This method only works if the widget is already created and
     * added to the document.
     *
     */
    clearTextSelection : function() {
      this.getContentElement().clearTextSelection();
    },


    /**
     * Selects the whole content
     *
     */
    selectAllText : function() {
      this.setTextSelection(0);
    },


    /*
    ---------------------------------------------------------------------------
      PLACEHOLDER HELPERS
    ---------------------------------------------------------------------------
    */

    // overridden
    setLayoutParent : function(parent)
    {
      this.base(arguments, parent);
      if (this.__useQxPlaceholder) {
        if (parent) {
          this.getLayoutParent().getContentElement().add(this._getPlaceholderElement());
        } else {
          var placeholder = this._getPlaceholderElement();
          placeholder.getParent().remove(placeholder);
        }
      }
    },


    /**
     * Helper to show the placeholder text in the field. It checks for all
     * states and possible conditions and shows the placeholder only if allowed.
     */
    _showPlaceholder : function()
    {
      var fieldValue = this.getValue() || "";
      var placeholder = this.getPlaceholder();
      if (
        placeholder != null &&
        fieldValue == "" &&
        !this.hasState("focused") &&
        !this.hasState("disabled")
      )
      {
        if (this.hasState("showingPlaceholder"))
        {
          this._syncPlaceholder();
        }
        else
        {
          // the placeholder will be set as soon as the appearance is applied
          this.addState("showingPlaceholder");
        }
      }
    },


    /**
     * Remove the fake placeholder
     */
    _onPointerDownPlaceholder : function() {
      window.setTimeout(function() {
        this.focus();
      }.bind(this), 0);
    },


    /**
     * Helper to remove the placeholder. Deletes the placeholder text from the
     * field and removes the state.
     */
    _removePlaceholder: function() {
      if (this.hasState("showingPlaceholder")) {
        if (this.__useQxPlaceholder) {
          this._getPlaceholderElement().setStyle("visibility", "hidden");
        }
        this.removeState("showingPlaceholder");
      }
    },


    /**
     * Updates the placeholder text with the DOM
     */
    _syncPlaceholder : function ()
    {
      if (this.hasState("showingPlaceholder") && this.__useQxPlaceholder) {
        this._getPlaceholderElement().setStyle("visibility", "visible");
      }
    },


    /**
     * Returns the placeholder label and creates it if necessary.
     */
    _getPlaceholderElement : function()
    {
      if (this._placeholder == null) {
        // create the placeholder
        this._placeholder = new qx.html.Label();
        var colorManager = qx.theme.manager.Color.getInstance();
        this._placeholder.setStyles({
          "zIndex" : 11,
          "position" : "absolute",
          "color" : colorManager.resolve("text-placeholder"),
          "whiteSpace": "normal", // enable wrap by default
          "cursor": "text",
          "visibility" : "hidden"
        });

        this._placeholder.addListener("pointerdown", this._onPointerDownPlaceholder, this);
      }
      return this._placeholder;
    },


    /**
     * Locale change event handler
     *
     * @signature function(e)
     * @param e {Event} the change event
     */
    _onChangeLocale : qx.core.Environment.select("qx.dynlocale",
    {
      "true" : function(e)
      {
        var content = this.getPlaceholder();
        if (content && content.translate) {
          this.setPlaceholder(content.translate());
        }
      },

      "false" : null
    }),


    // overridden
    _onChangeTheme : function() {
      this.base(arguments);
      if (this._placeholder) {
        // delete the placeholder element because it uses a theme dependent color
        this._placeholder.dispose();
        this._placeholder = null;
      }
      if (!this.__useQxPlaceholder && qx.ui.form.AbstractField.__stylesheet) {
        qx.bom.Stylesheet.removeSheet(qx.ui.form.AbstractField.__stylesheet);
        qx.ui.form.AbstractField.__stylesheet = null;
        qx.ui.form.AbstractField.__addPlaceholderRules();
      }
    },

    /**
     * Validates the the input value.
     * 
     * @param value {Object} The value to check
     * @returns The checked value
     */
    _validateInput : function(value) {
      var filteredValue = value;
      var filter = this.getFilter();

      // If no filter is set return just the value
      if (filter !== null) {
        filteredValue = "";
        var index = value.search(filter);
        var processedValue = value;

        while((index >= 0) && (processedValue.length > 0)) {
          filteredValue = filteredValue + (processedValue.charAt(index));
          processedValue = processedValue.substring(index + 1, processedValue.length);
          index = processedValue.search(filter);
        }
      }

      return filteredValue;
    },

    /*
    ---------------------------------------------------------------------------
      PROPERTY APPLY ROUTINES
    ---------------------------------------------------------------------------
    */

    // property apply
    _applyPlaceholder : function(value, old)
    {
      if (this.__useQxPlaceholder) {
        this._getPlaceholderElement().setValue(value);
        if (value != null) {
          this.addListener("focusin", this._removePlaceholder, this);
          this.addListener("focusout", this._showPlaceholder, this);
          this._showPlaceholder();
        } else {
          this.removeListener("focusin", this._removePlaceholder, this);
          this.removeListener("focusout", this._showPlaceholder, this);
          this._removePlaceholder();
        }
      } else {
        // only apply if the widget is enabled
        if (this.getEnabled()) {
          this.getContentElement().setAttribute("placeholder", value);

          if (qx.core.Environment.get("browser.name") === "firefox" &&
              parseFloat(qx.core.Environment.get("browser.version")) < 36 &&
              this.getContentElement().getNodeName() === "textarea" &&
              !this.getContentElement().getDomElement())
          {
            /* qx Bug #8870: Firefox 35 will not display a text area's
               placeholder text if the attribute is set before the
               element is added to the DOM. This is fixed in FF 36. */
            this.addListenerOnce("appear", function() {
              this.getContentElement().getDomElement().removeAttribute("placeholder");
              this.getContentElement().getDomElement().setAttribute("placeholder", value);
            }, this);
          }
        }
      }
    },


    // property apply
    _applyTextAlign : function(value, old) {
      this.getContentElement().setStyle("textAlign", value);
    },


    // property apply
    _applyReadOnly : function(value, old)
    {
      var element = this.getContentElement();

      element.setAttribute("readOnly", value);

      if (value)
      {
        this.addState("readonly");
        this.setFocusable(false);
      }
      else
      {
        this.removeState("readonly");
        this.setFocusable(true);
      }
    }

  },


  defer : function(statics) {
    var css = "border: none;" +
      "padding: 0;" +
      "margin: 0;" +
      "display : block;" +
      "background : transparent;" +
      "outline: none;" +
      "appearance: none;" +
      "position: absolute;" +
      "autoComplete: off;" +
      "resize: none;" +
      "border-radius: 0;";

    qx.ui.style.Stylesheet.getInstance().addRule(".qx-abstract-field", css);
  },


  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */
  destruct : function()
  {
    if (this._placeholder) {
      this._placeholder.removeListener("pointerdown", this._onPointerDownPlaceholder, this);
      var parent = this._placeholder.getParent();
      if (parent) {
        parent.remove(this._placeholder);
      }
      this._placeholder.dispose();
    }

    this._placeholder = this.__font = null;

    if (qx.core.Environment.get("qx.dynlocale")) {
      qx.locale.Manager.getInstance().removeListener("changeLocale", this._onChangeLocale, this);
    }

    if (this.__font && this.__webfontListenerId) {
      this.__font.removeListenerById(this.__webfontListenerId);
    }

    this.getContentElement().removeListener("input", this._onHtmlInput, this);
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * A Input wrap any valid HTML input element and make it accessible
 * through the normalized qooxdoo element interface.
 */
qx.Class.define("qx.html.Input",
{
  extend : qx.html.Element,



  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param type {String} The type of the input field. Valid values are
   *   <code>text</code>, <code>textarea</code>, <code>select</code>,
   *   <code>checkbox</code>, <code>radio</code>, <code>password</code>,
   *   <code>hidden</code>, <code>submit</code>, <code>image</code>,
   *   <code>file</code>, <code>search</code>, <code>reset</code>,
   *   <code>select</code> and <code>textarea</code>.
   * @param styles {Map?null} optional map of CSS styles, where the key is the name
   *    of the style and the value is the value to use.
   * @param attributes {Map?null} optional map of element attributes, where the
   *    key is the name of the attribute and the value is the value to use.
   */
  construct : function(type, styles, attributes)
  {
    // Update node name correctly
    if (type === "select" || type === "textarea") {
      var nodeName = type;
    } else {
      nodeName = "input";
    }

    this.base(arguments, nodeName, styles, attributes);

    this.__type = type;
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {

    __type : null,
    // used for webkit only
    __selectable : null,
    __enabled : null,

    /*
    ---------------------------------------------------------------------------
      ELEMENT API
    ---------------------------------------------------------------------------
    */

    //overridden
    _createDomElement : function() {
      return qx.bom.Input.create(this.__type);
    },


    // overridden
    _applyProperty : function(name, value)
    {
      this.base(arguments, name, value);
      var element = this.getDomElement();

      if (name === "value") {
        qx.bom.Input.setValue(element, value);
      } else if (name === "wrap") {
        qx.bom.Input.setWrap(element, value);

        // qx.bom.Input#setWrap has the side-effect that the CSS property
        // overflow is set via DOM methods, causing queue and DOM to get
        // out of sync. Mirror all overflow properties to handle the case
        // when group and x/y property differ.
        this.setStyle("overflow", element.style.overflow, true);
        this.setStyle("overflowX", element.style.overflowX, true);
        this.setStyle("overflowY", element.style.overflowY, true);
      }
    },


    /**
     * Set the input element enabled / disabled.
     * Webkit needs a special treatment because the set color of the input
     * field changes automatically. Therefore, we use
     * <code>-webkit-user-modify: read-only</code> and
     * <code>-webkit-user-select: none</code>
     * for disabling the fields in webkit. All other browsers use the disabled
     * attribute.
     *
     * @param value {Boolean} true, if the input element should be enabled.
     */
    setEnabled : function(value)
    {
      this.__enabled = value;

      this.setAttribute("disabled", value===false);

      if (qx.core.Environment.get("engine.name") == "webkit") {
        if (!value) {
          this.setStyles({
            "userModify": "read-only",
            "userSelect": "none"
          });
        } else {
          this.setStyles({
            "userModify": null,
            "userSelect": this.__selectable ? null : "none"
          });
        }
      }
    },


    /**
     * Set whether the element is selectable. It uses the qooxdoo attribute
     * qxSelectable with the values 'on' or 'off'.
     * In webkit, a special css property will be used and checks for the
     * enabled state.
     *
     * @param value {Boolean} True, if the element should be selectable.
     */
    setSelectable : qx.core.Environment.select("engine.name",
    {
      "webkit" : function(value)
      {
        this.__selectable = value;

        // Only apply the value when it is enabled
        this.base(arguments, this.__enabled && value);
      },

      "default" : function(value)
      {
        this.base(arguments, value);
      }
    }),



    /*
    ---------------------------------------------------------------------------
      INPUT API
    ---------------------------------------------------------------------------
    */

    /**
     * Sets the value of the input element.
     *
     * @param value {var} the new value
     * @return {qx.html.Input} This instance for for chaining support.
     */
    setValue : function(value)
    {
      var element = this.getDomElement();

      if (element)
      {
        // Do not overwrite when already correct (on input events)
        // This is needed to keep caret position while typing.
        if (element.value != value) {
          qx.bom.Input.setValue(element, value);
        }
      } else {
        this._setProperty("value", value);
      }

      return this;
    },


    /**
     * Get the current value.
     *
     * @return {String} The element's current value.
     */
    getValue : function()
    {
      var element = this.getDomElement();

      if (element) {
        return qx.bom.Input.getValue(element);
      }

      return this._getProperty("value") || "";
    },


    /**
     * Sets the text wrap behavior of a text area element.
     *
     * This property uses the style property "wrap" (IE) respectively "whiteSpace"
     *
     * @param wrap {Boolean} Whether to turn text wrap on or off.
     * @param direct {Boolean?false} Whether the execution should be made
     *  directly when possible
     * @return {qx.html.Input} This instance for for chaining support.
     */
    setWrap : function(wrap, direct)
    {
      if (this.__type === "textarea") {
        this._setProperty("wrap", wrap, direct);
      } else {
        throw new Error("Text wrapping is only support by textareas!");
      }

      return this;
    },


    /**
     * Gets the text wrap behavior of a text area element.
     *
     * This property uses the style property "wrap" (IE) respectively "whiteSpace"
     *
     * @return {Boolean} Whether wrapping is enabled or disabled.
     */
    getWrap : function()
    {
      if (this.__type === "textarea") {
        return this._getProperty("wrap");
      } else {
        throw new Error("Text wrapping is only support by textareas!");
      }
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)
     * Fabian Jakobs (fjakobs)
     * Adrian Olaru (adrianolaru)

************************************************************************ */

/**
 * The TextField is a single-line text input field.
 */
qx.Class.define("qx.ui.form.TextField",
{
  extend : qx.ui.form.AbstractField,


  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    // overridden
    appearance :
    {
      refine : true,
      init : "textfield"
    },

    // overridden
    allowGrowY :
    {
      refine : true,
      init : false
    },

    // overridden
    allowShrinkY :
    {
      refine : true,
      init : false
    }
  },

  members : {

    // overridden
    _renderContentElement : function(innerHeight, element) {
     if ((qx.core.Environment.get("engine.name") == "mshtml") &&
         (parseInt(qx.core.Environment.get("engine.version"), 10) < 9
         || qx.core.Environment.get("browser.documentmode") < 9))
     {
       element.setStyles({
         "line-height" : innerHeight + 'px'
       });
     }
    },


    // overridden
    _createContentElement : function() {
      var el = this.base(arguments);
      var deviceType = qx.core.Environment.get("device.type");
      if (deviceType == "tablet" || deviceType == "mobile") {
        el.addListener("keypress", this._onKeyPress, this);
      }

      return el;
    },


    /**
    * Close the virtual keyboard if the Enter key is pressed.
    * @param evt {qx.event.type.KeySequence} the keypress event.
    */
    _onKeyPress : function(evt) {
      // On return
      if (evt.getKeyIdentifier() == "Enter") {
        if (this.isFocusable()) {
          this.blur();
        }
        else {
           // When the text field is not focusable, blur() will raise an exception on
           // touch devices and the virtual keyboard is not closed. To work around this
           // issue, we're enabling the focus just for the blur() call.
           this.setFocusable(true);
           this.blur();
           this.setFocusable(false);
        }
      }
    }
  },

  destruct : function() {
    this.getContentElement().removeListener("keypress", this._onKeyPress, this);
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * The form object is responsible for managing form items. For that, it takes
 * advantage of two existing qooxdoo classes.
 * The {@link qx.ui.form.Resetter} is used for resetting and the
 * {@link qx.ui.form.validation.Manager} is used for all validation purposes.
 *
 * The view code can be found in the used renderer ({@link qx.ui.form.renderer}).
 */
qx.Class.define("qx.ui.form.Form",
{
  extend : qx.core.Object,


  construct : function()
  {
    this.base(arguments);

    this.__groups = [];
    this._buttons = [];
    this._buttonOptions = [];
    this._validationManager = this._createValidationManager();
    this._resetter = this._createResetter();
  },


  events : {
    /** Fired as soon as something changes in the form.*/
    "change" : "qx.event.type.Event"
  },


  members :
  {
    __groups : null,
    _validationManager : null,
    _groupCounter : 0,
    _buttons : null,
    _buttonOptions : null,
    _resetter : null,

    /*
    ---------------------------------------------------------------------------
       ADD
    ---------------------------------------------------------------------------
    */

    /**
     * Adds a form item to the form including its internal
     * {@link qx.ui.form.validation.Manager} and {@link qx.ui.form.Resetter}.
     *
     * *Hint:* The order of all add calls represent the order in the layout.
     *
     * @param item {qx.ui.form.IForm} A supported form item.
     * @param label {String} The string, which should be used as label.
     * @param validator {Function | qx.ui.form.validation.AsyncValidator ? null}
     *   The validator which is used by the validation
     *   {@link qx.ui.form.validation.Manager}.
     * @param name {String?null} The name which is used by the data binding
     *   controller {@link qx.data.controller.Form}.
     * @param validatorContext {var?null} The context of the validator.
     * @param options {Map?null} An additional map containing custom data which
     *   will be available in your form renderer specific to the added item.
     */
    add : function(item, label, validator, name, validatorContext, options) {
      if (this.__isFirstAdd()) {
        this.__groups.push({
          title: null, items: [], labels: [], names: [],
          options: [], headerOptions: {}
        });
      }
      // save the given arguments
      this.__groups[this._groupCounter].items.push(item);
      this.__groups[this._groupCounter].labels.push(label);
      this.__groups[this._groupCounter].options.push(options);
      // if no name is given, use the label without not working character
      if (name == null) {
        name = label.replace(
          /\s+|&|-|\+|\*|\/|\||!|\.|,|:|\?|;|~|%|\{|\}|\(|\)|\[|\]|<|>|=|\^|@|\\/g, ""
        );
      }
      this.__groups[this._groupCounter].names.push(name);

      // add the item to the validation manager
      this._validationManager.add(item, validator, validatorContext);
      // add the item to the reset manager
      this._resetter.add(item);
      // fire the change event
      this.fireEvent("change");
    },


    /**
     * Adds a group header to the form.
     *
     * *Hint:* The order of all add calls represent the order in the layout.
     *
     * @param title {String} The title of the group header.
     * @param options {Map?null} A special set of custom data which will be
     *   given to the renderer.
     */
    addGroupHeader : function(title, options) {
      if (!this.__isFirstAdd()) {
        this._groupCounter++;
      }
      this.__groups.push({
        title: title, items: [], labels: [], names: [],
        options: [], headerOptions: options
      });
      // fire the change event
      this.fireEvent("change");
    },


    /**
     * Adds a button to the form.
     *
     * *Hint:* The order of all add calls represent the order in the layout.
     *
     * @param button {qx.ui.form.Button} The button to add.
     * @param options {Map?null} An additional map containing custom data which
     *   will be available in your form renderer specific to the added button.
     */
    addButton : function(button, options) {
      this._buttons.push(button);
      this._buttonOptions.push(options || null);
      // fire the change event
      this.fireEvent("change");
    },


    /**
     * Returns whether something has already been added.
     *
     * @return {Boolean} true, if nothing has been added jet.
     */
    __isFirstAdd : function() {
      return this.__groups.length === 0;
    },


    /*
    ---------------------------------------------------------------------------
       REMOVE
    ---------------------------------------------------------------------------
    */


    /**
     * Removes the given item from the form.
     *
     * @param item {qx.ui.form.IForm} A supported form item.
     * @return {Boolean} <code>true</code>, if the item could be removed.
     */
    remove : function(item) {
      for (var i = 0; i < this.__groups.length; i++) {
        var group = this.__groups[i];
        for (var j = 0; j < group.items.length; j++) {
          var storedItem = group.items[j];
          if (storedItem === item) {
            // remove all stored data
            group.items.splice(j, 1);
            group.labels.splice(j, 1);
            group.names.splice(j, 1);
            group.options.splice(j, 1);

            // remove the item to the validation manager
            this._validationManager.remove(item);
            // remove the item to the reset manager
            this._resetter.remove(item);

            // fire the change event
            this.fireEvent("change");
            return true;
          }
        }
      }
      return false;
    },


    /**
     * Removes the given group header from the form. All items in the group will be moved to
     * another group (usually the previous group). If there is more than one group with
     * the same title, only the first group will be removed.
     *
     * @param title {String} The title.
     * @return {Boolean} <code>true</code>, if the header could be removed.
     */
    removeGroupHeader : function(title) {
      for (var i = 0; i < this.__groups.length; i++) {
        var group = this.__groups[i];
        if (group.title === title) {
          var targetGroup;

          // if it's the first group
          if (i == 0) {
            // if it's the only group
            if (this.__groups.length == 1) {
              // remove the title and the header options
              group.title = null;
              group.headerOptions = {};
              // fire the change event
              this.fireEvent("change");
              return true;
            } else {
              // add to the next
              targetGroup = this.__groups[i+1];
            }
          } else {
            // add to the previous group
            targetGroup = this.__groups[i-1];
          }

          // copy the data over
          targetGroup.items = targetGroup.items.concat(group.items);
          targetGroup.labels = targetGroup.labels.concat(group.labels);
          targetGroup.names = targetGroup.names.concat(group.names);
          targetGroup.options = targetGroup.options.concat(group.options);

          // delete the group
          this.__groups.splice(i, 1);

          this._groupCounter--;

          // fire the change event
          this.fireEvent("change");
          return true;
        }
      }
      return false;
    },


    /**
     * Removes the given button from the form.
     *
     * @param button {qx.ui.form.Button} The button to remove.
     * @return {Boolean} <code>true</code>, if the button could be removed.
     */
    removeButton : function(button) {
      for (var i = 0; i < this._buttons.length; i++) {
        var storedButton = this._buttons[i];
        if (storedButton === button) {
          this._buttons.splice(i, 1);
          this._buttonOptions.splice(i, 1);
          // fire the change event
          this.fireEvent("change");
          return true;
        }
      }
      return false;
    },


    /**
     * Returns all added items as a map.
     *
     * @return {Map} A map containing for every item an entry with its name.
     */
    getItems : function() {
      var items = {};
      // go threw all groups
      for (var i = 0; i < this.__groups.length; i++) {
        var group = this.__groups[i];
        // get all items
        for (var j = 0; j < group.names.length; j++) {
          var name = group.names[j];
          items[name] = group.items[j];
        }
      }
      return items;
    },


    /**
     * Return an item by name.
     *
     * @param name {string} Item name.
     * @return {qx.ui.form.IForm|null} The form item or null.
     */
    getItem : function(name) {
      for (var i = 0; i < this.__groups.length; i++) {
        var group = this.__groups[i];
        for (var j = 0; j < group.names.length; j++) {
          if (group.names[j] === name) {
            return group.items[j];
          }
        }
      }

      return null;
    },


    /*
    ---------------------------------------------------------------------------
       RESET SUPPORT
    ---------------------------------------------------------------------------
    */

    /**
     * Resets the form. This means reseting all form items and the validation.
     */
    reset : function() {
      this._resetter.reset();
      this._validationManager.reset();
    },


    /**
     * Redefines the values used for resetting. It calls
     * {@link qx.ui.form.Resetter#redefine} to get that.
     */
    redefineResetter : function() {
      this._resetter.redefine();
    },


    /**
     * Redefines the value used for resetting of the given item. It calls
     * {@link qx.ui.form.Resetter#redefineItem} to get that.
     *
     * @param item {qx.ui.core.Widget} The item to redefine.
     */
    redefineResetterItem : function(item) {
      this._resetter.redefineItem(item);
    },



    /*
    ---------------------------------------------------------------------------
       VALIDATION
    ---------------------------------------------------------------------------
    */

    /**
     * Validates the form using the
     * {@link qx.ui.form.validation.Manager#validate} method.
     *
     * @return {Boolean | null} The validation result.
     */
    validate : function() {
      return this._validationManager.validate();
    },


    /**
     * Returns the internally used validation manager. If you want to do some
     * enhanced validation tasks, you need to use the validation manager.
     *
     * @return {qx.ui.form.validation.Manager} The used manager.
     */
    getValidationManager : function() {
      return this._validationManager;
    },


    /*
    ---------------------------------------------------------------------------
       RENDERER SUPPORT
    ---------------------------------------------------------------------------
    */

    /**
     * Accessor method for the renderer which returns all added items in a
     * array containing a map of all items:
     * {title: title, items: [], labels: [], names: []}
     *
     * @return {Array} An array containing all necessary data for the renderer.
     * @internal
     */
    getGroups : function() {
      return this.__groups;
    },


    /**
     * Accessor method for the renderer which returns all added buttons in an
     * array.
     * @return {Array} An array containing all added buttons.
     * @internal
     */
    getButtons : function() {
      return this._buttons;
    },


    /**
     * Accessor method for the renderer which returns all added options for
     * the buttons in an array.
     * @return {Array} An array containing all added options for the buttons.
     * @internal
     */
    getButtonOptions : function() {
      return this._buttonOptions;
    },



    /*
    ---------------------------------------------------------------------------
       INTERNAL
    ---------------------------------------------------------------------------
    */

    /**
     * Creates and returns the used validation manager.
     *
     * @return {qx.ui.form.validation.Manager} The validation manager.
     */
    _createValidationManager : function() {
      return new qx.ui.form.validation.Manager();
    },


    /**
     * Creates and returns the used resetter.
     *
     * @return {qx.ui.form.Resetter} the resetter class.
     */
    _createResetter : function() {
      return new qx.ui.form.Resetter();
    }
  },


  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */
  destruct : function()
  {
    // holding references to widgets --> must set to null
    this.__groups = this._buttons = this._buttonOptions = null;
    this._validationManager.dispose();
    this._resetter.dispose();
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */
/**
 * This validation manager is responsible for validation of forms.
 *
 * @ignore(qx.ui.tooltip)
 * @ignore(qx.ui.tooltip.Manager.*)
 */
qx.Class.define("qx.ui.form.validation.Manager",
{
  extend : qx.core.Object,

  construct : function()
  {
    this.base(arguments);

    // storage for all form items
    this.__formItems = [];
    // storage for all results of async validation calls
    this.__asyncResults = {};
    // set the default required field message
    this.setRequiredFieldMessage(qx.locale.Manager.tr("This field is required"));
  },


  events :
  {
    /**
     * Change event for the valid state.
     */
    "changeValid" : "qx.event.type.Data",

    /**
     * Signals that the validation is done. This is not needed on synchronous
     * validation (validation is done right after the call) but very important
     * in the case an asynchronous validator will be used.
     */
    "complete" : "qx.event.type.Event"
  },


  properties :
  {
    /**
     * The validator of the form itself. You can set a function (for
     * synchronous validation) or a {@link qx.ui.form.validation.AsyncValidator}.
     * In both cases, the function can have all added form items as first
     * argument and the manager as a second argument. The manager should be used
     * to set the {@link #invalidMessage}.
     *
     * Keep in mind that the validator is optional if you don't need the
     * validation in the context of the whole form.
     * @type {Function | AsyncValidator}
     */
    validator :
    {
      check : "value instanceof Function || qx.Class.isSubClassOf(value.constructor, qx.ui.form.validation.AsyncValidator)",
      init : null,
      nullable : true
    },

    /**
     * The invalid message should store the message why the form validation
     * failed. It will be added to the array returned by
     * {@link #getInvalidMessages}.
     */
    invalidMessage :
    {
      check : "String",
      init: ""
    },


    /**
     * This message will be shown if a required field is empty and no individual
     * {@link qx.ui.form.MForm#requiredInvalidMessage} is given.
     */
    requiredFieldMessage :
    {
      check : "String",
      init : ""
    },


    /**
     * The context for the form validation.
     */
    context :
    {
      nullable : true
    }
  },


  members :
  {
    __formItems : null,
    __valid : null,
    __asyncResults : null,
    __syncValid : null,


    /**
     * Add a form item to the validation manager.
     *
     * The form item has to implement at least two interfaces:
     * <ol>
     *   <li>The {@link qx.ui.form.IForm} Interface</li>
     *   <li>One of the following interfaces:
     *     <ul>
     *       <li>{@link qx.ui.form.IBooleanForm}</li>
     *       <li>{@link qx.ui.form.IColorForm}</li>
     *       <li>{@link qx.ui.form.IDateForm}</li>
     *       <li>{@link qx.ui.form.INumberForm}</li>
     *       <li>{@link qx.ui.form.IStringForm}</li>
     *     </ul>
     *   </li>
     * </ol>
     * The validator can be a synchronous or asynchronous validator. In
     * both cases the validator can either returns a boolean or fire an
     * {@link qx.core.ValidationError}. For synchronous validation, a plain
     * JavaScript function should be used. For all asynchronous validations,
     * a {@link qx.ui.form.validation.AsyncValidator} is needed to wrap the
     * plain function.
     *
     * @param formItem {qx.ui.core.Widget} The form item to add.
     * @param validator {Function | qx.ui.form.validation.AsyncValidator}
     *   The validator.
     * @param context {var?null} The context of the validator.
     */
    add: function(formItem, validator, context) {
      // check for the form API
      if (!this.__supportsInvalid(formItem)) {
        throw new Error("Added widget not supported.");
      }
      // check for the data type
      if (this.__supportsSingleSelection(formItem) && !formItem.getValue) {
        // check for a validator
        if (validator != null) {
          throw new Error("Widgets supporting selection can only be validated " +
          "in the form validator");
        }
      }
      var dataEntry =
      {
        item : formItem,
        validator : validator,
        valid : null,
        context : context
      };
      this.__formItems.push(dataEntry);
    },


    /**
     * Remove a form item from the validation manager.
     *
     * @param formItem {qx.ui.core.Widget} The form item to remove.
     * @return {qx.ui.core.Widget?null} The removed form item or
     *  <code>null</code> if the item could not be found.
     */
    remove : function(formItem)
    {
      var items = this.__formItems;

      for (var i = 0, len = items.length; i < len; i++)
      {
        if (formItem === items[i].item)
        {
          items.splice(i, 1);
          return formItem;
        }
      }

      return null;
    },


    /**
     * Returns registered form items from the validation manager.
     *
     * @return {Array} The form items which will be validated.
     */
    getItems : function()
    {
      var items = [];
      for (var i=0; i < this.__formItems.length; i++) {
        items.push(this.__formItems[i].item);
      };
      return items;
    },


    /**
     * Invokes the validation. If only synchronous validators are set, the
     * result of the whole validation is available at the end of the method
     * and can be returned. If an asynchronous validator is set, the result
     * is still unknown at the end of this method so nothing will be returned.
     * In both cases, a {@link #complete} event will be fired if the validation
     * has ended. The result of the validation can then be accessed with the
     * {@link #getValid} method.
     *
     * @return {Boolean|undefined} The validation result, if available.
     */
    validate : function() {
      var valid = true;
      this.__syncValid = true; // collaboration of all synchronous validations
      var items = [];

      // check all validators for the added form items
      for (var i = 0; i < this.__formItems.length; i++) {
        var formItem = this.__formItems[i].item;
        var validator = this.__formItems[i].validator;

        // store the items in case of form validation
        items.push(formItem);

        // ignore all form items without a validator
        if (validator == null) {
          // check for the required property
          var validatorResult = this._validateRequired(formItem);
          valid = valid && validatorResult;
          this.__syncValid = validatorResult && this.__syncValid;
          continue;
        }

        var validatorResult = this._validateItem(
          this.__formItems[i], formItem.getValue()
        );
        // keep that order to ensure that null is returned on async cases
        valid = validatorResult && valid;
        if (validatorResult != null) {
          this.__syncValid = validatorResult && this.__syncValid;
        }
      }

      // check the form validator (be sure to invoke it even if the form
      // items are already false, so keep the order!)
      var formValid = this.__validateForm(items);
      if (qx.lang.Type.isBoolean(formValid)) {
        this.__syncValid = formValid && this.__syncValid;
      }
      valid = formValid && valid;

      this._setValid(valid);

      if (qx.lang.Object.isEmpty(this.__asyncResults)) {
        this.fireEvent("complete");
      }
      return valid;
    },


    /**
     * Checks if the form item is required. If so, the value is checked
     * and the result will be returned. If the form item is not required, true
     * will be returned.
     *
     * @param formItem {qx.ui.core.Widget} The form item to check.
     * @return {var} Validation result
     */
    _validateRequired : function(formItem) {
      if (formItem.getRequired()) {
        var validatorResult;
        // if its a widget supporting the selection
        if (this.__supportsSingleSelection(formItem)) {
          validatorResult = !!formItem.getSelection()[0];

        } else if (this.__supportsDataBindingSelection(formItem)) {
          validatorResult = (formItem.getSelection().getLength() > 0);

        } else {
          var value = formItem.getValue();
          validatorResult = !!value || value === 0;
        }
        formItem.setValid(validatorResult);
        var individualMessage = formItem.getRequiredInvalidMessage();
        var message = individualMessage ? individualMessage : this.getRequiredFieldMessage();
        formItem.setInvalidMessage(message);
        return validatorResult;
      }
      return true;
    },


    /**
     * Validates a form item. This method handles the differences of
     * synchronous and asynchronous validation and returns the result of the
     * validation if possible (synchronous cases). If the validation is
     * asynchronous, null will be returned.
     *
     * @param dataEntry {Object} The map stored in {@link #add}
     * @param value {var} The currently set value
     * @return {Boolean|null} Validation result or <code>null</code> for async
     * validation
     */
    _validateItem : function(dataEntry, value) {
      var formItem = dataEntry.item;
      var context = dataEntry.context;
      var validator = dataEntry.validator;

      // check for asynchronous validation
      if (this.__isAsyncValidator(validator)) {
        // used to check if all async validations are done
        this.__asyncResults[formItem.toHashCode()] = null;
        validator.validate(formItem, formItem.getValue(), this, context);
        return null;
      }

      var validatorResult = null;

      try {
        var validatorResult = validator.call(context || this, value, formItem);
        if (validatorResult === undefined) {
          validatorResult = true;
        }

      } catch (e) {
        if (e instanceof qx.core.ValidationError) {
          validatorResult = false;
          if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {
            var invalidMessage = e.message;
          } else {
            var invalidMessage = e.getComment();
          }
          formItem.setInvalidMessage(invalidMessage);
        } else {
          throw e;
        }
      }

      formItem.setValid(validatorResult);
      dataEntry.valid = validatorResult;

      return validatorResult;
    },


    /**
     * Validates the form. It checks for asynchronous validation and handles
     * the differences to synchronous validation. If no form validator is given,
     * true will be returned. If a synchronous validator is given, the
     * validation result will be returned. In asynchronous cases, null will be
     * returned cause the result is not available.
     *
     * @param items {qx.ui.core.Widget[]} An array of all form items.
     * @return {Boolean|null} description
     */
    __validateForm: function(items) {
      var formValidator = this.getValidator();
      var context = this.getContext() || this;

      if (formValidator == null) {
        return true;
      }

      // reset the invalidMessage
      this.setInvalidMessage("");

      if (this.__isAsyncValidator(formValidator)) {
        this.__asyncResults[this.toHashCode()] = null;
        formValidator.validateForm(items, this, context);
        return null;
      }

      try {
        var formValid = formValidator.call(context, items, this);
        if (formValid === undefined) {
          formValid = true;
        }
      } catch (e) {
        if (e instanceof qx.core.ValidationError) {
          formValid = false;

          if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {
            var invalidMessage = e.message;
          } else {
            var invalidMessage = e.getComment();
          }
          this.setInvalidMessage(invalidMessage);
        } else {
          throw e;
        }
      }
      return formValid;
    },


    /**
     * Helper function which checks, if the given validator is synchronous
     * or asynchronous.
     *
     * @param validator {Function|qx.ui.form.validation.AsyncValidator}
     *   The validator to check.
     * @return {Boolean} True, if the given validator is asynchronous.
     */
    __isAsyncValidator : function(validator) {
      var async = false;
      if (!qx.lang.Type.isFunction(validator)) {
        async = qx.Class.isSubClassOf(
          validator.constructor, qx.ui.form.validation.AsyncValidator
        );
      }
      return async;
    },


    /**
     * Returns true, if the given item implements the {@link qx.ui.form.IForm}
     * interface.
     *
     * @param formItem {qx.core.Object} The item to check.
     * @return {Boolean} true, if the given item implements the
     *   necessary interface.
     */
    __supportsInvalid : function(formItem) {
      var clazz = formItem.constructor;
      return qx.Class.hasInterface(clazz, qx.ui.form.IForm);
    },


    /**
     * Returns true, if the given item implements the
     * {@link qx.ui.core.ISingleSelection} interface.
     *
     * @param formItem {qx.core.Object} The item to check.
     * @return {Boolean} true, if the given item implements the
     *   necessary interface.
     */
    __supportsSingleSelection : function(formItem) {
      var clazz = formItem.constructor;
      return qx.Class.hasInterface(clazz, qx.ui.core.ISingleSelection);
    },


    /**
     * Returns true, if the given item implements the
     * {@link qx.data.controller.ISelection} interface.
     *
     * @param formItem {qx.core.Object} The item to check.
     * @return {Boolean} true, if the given item implements the
     *   necessary interface.
     */
    __supportsDataBindingSelection : function(formItem) {
      var clazz = formItem.constructor;
      return qx.Class.hasInterface(clazz, qx.data.controller.ISelection);
    },


    /**
     * Sets the valid state of the manager. It generates the event if
     * necessary and stores the new value.
     *
     * @param value {Boolean|null} The new valid state of the manager.
     */
    _setValid: function(value) {
      this._showToolTip(value);
      var oldValue = this.__valid;
      this.__valid = value;
      // check for the change event
      if (oldValue != value) {
        this.fireDataEvent("changeValid", value, oldValue);
      }
    },


    /**
     * Responsible for showing a tooltip in case the validation is done for
     * widgets based on qx.ui.core.Widget.
     * @param valid {Boolean} <code>false</code>, if the tooltip should be shown
     */
    _showToolTip : function(valid) {
      // ignore if we don't have a tooltip manager e.g. mobile apps
      if (!qx.ui.tooltip || !qx.ui.tooltip.Manager) {
        return;
      }
      var tooltip = qx.ui.tooltip.Manager.getInstance().getSharedErrorTooltip();

      if (!valid) {
        var firstInvalid;
        for (var i = 0; i < this.__formItems.length; i++) {
          var item = this.__formItems[i].item;
          if (!item.isValid()) {
            firstInvalid = item;
            // only for desktop widgets
            if (!(item.getContentLocation)) {
              return;
            }
            // only consider items on the screen
            if (item.isSeeable() === false) {
              continue;
            }

            tooltip.setLabel(item.getInvalidMessage());

            if (tooltip.getPlaceMethod() == "mouse") {
              var location = item.getContentLocation();
              var top = location.top - tooltip.getOffsetTop();
              tooltip.placeToPoint({left: location.right, top: top});
            } else {
              tooltip.placeToWidget(item);
            }

            tooltip.show();
            return;
          }
        }
      } else {
        tooltip.exclude();
      }
    },


    /**
     * Returns the valid state of the manager.
     *
     * @return {Boolean|null} The valid state of the manager.
     */
    getValid: function() {
      return this.__valid;
    },


    /**
     * Returns the valid state of the manager.
     *
     * @return {Boolean|null} The valid state of the manager.
     */
    isValid: function() {
      return this.getValid();
    },


    /**
     * Returns an array of all invalid messages of the invalid form items and
     * the form manager itself.
     *
     * @return {String[]} All invalid messages.
     */
    getInvalidMessages: function() {
      var messages = [];
      // combine the messages of all form items
      for (var i = 0; i < this.__formItems.length; i++) {
        var formItem = this.__formItems[i].item;
        if (!formItem.getValid()) {
          messages.push(formItem.getInvalidMessage());
        }
      }
      // add the forms fail message
      if (this.getInvalidMessage() != "") {
        messages.push(this.getInvalidMessage());
      }

      return messages;
    },


    /**
     * Selects invalid form items
     *
     * @return {Array} invalid form items
     */
    getInvalidFormItems : function() {
      var res = [];
      for (var i = 0; i < this.__formItems.length; i++) {
        var formItem = this.__formItems[i].item;
        if (!formItem.getValid()) {
          res.push(formItem);
        }
      }

      return res;
    },


    /**
     * Resets the validator.
     */
    reset: function() {
      // reset all form items
      for (var i = 0; i < this.__formItems.length; i++) {
        var dataEntry = this.__formItems[i];
        // set the field to valid
        dataEntry.item.setValid(true);
      }
      // set the manager to its initial valid value
      this.__valid = null;
      this._showToolTip(true);
    },


    /**
     * Internal helper method to set the given item to valid for asynchronous
     * validation calls. This indirection is used to determinate if the
     * validation process is completed or if other asynchronous validators
     * are still validating. {@link #__checkValidationComplete} checks if the
     * validation is complete and will be called at the end of this method.
     *
     * @param formItem {qx.ui.core.Widget} The form item to set the valid state.
     * @param valid {Boolean} The valid state for the form item.
     *
     * @internal
     */
    setItemValid: function(formItem, valid) {
      // store the result
      this.__asyncResults[formItem.toHashCode()] = valid;
      formItem.setValid(valid);
      this.__checkValidationComplete();
    },


    /**
     * Internal helper method to set the form manager to valid for asynchronous
     * validation calls. This indirection is used to determinate if the
     * validation process is completed or if other asynchronous validators
     * are still validating. {@link #__checkValidationComplete} checks if the
     * validation is complete and will be called at the end of this method.
     *
     * @param valid {Boolean} The valid state for the form manager.
     *
     * @internal
     */
    setFormValid : function(valid) {
      this.__asyncResults[this.toHashCode()] = valid;
      this.__checkValidationComplete();
    },


    /**
     * Checks if all asynchronous validators have validated so the result
     * is final and the {@link #complete} event can be fired. If that's not
     * the case, nothing will happen in the method.
     */
    __checkValidationComplete : function() {
      var valid = this.__syncValid;

      // check if all async validators are done
      for (var hash in this.__asyncResults) {
        var currentResult = this.__asyncResults[hash];
        valid = currentResult && valid;
        // the validation is not done so just do nothing
        if (currentResult == null) {
          return;
        }
      }
      // set the actual valid state of the manager
      this._setValid(valid);
      // reset the results
      this.__asyncResults = {};
      // fire the complete event (no entry in the results with null)
      this.fireEvent("complete");
    }
  },


  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */
  destruct : function()
  {
    this._showToolTip(true);
    this.__formItems = null;
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */
/**
 * This class is responsible for validation in all asynchronous cases and
 * should always be used with {@link qx.ui.form.validation.Manager}.
 *
 *
 * It acts like a wrapper for asynchronous validation functions. These
 * validation function must be set in the constructor. The form manager will
 * invoke the validation and the validator function will be called with two
 * arguments:
 * <ul>
 *  <li>asyncValidator: A reference to the corresponding validator.</li>
 *  <li>value: The value of the assigned input field.</li>
 * </ul>
 * These two parameters are needed to set the validation status of the current
 * validator. {@link #setValid} is responsible for doing that.
 *
 *
 * *Warning:* Instances of this class can only be used with one input
 * field at a time. Multi usage is not supported!
 *
 * *Warning:* Calling {@link #setValid} synchronously does not work. If you
 * have an synchronous validator, please check
 * {@link qx.ui.form.validation.Manager#add}. If you have both cases, you have
 * to wrap the synchronous call in a timeout to make it asynchronous.
 */
qx.Class.define("qx.ui.form.validation.AsyncValidator",
{
  extend : qx.core.Object,

  /**
   * @param validator {Function} The validator function, which has to be
   *   asynchronous.
   */
  construct : function(validator)
  {
    this.base(arguments);
    // save the validator function
    this.__validatorFunction = validator;
  },

  members :
  {
    __validatorFunction : null,
    __item : null,
    __manager : null,
    __usedForForm : null,

    /**
     * The validate function should only be called by
     * {@link qx.ui.form.validation.Manager}.
     *
     * It stores the given information and calls the validation function set in
     * the constructor. The method is used for form fields only. Validating a
     * form itself will be invokes with {@link #validateForm}.
     *
     * @param item {qx.ui.core.Widget} The form item which should be validated.
     * @param value {var} The value of the form item.
     * @param manager {qx.ui.form.validation.Manager} A reference to the form
     *   manager.
     * @param context {var?null} The context of the validator.
     *
     * @internal
     */
    validate: function(item, value, manager, context) {
      // mark as item validator
      this.__usedForForm = false;
      // store the item and the manager
      this.__item = item;
      this.__manager = manager;
      // invoke the user set validator function
      this.__validatorFunction.call(context || this, this, value);
    },


    /**
     * The validateForm function should only be called by
     * {@link qx.ui.form.validation.Manager}.
     *
     * It stores the given information and calls the validation function set in
     * the constructor. The method is used for forms only. Validating a
     * form item will be invokes with {@link #validate}.
     *
     * @param items {qx.ui.core.Widget[]} All form items of the form manager.
     * @param manager {qx.ui.form.validation.Manager} A reference to the form
     *   manager.
     * @param context {var?null} The context of the validator.
     *
     * @internal
     */
    validateForm : function(items, manager, context) {
      this.__usedForForm = true;
      this.__manager = manager;
      this.__validatorFunction.call(context, items, this);
    },


    /**
     * This method should be called within the asynchronous callback to tell the
     * validator the result of the validation.
     *
     * @param valid {Boolean} The boolean state of the validation.
     * @param message {String?} The invalidMessage of the validation.
     */
    setValid: function(valid, message) {
      // valid processing
      if (this.__usedForForm) {
        // message processing
        if (message !== undefined) {
          this.__manager.setInvalidMessage(message);
        }
        this.__manager.setFormValid(valid);
      } else {
        // message processing
        if (message !== undefined) {
          this.__item.setInvalidMessage(message);
        }
        this.__manager.setItemValid(this.__item, valid);
      }
    }
  },


  /*
   *****************************************************************************
      DESTRUCT
   *****************************************************************************
   */

  destruct : function() {
    this.__manager = this.__item = null;
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2012 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)

************************************************************************ */

/**
 * Interface for data binding classes offering a selection.
 */
qx.Interface.define("qx.data.controller.ISelection",
{
  members :
  {
    /**
     * Setter for the selection.
     * @param value {qx.data.IListData} The data of the selection.
     */
    setSelection : function(value) {},


    /**
     * Getter for the selection list.
     * @return {qx.data.IListData} The current selection.
     */
    getSelection : function() {},


    /**
     * Resets the selection to its default value.
     */
    resetSelection : function() {}
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
     2017 Martijn Evers, The Netherlands

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Martin Wittemann (martinwittemann)
     * Martijn Evers (mever)

************************************************************************ */
/**
 * The resetter is responsible for managing a set of fields and resetting these
 * fields on a {@link #reset} call. It can handle all form field implementing IField.
 */
qx.Class.define("qx.ui.form.Resetter",
{
  extend : qx.core.Object,


  construct : function()
  {
    this.base(arguments);

    this.__items = [];
  },

  members :
  {
    __items : null,

    /**
     * Adding a field to the resetter will get its current value and store
     * it for resetting.
     *
     * @param field {qx.ui.form.IField} The field which should be added.
     * @throws {TypeError} When given argument is not a field.
     */
    add : function(field) {
      this.__typeCheck(field);
      this.__items.push({item: field, init: field.getValue()});
    },


    /**
     * Removes a field from the resetter.
     *
     * @param field {qx.ui.form.IField} The field which should be removed.
     * @throws {TypeError} When given argument is not a field.
     * @return {Boolean} <code>true</code>, if the field has been removed.
     */
    remove : function(field) {
      this.__typeCheck(field);
      for (var i = 0; i < this.__items.length; i++) {
        var storedItem = this.__items[i];
        if (storedItem.item === field) {
          this.__items.splice(i, 1);
          return true;
        }
      }
      return false;
    },


    /**
     * Resets all added fields to their initial value. The initial value
     * is the value in the widget during the {@link #add}.
     *
     * @return {null|Error} Returns an error when some fields could not be reset.
     */
    reset: function() {
      var dataEntry, e, errors = [];
      for (var i = 0; i < this.__items.length; i++) {
        dataEntry = this.__items[i];
        e = dataEntry.item.setValue(dataEntry.init);
        if (e && e instanceof Error) {
          errors.push(e);
        }
      }

      if (errors.length) {
        return new Error(errors.join(', '));
      } else {
        return null;
      }
    },


    /**
     * Resets a single given field. The field has to be added to the resetter
     * instance before. Otherwise, an error is thrown.
     *
     * @param field {qx.ui.form.IField} The field, which should be reset.
     * @throws {TypeError} When given argument is not a field.
     * @return {null|Error} Returns an error when the field value could not be set.
     */
    resetItem : function(field) {
      this.__typeCheck(field);
      for (var i = 0; i < this.__items.length; i++) {
        var dataEntry = this.__items[i];
        if (dataEntry.item === field) {
          return field.setValue(dataEntry.init);
        }
      }

      throw new Error("The given field has not been added.");
    },


    /**
     * Takes the current values of all added fields and uses these values as
     * init values for resetting.
     */
    redefine: function() {
      // go threw all added items
      for (var i = 0; i < this.__items.length; i++) {
        var item = this.__items[i].item;
        // set the new init value for the item
        this.__items[i].init = item.getValue();
      }
    },


    /**
     * Takes the current value of the given field and stores this value as init
     * value for resetting.
     *
     * @param field {qx.ui.form.IField} The field to redefine.
     * @throws {TypeError} When given argument is not a field.
     */
    redefineItem : function(field) {
      this.__typeCheck(field);

      // get the data entry
      var dataEntry;
      for (var i = 0; i < this.__items.length; i++) {
        if (this.__items[i].item === field) {
          dataEntry = this.__items[i];
          dataEntry.init = dataEntry.item.getValue();
          return;
        }
      }

      throw new Error("The given field has not been added.");
    },


    /**
     * Assert when given argument is not a field.
     *
     * @param field {qx.ui.form.IField|var} Any argument that should be a field.
     * @throws {TypeError} When given argument is not a field.
     * @private
     */
    __typeCheck : function(field) {
      if (!qx.Class.hasInterface(field.constructor, qx.ui.form.IField)) {
        throw new TypeError("Field " + field + " not supported for resetting.");
      }
    }
  },


  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */
  destruct : function()
  {
    // holding references to widgets --> must set to null
    this.__items = null;
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * A Button widget which supports various states and allows it to be used
 * via the mouse, touch, pen and the keyboard.
 *
 * If the user presses the button by clicking on it, or the <code>Enter</code> or
 * <code>Space</code> keys, the button fires an {@link qx.ui.core.MExecutable#execute} event.
 *
 * If the {@link qx.ui.core.MExecutable#command} property is set, the
 * command is executed as well.
 *
 * *Example*
 *
 * Here is a little example of how to use the widget.
 *
 * <pre class='javascript'>
 *   var button = new qx.ui.form.Button("Hello World");
 *
 *   button.addListener("execute", function(e) {
 *     alert("Button was clicked");
 *   }, this);
 *
 *   this.getRoot().add(button);
 * </pre>
 *
 * This example creates a button with the label "Hello World" and attaches an
 * event listener to the {@link #execute} event.
 *
 * *External Documentation*
 *
 * <a href='http://manual.qooxdoo.org/${qxversion}/pages/widget/button.html' target='_blank'>
 * Documentation of this widget in the qooxdoo manual.</a>
 */
qx.Class.define("qx.ui.form.Button",
{
  extend : qx.ui.basic.Atom,
  include : [qx.ui.core.MExecutable],
  implement : [qx.ui.form.IExecutable],


  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param label {String} label of the atom
   * @param icon {String?null} Icon URL of the atom
   * @param command {qx.ui.command.Command?null} Command instance to connect with
   */
  construct : function(label, icon, command)
  {
    this.base(arguments, label, icon);

    if (command != null) {
      this.setCommand(command);
    }

    // Add listeners
    this.addListener("pointerover", this._onPointerOver);
    this.addListener("pointerout", this._onPointerOut);
    this.addListener("pointerdown", this._onPointerDown);
    this.addListener("pointerup", this._onPointerUp);
    this.addListener("tap", this._onTap);

    this.addListener("keydown", this._onKeyDown);
    this.addListener("keyup", this._onKeyUp);

    // Stop events
    this.addListener("dblclick", function(e) {
      e.stopPropagation();
    });
  },



  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    // overridden
    appearance :
    {
      refine : true,
      init : "button"
    },

    // overridden
    focusable :
    {
      refine : true,
      init : true
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    // overridden
    /**
     * @lint ignoreReferenceField(_forwardStates)
     */
    _forwardStates :
    {
      focused : true,
      hovered : true,
      pressed : true,
      disabled : true
    },


    /*
    ---------------------------------------------------------------------------
      USER API
    ---------------------------------------------------------------------------
    */

    /**
     * Manually press the button
     */
    press : function()
    {
      if (this.hasState("abandoned")) {
        return;
      }

      this.addState("pressed");
    },


    /**
     * Manually release the button
     */
    release : function()
    {
      if (this.hasState("pressed")) {
        this.removeState("pressed");
      }
    },


    /**
     * Completely reset the button (remove all states)
     */
    reset : function()
    {
      this.removeState("pressed");
      this.removeState("abandoned");
      this.removeState("hovered");
    },



    /*
    ---------------------------------------------------------------------------
      EVENT LISTENERS
    ---------------------------------------------------------------------------
    */

    /**
     * Listener method for "pointerover" event
     * <ul>
     * <li>Adds state "hovered"</li>
     * <li>Removes "abandoned" and adds "pressed" state (if "abandoned" state is set)</li>
     * </ul>
     *
     * @param e {qx.event.type.Pointer} Mouse event
     */
    _onPointerOver : function(e)
    {
      if (!this.isEnabled() || e.getTarget() !== this) {
        return;
      }

      if (this.hasState("abandoned"))
      {
        this.removeState("abandoned");
        this.addState("pressed");
      }

      this.addState("hovered");
    },


    /**
     * Listener method for "pointerout" event
     * <ul>
     * <li>Removes "hovered" state</li>
     * <li>Adds "abandoned" and removes "pressed" state (if "pressed" state is set)</li>
     * </ul>
     *
     * @param e {qx.event.type.Pointer} Mouse event
     */
    _onPointerOut : function(e)
    {
      if (!this.isEnabled() || e.getTarget() !== this) {
        return;
      }

      this.removeState("hovered");

      if (this.hasState("pressed"))
      {
        this.removeState("pressed");
        this.addState("abandoned");
      }
    },


    /**
     * Listener method for "pointerdown" event
     * <ul>
     * <li>Removes "abandoned" state</li>
     * <li>Adds "pressed" state</li>
     * </ul>
     *
     * @param e {qx.event.type.Pointer} Mouse event
     */
    _onPointerDown : function(e)
    {
      if (!e.isLeftPressed()) {
        return;
      }

      e.stopPropagation();

      // Activate capturing if the button get a pointerout while
      // the button is pressed.
      this.capture();

      this.removeState("abandoned");
      this.addState("pressed");
    },


    /**
     * Listener method for "pointerup" event
     * <ul>
     * <li>Removes "pressed" state (if set)</li>
     * <li>Removes "abandoned" state (if set)</li>
     * <li>Adds "hovered" state (if "abandoned" state is not set)</li>
     *</ul>
     *
     * @param e {qx.event.type.Pointer} Mouse event
     */
    _onPointerUp : function(e)
    {
      this.releaseCapture();

      // We must remove the states before executing the command
      // because in cases were the window lost the focus while
      // executing we get the capture phase back (mouseout).
      var hasPressed = this.hasState("pressed");
      var hasAbandoned = this.hasState("abandoned");

      if (hasPressed) {
        this.removeState("pressed");
      }

      if (hasAbandoned) {
        this.removeState("abandoned");
      }

      e.stopPropagation();
    },


    /**
     * Listener method for "tap" event which stops the propagation.
     *
     * @param e {qx.event.type.Pointer} Pointer event
     */
    _onTap : function(e) {
      // "execute" is fired here so that the button can be dragged
      // without executing it (e.g. in a TabBar with overflow)
      this.execute();
      e.stopPropagation();
    },


    /**
     * Listener method for "keydown" event.<br/>
     * Removes "abandoned" and adds "pressed" state
     * for the keys "Enter" or "Space"
     *
     * @param e {Event} Key event
     */
    _onKeyDown : function(e)
    {
      switch(e.getKeyIdentifier())
      {
        case "Enter":
        case "Space":
          this.removeState("abandoned");
          this.addState("pressed");
          e.stopPropagation();
      }
    },


    /**
     * Listener method for "keyup" event.<br/>
     * Removes "abandoned" and "pressed" state (if "pressed" state is set)
     * for the keys "Enter" or "Space"
     *
     * @param e {Event} Key event
     */
    _onKeyUp : function(e)
    {
      switch(e.getKeyIdentifier())
      {
        case "Enter":
        case "Space":
          if (this.hasState("pressed"))
          {
            this.removeState("abandoned");
            this.removeState("pressed");
            this.execute();
            e.stopPropagation();
          }
      }
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * This mixin implements the key methods of the {@link qx.ui.window.IDesktop}.
 *
 * @ignore(qx.ui.window.Window)
 * @ignore(qx.ui.window.Window.*)
 */
qx.Mixin.define("qx.ui.window.MDesktop",
{
  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /**
     * The currently active window
     */
    activeWindow :
    {
      check : "qx.ui.window.Window",
      apply : "_applyActiveWindow",
      event : "changeActiveWindow",
      init  : null,
      nullable : true
    }
  },


  events:
  {
    /**
     * Fired when a window was added.
     */
    windowAdded: "qx.event.type.Data",

    /**
     * Fired when a window was removed.
     */
    windowRemoved: "qx.event.type.Data"
  },



  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    __windows : null,
    __manager: null,


    /**
     * Get the desktop's window manager. Each desktop must have a window manager.
     * If none is configured the default window manager {@link qx.ui.window.Window#DEFAULT_MANAGER_CLASS}
     * is used.
     *
     * @return {qx.ui.window.IWindowManager} The desktop's window manager
     */
    getWindowManager : function()
    {
      if (!this.__manager) {
        this.setWindowManager(new qx.ui.window.Window.DEFAULT_MANAGER_CLASS());
      }
      return this.__manager;
    },


    /**
     * Whether the configured layout supports a maximized window
     * e.g. is a Canvas.
     *
     * @return {Boolean} Whether the layout supports maximized windows
     */
    supportsMaximize : function() {
      return true;
    },

    /**
     * Sets the desktop's window manager
     *
     * @param manager {qx.ui.window.IWindowManager} The window manager
     */
    setWindowManager : function(manager)
    {
      if (this.__manager) {
        this.__manager.setDesktop(null);
      }

      manager.setDesktop(this);
      this.__manager = manager;
    },


    /**
     * Event handler. Called if one of the managed windows changes its active
     * state.
     *
     * @param e {qx.event.type.Event} the event object.
     */
    _onChangeActive : function(e)
    {
      if (e.getData()) {
        this.setActiveWindow(e.getTarget());
      } else if (this.getActiveWindow() == e.getTarget()) {
        this.setActiveWindow(null);
      }
    },


    // property apply
    _applyActiveWindow : function(value, old) {
      this.getWindowManager().changeActiveWindow(value, old);
      this.getWindowManager().updateStack();
    },


    /**
     * Event handler. Called if one of the managed windows changes its modality
     *
     * @param e {qx.event.type.Event} the event object.
     */
    _onChangeModal : function(e) {
      this.getWindowManager().updateStack();
    },


    /**
     * Event handler. Called if one of the managed windows changes its visibility
     * state.
     */
    _onChangeVisibility : function() {
      this.getWindowManager().updateStack();
    },


    /**
     * Overrides the method {@link qx.ui.core.Widget#_afterAddChild}
     *
     * @param win {qx.ui.core.Widget} added widget
     */
    _afterAddChild : function(win)
    {
      if (qx.Class.isDefined("qx.ui.window.Window") && win instanceof qx.ui.window.Window) {
        this._addWindow(win);
      }
    },


    /**
     * Handles the case, when a window is added to the desktop.
     *
     * @param win {qx.ui.window.Window} Window, which has been added
     */
    _addWindow : function(win)
    {
      if (!this.getWindows().includes(win))
      {
        this.getWindows().push(win);

        this.fireDataEvent("windowAdded", win);

        win.addListener("changeActive", this._onChangeActive, this);
        win.addListener("changeModal", this._onChangeModal, this);
        win.addListener("changeVisibility", this._onChangeVisibility, this);
      }

      if (win.getActive()) {
        this.setActiveWindow(win);
      }

      this.getWindowManager().updateStack();
    },


    /**
     * Overrides the method {@link qx.ui.core.Widget#_afterRemoveChild}
     *
     * @param win {qx.ui.core.Widget} removed widget
     */
    _afterRemoveChild : function(win)
    {
      if (qx.Class.isDefined("qx.ui.window.Window") && win instanceof qx.ui.window.Window) {
        this._removeWindow(win);
      }
    },


    /**
     * Handles the case, when a window is removed from the desktop.
     *
     * @param win {qx.ui.window.Window} Window, which has been removed
     */
    _removeWindow : function(win)
    {
      if (this.getWindows().includes(win))
      {
        qx.lang.Array.remove(this.getWindows(), win);

        this.fireDataEvent("windowRemoved", win);

        win.removeListener("changeActive", this._onChangeActive, this);
        win.removeListener("changeModal", this._onChangeModal, this);
        win.removeListener("changeVisibility", this._onChangeVisibility, this);

        this.getWindowManager().updateStack();
      }
    },


    /**
     * Get a list of all windows added to the desktop (including hidden windows)
     *
     * @return {qx.ui.window.Window[]} Array of managed windows
     */
    getWindows : function()
    {
      if (!this.__windows) {
        this.__windows = [];
      }
      return this.__windows;
    }
  },





  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    this._disposeArray("__windows");
    this._disposeObjects("__manager");
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * This mixin blocks events and can be included into all widgets.
 *
 * The {@link #block} and {@link #unblock} methods provided by this mixin can be used
 * to block any event from the widget. When blocked,
 * the blocker widget overlays the widget to block, including the padding area.
 *
 * The ({@link #blockContent} method can be used to block child widgets with a
 * zIndex below a certain value.
 */
qx.Mixin.define("qx.ui.core.MBlocker",
{
  properties :
  {
    /**
     * Color of the blocker
     */
    blockerColor  :
    {
      check : "Color",
      init : null,
      nullable: true,
      apply : "_applyBlockerColor",
      themeable: true
    },


    /**
     * Opacity of the blocker
     */
    blockerOpacity :
    {
      check : "Number",
      init : 1,
      apply : "_applyBlockerOpacity",
      themeable: true
    }
  },


  members :
  {
    __blocker : null,


    /**
     * Template method for creating the blocker item.
     * @return {qx.ui.core.Blocker} The blocker to use.
     */
    _createBlocker : function() {
      return new qx.ui.core.Blocker(this);
    },


    // property apply
    _applyBlockerColor : function(value, old) {
      this.getBlocker().setColor(value);
    },


    // property apply
    _applyBlockerOpacity : function(value, old) {
      this.getBlocker().setOpacity(value);
    },

    /**
     * Block all events from this widget by placing a transparent overlay widget,
     * which receives all events, exactly over the widget.
     */
    block : function() {
      this.getBlocker().block();
    },


    /**
     * Returns whether the widget is blocked.
     *
     * @return {Boolean} Whether the widget is blocked.
     */
    isBlocked : function() {
      return this.__blocker && this.__blocker.isBlocked();
    },


    /**
     * Unblock the widget blocked by {@link #block}, but it takes care of
     * the amount of {@link #block} calls. The blocker is only removed if
     * the number of {@link #unblock} calls is identical to {@link #block} calls.
     */
    unblock : function() {
      if (this.__blocker) {
        this.__blocker.unblock();
      }
    },


    /**
     * Unblock the widget blocked by {@link #block}, but it doesn't take care of
     * the amount of {@link #block} calls. The blocker is directly removed.
     */
    forceUnblock : function() {
      if (this.__blocker) {
        this.__blocker.forceUnblock();
      }
    },


    /**
     * Block direct child widgets with a zIndex below <code>zIndex</code>
     *
     * @param zIndex {Integer} All child widgets with a zIndex below this value
     *     will be blocked
     */
    blockContent : function(zIndex) {
      this.getBlocker().blockContent(zIndex);
    },


    /**
     * Get the blocker
     *
     * @return {qx.ui.core.Blocker} The blocker
     */
    getBlocker : function() {
      if (!this.__blocker) {
        this.__blocker = this._createBlocker();
      }
      return this.__blocker;
    }
  },


  destruct : function() {
    this._disposeObjects("__blocker");
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * This class blocks events and can be included into all widgets.
 *
 * The {@link #block} and {@link #unblock} methods provided by this class can be used
 * to block any event from the widget. When blocked,
 * the blocker widget overlays the widget to block, including the padding area.
 *
 * @ignore(qx.ui.root.Abstract)
 */
qx.Class.define("qx.ui.core.Blocker",
{
  extend : qx.core.Object,


  events :
  {
    /**
     * Fires after {@link #block} executed.
     */
    blocked : "qx.event.type.Event",


    /**
     * Fires after {@link #unblock} executed.
     */
    unblocked : "qx.event.type.Event"
  },


  /**
   * Creates a blocker for the passed widget.
   *
   * @param widget {qx.ui.core.Widget} Widget which should be added the blocker
   */
  construct: function(widget)
  {
    this.base(arguments);
    this._widget = widget;

    widget.addListener("resize", this.__onBoundsChange, this);
    widget.addListener("move", this.__onBoundsChange, this);
    widget.addListener("disappear", this.__onWidgetDisappear, this);

    if (qx.Class.isDefined("qx.ui.root.Abstract") &&
        widget instanceof qx.ui.root.Abstract) {
      this._isRoot = true;
      this.setKeepBlockerActive(true);
    }

    // dynamic theme switch
    if (qx.core.Environment.get("qx.dyntheme")) {
      qx.theme.manager.Meta.getInstance().addListener(
        "changeTheme", this._onChangeTheme, this
      );
    }

    this.__activeElements = [];
    this.__focusElements = [];
  },

  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    /**
     * Color of the blocker
     */
    color  :
    {
      check : "Color",
      init : null,
      nullable: true,
      apply : "_applyColor",
      themeable: true
    },


    /**
     * Opacity of the blocker
     */
    opacity :
    {
      check : "Number",
      init : 1,
      apply : "_applyOpacity",
      themeable: true
    },


    /**
     * If this property is enabled, the blocker created with {@link #block}
     * will always stay activated. This means that the blocker then gets all keyboard
     * events, this is useful to block keyboard input on other widgets.
     * Take care that only one blocker instance will be kept active, otherwise your
     * browser will freeze.
     *
     * Setting this property to true is ignored, if the blocker is attached to a
     * widget with a focus handler, as this would mean that the focus handler
     * tries to activate the widget behind the blocker.
     *
     * fixes:
     *     https://github.com/qooxdoo/qooxdoo/issues/9449
     *     https://github.com/qooxdoo/qooxdoo/issues/8104
     */
    keepBlockerActive :
    {
      check : "Boolean",
      init : false
    }
  },





  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    __blocker : null,
    __blockerCount : 0,

    __activeElements  : null,
    __focusElements   : null,

    __timer : null,

    _widget : null,
    _isRoot : false,

    __appearListener : null,


    /**
     * Adjust html element size on layout resizes.
     *
     * @param e {qx.event.type.Data} event object
     */
    __onBoundsChange : function(e)
    {
      var data = e.getData();

      if (this.isBlocked()) {
        this._updateBlockerBounds(data);
      }
    },


    /**
     * Widget re-appears: Update blocker size/position and attach to (new) parent
     */
    __onWidgetAppear : function()
    {
      this._updateBlockerBounds(this._widget.getBounds());
      if (this._widget.isRootWidget()) {
        this._widget.getContentElement().add(this.getBlockerElement());
      } else {
        this._widget.getLayoutParent().getContentElement().add(this.getBlockerElement());
      }
    },


    /**
     * Remove the blocker if the widget disappears
     */
    __onWidgetDisappear : function()
    {
      if (this.isBlocked()) {
        this.getBlockerElement().getParent().remove(this.getBlockerElement());
        this._widget.addListenerOnce("appear", this.__onWidgetAppear, this);
      }
    },


    /**
     * set the blocker's size and position
     * @param bounds {Map} Map with the new width, height, left and top values
     */
    _updateBlockerBounds : function(bounds)
    {
      this.getBlockerElement().setStyles({
        width: bounds.width + "px",
        height: bounds.height + "px",
        left: bounds.left + "px",
        top: bounds.top + "px"
      });
    },


    // property apply
    _applyColor : function(value, old)
    {
      var color = qx.theme.manager.Color.getInstance().resolve(value);
      this.__setBlockersStyle("backgroundColor", color);
    },


    // property apply
    _applyOpacity : function(value, old)
    {
      this.__setBlockersStyle("opacity", value);
    },


    /**
     * Handler for the theme change.
     * @signature function()
     */
    _onChangeTheme : qx.core.Environment.select("qx.dyntheme",
    {
      "true" : function() {
        this._applyColor(this.getColor());
      },
      "false" : null
    }),


    /**
     * Set the style to all blockers (blocker and content blocker).
     *
     * @param key {String} The name of the style attribute.
     * @param value {String} The value.
     */
    __setBlockersStyle : function(key, value)
    {
      var blockers = [];
      this.__blocker && blockers.push(this.__blocker);

      for (var i = 0; i < blockers.length; i++) {
        blockers[i].setStyle(key, value);
      }
    },


    /**
     * Backup the current active and focused widget.
     */
    _backupActiveWidget : function()
    {
      var focusHandler = qx.event.Registration.getManager(window).getHandler(qx.event.handler.Focus);
      var activeWidget = qx.ui.core.Widget.getWidgetByElement(focusHandler.getActive());
      var focusedWidget = qx.ui.core.Widget.getWidgetByElement(focusHandler.getFocus());

      this.__activeElements.push(activeWidget);
      this.__focusElements.push(focusedWidget);

      if (activeWidget) {
        activeWidget.deactivate();
      }

      if (focusedWidget && focusedWidget.isFocusable()) {
        focusedWidget.blur();
      }
    },


    /**
     * Restore the current active and focused widget.
     */
    _restoreActiveWidget : function()
    {
      var widget;

      var focusElementsLength = this.__focusElements.length;
      if (focusElementsLength > 0)       {
        widget = this.__focusElements.pop();

        if (widget && !widget.isDisposed() && widget.isFocusable()) {
          widget.focus();
        }
      }

      var activeElementsLength = this.__activeElements.length;
      if (activeElementsLength > 0) {
        widget = this.__activeElements.pop();

        if (widget && !widget.isDisposed()) {
          widget.activate();
        }
      }
    },


    /**
     * Creates the blocker element.
     *
     * @return {qx.html.Element} The blocker element
     */
    __createBlockerElement : function() {
      return new qx.html.Blocker(this.getColor(), this.getOpacity());
    },


    /**
     * Get/create the blocker element
     *
     * @param widget {qx.ui.core.Widget} The blocker will be added to this
     * widget's content element
     * @return {qx.html.Element} The blocker element
     */
    getBlockerElement : function(widget)
    {
      if (!this.__blocker)
      {
        this.__blocker = this.__createBlockerElement();
        this.__blocker.setStyle("zIndex", 15);

        if (!widget) {
          if (this._isRoot) {
            widget = this._widget;
          } else {
            widget = this._widget.getLayoutParent();
          }
        }

        widget.getContentElement().add(this.__blocker);
        this.__blocker.exclude();
      }
      return this.__blocker;
    },


    /**
     * Block all events from this widget by placing a transparent overlay widget,
     * which receives all events, exactly over the widget.
     */
    block : function()
    {
      this._block();
    },


    /**
     * Adds the blocker to the appropriate element and includes it.
     *
     * @param zIndex {Number} All child widgets with a zIndex below this value will be blocked
     * @param blockContent {Boolean} append the blocker to the widget's content if true
     */
    _block : function(zIndex, blockContent) {
      if (!this._isRoot && !this._widget.getLayoutParent()) {
        this.__appearListener = this._widget.addListenerOnce("appear", this._block.bind(this, zIndex));
        return;
      }

      var parent;
      if (this._isRoot || blockContent) {
        parent = this._widget;
      } else {
        parent = this._widget.getLayoutParent();
      }

      var blocker = this.getBlockerElement(parent);
      if (zIndex != null) {
        blocker.setStyle("zIndex", zIndex);
      }

      this.__blockerCount++;
      if (this.__blockerCount < 2)
      {
        this._backupActiveWidget();

        var bounds = this._widget.getBounds();
        // no bounds -> widget not yet rendered -> bounds will be set on resize
        if (bounds) {
          this._updateBlockerBounds(bounds);
        }

        blocker.include();
        if (!blockContent) {
          blocker.activate();
        }

        blocker.addListener("deactivate", this.__activateBlockerElement, this);
        blocker.addListener("keypress", this.__stopTabEvent, this);
        blocker.addListener("keydown", this.__stopTabEvent, this);
        blocker.addListener("keyup", this.__stopTabEvent, this);

        this.fireEvent("blocked", qx.event.type.Event);
      }
    },


    /**
     * Returns whether the widget is blocked.
     *
     * @return {Boolean} Whether the widget is blocked.
     */
    isBlocked : function() {
      return this.__blockerCount > 0;
    },


    /**
     * Unblock the widget blocked by {@link #block}, but it takes care of
     * the amount of {@link #block} calls. The blocker is only removed if
     * the number of {@link #unblock} calls is identical to {@link #block} calls.
     */
    unblock : function()
    {
      if (this.__appearListener) {
        this._widget.removeListenerById(this.__appearListener);
      }

      if (!this.isBlocked()){
        return;
      }

      this.__blockerCount--;
      if (this.__blockerCount < 1) {
        this.__unblock();
        this.__blockerCount = 0;
      }
    },


    /**
     * Unblock the widget blocked by {@link #block}, but it doesn't take care of
     * the amount of {@link #block} calls. The blocker is directly removed.
     */
    forceUnblock : function()
    {
      if (!this.isBlocked()){
        return;
      }

      this.__blockerCount = 0;
      this.__unblock();
    },


    /**
     * Unblock the widget blocked by {@link #block}.
     */
    __unblock : function()
    {
      this._restoreActiveWidget();

      var blocker = this.getBlockerElement();
      blocker.removeListener("deactivate", this.__activateBlockerElement, this);
      blocker.removeListener("keypress", this.__stopTabEvent, this);
      blocker.removeListener("keydown", this.__stopTabEvent, this);
      blocker.removeListener("keyup", this.__stopTabEvent, this);
      blocker.exclude();

      this.fireEvent("unblocked", qx.event.type.Event);
    },


    /**
     * Block direct child widgets with a zIndex below <code>zIndex</code>
     *
     * @param zIndex {Integer} All child widgets with a zIndex below this value
     *     will be blocked
     */
    blockContent : function(zIndex) {
      this._block(zIndex, true);
    },


    /**
     * Stops the passed "Tab" event.
     *
     * @param e {qx.event.type.KeySequence} event to stop.
     */
    __stopTabEvent : function(e) {
      if (e.getKeyIdentifier() == "Tab") {
        e.stop();
      }
    },


    /**
     * Sets the blocker element to active.
     */
    __activateBlockerElement : function() {
      //
      // If this._widget is attached to the focus handler as a focus root,
      // activating the blocker after this widget was deactivated,
      // leads to the focus handler re-activate the widget behind
      // the blocker, loosing tab handling for this._widget which is
      // visually in front. Hence we prevent activating the
      // blocker in this situation.
      //
      // fixes:
      //  https://github.com/qooxdoo/qooxdoo/issues/9449
      //  https://github.com/qooxdoo/qooxdoo/issues/8104
      //
      if (this.getKeepBlockerActive() &&
          !qx.ui.core.FocusHandler.getInstance().isFocusRoot(this._widget)) {
        this.getBlockerElement().activate();
      }
    }
  },


  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    // remove dynamic theme listener
    if (qx.core.Environment.get("qx.dyntheme")) {
      qx.theme.manager.Meta.getInstance().removeListener(
        "changeTheme", this._onChangeTheme, this
      );
    }

    this._widget.removeListener("resize", this.__onBoundsChange, this);
    this._widget.removeListener("move", this.__onBoundsChange, this);
    this._widget.removeListener("appear", this.__onWidgetAppear, this);
    this._widget.removeListener("disappear", this.__onWidgetDisappear, this);

    if (this.__appearListener) {
      this._widget.removeListenerById(this.__appearListener);
    }

    this._disposeObjects("__blocker", "__timer");
    this.__activeElements = this.__focusElements =
      this._widget = null;
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2009 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * The blocker element is used to block interaction with the application.
 *
 * It is usually transparent or semi-transparent and blocks all events from
 * the underlying elements.
 */
qx.Class.define("qx.html.Blocker",
{
  extend : qx.html.Element,

  /**
   * @param backgroundColor {Color?null} the blocker's background color. This
   *    color can be themed and will be resolved by the blocker.
   * @param opacity {Number?0} The blocker's opacity
   */
  construct : function(backgroundColor, opacity)
  {
    var backgroundColor = backgroundColor ?
        qx.theme.manager.Color.getInstance().resolve(backgroundColor) : null;

    var styles = {
      position: "absolute",
      opacity : opacity || 0,
      backgroundColor : backgroundColor
    };

    // IE needs some extra love here to convince it to block events.
    if ((qx.core.Environment.get("engine.name") == "mshtml"))
    {
      styles.backgroundImage = "url(" + qx.util.ResourceManager.getInstance().toUri("qx/static/blank.gif") + ")";
      styles.backgroundRepeat = "repeat";
    }

    this.base(arguments, "div", styles);

    this.addListener("mousedown", this._stopPropagation, this);
    this.addListener("mouseup", this._stopPropagation, this);
    this.addListener("click", this._stopPropagation, this);
    this.addListener("dblclick", this._stopPropagation, this);
    this.addListener("mousemove", this._stopPropagation, this);
    this.addListener("mouseover", this._stopPropagation, this);
    this.addListener("mouseout", this._stopPropagation, this);
    this.addListener("mousewheel", this._stopPropagation, this);
    this.addListener("roll", this._stopPropagation, this);
    this.addListener("contextmenu", this._stopPropagation, this);
    this.addListener("pointerdown", this._stopPropagation, this);
    this.addListener("pointerup", this._stopPropagation, this);
    this.addListener("pointermove", this._stopPropagation, this);
    this.addListener("pointerover", this._stopPropagation, this);
    this.addListener("pointerout", this._stopPropagation, this);
    this.addListener("tap", this._stopPropagation, this);
    this.addListener("dbltap", this._stopPropagation, this);
    this.addListener("swipe", this._stopPropagation, this);
    this.addListener("longtap", this._stopPropagation, this);
    this.addListener("appear", this.__refreshCursor, this);
    this.addListener("disappear", this.__refreshCursor, this);
  },

  members :
  {
    /**
     * Stop the event propagation from the passed event.
     *
     * @param e {qx.event.type.Mouse} mouse event to stop propagation.
     */
    _stopPropagation : function(e) {
      e.stopPropagation();
    },


    /**
     * Refreshes the cursor by setting it to <code>null</code> and then to the
     * old value.
     */
    __refreshCursor : function() {
      var currentCursor = this.getStyle("cursor");
      this.setStyle("cursor", null, true);
      this.setStyle("cursor", currentCursor, true);
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Andreas Ecker (ecker)

************************************************************************ */

/**
 * Each focus root delegates the focus handling to instances of the FocusHandler.
 */
qx.Class.define("qx.ui.core.FocusHandler",
{
  extend : qx.core.Object,
  type : "singleton",




  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function()
  {
    this.base(arguments);

    // Create data structure
    this.__roots = {};
  },


  /*
  ***********************************************
    PROPERTIES
  ***********************************************
  */
  properties: {
    useTabNavigation: {
      check: 'Boolean',
      init: true
    }
  },


  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    __roots : null,
    __activeChild : null,
    __focusedChild : null,
    __currentRoot : null,


    /**
     * Connects to a top-level root element (which initially receives
     * all events of the root). This are normally all page and application
     * roots, but no inline roots (they are typically sitting inside
     * another root).
     *
     * @param root {qx.ui.root.Abstract} Any root
     */
    connectTo : function(root)
    {
      // this.debug("Connect to: " + root);
      root.addListener("keypress", this.__onKeyPress, this);
      root.addListener("focusin", this._onFocusIn, this, true);
      root.addListener("focusout", this._onFocusOut, this, true);
      root.addListener("activate", this._onActivate, this, true);
      root.addListener("deactivate", this._onDeactivate, this, true);
    },

    /**
     * Registers a widget as a focus root. A focus root comes
     * with an separate tab sequence handling.
     *
     * @param widget {qx.ui.core.Widget} The widget to register
     */
    addRoot : function(widget)
    {
      // this.debug("Add focusRoot: " + widget);
      this.__roots[widget.toHashCode()] = widget;
    },


    /**
     * Deregisters a previous added widget.
     *
     * @param widget {qx.ui.core.Widget} The widget to deregister
     */
    removeRoot : function(widget)
    {
      // this.debug("Remove focusRoot: " + widget);
      delete this.__roots[widget.toHashCode()];
    },


    /**
     * Get the active widget
     *
     * @return {qx.ui.core.Widget|null} The active widget or <code>null</code>
     *    if no widget is active
     */
    getActiveWidget : function() {
      return this.__activeChild;
    },


    /**
     * Whether the given widget is the active one
     *
     * @param widget {qx.ui.core.Widget} The widget to check
     * @return {Boolean} <code>true</code> if the given widget is active
     */
    isActive : function(widget) {
      return this.__activeChild == widget;
    },


    /**
     * Get the focused widget
     *
     * @return {qx.ui.core.Widget|null} The focused widget or <code>null</code>
     *    if no widget has the focus
     */
    getFocusedWidget : function() {
      return this.__focusedChild;
    },


    /**
     * Whether the given widget is the focused one.
     *
     * @param widget {qx.ui.core.Widget} The widget to check
     * @return {Boolean} <code>true</code> if the given widget is focused
     */
    isFocused : function(widget) {
      return this.__focusedChild == widget;
    },


    /**
     * Whether the given widgets acts as a focus root.
     *
     * @param widget {qx.ui.core.Widget} The widget to check
     * @return {Boolean} <code>true</code> if the given widget is a focus root
     */
    isFocusRoot : function(widget) {
      return !!this.__roots[widget.toHashCode()];
    },





    /*
    ---------------------------------------------------------------------------
      EVENT HANDLER
    ---------------------------------------------------------------------------
    */

    /**
     * Internal event handler for activate event.
     *
     * @param e {qx.event.type.Focus} Focus event
     */
    _onActivate : function(e)
    {
      var target = e.getTarget();
      this.__activeChild = target;
      //this.debug("active: " + target);

      var root = this.__findFocusRoot(target);
      if (root != this.__currentRoot) {
        this.__currentRoot = root;
      }
    },


    /**
     * Internal event handler for deactivate event.
     *
     * @param e {qx.event.type.Focus} Focus event
     */
    _onDeactivate : function(e)
    {
      var target = e.getTarget();
      if (this.__activeChild == target) {
        this.__activeChild = null;
      }
    },


    /**
     * Internal event handler for focusin event.
     *
     * @param e {qx.event.type.Focus} Focus event
     */
    _onFocusIn : function(e)
    {
      var target = e.getTarget();
      if (target != this.__focusedChild)
      {
        this.__focusedChild = target;
        target.visualizeFocus();
      }
    },


    /**
     * Internal event handler for focusout event.
     *
     * @param e {qx.event.type.Focus} Focus event
     */
    _onFocusOut : function(e)
    {
      var target = e.getTarget();
      if (target == this.__focusedChild)
      {
        this.__focusedChild = null;
        target.visualizeBlur();
      }
    },


    /**
     * Internal event handler for TAB key.
     *
     * @param e {qx.event.type.KeySequence} Key event
     */
    __onKeyPress : function(e)
    {
      if (e.getKeyIdentifier() != "Tab" || !this.isUseTabNavigation()) {
        return;
      }

      if (!this.__currentRoot) {
        return;
      }

      // Stop all key-events with a TAB keycode
      e.stopPropagation();
      e.preventDefault();

      // Support shift key to reverse widget detection order
      var current = this.__focusedChild;
      if (!e.isShiftPressed()) {
        var next = current ? this.__getWidgetAfter(current) : this.__getFirstWidget();
      } else {
        var next = current ? this.__getWidgetBefore(current) : this.__getLastWidget();
      }

      // If there was a widget found, focus it
      if (next) {
        next.tabFocus();
      }
    },




    /*
    ---------------------------------------------------------------------------
      UTILS
    ---------------------------------------------------------------------------
    */

    /**
     * Finds the next focus root, starting with the given widget.
     *
     * @param widget {qx.ui.core.Widget} The widget to find a focus root for.
     * @return {qx.ui.core.Widget|null} The focus root for the given widget or
     * <code>true</code> if no focus root could be found
     */
    __findFocusRoot : function(widget)
    {
      var roots = this.__roots;
      while (widget)
      {
        if (roots[widget.toHashCode()]) {
          return widget;
        }

        widget = widget.getLayoutParent();
      }

      return null;
    },





    /*
    ---------------------------------------------------------------------------
      TAB SUPPORT IMPLEMENTATION
    ---------------------------------------------------------------------------
    */

    /**
     * Compares the order of two widgets
     *
     * @param widget1 {qx.ui.core.Widget} Widget A
     * @param widget2 {qx.ui.core.Widget} Widget B
     * @return {Integer} A sort() compatible integer with values
     *   small than 0, exactly 0 or bigger than 0.
     */
    __compareTabOrder : function(widget1, widget2)
    {
      if (widget1 === widget2) {
        return 0;
      }

      // Sort-Check #1: Tab-Index
      var tab1 = widget1.getTabIndex() || 0;
      var tab2 = widget2.getTabIndex() || 0;

      if (tab1 != tab2) {
        return tab1 - tab2;
      }

      // Computing location
      var el1 = widget1.getContentElement().getDomElement();
      var el2 = widget2.getContentElement().getDomElement();

      var Location = qx.bom.element.Location;

      var loc1 = Location.get(el1);
      var loc2 = Location.get(el2);

      // Sort-Check #2: Top-Position
      if (loc1.top != loc2.top) {
        return loc1.top - loc2.top;
      }

      // Sort-Check #3: Left-Position
      if (loc1.left != loc2.left) {
        return loc1.left - loc2.left;
      }

      // Sort-Check #4: zIndex
      var z1 = widget1.getZIndex();
      var z2 = widget2.getZIndex();

      if (z1 != z2) {
        return z1 - z2;
      }

      return 0;
    },


    /**
     * Returns the first widget.
     *
     * @return {qx.ui.core.Widget} Returns the first (positioned) widget from
     *    the current root.
     */
    __getFirstWidget : function() {
      return this.__getFirst(this.__currentRoot, null);
    },


    /**
     * Returns the last widget.
     *
     * @return {qx.ui.core.Widget} Returns the last (positioned) widget from
     *    the current root.
     */
    __getLastWidget : function() {
      return this.__getLast(this.__currentRoot, null);
    },


    /**
     * Returns the widget after the given one.
     *
     * @param widget {qx.ui.core.Widget} Widget to start with
     * @return {qx.ui.core.Widget} The found widget.
     */
    __getWidgetAfter : function(widget)
    {
      var root = this.__currentRoot;
      if (root == widget) {
        return this.__getFirstWidget();
      }

      while (widget && widget.getAnonymous()) {
        widget = widget.getLayoutParent();
      }

      if (widget == null) {
        return [];
      }

      var result = [];
      this.__collectAllAfter(root, widget, result);
      result.sort(this.__compareTabOrder);

      var len = result.length;
      return len > 0 ? result[0] : this.__getFirstWidget();
    },


    /**
     * Returns the widget before the given one.
     *
     * @param widget {qx.ui.core.Widget} Widget to start with
     * @return {qx.ui.core.Widget} The found widget.
     */
    __getWidgetBefore : function(widget)
    {
      var root = this.__currentRoot;
      if (root == widget) {
        return this.__getLastWidget();
      }

      while (widget && widget.getAnonymous()) {
        widget = widget.getLayoutParent();
      }

      if (widget == null) {
        return [];
      }

      var result = [];
      this.__collectAllBefore(root, widget, result);
      result.sort(this.__compareTabOrder);

      var len = result.length;
      return len > 0 ? result[len - 1] : this.__getLastWidget();
    },






    /*
    ---------------------------------------------------------------------------
      INTERNAL API USED BY METHODS ABOVE
    ---------------------------------------------------------------------------
    */

    /**
     * Collects all widgets which are after the given widget in
     * the given parent widget. Append all found children to the
     * <code>list</code>.
     *
     * @param parent {qx.ui.core.Widget} Parent widget
     * @param widget {qx.ui.core.Widget} Child widget to start with
     * @param result {Array} Result list
     */
    __collectAllAfter : function(parent, widget, result)
    {
      var children = parent.getLayoutChildren();
      var child;

      for (var i=0, l=children.length; i<l; i++)
      {
        child = children[i];

        // Filter spacers etc.
        if (!(child instanceof qx.ui.core.Widget)) {
          continue;
        }

        if (!this.isFocusRoot(child) && child.isEnabled() && child.isVisible())
        {
          if (child.isTabable() && this.__compareTabOrder(widget, child) < 0) {
            result.push(child);
          }

          this.__collectAllAfter(child, widget, result);
        }
      }
    },


    /**
     * Collects all widgets which are before the given widget in
     * the given parent widget. Append all found children to the
     * <code>list</code>.
     *
     * @param parent {qx.ui.core.Widget} Parent widget
     * @param widget {qx.ui.core.Widget} Child widget to start with
     * @param result {Array} Result list
     */
    __collectAllBefore : function(parent, widget, result)
    {
      var children = parent.getLayoutChildren();
      var child;

      for (var i=0, l=children.length; i<l; i++)
      {
        child = children[i];

        // Filter spacers etc.
        if (!(child instanceof qx.ui.core.Widget)) {
          continue;
        }

        if (!this.isFocusRoot(child) && child.isEnabled() && child.isVisible())
        {
          if (child.isTabable() && this.__compareTabOrder(widget, child) > 0) {
            result.push(child);
          }

          this.__collectAllBefore(child, widget, result);
        }
      }
    },


    /**
     * Find first (positioned) widget. (Sorted by coordinates, zIndex, etc.)
     *
     * @param parent {qx.ui.core.Widget} Parent widget
     * @param firstWidget {qx.ui.core.Widget?null} Current first widget
     * @return {qx.ui.core.Widget} The first (positioned) widget
     */
    __getFirst : function(parent, firstWidget)
    {
      var children = parent.getLayoutChildren();
      var child;

      for (var i=0, l=children.length; i<l; i++)
      {
        child = children[i];

        // Filter spacers etc.
        if (!(child instanceof qx.ui.core.Widget)) {
          continue;
        }

        // Ignore focus roots completely
        if (!this.isFocusRoot(child) && child.isEnabled() && child.isVisible())
        {
          if (child.isTabable())
          {
            if (firstWidget == null || this.__compareTabOrder(child, firstWidget) < 0) {
              firstWidget = child;
            }
          }

          // Deep iteration into children hierarchy
          firstWidget = this.__getFirst(child, firstWidget);
        }
      }

      return firstWidget;
    },


    /**
     * Find last (positioned) widget. (Sorted by coordinates, zIndex, etc.)
     *
     * @param parent {qx.ui.core.Widget} Parent widget
     * @param lastWidget {qx.ui.core.Widget?null} Current last widget
     * @return {qx.ui.core.Widget} The last (positioned) widget
     */
    __getLast : function(parent, lastWidget)
    {
      var children = parent.getLayoutChildren();
      var child;

      for (var i=0, l=children.length; i<l; i++)
      {
        child = children[i];

        // Filter spacers etc.
        if (!(child instanceof qx.ui.core.Widget)) {
          continue;
        }

        // Ignore focus roots completely
        if (!this.isFocusRoot(child) && child.isEnabled() && child.isVisible())
        {
          if (child.isTabable())
          {
            if (lastWidget == null || this.__compareTabOrder(child, lastWidget) > 0) {
              lastWidget = child;
            }
          }

          // Deep iteration into children hierarchy
          lastWidget = this.__getLast(child, lastWidget);
        }
      }

      return lastWidget;
    }
  },




  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    this._disposeMap("__roots");
    this.__focusedChild = this.__activeChild = this.__currentRoot = null;
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * Shared implementation for all root widgets.
 */
qx.Class.define("qx.ui.root.Abstract",
{
  type : "abstract",
  extend : qx.ui.core.Widget,

  include :
  [
    qx.ui.core.MChildrenHandling,
    qx.ui.core.MBlocker,
    qx.ui.window.MDesktop
  ],



  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  construct : function()
  {
    this.base(arguments);

    // Register as root for the focus handler
    qx.ui.core.FocusHandler.getInstance().addRoot(this);

    // Directly add to visibility queue
    qx.ui.core.queue.Visibility.add(this);

    this.initNativeHelp();

    this.addListener("keypress", this.__preventScrollWhenFocused, this);
  },




  /*
  *****************************************************************************
     PROPERTIES
  *****************************************************************************
  */

  properties :
  {
    // overridden
    appearance :
    {
      refine : true,
      init : "root"
    },

    // overridden
    enabled :
    {
      refine : true,
      init : true
    },

    // overridden
    focusable :
    {
      refine : true,
      init : true
    },

    /**
     *  Sets the global cursor style
     *
     *  The name of the cursor to show when the mouse pointer is over the widget.
     *  This is any valid CSS2 cursor name defined by W3C.
     *
     *  The following values are possible:
     *  <ul><li>default</li>
     *  <li>crosshair</li>
     *  <li>pointer (hand is the ie name and will mapped to pointer in non-ie).</li>
     *  <li>move</li>
     *  <li>n-resize</li>
     *  <li>ne-resize</li>
     *  <li>e-resize</li>
     *  <li>se-resize</li>
     *  <li>s-resize</li>
     *  <li>sw-resize</li>
     *  <li>w-resize</li>
     *  <li>nw-resize</li>
     *  <li>text</li>
     *  <li>wait</li>
     *  <li>help </li>
     *  <li>url([file]) = self defined cursor, file should be an ANI- or CUR-type</li>
     *  </ul>
     *
     * Please note that in the current implementation this has no effect in IE.
     */
    globalCursor :
    {
      check : "String",
      nullable : true,
      themeable : true,
      apply : "_applyGlobalCursor",
      event : "changeGlobalCursor"
    },


    /**
     * Whether the native context menu should be globally enabled. Setting this
     * property to <code>true</code> will allow native context menus in all
     * child widgets of this root.
     */
    nativeContextMenu :
    {
      refine : true,
      init : false
    },


    /**
     * If the user presses F1 in IE by default the onhelp event is fired and
     * IEs help window is opened. Setting this property to <code>false</code>
     * prevents this behavior.
     */
    nativeHelp :
    {
      check : "Boolean",
      init : false,
      apply : "_applyNativeHelp"
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {

    __globalCursorStyleSheet : null,

    // overridden
    isRootWidget : function() {
      return true;
    },


    /**
     * Get the widget's layout manager.
     *
     * @return {qx.ui.layout.Abstract} The widget's layout manager
     */
    getLayout : function() {
      return this._getLayout();
    },


    // property apply
    _applyGlobalCursor : qx.core.Environment.select("engine.name",
    {
      "mshtml" : function(value, old) {
        // empty implementation
      },

      // This would be the optimal solution.
      // For performance reasons this is impractical in IE
      "default" : function(value, old)
      {
        var Stylesheet = qx.bom.Stylesheet;

        var sheet = this.__globalCursorStyleSheet;
        if (!sheet) {
          this.__globalCursorStyleSheet = sheet = Stylesheet.createElement();
        }

        Stylesheet.removeAllRules(sheet);

        if (value) {
          Stylesheet.addRule(sheet, "*", qx.bom.element.Cursor.compile(value).replace(";", "") + " !important");
        }
      }
    }),


    // property apply
    _applyNativeContextMenu : function(value, old)
    {
      if (value) {
        this.removeListener("contextmenu", this._onNativeContextMenu, this, true);
      } else {
        this.addListener("contextmenu", this._onNativeContextMenu, this, true);
      }
    },


    /**
     * Stops the <code>contextmenu</code> event from showing the native context menu
     *
     * @param e {qx.event.type.Mouse} The event object
     */
    _onNativeContextMenu : function(e)
    {
      if (e.getTarget().getNativeContextMenu()) {
        return;
      }
      e.preventDefault();
    },


    /**
    * Fix unexpected scrolling when pressing "Space" while a widget is focused.
    *
    * @param e {qx.event.type.KeySequence} The KeySequence event
    */
    __preventScrollWhenFocused: function(e) {
      // Require space pressed
      if (e.getKeyIdentifier() !== "Space") {
        return;
      }

      var target = e.getTarget();

      // Require focused. Allow scroll when container or root widget.
      var focusHandler = qx.ui.core.FocusHandler.getInstance();
      if (!focusHandler.isFocused(target)) {
        return;
      }

      // Require that widget does not accept text input
      var el = target.getContentElement();
      var nodeName = el.getNodeName();
      var domEl = el.getDomElement();
      if (nodeName === "input" || nodeName === "textarea" || (domEl && domEl.contentEditable === "true")) {
        return;
      }

      // do not prevent "space" key for natively focusable elements
      nodeName = qx.dom.Node.getName(e.getOriginalTarget());
      if (nodeName && ["input", "textarea", "select", "a"].indexOf(nodeName) > -1) {
        return;
      }

      // Ultimately, prevent default
      e.preventDefault();
    },


    // property apply
    _applyNativeHelp : function(value, old)
    {
      if (qx.core.Environment.get("event.help")) {
        if (old === false) {
          qx.bom.Event.removeNativeListener(document, "help", (function() {return false;}));
        }

        if (value === false) {
          qx.bom.Event.addNativeListener(document, "help", (function() {return false;}));
        }
      }
    }
  },



  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function() {
    this.__globalCursorStyleSheet = null;
  },




  /*
  *****************************************************************************
     DEFER
  *****************************************************************************
  */

  defer : function(statics, members) {
    qx.ui.core.MChildrenHandling.remap(members);
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)
     * Alexander Steitz (aback)

************************************************************************ */

/**
 * This classes could be used to insert qooxdoo islands into existing
 * web pages. You can use the isles to place any qooxdoo powered widgets
 * inside a layout made using traditional HTML markup and CSS.
 *
 * The size of the widget in each dimension can either be determined by the
 * size hint of the inline's children or by the size of the root DOM element. If
 * <code>dynamicX</code>/<code>dynamicY</code> is true the width/height of the DOM
 * element is used.
 *
 * This class uses {@link qx.ui.layout.Basic} as default layout. The layout
 * can be changed using the {@link #setLayout} method.
 *
 * To position popups and tooltips please have a look at {@link qx.ui.root.Page}.
 *
 * @use(qx.event.handler.ElementResize)
 * @ignore(qx.ui.popup, qx.ui.popup.Manager.*)
 * @ignore(qx.ui.menu, qx.ui.menu.Manager.*)
 */
qx.Class.define("qx.ui.root.Inline",
{
  extend : qx.ui.root.Abstract,
  include : [qx.ui.core.MLayoutHandling],


  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param el {Element} DOM element to use as isle for qooxdoo content. Please
   *    note that existing content gets removed on the first layout flush.
   * @param dynamicX {Boolean} If <code>true</code> the widget's width is
   *    determined by the DOM element's width. Otherwise the children's size hint
   *    is used.
   * @param dynamicY {Boolean} If <code>true</code> the widget's height is
   *    determined by the DOM element's height. Otherwise the children's size hint
   *    is used.
   */
  construct : function(el, dynamicX, dynamicY)
  {
    // check the parameter
    if (qx.core.Environment.get("qx.debug")) {
      this.assertElement(el, "Please use a DOM element to create an inline root.");
    }

    // Temporary storage of element to use
    this.__elem = el;

    // Avoid any problems with dynamic resizing
    el.style.overflow = "hidden";

    // Avoid any problems with broken layout
    el.style.textAlign = "left";

    this.__dynX = dynamicX || false;
    this.__dynY = dynamicY || false;
    this.__initDynamicMode();

    this.base(arguments);

    // Use static layout
    this._setLayout(new qx.ui.layout.Basic());

    // Directly schedule layout for root element
    qx.ui.core.queue.Layout.add(this);

    // Register as root
    qx.ui.core.FocusHandler.getInstance().connectTo(this);

    // Avoid the automatically scroll in to view.
    // See http://bugzilla.qooxdoo.org/show_bug.cgi?id=3236 for details.
    if ((qx.core.Environment.get("engine.name") == "mshtml")) {
      this.setKeepFocus(true);
    }

    // Resize handling for the window
    var window = qx.dom.Node.getWindow(el);
    qx.event.Registration.addListener(window, "resize", this._onWindowResize, this);

    // quick fix for [BUG #7680]
    this.getContentElement().setStyle("-webkit-backface-visibility", "hidden");
  },


  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    __dynX : false,
    __dynY : false,
    __elem : null,


    /**
     * Performs several checks for dynamic mode and adds the "resize" listener
     */
    __initDynamicMode : function()
    {
      if (this.__dynX || this.__dynY)
      {
        // Check the DOM element for an usable width and height
        var elementDimensions = qx.bom.element.Dimension.getSize(this.__elem);

        if (this.__dynX && elementDimensions.width < 1) {
          throw new Error("The root element " + this.__elem + " of " + this +
            " needs a width when its width size should be used!");
        }

        if (this.__dynY)
        {
          if (elementDimensions.height < 1) {
            throw new Error("The root element " + this.__elem + " of " + this +
            " needs a height when its height size should be used!");
          }

          // check for implicit height. Set the height explicit to prevent that
          // the element grows indefinitely
          if (elementDimensions.height >= 1 &&
              qx.bom.element.Style.get(this.__elem, "height", 3) == "") {
            qx.bom.element.Style.set(this.__elem, "height", elementDimensions.height + "px");
          }
        }

        qx.event.Registration.addListener(this.__elem, "resize", this._onResize, this);
      }
    },


    // overridden
    _createContentElement : function()
    {
      var el = this.__elem;

      if (this.__dynX || this.__dynY)
      {
        var rootEl = document.createElement("div");
        el.appendChild(rootEl);
      } else {
        rootEl = el;
      }

      var root = new qx.html.Root(rootEl);

      // Make relative
      rootEl.style.position = "relative";

      // Store reference to the widget in the DOM element.
      root.connectWidget(this);

      // fire event asynchronously, otherwise the browser will fire the event
      // too early and no listener will be informed since they're not added
      // at this time
      qx.event.Timer.once(function(e) {
        this.fireEvent("appear");
      }, this, 0);

      return root;
    },


    /**
     * Listener for the element's resize event
     *
     * @param e {qx.event.type.Event} Event object
     */
    _onResize : function(e)
    {
      var data = e.getData();
      if (
        (data.oldWidth !== data.width) && this.__dynX ||
        (data.oldHeight !== data.height) && this.__dynY
      ) {
        qx.ui.core.queue.Layout.add(this);
      }
    },


    /**
     * Listener for the window's resize event.
     */
    _onWindowResize : function() {
      // close all popups
      if (qx.ui.popup && qx.ui.popup.Manager) {
        qx.ui.popup.Manager.getInstance().hideAll();
      }

      // close all menus
      if (qx.ui.menu && qx.ui.menu.Manager) {
        qx.ui.menu.Manager.getInstance().hideAll();
      }
    },


    // overridden
    _computeSizeHint : function()
    {
      var dynX = this.__dynX;
      var dynY = this.__dynY;

      if (!dynX || !dynY) {
        var hint = this.base(arguments);
      } else {
        hint = {};
      }

      var Dimension = qx.bom.element.Dimension;

      if (dynX)
      {
        var width = Dimension.getContentWidth(this.__elem);
        hint.width = width;
        hint.minWidth = width;
        hint.maxWidth = width;
      }

      if (dynY)
      {
        var height = Dimension.getContentHeight(this.__elem);
        hint.height = height;
        hint.minHeight = height;
        hint.maxHeight = height;
      }

      return hint;
    }
  },





  /*
  *****************************************************************************
     DEFER
  *****************************************************************************
  */

  defer : function(statics, members) {
    qx.ui.core.MLayoutHandling.remap(members);
  },


  /*
  *****************************************************************************
     DESTRUCT
  *****************************************************************************
  */

  destruct : function()
  {
    qx.event.Registration.removeListener(this.__elem, "resize", this._onResize, this);
    this.__elem = null;
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2007-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * This handler fires a <code>resize</code> event if the size of a DOM element
 * changes.
 * 
 * NOTE: Instances of this class must be disposed of after use
 *
 */
qx.Class.define("qx.event.handler.ElementResize",
{
  extend : qx.core.Object,
  implement : [ qx.event.IEventHandler, qx.core.IDisposable ],



  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * @param manager {qx.event.Manager} Event manager for the window to use
   */
  construct : function(manager)
  {
    this.base(arguments);

    this.__manager = manager;
    this.__elements = {};

    this.__timer = new qx.event.Timer(200);
    this.__timer.addListener("interval", this._onInterval, this);
  },




  /*
  *****************************************************************************
     STATICS
  *****************************************************************************
  */

  statics :
  {
    /** @type {Integer} Priority of this handler */
    PRIORITY : qx.event.Registration.PRIORITY_NORMAL,


    /** @type {Map} Supported event types */
    SUPPORTED_TYPES :
    {
      resize : true
    },


    /** @type {Integer} Which target check to use */
    TARGET_CHECK : qx.event.IEventHandler.TARGET_DOMNODE,


    /** @type {Integer} Whether the method "canHandleEvent" must be called */
    IGNORE_CAN_HANDLE : false
  },





  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    __elements : null,
    __manager : null,
    __timer : null,


    /*
    ---------------------------------------------------------------------------
      EVENT HANDLER INTERFACE
    ---------------------------------------------------------------------------
    */

    // interface implementation
    canHandleEvent : function(target, type) {
      return target.tagName.toLowerCase() !== "body";
    },


    // interface implementation
    registerEvent : function(target, type, capture)
    {
      var hash = qx.core.ObjectRegistry.toHashCode(target);

      var elements = this.__elements;
      if (!elements[hash])
      {
        elements[hash] = {
          element: target,
          width: qx.bom.element.Dimension.getWidth(target),
          height: qx.bom.element.Dimension.getHeight(target)
        };
        this.__timer.start();
      }
    },


    // interface implementation
    unregisterEvent : function(target, type, capture)
    {
      var hash = qx.core.ObjectRegistry.toHashCode(target);

      var elements = this.__elements;
      if (elements[hash])
      {
        delete elements[hash];

        if (qx.lang.Object.isEmpty(elements)) {
          this.__timer.stop();
        }
      }
    },


    /**
     * Checks elements for width and height changes and fires resize event
     * if needed.
     *
     * @param e {qx.event.type.Data} The incoming data event
     */
    _onInterval : function(e)
    {
      var elements = this.__elements;
      for (var key in elements)
      {
        var data = elements[key];

        var el = data.element;
        var width = qx.bom.element.Dimension.getWidth(el);
        var height = qx.bom.element.Dimension.getHeight(el);

        if (data.height !== height || data.width !== width)
        {
          qx.event.Registration.fireNonBubblingEvent(
            el,
            "resize",
            qx.event.type.Data,
            [{
              width: width,
              oldWidth: data.width,
              height: height,
              oldHeight: data.height
            }]
          );

          data.width = width;
          data.height = height;
        }
      }
    }
  },





  /*
  *****************************************************************************
     DESTRUCTOR
  *****************************************************************************
  */

  destruct : function()
  {
    this.__manager = this.__elements = null;
    this._disposeObjects("__timer");
  },






  /*
  *****************************************************************************
     DEFER
  *****************************************************************************
  */

  defer : function(statics) {
    qx.event.Registration.addHandler(statics);
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)
     * Fabian Jakobs (fjakobs)

************************************************************************ */

/**
 * A basic layout, which supports positioning of child widgets by absolute
 * left/top coordinates. This layout is very simple but should also
 * perform best.
 *
 * *Features*
 *
 * * Basic positioning using <code>left</code> and <code>top</code> properties
 * * Respects minimum and maximum dimensions without shrinking/growing
 * * Margins for top and left side (including negative ones)
 * * Respects right and bottom margins in the size hint
 * * Auto-sizing
 *
 * *Item Properties*
 *
 * <ul>
 * <li><strong>left</strong> <em>(Integer)</em>: The left coordinate in pixel</li>
 * <li><strong>top</strong> <em>(Integer)</em>: The top coordinate in pixel</li>
 * </ul>
 *
 * *Details*
 *
 * The default location of any widget is zero for both
 * <code>left</code> and <code>top</code>.
 *
 * *Example*
 *
 * Here is a little example of how to use the basic layout.
 *
 * <pre class="javascript">
 * var container = new qx.ui.container.Composite(new qx.ui.layout.Basic());
 *
 * // simple positioning
 * container.add(new qx.ui.core.Widget(), {left: 10, top: 10});
 * container.add(new qx.ui.core.Widget(), {left: 100, top: 50});
 * </pre>
 *
 * *External Documentation*
 *
 * <a href='http://manual.qooxdoo.org/${qxversion}/pages/layout/basic.html'>
 * Extended documentation</a> and links to demos of this layout in the qooxdoo manual.
 */
qx.Class.define("qx.ui.layout.Basic",
{
  extend : qx.ui.layout.Abstract,



  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /*
    ---------------------------------------------------------------------------
      LAYOUT INTERFACE
    ---------------------------------------------------------------------------
    */

    // overridden
    verifyLayoutProperty : qx.core.Environment.select("qx.debug",
    {
      "true" : function(item, name, value)
      {
        this.assert(name == "left" || name == "top", "The property '"+name+"' is not supported by the Basic layout!");
        this.assertInteger(value);
      },

      "false" : null
    }),


    // overridden
    renderLayout : function(availWidth, availHeight, padding)
    {
      var children = this._getLayoutChildren();
      var child, size, props, left, top;

      // Render children
      for (var i=0, l=children.length; i<l; i++)
      {
        child = children[i];
        size = child.getSizeHint();
        props = child.getLayoutProperties();

        left = padding.left + (props.left || 0) + child.getMarginLeft();
        top = padding.top + (props.top || 0) + child.getMarginTop();

        child.renderLayout(left, top, size.width, size.height);
      }
    },


    // overridden
    _computeSizeHint : function()
    {
      var children = this._getLayoutChildren();
      var child, size, props;
      var neededWidth=0, neededHeight=0;
      var localWidth, localHeight;


      // Iterate over children
      for (var i=0, l=children.length; i<l; i++)
      {
        child = children[i];
        size = child.getSizeHint();
        props = child.getLayoutProperties();

        localWidth = size.width + (props.left || 0) + child.getMarginLeft() + child.getMarginRight();
        localHeight = size.height + (props.top || 0) + child.getMarginTop() + child.getMarginBottom();

        if (localWidth > neededWidth) {
          neededWidth = localWidth;
        }

        if (localHeight > neededHeight) {
          neededHeight = localHeight;
        }
      }


      // Return hint
      return {
        width : neededWidth,
        height : neededHeight
      };
    }
  }
});
/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Sebastian Werner (wpbasti)

************************************************************************ */

/**
 * This is the root element for a set of {@link qx.html.Element}s.
 *
 * To make other elements visible these elements must be inserted
 * into an root element at any level.
 *
 * A root element uses an existing DOM element where is assumed that
 * this element is always visible. In the easiest case, the root element
 * is identical to the document's body.
 */
qx.Class.define("qx.html.Root",
{
  extend : qx.html.Element,



  /*
  *****************************************************************************
     CONSTRUCTOR
  *****************************************************************************
  */

  /**
   * Creates a root element
   *
   * @param elem {Element?null} DOM element to use
   */
  construct : function(elem)
  {
    this.base(arguments);

    if (elem != null) {
      this.useElement(elem);
    }
  },




  /*
  *****************************************************************************
     MEMBERS
  *****************************************************************************
  */

  members :
  {
    /**
     * Sets the element to an already existing node. It will be
     * assumed that this DOM element is already visible e.g.
     * like a normal displayed element in the document's body.
     *
     * @param elem {Element} the dom element to set
     * @throws {Error} if the element is assigned again
     */
    useElement : function(elem)
    {
      // Base call
      this.base(arguments, elem);

      // Mark as root
      this.setRoot(true);

      // Register for synchronization
      qx.html.Element._modified[this.toHashCode()] = this;
    }
  }
});
/* ************************************************************************

  OSparc Dark Theme for Qooxdoo

  Copyright:
     2018 IT'IS Foundation

  License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

  Authors:
    * Tobias Oetiker (oetiker)

  Origin:
    This theme is based in large parts on the the Simple
    theme included with Qooxdoo.
************************************************************************ */
/**
 * Simple color theme
 */
qx.Theme.define("osparc.theme.osparcdark.Color", {
  colors: {
    // main
    "background-main": "#202020",
    "light-background": "#444",

    // window
    "window-caption-background": "background-main",
    "window-caption-background-active": "light-background",
    "window-caption-text": "text",
    "window-caption-text-active": "text-selected",

    // material-button
    "material-button-background": "#404040",
    "material-button-background-disabled": "#303030",
    "material-button-background-hovered": "#505050",
    "material-button-background-pressed": "#505050",
    "material-button-text-disabled": "text-disabled",
    "material-button-text": "text",
    // material-textfield
    "material-textfield": "#808080",
    "material-textfield-focused": "#e0e0e0",
    "material-textfield-disabled": "#555",
    "material-textfield-invalid": "#a04040",
    "invalid":"material-textfield-invalid",

    // backgrounds
    "background-selected": "#555",
    "background-selected-disabled": "#333",
    "background-selected-dark": "#444",
    "background-disabled": "background-main",
    "background-disabled-checked": "#333",
    "background-pane": "#222",

    // tabview
    "tabview-unselected": "#ffffff",
    "tabview-button-border": "#ffffff",
    "tabview-label-active-disabled": "#d9d9d9",
    "tabview-pane-background": "background-pane",
    "tabview-button-background": "transparent",
    // text colors
    "link": "#aaa",

    // scrollbar
    "scrollbar-passive": "#333",
    "scrollbar-active": "#444",

    // form
    "button": "#555",
    "button-border": "#666",
    "button-border-hovered": "#888",
    "button-box": "#444",
    "button-box-pressed": "#555",
    "border-lead": "#888888",

    // window
    "window-border": "#444",
    "window-border-inner": "#222",

    // group box
    "white-box-border": "#404040",

    // shadows
    "shadow": qx.core.Environment.get("css.rgba") ? "rgba(0, 0, 0, 0.4)" : "#666666",

    // borders
    // 'border-main' is an alias of 'background-selected' (compatibility reasons)
    "border": "#484848",
    "border-focused": "#B7B7B7",
    "border-invalid": "material-textfield-invalid",
    "border-disabled": "#222",

    // separator
    "border-separator": "#808080",


    // text
    "text": "#bfbfbf",
    "text-disabled": "#808080",
    "text-selected": "#f0f0f0",
    "text-placeholder": "#404040",

    // tooltip
    "tooltip": "#808080",
    "tooltip-text": "#f0f0f0",

    // table
    "table-header": "background-main",
    "table-header-foreground": "text",
    "table-header-border": "#888",
    "table-focus-indicator": "#757575",

    // used in table code
    "table-header-cell": "#202020",
    "table-row-background-focused-selected": "#565656",
    "table-row-background-focused": "#454545",
    "table-row-background-selected": "#565656",
    "table-row-background-even": "#202020",
    "table-row-background-odd": "#303030",
    // foreground
    "table-row-selected": "#f0f0f0",
    "table-row": "#bfbfbf",
    // table grid color
    "table-row-line": "#222",
    "table-column-line": "#222",

    // used in progressive code
    "progressive-table-header": "#AAAAAA",
    "progressive-table-row-background-even": "#202020",
    "progressive-table-row-background-odd": "#303030",
    "progressive-progressbar-background": "#000",
    "progressive-progressbar-indicator-done": "#222",
    "progressive-progressbar-indicator-undone": "#333",
    "progressive-progressbar-percent-background": "#000",
    "progressive-progressbar-percent-text": "#333"
  }
});
