{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/source/class/cv/ui/manager/model/schema/SimpleType.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "cv",
    "ui",
    "manager",
    "model",
    "schema",
    "Base",
    "construct",
    "node",
    "__enumerations",
    "__pattern",
    "__regexCache",
    "__bases",
    "parse",
    "properties",
    "type",
    "refine",
    "init",
    "optional",
    "check",
    "baseType",
    "nullable",
    "members",
    "getNode",
    "setOptional",
    "getAttribute",
    "__fillNodeData",
    "getSchema",
    "hasAttribute",
    "refName",
    "getReferencedNode",
    "match",
    "subnode",
    "setBaseType",
    "subNodes",
    "Array",
    "from",
    "querySelectorAll",
    "forEach",
    "subNode",
    "patternNode",
    "push",
    "enumerationNode",
    "getBaseType",
    "isValueValid",
    "value",
    "isOptional",
    "search",
    "typeNode",
    "getTypeNode",
    "subType",
    "SimpleType",
    "length",
    "includes",
    "boolValid",
    "item",
    "hasOwnProperty",
    "branchIndices",
    "start",
    "i",
    "indexOf",
    "isRootBranch",
    "j",
    "branches",
    "map",
    "entry",
    "substr",
    "replace",
    "regexFromString",
    "join",
    "test",
    "getEnumeration",
    "destruct"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/**\n * a single SimpleType from the schema.\n * Should be useable for SimpleContent, too.\n * Is usable for attributes, too.\n */\nqx.Class.define('cv.ui.manager.model.schema.SimpleType', {\n  extend: cv.ui.manager.model.schema.Base,\n\n  /*\n  ***********************************************\n    CONSTRUCTOR\n  ***********************************************\n  */\n  construct: function (node, schema) {\n    this.base(arguments, node, schema);\n    this.__enumerations = [];\n    this.__pattern = [];\n    this.__regexCache = {};\n    this.__bases = [];\n    this.parse();\n  },\n\n  /*\n  ***********************************************\n    PROPERTIES\n  ***********************************************\n  */\n  properties: {\n    type: {\n      refine: true,\n      init: 'simpleType'\n    },\n    optional: {\n      check: 'Boolean',\n      init: false\n    },\n\n    /**\n     * the baseType of this element, which is one of the xsd-namespaced types (like 'string')\n     * @var string\n     */\n    baseType: {\n      check: 'String',\n      nullable: true\n    }\n  },\n\n  /*\n  ***********************************************\n    MEMBERS\n  ***********************************************\n  */\n  members: {\n    __pattern: null,\n    __enumerations: null,\n    __bases: null,\n    __regexCache: null,\n\n    parse: function () {\n      const node = this.getNode();\n      this.setOptional(node.getAttribute('use') === 'required');\n      this.__fillNodeData(node);\n    },\n\n    /**\n     * parse a node, find it's data (restrictions, extensions, bases ... whatever)\n     *\n     * @param   node    DOMNode the node to parse\n     */\n    __fillNodeData: function (node) {\n      const schema = this.getSchema();\n\n      if (node.hasAttribute('ref')) {\n        // it's a ref, seek other element!\n        const refName = node.getAttribute('ref');\n        node = schema.getReferencedNode('attribute', refName);\n\n        if (!node) {\n          throw 'schema/xsd appears to be invalid, can not find element ' + refName;\n        }\n      }\n\n      if (node.hasAttribute('type')) {\n        // hacked: allow this to be used for attributes\n        const baseType = node.getAttribute('type');\n\n        if (!baseType.match(/^xsd:/)) {\n          // if it's not an xsd-default-basetype, we need to find out what it is\n          const subnode = schema.getReferencedNode('simpleType', baseType)\n          this.__fillNodeData(subnode);\n        } else {\n          this.setBaseType(baseType);\n        }\n        // is this attribute optional?\n        this.setOptional(node.getAttribute('use') !== 'required');\n\n        return;\n      }\n\n      const subNodes = Array.from(node.querySelectorAll(':scope > restriction, :scope > extension, :scope > simpleType > restriction, :scope > simpleType > extension'));\n\n      subNodes.forEach( (subNode) => {\n        const baseType = subNode.getAttribute('base');\n\n        if (!baseType.match(/^xsd:/)) {\n          // don't dive in for default-types, they simply can not be found\n          const subnode = schema.getReferencedNode('simpleType', baseType)\n          this.__fillNodeData(subnode);\n        } else {\n          this.setBaseType(baseType);\n        }\n        Array.from(subNode.querySelectorAll(':scope > pattern')).forEach((patternNode) => {\n          this.__pattern.push(patternNode.getAttribute('value'));\n        });\n\n        Array.from(subNode.querySelectorAll(':scope > enumeration')).forEach((enumerationNode) => {\n          this.__enumerations.push(enumerationNode.getAttribute('value'));\n        });\n      });\n\n      if (!this.getBaseType()) {\n        this.setBaseType('xsd:anyType');\n      }\n      this.__bases.push(this.getBaseType());\n    },\n\n    /**\n     * check if a given value is valid for this type\n     *\n     * @param   value   mixed   the value to check\n     * @return  boolean         if the value is valid\n     */\n    isValueValid: function (value) {\n      const baseType = this.getBaseType();\n      const schema = this.getSchema();\n      if (!baseType) {\n        throw 'something is wrong, do not have a baseType for type';\n      }\n\n      if (value === '') {\n        // empty values are valid if this node is optional!\n        return this.isOptional();\n      }\n\n      if (-1 === baseType.search(/^xsd:/)) {\n        // created our own type, will need to find and use it.\n        const typeNode = schema.getTypeNode('simple', baseType);\n        const subType = new cv.ui.manager.model.schema.SimpleType(typeNode, schema);\n        return subType.isValueValid(value);\n      } else {\n        // xsd:-namespaces types, those are the originals\n        switch (baseType) {\n          case 'xsd:string':\n          case 'xsd:anyURI':\n          case 'xsd:anyType':\n            if (!(typeof(value) == 'string')) {\n              // it's not a string, but it should be.\n              // pretty much any input a user gives us is string, so this is pretty much moot.\n              return false;\n            }\n            break;\n          case 'xsd:decimal':\n            if (!value.match(/^[-+]?[0-9]*(\\.[0-9]+)?$/)) {\n              return false;\n            }\n            break;\n          case 'xsd:unsignedByte':\n          case 'xsd:nonNegativeInteger':\n            if (!value.match(/^[+]?[0-9]+$/)) {\n              return false;\n            }\n            break;\n          case 'xsd:integer':\n            if (!value.match(/^[-+]?[0-9]+$/)) {\n              return false;\n            }\n            break;\n          case 'xsd:float':\n            if (!value.match(/^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$/)) {\n              return false;\n            }\n            break;\n          case 'xsd:boolean':\n            if (!value.match(/^(true|false|0|1)$/)) {\n              return false;\n            }\n            break;\n          default:\n            throw 'not implemented baseType ' + baseType;\n        }\n      }\n\n      // check if the value is in our list of valid values, if there is such a list\n      if (this.__enumerations.length > 0) {\n        if (!this.__enumerations.includes(value)) {\n          return false;\n        }\n      }\n\n      // check if the value matches any given pattern\n      if (this.__pattern.length > 0) {\n        // start with assuming it's valid\n        let boolValid = true;\n\n        this.__pattern.forEach((item) => {\n          if (!this.__regexCache.hasOwnProperty(item)) {\n            // create a regex from the pattern; mind ^ an $ - XSD has them implicitly (XSD Datatypes, Appendix G)\n            // so for our purpose, we need to add them for every branch (that is not inside [])\n            const branchIndices = []\n            let start = 0;\n            let i = item.indexOf(\"|\", start);\n            while (i < item.length) {\n              if (i < 0) {\n                break;\n              }\n              // go backwards and look for an [ stop looking on ]\n              let isRootBranch = true;\n              for (let j = i; j >= start; j--) {\n                if (item[j] === ']') {\n                  break;\n                } else if (item[j] === '[') {\n                  isRootBranch = false;\n                }\n              }\n              if (isRootBranch) {\n                branchIndices.push([start, i - start]);\n              }\n              start = i + 1;\n              i = item.indexOf('|', start);\n              if (branchIndices.length > 100) debugger;\n            }\n            if (item.length > start) {\n              // append the rest\n              branchIndices.push([start, item.length - start]);\n            }\n            const branches = branchIndices.map((entry) => `^${item.substr(entry[0], entry[1]).replace(/\\\\([\\s\\S])|(\\$)/g, '\\\\$1$2')}$`);\n            this.__regexCache[item] = this.regexFromString(branches.join(\"|\"));\n          }\n\n          if (false === this.__regexCache[item].test(value)) {\n            // regular expression did not match\n            // bad bad value!\n            boolValid = false;\n          }\n        }, this);\n\n        // if the value has been marked invalid by a regex, return invalid.\n        if (false === boolValid) {\n          return false;\n        }\n      }\n\n      // if no check said the value is invalid, then it is not invalid\n      return true;\n    },\n\n    /**\n     * get this elements enumeration (if there is any)\n     *\n     * @return  array   list of allowed values (if there are any)\n     */\n    getEnumeration: function () {\n      if (this.getBaseType() === 'xsd:boolean') {\n        // special handling for boolean, as we KNOW it to be an enumeration\n        return ['true', 'false'];\n      }\n\n      return this.__enumerations;\n    }\n  },\n\n  /*\n  ***********************************************\n    DESTRUCTOR\n  ***********************************************\n  */\n  destruct: function () {\n    this.__regexCache = null;\n  }\n});\n"
  ]
}