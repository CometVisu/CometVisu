{
  "version": 3,
  "sources": [
    "/home/travis/build/CometVisu/CometVisu/external/qooxdoo/framework/source/class/qx/util/DeferredCallManager.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "type",
    "implement",
    "IDisposable",
    "construct",
    "__calls",
    "__timeoutWrapper",
    "lang",
    "Function",
    "bind",
    "__timeout",
    "__hasCalls",
    "members",
    "__timeoutId",
    "__currentQueue",
    "schedule",
    "deferredCall",
    "window",
    "setTimeout",
    "callKey",
    "toHashCode",
    "refreshTimeout",
    "cancel",
    "isEmpty",
    "clearTimeout",
    "event",
    "GlobalError",
    "observeMethod",
    "clone",
    "key",
    "call",
    "destruct",
    "util",
    "DeferredCallManager"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * This class manages the timer used for deferred calls. All\n * {@link qx.util.DeferredCall} instances use the single timer from this class.\n * \n * NOTE: Instances of this class must be disposed of after use\n *\n */\nqx.Class.define(\"qx.util.DeferredCallManager\",\n{\n  extend : qx.core.Object,\n  type : \"singleton\",\n  implement : [ qx.core.IDisposable ],\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  construct : function()\n  {\n    this.__calls = {};\n    this.__timeoutWrapper = qx.lang.Function.bind(this.__timeout, this);\n    this.__hasCalls = false;\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n    __timeoutId : null,\n    __currentQueue : null,\n    __calls : null,\n    __hasCalls : null,\n    __timeoutWrapper : null,\n\n\n    /**\n     * Schedule a deferred call\n     *\n     * @param deferredCall {qx.util.DeferredCall} The call to schedule\n     */\n    schedule : function(deferredCall)\n    {\n      if (this.__timeoutId == null)\n      {\n        this.__timeoutId = window.setTimeout(this.__timeoutWrapper, 0);\n      }\n\n      var callKey = deferredCall.toHashCode();\n\n      // the flush is currently running and the call is already\n      // scheduled\n      if (this.__currentQueue && this.__currentQueue[callKey]) {\n        return;\n      }\n\n      this.__calls[callKey] = deferredCall;\n      this.__hasCalls = true;\n    },\n\n    /**\n     * Refresh the timeout if the current one is not active anymore.\n     * This is a very special case which can happen in unit tests using\n     * fakeTimers, which overrides the window.setTimeout function (amongst others)\n     * after restoring the sinon sandbox the timeout must be refreshed otherwise\n     * DeferredCalls would never fire.\n     */\n    refreshTimeout : function() {\n      if (this.__timeoutId !== null) {\n        this.__timeoutId = window.setTimeout(this.__timeoutWrapper, 0);\n      }\n    },\n\n    /**\n     * Cancel a scheduled deferred call\n     *\n     * @param deferredCall {qx.util.DeferredCall} The call to schedule\n     */\n    cancel : function(deferredCall)\n    {\n      var callKey = deferredCall.toHashCode();\n\n      // the flush is currently running and the call is already\n      // scheduled -> remove it from the current queue\n      if(this.__currentQueue && this.__currentQueue[callKey])\n      {\n        this.__currentQueue[callKey] = null;\n        return;\n      }\n\n      delete this.__calls[callKey];\n\n      // stop timer if no other calls are waiting\n      if(qx.lang.Object.isEmpty(this.__calls) && this.__timeoutId != null)\n      {\n        window.clearTimeout(this.__timeoutId);\n        this.__timeoutId = null;\n      }\n    },\n\n\n    /**\n     * Helper function for the timer.\n     *\n     * @signature function()\n     */\n    __timeout : qx.event.GlobalError.observeMethod(function()\n    {\n      this.__timeoutId = null;\n\n      // the queue may change while doing the flush so we work on a copy of\n      // the queue and loop while the queue has any entries.\n      while(this.__hasCalls)\n      {\n        this.__currentQueue = qx.lang.Object.clone(this.__calls);\n        this.__calls = {};\n        this.__hasCalls = false;\n\n        for (var key in this.__currentQueue)\n        {\n          var call = this.__currentQueue[key];\n          if (call)\n          {\n            this.__currentQueue[key] = null;\n            call.call();\n          }\n        }\n      }\n\n      this.__currentQueue = null;\n    })\n\n  },\n\n\n  /*\n  *****************************************************************************\n     DESTRUCTOR\n  *****************************************************************************\n  */\n\n  destruct : function()\n  {\n    if (this.__timeoutId != null) {\n      window.clearTimeout(this.__timeoutId);\n    }\n    this.__timeoutWrapper = this.__calls = null;\n  }\n});\n"
  ]
}