{
  "version": 3,
  "sources": [
    "/home/travis/build/CometVisu/CometVisu/external/qooxdoo/framework/source/class/qx/event/message/Bus.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "type",
    "extend",
    "core",
    "Object",
    "statics",
    "getSubscriptions",
    "getInstance",
    "subscribe",
    "message",
    "subscriber",
    "context",
    "checkSubscription",
    "unsubscribe",
    "dispatch",
    "msg",
    "apply",
    "arguments",
    "dispatchByName",
    "name",
    "data",
    "construct",
    "__subscriptions",
    "members",
    "error",
    "sub",
    "warn",
    "push",
    "length",
    "i",
    "subscrList",
    "subscription",
    "splice",
    "msgName",
    "getName",
    "dispatched",
    "key",
    "pos",
    "indexOf",
    "substr",
    "__callSubscribers",
    "event",
    "Message",
    "ret",
    "dispose",
    "subscribers",
    "slice",
    "isDisposed",
    "call",
    "Bus"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007 Christian Boulanger\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Christian Boulanger\n\n************************************************************************ */\n\n/**\n * A simple message bus singleton.\n * The message bus registers subscriptions and notifies subscribers when\n * a matching message is dispatched\n */\nqx.Class.define(\"qx.event.message.Bus\",\n{\n  type : \"singleton\",\n\n  extend : qx.core.Object,\n\n  statics :\n  {\n\n    /**\n     * gets the hash map of message subscriptions\n     *\n     * @return {Map} with registered subscriptions. The key is the\n     *    <code>message</code> and the value is a map with <code>{subscriber: {Function},\n     *    context: {Object|null}}</code>.\n     */\n    getSubscriptions : function() {\n      return this.getInstance().getSubscriptions();\n    },\n\n\n    /**\n     * subscribes to a message\n     *\n     * @param message {String} name of message, can be truncated by *\n     * @param subscriber {Function} subscribing callback function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Success\n     */\n    subscribe : function(message, subscriber, context)\n    {\n      return this.getInstance().subscribe(message, subscriber, context);\n\n    },\n\n    /**\n     * checks if subscription is already present\n     * if you supply the callback function, match only the exact message monitor\n     * otherwise match all monitors that have the given message\n     *\n     * @param message {String} Name of message, can be truncated by *\n     * @param subscriber {Function} Callback Function\n     * @param context {Object} execution context\n     * @return {Boolean} Whether monitor is present or not\n     */\n    checkSubscription : function(message, subscriber, context)\n    {\n      return this.getInstance().checkSubscription(message, subscriber, context);\n    },\n\n    /**\n     * unsubscribe a listening method\n     * if you supply the callback function and execution context,\n     * remove only this exact subscription\n     * otherwise remove all subscriptions\n     *\n     * @param message {String} Name of message, can be truncated by *\n     * @param subscriber {Function} Callback Function\n     * @param context {Object} execution context\n     * @return {Boolean} Whether monitor was removed or not\n     */\n    unsubscribe : function(message, subscriber, context)\n    {\n      return this.getInstance().unsubscribe(message, subscriber, context);\n    },\n\n    /**\n     * dispatch message and call subscribed functions\n     *\n     * @param msg {qx.event.message.Message} message which is being dispatched\n     * @return {Boolean} <code>true</code> if the message was dispatched,\n     *    <code>false</code> otherwise.\n     */\n    dispatch : function(msg)\n    {\n      return this.getInstance().dispatch.apply(this.getInstance(), arguments);\n    },\n\n    /**\n     * Dispatches a new message by supplying the name of the\n     * message and its data.\n     *\n     * @param name {String} name of the message\n     * @param data {var} Any type of data to attach\n     *\n     * @return {Boolean} <code>true</code> if the message was dispatched,\n     *    <code>false</code> otherwise.\n     */\n    dispatchByName : function(name, data)\n    {\n      return this.getInstance().dispatchByName.apply(this.getInstance(), arguments);\n    }\n  },\n\n  /**\n   * constructor\n   */\n  construct : function()\n  {\n    /*\n     * message subscriptions database\n     */\n    this.__subscriptions = {};\n  },\n\n  members :\n  {\n    __subscriptions : null,\n\n\n    /**\n     * gets the hash map of message subscriptions\n     *\n     * @return {Map} with registered subscriptions. The key is the\n     *    <code>message</code> and the value is a map with <code>{subscriber: {Function},\n     *    context: {Object|null}}</code>.\n     */\n    getSubscriptions : function() {\n      return this.__subscriptions;\n    },\n\n\n    /**\n     * subscribes to a message\n     *\n     * @param message {String} name of message, can be truncated by *\n     * @param subscriber {Function} subscribing callback function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Success\n     */\n    subscribe : function(message, subscriber, context)\n    {\n      if (!message || typeof subscriber != \"function\")\n      {\n        this.error(\"Invalid parameters! \"+ [message, subscriber, context]);\n\n        return false;\n      }\n\n      var sub = this.getSubscriptions();\n\n      if (this.checkSubscription(message))\n      {\n        if (this.checkSubscription(message, subscriber, context))\n        {\n          this.warn(\"Object method already subscribed to \" + message);\n          return false;\n        }\n\n        // add a subscription\n        sub[message].push(\n        {\n          subscriber : subscriber,\n          context    : context || null\n        });\n\n        return true;\n      }\n      else\n      {\n        // create a subscription\n        sub[message] = [ {\n          subscriber : subscriber,\n          context    : context || null\n        } ];\n\n        return true;\n      }\n    },\n\n\n    /**\n     * checks if subscription is already present\n     * if you supply the callback function, match only the exact message monitor\n     * otherwise match all monitors that have the given message\n     *\n     * @param message {String} Name of message, can be truncated by *\n     * @param subscriber {Function} Callback Function\n     * @param context {Object} execution context\n     * @return {Boolean} Whether monitor is present or not\n     */\n    checkSubscription : function(message, subscriber, context)\n    {\n      var sub = this.getSubscriptions();\n\n      if (!sub[message] || sub[message].length === 0) {\n        return false;\n      }\n\n      if (subscriber)\n      {\n        for (var i=0; i<sub[message].length; i++)\n        {\n          if (sub[message][i].subscriber === subscriber && sub[message][i].context === (context || null)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      return true;\n    },\n\n\n    /**\n     * unsubscribe a listening method\n     * if you supply the callback function and execution context,\n     * remove only this exact subscription\n     * otherwise remove all subscriptions\n     *\n     * @param message {String} Name of message, can be truncated by *\n     * @param subscriber {Function} Callback Function\n     * @param context {Object} execution context\n     * @return {Boolean} Whether monitor was removed or not\n     */\n    unsubscribe : function(message, subscriber, context)\n    {\n       var sub = this.getSubscriptions();\n       var subscrList = sub[message];\n       if (subscrList) {\n         if (!subscriber) {\n           sub[message] = null;\n           delete sub[message];\n           return true;\n         } else {\n           if (! context) {\n             context = null;\n           }\n           var i = subscrList.length;\n           var subscription;\n           do {\n             subscription = subscrList[--i];\n             if (subscription.subscriber === subscriber && subscription.context === context) {\n               subscrList.splice(i, 1);\n               if (subscrList.length === 0) {\n                 sub[message] = null;\n                 delete sub[message];\n               }\n               return true;\n             }\n           } while (i);\n         }\n       }\n       return false;\n    },\n\n    /**\n     * dispatch message and call subscribed functions\n     *\n     * @param msg {qx.event.message.Message} message which is being dispatched\n     * @return {Boolean} <code>true</code> if the message was dispatched,\n     *    <code>false</code> otherwise.\n     */\n    dispatch : function(msg)\n    {\n      var sub = this.getSubscriptions();\n      var msgName = msg.getName();\n      var dispatched = false;\n\n      for (var key in sub)\n      {\n        var pos = key.indexOf(\"*\");\n\n        if (pos > -1)\n        {\n          // use of wildcard\n          if (pos === 0 || key.substr(0, pos) === msgName.substr(0, pos))\n          {\n            this.__callSubscribers(sub[key], msg);\n            dispatched = true;\n          }\n        }\n        else\n        {\n          // exact match\n          if (key === msgName)\n          {\n            this.__callSubscribers(sub[msgName], msg);\n            dispatched = true;\n          }\n        }\n      }\n\n      return dispatched;\n    },\n\n    /**\n     * Dispatches a new message by supplying the name of the\n     * message and its data.\n     *\n     * @param name {String} name of the message\n     * @param data {var} Any type of data to attach\n     *\n     * @return {Boolean} <code>true</code> if the message was dispatched,\n     *    <code>false</code> otherwise.\n     */\n    dispatchByName : function(name, data)\n    {\n      var message = new qx.event.message.Message(name, data);\n\n      // Dispatch the message\n      var ret = this.dispatch(message);\n\n      // We instantiated this message, so it's our responsibility to dispose it.\n      message.dispose();\n      message = null;\n\n      // Let 'em know whether this message was dispatched to any subscribers.\n      return ret;\n    },\n\n\n    /**\n     * Call subscribers with passed message.\n     *\n     * Each currently-subscribed subscriber function will be called in\n     * turn. Any requests to unsubscribe a subscriber from the list, while\n     * processing the currently-subscribed subscriber functions, will take\n     * effect after all currently-subscribed subscriber functions have been\n     * processed.\n     *\n     * @param subscribers {Array} subscribers to call\n     * @param msg {qx.event.message.Message} message for subscribers\n     */\n    __callSubscribers : function(subscribers, msg)\n    {\n      // (Shallow) clone the subscribers array in case one of them alters the\n      // list, e.g., by unsubscribing\n      subscribers = subscribers.slice();\n\n      for (var i=0; i<subscribers.length; i++)\n      {\n        var subscriber = subscribers[i].subscriber;\n        var context = subscribers[i].context;\n\n        // call message monitor subscriber\n        if (context && context.isDisposed)\n        {\n          if (context.isDisposed())\n          {\n            subscribers.splice(i, 1);\n            i--;\n          }\n          else\n          {\n            subscriber.call(context, msg);\n          }\n        }\n        else\n        {\n          subscriber.call(context, msg);\n        }\n      }\n    }\n  }\n});\n"
  ]
}