{
  "version": 3,
  "sources": [
    "/home/runner/work/CometVisu/CometVisu/node_modules/@qooxdoo/compiler/node_modules/@qooxdoo/framework/source/class/qx/event/message/Bus.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "type",
    "extend",
    "core",
    "Object",
    "statics",
    "getSubscriptions",
    "getInstance",
    "subscribe",
    "topic",
    "subscriber",
    "context",
    "apply",
    "arguments",
    "subscribeOnce",
    "checkSubscription",
    "unsubscribe",
    "dispatch",
    "message",
    "dispatchByName",
    "name",
    "data",
    "construct",
    "__subscriptions",
    "members",
    "Error",
    "regex",
    "RegExp",
    "toString",
    "sub",
    "warn",
    "push",
    "that",
    "modified_subscriber",
    "call",
    "length",
    "i",
    "subscrList",
    "subscription",
    "splice",
    "msgName",
    "getName",
    "dispatched",
    "len",
    "substr",
    "__callSubscribers",
    "match",
    "event",
    "Message",
    "ret",
    "dispose",
    "removeAllSubscriptions",
    "subscriptions",
    "key",
    "subscribers",
    "slice",
    "isDisposed",
    "Bus"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007 Christian Boulanger\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Christian Boulanger (cboulanger)\n     * Sebastian Werner (wpbasti)\n     * Christian Hagendorn (chris_schmidt)\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * A simple message bus singleton.\n * The message bus registers subscriptions to topics and notifies subscribers when\n * a matching message is dispatched. A topic acts as a filter to select only those\n * messages which match the filter. It can be the name of a message, which can\n * terminated with a trailing `*` as a wildcard, or a regular expression.\n */\nqx.Class.define(\"qx.event.message.Bus\",\n{\n  type : \"singleton\",\n\n  extend : qx.core.Object,\n\n  statics :\n  {\n\n    /**\n     * Shorthand method for {@link qx.event.message.Bus.getSubscription}\n     * @return {Object}\n     */\n    getSubscriptions : function() {\n      return this.getInstance().getSubscriptions();\n    },\n\n    /**\n     * Shorthand method for {@link qx.event.message.Bus.subscribe}\n     * @param topic {String|RegExp}\n     * @param subscriber {Function} Message handler function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Success\n     */\n    subscribe : function(topic, subscriber, context)\n    {\n      return this.getInstance().subscribe.apply(this.getInstance(), arguments);\n    },\n\n    /**\n     * Shorthand method for {@link qx.event.message.Bus.subscribeOnce}\n     * @param topic {String|RegExp}\n     * @param subscriber {Function} Message handler function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Success\n     */\n    subscribeOnce : function(topic, subscriber, context)\n    {\n      return this.getInstance().subscribeOnce.apply(this.getInstance(), arguments);\n    },\n\n    /**\n     * Shorthand method for {@link qx.event.message.Bus.checkSubscription}\n     * @param topic {String|RegExp} The topic that has been used when subscribing\n     * @param subscriber {Function} Message handler function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Whether a subscription was removed\n     */\n    checkSubscription : function(topic, subscriber, context)\n    {\n      return this.getInstance().checkSubscription.apply(this.getInstance(), arguments);\n    },\n\n    /**\n     * Shorthand method for {@link qx.event.message.Bus.unsubscribe}\n     * @param topic {String|RegExp} The topic that has been used when subscribing\n     * @param subscriber {Function} Message handler function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Whether a subscription was removed\n     */\n    unsubscribe : function(topic, subscriber, context)\n    {\n      return this.getInstance().unsubscribe.apply(this.getInstance(), arguments);\n    },\n\n    /**\n     * Shorthand method for {@link qx.event.message.Bus.dispatch}\n     * @param message {qx.event.message.Message} Message which is being dispatched\n     * @return {Boolean} If the message could be dispatched\n     */\n    dispatch : function(message)\n    {\n      return this.getInstance().dispatch.apply(this.getInstance(), arguments);\n    },\n\n    /**\n     * Shorthand method for {@link qx.event.message.Bus.dispatchByName}\n     * @param name {String} name of the message\n     * @param data {var} Any type of data to attach\n     * @return {Boolean} If the message was dispatched\n     */\n    dispatchByName : function(name, data)\n    {\n      return this.getInstance().dispatchByName.apply(this.getInstance(), arguments);\n    }\n  },\n\n  /**\n   * constructor\n   */\n  construct : function()\n  {\n    this.base(arguments);\n    this.__subscriptions = {};\n  },\n\n  members :\n  {\n    /**\n     * Subscriptions cache\n     * @var {Object}\n     */\n    __subscriptions : null,\n\n    /**\n     * Returns the map of message subscriptions with registered subscriptions. The key is\n     * the topic and the value is a map with <code>{subscriber:\n     * {Function}, context: {Object|null}}</code>.\n     *\n     * @return {Object}\n     */\n    getSubscriptions : function() {\n      return this.__subscriptions;\n    },\n\n\n    /**\n     * Subscribes to a topic\n     *\n     * @param topic {String|RegExp} Either a string, which can be\n     * terminated with a trailing `*` as a wildcard to match all message\n     * names that start with the prefix, or a regular expression\n     * object, which the message name has to match. If you use regular\n     * expressions, you cannot use message names that start and end\n     * with a slash (\"/\") at the same time, because regular expressions\n     * are converted to their string representation when stored.\n     * @param subscriber {Function} Message handler function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Success\n     */\n    subscribe : function(topic, subscriber, context)\n    {\n      if (!topic || typeof subscriber != \"function\")\n      {\n        throw new Error(\"Invalid parameters! \"+ [topic, subscriber, context]); // since v6.0.0\n      }\n\n      // handle regexes\n      var regex = topic instanceof RegExp ? topic : null;\n      topic = topic.toString();\n\n      var sub = this.getSubscriptions();\n\n      if (this.checkSubscription(topic))\n      {\n        if (this.checkSubscription(topic, subscriber, context))\n        {\n          this.warn(\"Object method already subscribed to \" + topic);\n          return false;\n        }\n\n        // add a subscription\n        sub[topic].push(\n        {\n          regex      : regex,\n          subscriber : subscriber,\n          context    : context || null\n        });\n\n        return true;\n      }\n      else\n      {\n        // create a subscription\n        sub[topic] = [ {\n          regex      : regex,\n          subscriber : subscriber,\n          context    : context || null\n        } ];\n\n        return true;\n      }\n    },\n\n    /**\n     * Subscribes to a topic just for one dispatch and automatically unsubscribes\n     * after executing the message handler. This subscription cannot be unsubscribed\n     * from after it has been registered.\n\n     *\n     * @param topic {String|RegExp} Topic to subscribe to. see {@link qx.event.message.Bus#subscribe}\n     * for details\n     * @param subscriber {Function} Message handler function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Success\n     */\n    subscribeOnce : function(topic, subscriber, context)\n    {\n      var that = this;\n      var modified_subscriber = function(message) {\n        subscriber.call(context, message);\n        that.unsubscribe(topic, modified_subscriber, context);\n      }\n      return this.subscribe(topic, modified_subscriber, context);\n    },\n\n    /**\n     * Checks if subscription is already present. If you supply\n     * the message handler function, match only this exact subscription,\n     * otherwise any topic subscription will match.\n     *\n     * @param topic {String|RegExp} Either a string, which can be truncated by `*`\n     * to match all message names that start with the prefix, or a regular expression\n     * object, which the message name has to match.\n     * @param subscriber {Function} Message handler function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Whether a subscription exists for the topic\n     */\n    checkSubscription : function(topic, subscriber, context)\n    {\n      var topic = topic.toString();\n      var sub = this.getSubscriptions();\n\n      if (!sub[topic] || sub[topic].length === 0) {\n        return false;\n      }\n\n      if (subscriber)\n      {\n        for (var i=0; i<sub[topic].length; i++)\n        {\n          if (sub[topic][i].subscriber === subscriber && sub[topic][i].context === (context || null)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      return true;\n    },\n\n\n    /**\n     * Unsubscribe from a topic.\n     *\n     * If a \"wildcard\" topic was subscribed to with a trailing asterisk,\n     * because the subscriber wanted to receive messages for any topic\n     * with the given prefix, that same \"wildcard\" topic should be used to\n     * unsubscribe. It is not possible to unsubscribe using any topic other\n     * than one exactly matching one that has previously been subscribed to.\n     *\n     * If you supply the callback function and execution context, only this\n     * exact subscription is removed. Otherwise, all subscriptions to this topic\n     * will be removed.\n     *\n     * @param topic {String|RegExp} The topic that has been used when subscribing\n     * @param subscriber {Function} Message handler function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Whether a subscription was removed\n     */\n    unsubscribe : function(topic, subscriber, context)\n    {\n       var topic = topic.toString();\n       var sub = this.getSubscriptions();\n       var subscrList = sub[topic];\n       if (subscrList) {\n         if (!subscriber) {\n           sub[topic] = null;\n           delete sub[topic];\n           return true;\n         } else {\n           if (! context) {\n             context = null;\n           }\n           var i = subscrList.length;\n           var subscription;\n           do {\n             subscription = subscrList[--i];\n             if (subscription.subscriber === subscriber && subscription.context === context) {\n               subscrList.splice(i, 1);\n               if (subscrList.length === 0) {\n                 sub[topic] = null;\n                 delete sub[topic];\n               }\n               return true;\n             }\n           } while (i);\n         }\n       }\n       return false;\n    },\n\n    /**\n     * Dispatch message, which calls subscribers\n     *\n     * @param message {qx.event.message.Message} Message which is being dispatched\n     * @return {Boolean} If the message could be dispatched, i.e. if subscribers\n     * exist which have received the message\n     */\n    dispatch : function(message)\n    {\n      var sub = this.getSubscriptions();\n      var msgName = message.getName();\n      var dispatched = false;\n\n      for (var topic in sub)\n      {\n        var len = topic.length;\n        if (topic[len-1] === \"*\")\n        {\n          // use of wildcard, only allowed as \"*\" or at the end of the topic\n          if (len === 1 || topic.substr(0, len-2) === msgName.substr(0, len-2))\n          {\n            this.__callSubscribers(sub[topic], message);\n            dispatched = true;\n          }\n        }\n        else if (sub[topic][0].regex)\n        {\n          // regular expression\n          if (message.getName().match(sub[topic][0].regex)) {\n            this.__callSubscribers(sub[topic], message);\n            dispatched = true;\n          }\n        }\n        else if (topic === msgName)\n        {\n          // exact match\n          this.__callSubscribers(sub[topic], message);\n          dispatched = true;\n        }\n      }\n      return dispatched;\n    },\n\n    /**\n     * Dispatches a new message by supplying the name of the\n     * message and its data.\n     *\n     * @param name {String} name of the message\n     * @param data {var} Any type of data to attach\n     * @return {Boolean} If the message was dispatched\n     */\n    dispatchByName : function(name, data)\n    {\n      var message = new qx.event.message.Message(name, data);\n\n      // Dispatch the message\n      var ret = this.dispatch(message);\n\n      // We instantiated this message, so it's our responsibility to dispose it.\n      message.dispose();\n      message = null;\n\n      // Let 'em know whether this message was dispatched to any subscribers.\n      return ret;\n    },\n\n    /**\n     * Removes all subscriptions\n     */\n    removeAllSubscriptions : function() {\n      var subscriptions = this.getSubscriptions();\n      for (var key in subscriptions) {\n        delete subscriptions[key];\n      }\n    },\n\n    /**\n     * Call subscribers with passed message.\n     *\n     * Each currently-subscribed subscriber function will be called in\n     * turn. Any requests to unsubscribe a subscriber from the list, while\n     * processing the currently-subscribed subscriber functions, will take\n     * effect after all currently-subscribed subscriber functions have been\n     * processed.\n     *\n     * @param subscribers {Array} subscribers to call\n     * @param message {qx.event.message.Message} message for subscribers\n     */\n    __callSubscribers : function(subscribers, message)\n    {\n      // (Shallow) clone the subscribers array in case one of them alters the\n      // list, e.g., by unsubscribing\n      subscribers = subscribers.slice();\n\n      for (var i=0; i<subscribers.length; i++)\n      {\n        var subscriber = subscribers[i].subscriber;\n        var context = subscribers[i].context;\n\n        // call topic subscriber\n        if (context && context.isDisposed)\n        {\n          if (context.isDisposed())\n          {\n            subscribers.splice(i, 1);\n            i--;\n          }\n          else\n          {\n            subscriber.call(context, message);\n          }\n        }\n        else\n        {\n          subscriber.call(context, message);\n        }\n      }\n    }\n  }\n});\n"
  ]
}