{
  "version": 3,
  "sources": [
    "/home/travis/build/CometVisu/CometVisu/node_modules/@qooxdoo/compiler/node_modules/@qooxdoo/framework/source/class/qx/core/MEvent.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Mixin",
    "define",
    "members",
    "__Registration",
    "event",
    "Registration",
    "addListener",
    "type",
    "listener",
    "self",
    "capture",
    "$$disposed",
    "addListenerOnce",
    "context",
    "id",
    "callback",
    "e",
    "removeListenerById",
    "call",
    "$$wrapped_callback",
    "toHashCode",
    "removeListener",
    "$$hash",
    "hasListener",
    "dispatchEvent",
    "evt",
    "fireEvent",
    "clazz",
    "args",
    "fireEventAsync",
    "Error",
    "classname",
    "Promise",
    "resolve",
    "fireNonBubblingEvent",
    "fireNonBubblingEventAsync",
    "fireDataEvent",
    "data",
    "oldData",
    "cancelable",
    "undefined",
    "Data",
    "fireDataEventAsync",
    "core",
    "MEvent"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2011 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (martinwittemann)\n\n************************************************************************ */\n\n/**\n * This mixin offers basic event handling capabilities. It includes the\n * commonly known methods for managing event listeners and firing events.\n *\n * @use(qx.event.dispatch.Direct)\n * @use(qx.event.handler.Object)\n */\nqx.Mixin.define(\"qx.core.MEvent\",\n{\n  members :\n  {\n    /** @type {Class} Pointer to the regular event registration class */\n    __Registration : qx.event.Registration,\n\n\n    /**\n     * Add event listener to this object.\n     *\n     * @param type {String} name of the event type\n     * @param listener {Function} event callback function\n     * @param self {Object ? null} Reference to the 'this' variable inside\n     *         the event listener. When not given, the corresponding dispatcher\n     *         usually falls back to a default, which is the target\n     *         by convention. Note this is not a strict requirement, i.e.\n     *         custom dispatchers can follow a different strategy.\n     * @param capture {Boolean ? false} Whether to attach the event to the\n     *         capturing phase or the bubbling phase of the event. The default is\n     *         to attach the event handler to the bubbling phase.\n     * @return {String} An opaque id, which can be used to remove the event listener\n     *         using the {@link #removeListenerById} method.\n     */\n    addListener : function(type, listener, self, capture)\n    {\n      if (!this.$$disposed) {\n        return this.__Registration.addListener(this, type, listener, self, capture);\n      }\n\n      return null;\n    },\n\n\n    /**\n     * Add event listener to this object, which is only called once. After the\n     * listener is called the event listener gets removed.\n     *\n     * @param type {String} name of the event type\n     * @param listener {Function} event callback function\n     * @param context {Object ? window} reference to the 'this' variable inside the callback\n     * @param capture {Boolean ? false} Whether to attach the event to the\n     *         capturing phase or the bubbling phase of the event. The default is\n     *         to attach the event handler to the bubbling phase.\n     * @return {String} An opaque id, which can be used to remove the event listener\n     *         using the {@link #removeListenerById} method.\n     */\n    addListenerOnce : function(type, listener, context, capture)\n    {\n      var self = this; // self is needed to remove the listener inside the callback\n      if (!context) {\n        context = this;\n      }\n      var id;         // store id in closure context\n      var callback = function(e)\n      {\n        self.removeListenerById(id);\n        listener.call(context, e);\n      };\n      // check for wrapped callback storage\n      if (!listener.$$wrapped_callback) {\n        listener.$$wrapped_callback = {};\n      }\n      // store the call for each type in case the listener is\n      // used for more than one type [BUG #8038]\n      listener.$$wrapped_callback[type + this.toHashCode()] = callback;\n      id = this.addListener(type, callback, context, capture);\n      return id;\n    },\n\n\n    /**\n     * Remove event listener from this object\n     *\n     * @param type {String} name of the event type\n     * @param listener {Function} event callback function\n     * @param self {Object ? null} reference to the 'this' variable inside the callback\n     * @param capture {Boolean} Whether to remove the event listener of\n     *   the bubbling or of the capturing phase.\n     * @return {Boolean} Whether the event was removed successfully (has existed)\n     */\n    removeListener : function(type, listener, self, capture)\n    {\n      if (!this.$$disposed) {\n        // special handling for wrapped once listener\n        if (listener.$$wrapped_callback && listener.$$wrapped_callback[type + this.$$hash]) {\n          var callback = listener.$$wrapped_callback[type + this.$$hash];\n          delete listener.$$wrapped_callback[type + this.$$hash];\n          listener = callback;\n        }\n        return this.__Registration.removeListener(this, type, listener, self, capture);\n      }\n      return false;\n    },\n\n\n    /**\n     * Removes an event listener from an event target by an id returned by\n     * {@link #addListener}\n     *\n     * @param id {String} The id returned by {@link #addListener}\n     * @return {Boolean} Whether the event was removed successfully (has existed)\n     */\n    removeListenerById : function(id)\n    {\n      if (!this.$$disposed) {\n        return this.__Registration.removeListenerById(this, id);\n      }\n\n      return false;\n    },\n\n\n    /**\n     * Check if there are one or more listeners for an event type.\n     *\n     * @param type {String} name of the event type\n     * @param capture {Boolean ? false} Whether to check for listeners of\n     *         the bubbling or of the capturing phase.\n     * @return {Boolean} Whether the object has a listener of the given type.\n     */\n    hasListener : function(type, capture) {\n      return this.__Registration.hasListener(this, type, capture);\n    },\n\n\n    /**\n     * Dispatch an event on this object\n     *\n     * @param evt {qx.event.type.Event} event to dispatch\n     * @return {Boolean} Whether the event default was prevented or not.\n     *     Returns true, when the event was NOT prevented.\n     */\n    dispatchEvent : function(evt)\n    {\n      if (!this.$$disposed) {\n        return this.__Registration.dispatchEvent(this, evt);\n      }\n\n      return true;\n    },\n\n\n    /**\n     * Creates and dispatches an event on this object.\n     *\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {Boolean|qx.Promise} whether the event default was prevented or not.\n     *     Returns true, when the event was NOT prevented.\n     */\n    fireEvent : function(type, clazz, args)\n    {\n      if (!this.$$disposed) {\n        return this.__Registration.fireEvent(this, type, clazz, args);\n      }\n\n      return true;\n    },\n\n\n    /**\n     * Creates and dispatches an event on this object; equivalent to fireEvent, except that it\n     * always returns a promise\n     *\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {qx.Promise} a promise aggregated from the event handlers;\n     *  if the default was prevented, the promise is rejected\n     */\n    fireEventAsync : function(type, clazz, args)\n    {\n      if (!qx.core.Environment.get(\"qx.promise\")) {\n        throw new Error(this.classname + \".fireEventAsync not supported because qx.promise==false\");\n      }\n      \n      if (!this.$$disposed) {\n        return this.__Registration.fireEventAsync(this, type, clazz, args);\n      }\n\n      return qx.Promise.resolve(true);\n    },\n\n\n    /**\n     * Create an event object and dispatch it on this object.\n     * The event dispatched with this method does never bubble! Use only if you\n     * are sure that bubbling is not required.\n     *\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {Boolean} Whether the event default was prevented or not.\n     *     Returns true, when the event was NOT prevented.\n     */\n    fireNonBubblingEvent : function(type, clazz, args)\n    {\n      if (!this.$$disposed) {\n        return this.__Registration.fireNonBubblingEvent(this, type, clazz, args);\n      }\n\n      return true;\n    },\n\n\n    /**\n     * Create an event object and dispatch it on this object; equivalent to fireNonBubblingEvent, \n     * except that it always returns a promise.\n     * \n     * The event dispatched with this method does never bubble! Use only if you\n     * are sure that bubbling is not required.\n     *\n     * @param type {String} Event type to fire\n     * @param clazz {Class?qx.event.type.Event} The event class\n     * @param args {Array?null} Arguments, which will be passed to\n     *       the event's init method.\n     * @return {qx.Promise} a promise aggregated from the event handlers;\n     *  if the default was prevented, the promise is rejected\n     */\n    fireNonBubblingEventAsync : function(type, clazz, args)\n    {\n      if (!qx.core.Environment.get(\"qx.promise\")) {\n        throw new Error(this.classname + \".fireNonBubblingEventAsync not supported because qx.promise==false\");\n      }\n      \n      if (!this.$$disposed) {\n        return this.__Registration.fireNonBubblingEventAsync(this, type, clazz, args);\n      }\n\n      return qx.Promise.resolve(true);\n    },\n\n\n    /**\n     * Creates and dispatches an non-bubbling data event on this object.\n     *\n     * @param type {String} Event type to fire\n     * @param data {var} User defined data attached to the event object\n     * @param oldData {var?null} The event's old data (optional)\n     * @param cancelable {Boolean?false} Whether or not an event can have its default\n     *     action prevented. The default action can either be the browser's\n     *     default action of a native event (e.g. open the context menu on a\n     *     right click) or the default action of a qooxdoo class (e.g. close\n     *     the window widget). The default action can be prevented by calling\n     *     {@link qx.event.type.Event#preventDefault}\n     * @return {Boolean|qx.Promise} whether the event default was prevented or not.\n     *     Returns true, when the event was NOT prevented.\n     */\n    fireDataEvent : function(type, data, oldData, cancelable)\n    {\n      if (!this.$$disposed)\n      {\n        if (oldData === undefined) {\n          oldData = null;\n        }\n        return this.__Registration.fireEvent(\n          this, type, qx.event.type.Data, [data, oldData, !!cancelable]\n        );\n      }\n\n      return true;\n    },\n\n\n    /**\n     * Creates and dispatches an non-bubbling data event on this object; equivalent to \n     * fireEvent, except that it always returns a promise.\n     *\n     * @param type {String} Event type to fire\n     * @param data {var} User defined data attached to the event object\n     * @param oldData {var?null} The event's old data (optional)\n     * @param cancelable {Boolean?false} Whether or not an event can have its default\n     *     action prevented. The default action can either be the browser's\n     *     default action of a native event (e.g. open the context menu on a\n     *     right click) or the default action of a qooxdoo class (e.g. close\n     *     the window widget). The default action can be prevented by calling\n     *     {@link qx.event.type.Event#preventDefault}\n     * @return {qx.Promise} a promise aggregated from the event handlers;\n     *  if the default was prevented, the promise is rejected\n     */\n    fireDataEventAsync : function(type, data, oldData, cancelable)\n    {\n      if (!qx.core.Environment.get(\"qx.promise\")) {\n        throw new Error(this.classname + \".fireDataEventAsync not supported because qx.promise==false\");\n      }\n      \n      if (!this.$$disposed)\n      {\n        if (oldData === undefined) {\n          oldData = null;\n        }\n        return this.__Registration.fireEventAsync(\n          this, type, qx.event.type.Data, [data, oldData, !!cancelable]\n        );\n      }\n\n      return qx.Promise.resolve(true);\n    }\n  }\n});\n"
  ]
}